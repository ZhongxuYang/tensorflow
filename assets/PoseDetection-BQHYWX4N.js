import{S as xx,M as wx,R as vx,B as Cx,C as kx,D as Sx,E as Ix,F as Ad,m as O,G as hr,c as mt,H as dr,I as Ie,J as ns,i as Lt,K as se,L as Me,h as Ct,N as pr,O as Td,P as Ne,Q as $e,U as Et,r as Q,V as xl,W as wl,X as ce,Y as vl,Z as fr,$ as mr,g as ct,a0 as gr,a1 as yr,a2 as br,a3 as wi,a4 as Mn,z as tt,a5 as xr,a6 as yn,a7 as Cl,a8 as kl,a9 as Sl,aa as Il,ab as Nl,ac as Dn,ad as $l,ae as zd,af as Nx,ag as Fd,ah as Md,ai as wr,aj as Zn,ak as vi,al as Ci,am as vr,an as Dl,ao as Rl,ap as ee,aq as Kn,ar as Al,as as Tl,at as $x,au as Pd,av as zl,aw as Vo,ax as Fl,ay as Ml,az as Dx,aA as Cr,aB as Ed,aC as kr,aD as Ld,aE as Pl,aF as Pe,aG as Od,aH as Vt,aI as El,aJ as ki,aK as Rx,aL as Ax,aM as Ll,aN as Uo,aO as Go,aP as Sr,aQ as Ol,aR as Ir,A as Qn,aS as _d,aT as _l,aU as Bd,aV as Wd,aW as Vd,aX as Bl,aY as Ud,aZ as As,a_ as Wl,a$ as Gd,b0 as _s,b1 as lo,b2 as Hd,b3 as jd,b4 as Nr,b5 as $r,b6 as Dr,b7 as Vl,b8 as Wn,b9 as Rr,ba as Kd,bb as Tx,bc as Ul,bd as Gl,be as Jn,bf as ts,bg as Hl,bh as Xd,bi as qd,bj as jl,bk as Kl,bl as Xl,bm as ql,bn as Yl,bo as un,bp as et,bq as Bs,br as Zl,bs as Yd,bt as Ql,s as ue,bu as Ar,bv as Jl,bw as Zd,bx as Qd,by as tu,bz as Le,bA as eu,bB as nu,bC as Zi,bD as su,bE as Tr,bF as zr,bG as ps,bH as iu,bI as Jd,bJ as Qa,bK as Fr,bL as Mr,bM as Pr,bN as Er,bO as ou,bP as ru,bQ as au,bR as lu,bS as uu,bT as cu,bU as Qi,bV as Lr,bW as tp,bX as hu,bY as ep,bZ as Or,b_ as du,b$ as pu,c0 as np,c1 as _r,c2 as Br,c3 as fu,c4 as Wr,c5 as sp,c6 as ip,c7 as op,c8 as li,c9 as mu,ca as Vr,p as Ws,cb as gu,cc as rp,cd as yu,x as fs,ce as ap,cf as bu,cg as lp,ch as Ur,ci as up,cj as xu,ck as Gr,cl as Hr,cm as wu,cn as cp,co as vu,cp as Cu,cq as Vs,cr as ku,e as Ye,cs as Su,ct as zx,cu as H,cv as Ls,cw as Fx,cx as Mx,cy as hp,cz as Ja,cA as ui,cB as Px,cC as Ex,cD as Lx,cE as Ox,cF as _x,cG as Bx,cH as dp,cI as Wx,cJ as Vx,cK as Ux,y as Ue,T as Ge,cL as pp,cM as fp,cN as Gx,cO as mp,cP as Hx,cQ as jx,cR as Kx,cS as Iu,cT as gp,cU as Xx,cV as qx,cW as Yx,cX as Zx,cY as Qx,cZ as Jx,c_ as tw,c$ as ew,d0 as nw,d1 as yp,d2 as sw,d3 as iw,d4 as bp,d5 as xp,d6 as wp,d7 as ow,d8 as rw,d9 as vp,da as ci,db as ve,dc as Cp,dd as jr,de as kp,df as aw,dg as lw,dh as Ho,di as Sp,dj as ln,dk as uw,dl as Ip,dm as cw,dn as hw,dp as Si,dq as dw,dr as pw,ds as fw,dt as mw,du as gw,dv as Np,dw as $p,dx as yw,dy as Nu,dz as Kr,dA as bw,o as Xt,dB as xw,dC as ww,dD as Xr,dE as vw,dF as Cw,dG as jo,dH as hi,dI as kw,t as B,dJ as Ko,dK as $u,dL as Dp,dM as Du,dN as Sw,dO as Iw,j as Nw,dP as $w,dQ as Yc,d as jn,dR as Dw,dS as q,dT as qr,dU as Rp,dV as uo,dW as Rw,dX as Aw,dY as co,dZ as Tw,d_ as ke,w as zt,n as he,d$ as Xn,e0 as zw,e1 as Zc,e2 as Fw,e3 as Mw,e4 as Pw,e5 as Ew,e6 as Qc,e7 as Lw,e8 as Jc,e9 as Ow,ea as _w,q as Oe,eb as Bw,ec as Ww,ed as Ru,ee as Vw,ef as Uw,eg as Gw,eh as Hw,ei as jw,ej as Kw,ek as Xw,el as th,em as Ap,en as Tp,eo as us,ep as qw,eq as zp,er as Fp,es as di,et as Bo,eu as ho,ev as le,ew as yt,ex as Yw,ey as Mp,ez as Qt,eA as Ln,eB as Us,eC as Gs,eD as Zw,eE as Pp,eF as Tt,eG as Ep,eH as Ji,eI as Lp,eJ as Ze,eK as Ke,eL as Vn,eM as ss,eN as Op,eO as Ii,eP as Un,eQ as xs,eR as Yr,eS as Zr,eT as Qr,eU as _p,eV as Bp,eW as pi,eX as Wp,eY as Vp,eZ as Up,e_ as Gp,e$ as Hp,f0 as cs,f1 as to,f2 as Fn,f3 as Qw,f4 as ws,f5 as Xe,f6 as Ve,f7 as jp,f8 as Ni,f9 as Kp,fa as Xp,fb as qp,fc as es,fd as Jw,fe as Yp,ff as t0,fg as Zp,fh as Qp,fi as Jp,fj as tf,fk as $i,fl as Jr,fm as Xi,fn as Au,fo as oi,fp as ef,fq as nf,fr as Tu,fs as e0,ft as sf,fu as of,fv as rf,fw as af,fx as lf,fy as uf,fz as zu,fA as cf,fB as hf,fC as df,fD as pf,fE as ff,fF as mf,fG as gf,fH as yf,fI as n0,fJ as s0,fK as i0,fL as o0,fM as bf,fN as r0,fO as a0,fP as xf,fQ as wf,fR as vf,fS as Cf,fT as kf,fU as Sf,fV as If,fW as Nf,fX as l0,fY as $f,fZ as u0,f_ as Df,f$ as Rf,g0 as c0,g1 as Fu,g2 as Mu,g3 as Pu,g4 as h0,g5 as d0,g6 as Af,g7 as Tf,g8 as p0,g9 as zf,ga as f0,gb as Ff,gc as Mf,gd as m0,ge as g0,gf as Pf,gg as Ef,gh as Lf,gi as y0,gj as b0,gk as x0,gl as w0,gm as v0,gn as C0,go as Of,gp as k0,gq as _f,gr as Bf,gs as Wf,gt as Di,gu as ii,gv as Vf,gw as S0,gx as I0,gy as N0,gz as $0,gA as Uf,gB as Gf,gC as Hf,gD as jf,gE as Kf,gF as Xf,gG as qf,gH as Yf,gI as D0,gJ as Zf,gK as R0,gL as A0,gM as T0,gN as z0,gO as F0,gP as Qf,gQ as M0,gR as Jf,gS as P0,gT as tm,gU as Eu,gV as E0,gW as L0,gX as O0,gY as em,gZ as _0,g_ as B0,g$ as W0,h0 as V0,h1 as U0,h2 as G0,h3 as H0,h4 as j0,h5 as K0,h6 as X0,h7 as q0,h8 as Y0,h9 as Z0,ha as Q0,hb as J0,hc as t1,hd as e1,he as n1,hf as s1,hg as i1,hh as o1,hi as r1,hj as a1,hk as l1,hl as u1,hm as c1,hn as h1,ho as d1,hp as p1,hq as f1,hr as m1,hs as g1,u as Ma,ht as nm,hu as eh,hv as y1,hw as nh,hx as b1,hy as sh,hz as x1,hA as w1,hB as v1,hC as C1,hD as k1,hE as S1,hF as I1,hG as N1,hH as $1,hI as D1,hJ as R1,hK as A1,l as fi,k as Xo,v as Lu,b as zs,a as sm,hL as T1,_ as z1}from"./VueWebcam.vue_vue_type_script_setup_true_lang-Bage4EEm.js";import{d as F1,r as ih,o as M1,f as P1,c as E1,a as oh,b as L1,u as O1,e as _1}from"./index-p5RsmaO6.js";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class B1{static sgd(t){return new xx(t)}static momentum(t,e,s=!1){return new wx(t,e,s)}static rmsprop(t,e=.9,s=0,i=null,o=!1){return new vx(t,e,s,i,o)}static adam(t=.001,e=.9,s=.999,i=null){return new Cx(t,e,s,i)}static adadelta(t=.001,e=.95,s=null){return new kx(t,e,s)}static adamax(t=.002,e=.9,s=.999,i=null,o=0){return new Sx(t,e,s,i,o)}static adagrad(t,e=.1){return new Ix(t,e)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Js=B1;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const im={kernelName:Ad,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>O(n,hr(mt(e,"float32"),-1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const W1={kernelName:dr,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const s=Ie(mt(e,"float32")),i=ns(Lt(se(1),s));return Me(Ct(n,i))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const V1={kernelName:pr,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const s=ns(Lt(Ie(mt(e,"float32")),1));return Ct(n,s)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const U1={kernelName:Td,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,i=Ne(e.shape,s.shape);return{a:()=>{let a=n;const l=$e(e.shape,i);return l.length>0&&(a=Et(a,l)),Q(a,e.shape)},b:()=>{let a=n;const l=$e(s.shape,i);return l.length>0&&(a=Et(a,l)),Q(a,s.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const G1={kernelName:xl,saveAllInputs:!0,gradFunc:(n,t)=>{const e={};return t.forEach((s,i)=>{e[i]=()=>n.clone()}),e}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H1={kernelName:wl,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>ce(e)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const j1={kernelName:vl,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>ce(e)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const K1={kernelName:fr,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Ct(n,ns(Lt(se(1),Ie(mt(e,"float32")))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const X1={kernelName:mr,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const s=ns(ct(se(1),Ie(mt(e,"float32"))));return Ct(n,s)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const q1={kernelName:gr,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,i=Ne(e.shape,s.shape);return{a:()=>{const a=ct(Ie(e),Ie(s));let l=O(n,Ct(s,a));const u=$e(e.shape,i);return u.length>0&&(l=Et(l,u)),Q(l,e.shape)},b:()=>{const a=ct(Ie(e),Ie(s));let l=Me(O(n,Ct(e,a)));const u=$e(s.shape,i);return u.length>0&&(l=Et(l,u)),Q(l,s.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Y1={kernelName:yr,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Ct(n,ct(Ie(mt(e,"float32")),1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Z1={kernelName:br,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Ct(n,Lt(se(1),Ie(mt(e,"float32"))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q1(n,t,e,s,i,o){const r=Mn(n,"dy","avgPool3dGrad"),a=Mn(t,"input","avgPool3dGrad");let l=r,u=a,c=!1;a.rank===4&&(c=!0,l=Q(r,[1,r.shape[0],r.shape[1],r.shape[2],r.shape[3]]),u=Q(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),tt(l.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),tt(u.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`),xr("avgPool3dGrad",i,o);const h={dy:l,input:u},p={filterSize:e,strides:s,pad:i,dimRoundingMode:o},f=yn.runKernel(Cl,h,p);return c?Q(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const J1=wi({avgPool3dGrad_:Q1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tv={kernelName:kl,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{filterSize:i,strides:o,pad:r,dimRoundingMode:a}=e;return{x:()=>J1(n,s,i,o,r,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ev(n,t,e,s,i){const o=Mn(n,"dy","avgPoolGrad"),r=Mn(t,"input","avgPoolGrad");tt(r.rank===o.rank,()=>`Rank of input (${r.rank}) does not match rank of dy (${o.rank})`);let a=r,l=o,u=!1;r.rank===3&&(u=!0,a=Q(r,[1,r.shape[0],r.shape[1],r.shape[2]]),l=Q(o,[1,o.shape[0],o.shape[1],o.shape[2]])),tt(l.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),tt(a.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`);const c={dy:l,input:a},h={filterSize:e,strides:s,pad:i},p=yn.runKernel(Sl,c,h);return u?Q(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const nv=wi({avgPoolGrad_:ev});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sv={kernelName:Il,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{filterSize:i,strides:o,pad:r}=e;return{x:()=>nv(n,s,i,o,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iv={kernelName:Nl,inputsToSave:["a","b"],gradFunc:(n,t,e)=>{const[s,i]=t,{transposeA:o,transposeB:r}=e;return!o&&!r?{a:()=>Dn(n,i,!1,!0),b:()=>Dn(s,n,!0,!1)}:!o&&r?{a:()=>Dn(n,i,!1,!1),b:()=>Dn(n,s,!0,!1)}:o&&!r?{a:()=>Dn(i,n,!1,!0),b:()=>Dn(s,n,!1,!1)}:{a:()=>Dn(i,n,!0,!0),b:()=>Dn(n,s,!0,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ov={kernelName:$l,gradFunc:(n,t,e)=>{const{blockShape:s,crops:i}=e;return{x:()=>zd(n,s,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rv={kernelName:Nx,gradFunc:(n,t,e)=>{const s=e,i=s.inputShape,o=s.shape,r=Array.from(o);for(let l=i.length-1;l>=0;l--)if(i[l]===o[l])r[l]=1;else if(i[l]!==1)throw new Error(`broadcastTo(): [${i}] cannot be broadcast to [${o}].`);const a=[];for(let l=0;l<r.length;l++)r[l]>1&&a.push(l);return{x:()=>Et(n,a,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const av={kernelName:Fd,gradFunc:n=>({x:()=>n.clone()})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lv={kernelName:Md,gradFunc:n=>({x:()=>ce(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uv={kernelName:wr,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{clipValueMin:i,clipValueMax:o}=e;return{x:()=>Zn(vi(Ci(s,i),vr(s,o)),n,ce(n))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cv={kernelName:Dl,inputsToSave:["x"],gradFunc:im.gradFunc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hv={kernelName:Rl,saveAllInputs:!0,gradFunc:(n,t,e)=>{const s=t.map(l=>l.shape),{axis:i}=e,o=ee(i,t[0].shape)[0],r=s.map(l=>l[o]);return Kn(n,r,o).map(l=>()=>l)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dv={kernelName:Al,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const[s,i]=t,{dilations:o,strides:r,pad:a,dataFormat:l}=e;return tt(Tl(o),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`),{x:()=>$x(s.shape,n,i,r,a,l),filter:()=>Pd(s,n,i.shape,r,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pv={kernelName:zl,inputsToSave:["dy","filter"],gradFunc:(n,t,e)=>{const[s,i]=t,{strides:o,pad:r,dataFormat:a,dimRoundingMode:l}=e;return{dy:()=>Vo(n,i,o,r,a,1,l),filter:()=>Pd(n,s,i.shape,o,r,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fv(n,t,e,s,i){let o=n;n.rank===4&&(o=Q(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));let r=t;r.rank===4&&(r=Q(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),tt(o.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${o.shape}.`),tt(r.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${r.shape}.`),tt(e.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${e}.`),tt(o.shape[4]===e[3],()=>`Error in conv3dDerFilter: depth of input ${o.shape[4]}) must match input depth in filter (${e[3]}.`),tt(r.shape[4]===e[4],()=>`Error in conv3dDerFilter: depth of dy (${r.shape[4]}) must match output depth for filter (${e[4]}).`);const a={x:o,dy:r},l={strides:s,pad:i,filterShape:e};return yn.runKernel(Fl,a,l)}const mv=wi({conv3DBackpropFilter_:fv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gv={kernelName:Ml,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const{dilations:s,strides:i,pad:o}=e;tt(Tl(s),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);const[r,a]=t;return{x:()=>Dx(r.shape,n,a,i,o),filter:()=>mv(r,n,a.shape,i,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yv={kernelName:Cr,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>O(Me(Ed(mt(e,"float32"))),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bv={kernelName:kr,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>O(Ld(mt(e,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xv={kernelName:Pl,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{axis:i,exclusive:o,reverse:r}=e;return{x:()=>{const a=Pe([i],s.rank);let l=Od(n,i,o,!r);return a!=null&&(l=Vt(l,a)),l}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wv={kernelName:El,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const{dilations:s,strides:i,pad:o,dimRoundingMode:r}=e,a=s??[1,1];tt(Tl(a),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[l,u]=t;return tt(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),tt(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`),tt(l.shape[3]===u.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),tt(ki(i,a),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${i} and dilations '${a}'.`),xr("depthwiseConv2d",o,r),{x:()=>Rx(l.shape,n,u,i,o,a,r),filter:()=>Ax(l,n,u.shape,i,o,a,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vv={kernelName:Ll,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const[s,i]=t,o={x:s,filter:i,dy:n},r={x:s,filter:i,dy:n};return{x:()=>yn.runKernel(Uo,o,e),filter:()=>yn.runKernel(Go,r,e)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cv={kernelName:Sr,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t,s={dy:n,y:e};return{x:()=>yn.runKernel(Ol,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kv={kernelName:Ir,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t,s=O(Qn(Me(Ie(e))),2/Math.sqrt(Math.PI));return{x:()=>O(n,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sv={kernelName:_d,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>O(n,e)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Iv={kernelName:_l,inputsToSave:["input"],gradFunc:(n,t)=>{const[e]=t;return{input:()=>Q(n,e.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nv={kernelName:Bd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>O(n,Qn(e))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $v={kernelName:Wd,gradFunc:n=>({x:()=>ce(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dv={kernelName:Vd,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,i=Ne(e.shape,s.shape);return{a:()=>{const a=Ct(n,mt(s,"float32")),l=$e(e.shape,i);return l.length>0?Q(Et(a,l),e.shape):a},b:()=>{let a=O(n,mt(e,"float32"));const l=$e(s.shape,i);l.length>0&&(a=Q(Et(a,l),s.shape));const u=Ie(s);return Me(Ct(a,mt(u,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rv={kernelName:Bl,inputsToSave:["x","mean","variance","scale"],gradFunc:(n,t,e)=>{const{varianceEpsilon:s}=e,[i,o,r,a]=t,l=a??se(1),u=$e(o.shape,i.shape),c=[];if(o.rank===1){for(let C=0;C<i.shape.length-1;++C)c.push(i.shape[C]);c.push(1)}const h=Lt(i,o),p=O(n,l),f=Ud(ct(r,se(s))),m=O(O(O(f,f),f),se(-.5));return{x:()=>o.rank===1?Q(O(O(n,As(Q(f,[1,1,1,o.shape[0]]),c)),l),i.shape):Q(O(O(n,f),l),i.shape),mean:()=>{let C=O(O(f,se(-1)),p);return o.rank===1&&(C=Et(C,u)),Q(C,o.shape)},variance:()=>{let C=O(O(m,h),p);return o.rank===1&&(C=Et(C,u)),Q(C,o.shape)},scale:()=>{const C=O(h,f);let I=O(n,C);return o.rank===1&&(I=Et(I,u)),Q(I,o.shape)},offset:()=>{let C=n;return o.rank===1&&(C=Et(C,u)),Q(C,o.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Av={kernelName:Wl,inputsToSave:["x","indices"],gradFunc:(n,t,e)=>{const[s,i]=t,{axis:o,batchDims:r}=e,a=ee(o,s.shape)[0],l=(u,c,h)=>()=>{const p=u.shape,f=c.size,m=p.slice(0,a),g=m.length,b=p.slice(o,p.length).slice(1),v=b.length,w=rh(0,g),k=rh(g+1,g+1+v),C=ah([m,[f],b]),I=Q(h,C),N=Q(c,[f]),$=ah([[g],w,k]),A=Vt(I,$);let z=Gd(A,N,u.shape[a]);const F=_s($);return z=Vt(z,F),z};if(r===1){const u=s.shape[0],c=s.split(u,0);return{x:()=>lo(c.map((f,m)=>l(f,i.slice(m,1),n.slice(m,1))())).reshape(s.shape),indices:()=>i}}else return{x:l(s,i,n),indices:()=>i}}};function rh(n,t){const e=[];for(let s=n;s<t;++s)e.push(s);return e}function ah(n){const t=[];for(let e=0;e<n.length;++e)for(let s=0;s<n[e].length;++s)t.push(n[e][s]);return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tv={kernelName:Hd,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t;return{a:()=>ce(e),b:()=>ce(s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zv={kernelName:jd,gradFunc:n=>({x:()=>mt(n,"float32")})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fv={kernelName:Nr,gradFunc:n=>({x:()=>ce(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mv={kernelName:$r,gradFunc:n=>({x:()=>ce(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pv={kernelName:Dr,gradFunc:n=>({x:()=>ce(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ev={kernelName:Vl,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{alpha:i}=e,o=Wn(s,0);return{x:()=>Zn(o,n,O(n,i))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lv={kernelName:Rr,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Ct(n,ct(e,1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ov={kernelName:Kd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Ct(n,mt(e,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _v={kernelName:Tx,inputsToSave:[],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s]=t,{axis:i}=e;return{logits:()=>{const r=Qn(s);return Lt(n,O(Et(n,i,!0),r))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bv(n,t,e,s=5,i=1,o=1,r=.5){const a={x:n,y:t,dy:e},l={depthRadius:s,bias:i,alpha:o,beta:r};return yn.runKernel(Ul,a,l)}const Wv=wi({localResponseNormalizationBackprop_:Bv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vv={kernelName:Gl,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s,i]=t,{depthRadius:o,bias:r,alpha:a,beta:l}=e;return{x:()=>Wv(s,i,n,o,r,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function om(n,t,e,s){return t.rank<e.rank&&(t=Q(t,Jn(t.shape,s))),n.rank<e.rank&&(n=Q(n,Jn(n.shape,s))),{x:()=>O(n,mt(ts(e,t),n.dtype))}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lh={kernelName:Hl,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const s=e,{reductionIndices:i}=s,o=t[0],r=t[1],a=ee(i,o.shape),l=om(n,r,o,a);return{x:()=>l.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uv={kernelName:Xd,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t;return{a:()=>O(n,mt(Ci(e,s),"float32")),b:()=>O(n,mt(qd(e,s),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gv(n,t,e,s,i,o,r){const a=Mn(n,"dy","maxPool3dGrad"),l=Mn(t,"input","maxPool3dGrad"),u=Mn(e,"output","maxPool3dGrad");let c=a,h=l,p=u,f=!1;l.rank===4&&(f=!0,c=Q(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),h=Q(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),p=Q(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),tt(c.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),tt(h.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${h.rank}.`),tt(p.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${p.rank}.`),xr("maxPool3dGrad",o,r);const m={dy:c,input:h,output:p},g={filterSize:s,strides:i,pad:o,dimRoundingMode:r},b=yn.runKernel(jl,m,g);return f?Q(b,[b.shape[1],b.shape[2],b.shape[3],b.shape[4]]):b}const Hv=wi({maxPool3dGrad_:Gv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jv={kernelName:Kl,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s,i]=t,{filterSize:o,strides:r,pad:a,dimRoundingMode:l}=e;return{x:()=>Hv(n,s,i,o,r,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kv(n,t,e,s,i,o,r){const a=Mn(n,"dy","maxPoolGrad"),l=Mn(t,"input","maxPoolGrad"),u=Mn(e,"output","maxPoolGrad");tt(l.rank===a.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${a.rank})`),tt(a.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`),tt(l.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),xr("maxPoolGrad",o,r);const c={dy:a,input:l,output:u},h={filterSize:s,strides:i,pad:o,dimRoundingMode:r};return yn.runKernel(Xl,c,h)}const Xv=wi({maxPoolGrad_:Kv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qv={kernelName:ql,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s,i]=t,{filterSize:o,strides:r,pad:a}=e;return{x:()=>Xv(n,s,i,o,r,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yv={kernelName:Yl,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{axis:i}=e,o=ee(i,s.shape),a=un(s.shape,o)[1],l=et(a);return{x:()=>{const c=s.shape.slice();o.forEach(f=>{c[f]=1});const h=Q(n,c);return Ct(O(h,Bs(s.shape,"float32")),l)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zv={kernelName:Zl,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const s=e,{axis:i}=s,[o,r]=t,a=ee(i,o.shape),l=om(n,r,o,a);return{x:()=>l.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qv={kernelName:Yd,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t;return{a:()=>O(n,mt(vr(e,s),"float32")),b:()=>O(n,mt(Wn(e,s),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jv={kernelName:Ql,inputsToSave:["x"],gradFunc:(n,t,e)=>{const s=t[0],{paddings:i}=e,o=i.map(r=>r[0]);return{x:()=>ue(n,o,s.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const t2={kernelName:Ar,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,i=Ne(e.shape,s.shape);return{a:()=>{const a=$e(e.shape,i);return a.length>0?Q(Et(n,a),e.shape):n},b:()=>{const a=O(n,Me(Jl(Ct(e,s)))),l=$e(s.shape,i);return l.length>0?Q(Et(a,l),s.shape):a}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const e2={kernelName:Zd,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,i=Ne(e.shape,s.shape);return{a:()=>{const a=O(n,mt(s,"float32")),l=$e(e.shape,i);return l.length>0?Q(Et(a,l),e.shape):a},b:()=>{const a=O(n,mt(e,"float32")),l=$e(s.shape,i);return l.length>0?Q(Et(a,l),s.shape):a}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const n2={kernelName:Qd,gradFunc:n=>({x:()=>Me(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const s2={kernelName:tu,inputsToSave:["indices"],gradFunc:(n,t)=>{const e=t[0];return{indices:()=>Le(e.shape,"float32")}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i2={kernelName:eu,gradFunc:n=>({x:()=>ce(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o2={kernelName:nu,saveAllInputs:!0,gradFunc:(n,t,e)=>{const{axis:s}=e;return Zi(n,s).map(o=>()=>o)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uh={kernelName:su,inputsToSave:["x"],gradFunc:(n,t,e)=>{const s=t[0],{paddings:i}=e,o=i.map(r=>r[0]);return{x:()=>ue(n,o,s.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r2={kernelName:Tr,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(n,t)=>{const[e,s,i]=t,o=e,r=s,a=Ne(o.shape,r.shape);return{a:()=>{const c=mt(r,"float32");let h=O(n,O(c,zr(o,Lt(c,se(1)))));const p=$e(o.shape,a);return p.length>0&&(h=Et(h,p)),Q(h,o.shape)},b:()=>{const c=Wn(o,0),h=Zn(c,ps(o),ce(o));let p=O(n,O(i,h));const f=$e(r.shape,a);return f.length>0&&(p=Et(p,f)),Q(p,r.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a2={kernelName:iu,inputsToSave:["x","alpha"],gradFunc:(n,t)=>{const[e,s]=t,i=Wn(e,0);return{x:()=>Zn(i,n,O(n,s)),alpha:()=>{let o=Zn(i,ce(n),O(n,e));const r=$e(s.shape,n.shape);return r.length>0&&(o=Et(o,r)),Q(o,s.shape)}}}};/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l2(n,t,e){const s=n.shape.slice();s[e]=1;const i=Q(t,s),o=Qa(n,e,!0,!1),r=Qa(n,e,!0,!0),a=O(o,r);return O(i,a)}function u2(n,t,e){const s=n.shape.length,i=s-e.length,o=Pe(e,s);let r=n;o!=null&&(r=Vt(n,o));const a=r.shape.slice(),u=a.splice(s-e.length,e.length).reduce((p,f)=>p*f,1);a.push(u);const c=r.reshape(a);let h=l2(c,t,i);if(h=h.reshape(r.shape),o!=null){const p=_s(o);h=Vt(h,p)}return h}const c2={kernelName:Jd,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{axis:i}=e;let o=[];return i==null?o=s.shape.map((r,a)=>a):typeof i=="number"?o=[i]:o=i,{x:()=>u2(s,n,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h2={kernelName:Fr,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,i=Ne(e.shape,s.shape);return{a:()=>{const a=Ct(n,mt(s,"float32")),l=$e(e.shape,i);return l.length>0?Q(Et(a,l),e.shape):a},b:()=>{let a=O(n,mt(e,"float32"));const l=$e(s.shape,i);l.length>0&&(a=Q(Et(a,l),s.shape));const u=Ie(s);return Me(Ct(a,mt(u,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const d2={kernelName:Mr,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Ct(n,Me(Ie(e)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const p2={kernelName:Pr,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t,s=O(vr(e,6),hr(e));return{x:()=>O(n,mt(s,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const f2={kernelName:Er,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>O(n,mt(hr(e),"float32"))}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m2={kernelName:ou,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Q(n,e.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const g2={kernelName:ru,inputsToSave:["images"],gradFunc:(n,t,e)=>{const[s]=t,i={dy:n,images:s};return{images:()=>yn.runKernel(au,i,e)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const y2={kernelName:lu,inputsToSave:["images"],gradFunc:(n,t,e)=>{const[s]=t,i={dy:n,images:s};return{images:()=>yn.runKernel(uu,i,e)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b2={kernelName:cu,gradFunc:(n,t,e)=>{const{dims:s}=e,i=ee(s,n.shape);return{x:()=>Qi(n,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const x2={kernelName:Lr,gradFunc:n=>({x:()=>ce(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const w2={kernelName:tp,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Me(Ct(n,O(zr(e,1.5),2)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v2={kernelName:hu,inputsToSave:["condition"],gradFunc:(n,t)=>{const[e]=t;return{condition:()=>mt(ce(e),"float32"),t:()=>O(n,mt(e,n.dtype)),e:()=>O(n,mt(ep(e),n.dtype))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const C2={kernelName:Or,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const s=Wn(e,se(0)),i=se(du),o=se(pu),r=O(n,o),a=O(O(n,i),Qn(mt(e,"float32")));return Zn(s,r,a)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const k2={kernelName:np,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>O(n,O(e,Lt(se(1),e)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const S2={kernelName:_r,gradFunc:n=>({x:()=>ce(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const I2={kernelName:Br,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>O(fu(mt(e,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const N2={kernelName:Wr,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>O(sp(mt(e,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $2={kernelName:ip,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{begin:i,size:o}=e,r=s.shape,[a,l]=op(s,i,o),u=[];for(let c=0;c<n.rank;c++)u.push([a[c],r[c]-a[c]-l[c]]);return{x:()=>li(n,u)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const D2={kernelName:mu,outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s]=t,{dim:i}=e,o=!0,r=O(n,s);return{logits:()=>Lt(r,O(Et(r,[i],o),s))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const R2={kernelName:Vr,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>O(n,Ws(e))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ch={kernelName:gu,gradFunc:(n,t,e)=>{const{blockShape:s,paddings:i}=e;return{x:()=>rp(n,s,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hh={kernelName:yu,gradFunc:(n,t,e)=>{const{axis:s}=e;return{x:()=>fs(n,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const A2={kernelName:ap,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Ct(n,O(ns(mt(e,"float32")),2))}}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const T2={kernelName:bu,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>O(n,O(mt(e,"float32"),2))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const z2={kernelName:lp,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,i=se(2);return{a:()=>O(n,O(i,Lt(e,s))),b:()=>O(n,O(i,Lt(s,e)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const F2={kernelName:Ur,gradFunc:n=>({x:()=>ce(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const M2={kernelName:up,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,i=Ne(e.shape,s.shape);return{a:()=>{let a=n;const l=$e(e.shape,i);return l.length>0&&(a=Et(a,l)),Q(a,e.shape)},b:()=>{let a=n;const l=$e(s.shape,i);return l.length>0&&(a=Et(a,l)),Q(Me(a),s.shape)}}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const P2={kernelName:xu,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,i=s.shape.slice(),{axis:o}=e;ee(o,s.shape).forEach(u=>{i[u]=1});const a=Q(n,i),l=O(a,Bs(s.shape,"float32"));return{x:()=>l}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const E2={kernelName:Gr,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Ct(n,Ie(fu(e)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const L2={kernelName:Hr,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>O(Lt(se(1),Ie(e)),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const O2={kernelName:wu,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{reps:i}=e;return{x:()=>{let r=ce(s);if(s.rank===1)for(let a=0;a<i[0];++a)r=ct(r,ue(n,[a*s.shape[0]],[s.shape[0]]));else if(s.rank===2)for(let a=0;a<i[0];++a)for(let l=0;l<i[1];++l)r=ct(r,ue(n,[a*s.shape[0],l*s.shape[1]],[s.shape[0],s.shape[1]]));else if(s.rank===3)for(let a=0;a<i[0];++a)for(let l=0;l<i[1];++l)for(let u=0;u<i[2];++u)r=ct(r,ue(n,[a*s.shape[0],l*s.shape[1],u*s.shape[2]],[s.shape[0],s.shape[1],s.shape[2]]));else if(s.rank===4)for(let a=0;a<i[0];++a)for(let l=0;l<i[1];++l)for(let u=0;u<i[2];++u)for(let c=0;c<i[3];++c)r=ct(r,ue(n,[a*s.shape[0],l*s.shape[1],u*s.shape[2],c*s.shape[3]],[s.shape[0],s.shape[1],s.shape[2],s.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${s.rank} tensors yet.`);return r}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _2={kernelName:cp,gradFunc:(n,t,e)=>{const s=e,{perm:i}=s,o=_s(i);return{x:()=>Vt(n,o)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const B2={kernelName:vu,gradFunc:(n,t,e)=>{const s=e,{axis:i}=s;return{value:()=>lo(n,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const W2={kernelName:Cu,inputsToSave:["segmentIds"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>V2(n,e)}}};function V2(n,t){const e=Vs(t,ce(t)),s=ku(n,e);let i=Ci(t,se(0,"int32"));const o=s.rank-i.rank;for(let a=0;a<o;++a)i=Ye(i,a+1);i=vi(i,Bs(s.shape,"bool"));const r=ce(s);return Zn(i,s,r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const U2={kernelName:Su,gradFunc:n=>({x:()=>ce(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const G2=[im,W1,V1,U1,G1,H1,j1,K1,X1,q1,Y1,Z1,tv,sv,iv,ov,rv,av,lv,uv,cv,hv,pv,dv,gv,yv,bv,xv,wv,vv,h2,Cv,kv,Sv,Iv,Nv,Dv,$v,Rv,Av,Tv,zv,Fv,Mv,Pv,Ev,Lv,Ov,_v,Vv,lh,lh,Uv,jv,qv,Yv,Zv,Qv,Jv,t2,e2,n2,s2,i2,o2,uh,uh,r2,a2,c2,d2,p2,f2,m2,g2,y2,b2,x2,w2,v2,C2,k2,S2,I2,N2,$2,D2,R2,ch,ch,hh,hh,A2,z2,T2,F2,M2,P2,E2,L2,O2,_2,B2,W2,U2];for(const n of G2)zx(n);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.abs=function(){return this.throwIfDisposed(),Ls(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.acos=function(){return this.throwIfDisposed(),Fx(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.acosh=function(){return this.throwIfDisposed(),Mx(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.add=function(n){return this.throwIfDisposed(),ct(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.all=function(n,t){return this.throwIfDisposed(),hp(this,n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.any=function(n,t){return this.throwIfDisposed(),Ja(this,n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.argMax=function(n){return this.throwIfDisposed(),ui(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.argMin=function(n){return this.throwIfDisposed(),Px(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.asScalar=function(){return this.throwIfDisposed(),tt(this.size===1,()=>"The array must have only 1 element."),Q(this,[])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.asType=function(n){return this.throwIfDisposed(),mt(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.as1D=function(){return this.throwIfDisposed(),Q(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.as2D=function(n,t){return this.throwIfDisposed(),Q(this,[n,t])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.as3D=function(n,t,e){return this.throwIfDisposed(),Q(this,[n,t,e])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.as4D=function(n,t,e,s){return this.throwIfDisposed(),Q(this,[n,t,e,s])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.as5D=function(n,t,e,s,i){return this.throwIfDisposed(),Q(this,[n,t,e,s,i])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.asin=function(){return this.throwIfDisposed(),Ex(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.asinh=function(){return this.throwIfDisposed(),Lx(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.atan=function(){return this.throwIfDisposed(),Ox(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.atan2=function(n){return this.throwIfDisposed(),_x(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.atanh=function(){return this.throwIfDisposed(),Bx(this)};H().prototype.avgPool=function(n,t,e,s){return this.throwIfDisposed(),dp(this,n,t,e,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.batchToSpaceND=function(n,t){return this.throwIfDisposed(),rp(this,n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.batchNorm=function(n,t,e,s,i){return this.throwIfDisposed(),Wx(this,n,t,e,s,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.broadcastTo=function(n){return this.throwIfDisposed(),Vx(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.cast=function(n){return this.throwIfDisposed(),mt(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.ceil=function(){return this.throwIfDisposed(),Ux(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.clipByValue=function(n,t){return this.throwIfDisposed(),Ue(this,n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.concat=function(n,t){return this.throwIfDisposed(),n instanceof Ge&&(n=[n]),fs([this,...n],t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.conv1d=function(n,t,e,s,i,o){return this.throwIfDisposed(),pp(this,n,t,e,s,i,o)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.conv2dTranspose=function(n,t,e,s,i){return this.throwIfDisposed(),fp(this,n,t,e,s,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.conv2d=function(n,t,e,s,i,o){return this.throwIfDisposed(),Vo(this,n,t,e,s,i,o)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.cos=function(){return this.throwIfDisposed(),fu(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.cosh=function(){return this.throwIfDisposed(),sp(this)};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.cumprod=function(n,t,e){return this.throwIfDisposed(),Qa(this,n,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.cumsum=function(n,t,e){return this.throwIfDisposed(),Od(this,n,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.depthToSpace=function(n,t){return this.throwIfDisposed(),Gx(this,n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.depthwiseConv2d=function(n,t,e,s,i,o){return this.throwIfDisposed(),mp(this,n,t,e,s,i,o)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.dilation2d=function(n,t,e,s,i){return this.throwIfDisposed(),Hx(this,n,t,e,s,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.divNoNan=function(n){return this.throwIfDisposed(),jx(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.div=function(n){return this.throwIfDisposed(),Ct(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.dot=function(n){return this.throwIfDisposed(),Kx(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.elu=function(){return this.throwIfDisposed(),Iu(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.equal=function(n){return this.throwIfDisposed(),ts(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.erf=function(){return this.throwIfDisposed(),gp(this)};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.euclideanNorm=function(n,t){return this.throwIfDisposed(),Xx(this,n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.exp=function(){return this.throwIfDisposed(),Qn(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.expandDims=function(n){return this.throwIfDisposed(),Ye(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.expm1=function(){return this.throwIfDisposed(),qx(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.fft=function(){return this.throwIfDisposed(),Yx(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.flatten=function(){return this.throwIfDisposed(),Q(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.floor=function(){return this.throwIfDisposed(),Jl(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.floorDiv=function(n){return this.throwIfDisposed(),Zx(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.gather=function(n,t,e){return this.throwIfDisposed(),ku(this,n,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.greaterEqual=function(n){return this.throwIfDisposed(),Ci(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.greater=function(n){return this.throwIfDisposed(),Wn(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.ifft=function(){return this.throwIfDisposed(),Qx(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.irfft=function(){return this.throwIfDisposed(),Jx(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.isFinite=function(){return this.throwIfDisposed(),tw(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.isInf=function(){return this.throwIfDisposed(),ew(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.isNaN=function(){return this.throwIfDisposed(),nw(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.leakyRelu=function(n){return this.throwIfDisposed(),yp(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.lessEqual=function(n){return this.throwIfDisposed(),vr(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.less=function(n){return this.throwIfDisposed(),qd(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.localResponseNormalization=function(n,t,e,s){return this.throwIfDisposed(),sw(this,n,t,e,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.logSigmoid=function(){return this.throwIfDisposed(),iw(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.logSoftmax=function(n){return this.throwIfDisposed(),bp(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.logSumExp=function(n,t){return this.throwIfDisposed(),xp(this,n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.log=function(){return this.throwIfDisposed(),ps(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.log1p=function(){return this.throwIfDisposed(),wp(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.logicalAnd=function(n){return this.throwIfDisposed(),vi(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.logicalNot=function(){return this.throwIfDisposed(),ep(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.logicalOr=function(n){return this.throwIfDisposed(),ow(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.logicalXor=function(n){return this.throwIfDisposed(),rw(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.matMul=function(n,t,e){return this.throwIfDisposed(),Dn(this,n,t,e)};H().prototype.maxPool=function(n,t,e,s){return this.throwIfDisposed(),vp(this,n,t,e,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.max=function(n,t){return this.throwIfDisposed(),ci(this,n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.maximum=function(n){return this.throwIfDisposed(),Vs(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.mean=function(n,t){return this.throwIfDisposed(),ve(this,n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.min=function(n,t){return this.throwIfDisposed(),Cp(this,n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.minimum=function(n){return this.throwIfDisposed(),jr(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.mirrorPad=function(n,t){return this.throwIfDisposed(),kp(this,n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.mod=function(n){return this.throwIfDisposed(),aw(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.mul=function(n){return this.throwIfDisposed(),O(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.neg=function(){return this.throwIfDisposed(),Me(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.norm=function(n,t,e){return this.throwIfDisposed(),lw(this,n,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.notEqual=function(n){return this.throwIfDisposed(),Ho(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.oneHot=function(n,t=1,e=0){return this.throwIfDisposed(),Sp(this,n,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.onesLike=function(){return this.throwIfDisposed(),ln(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.pad=function(n,t){return this.throwIfDisposed(),li(this,n,t)};H().prototype.pool=function(n,t,e,s,i,o){return this.throwIfDisposed(),uw(this,n,t,e,s,i,o)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.pow=function(n){return this.throwIfDisposed(),zr(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.prelu=function(n){return this.throwIfDisposed(),Ip(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.prod=function(n,t){return this.throwIfDisposed(),cw(this,n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.reciprocal=function(){return this.throwIfDisposed(),hw(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.relu=function(){return this.throwIfDisposed(),Si(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.relu6=function(){return this.throwIfDisposed(),dw(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.reshapeAs=function(n){return this.throwIfDisposed(),Q(this,n.shape)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.reshape=function(n){return this.throwIfDisposed(),Q(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.resizeBilinear=function(n,t,e){return this.throwIfDisposed(),pw(this,n,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.resizeNearestNeighbor=function(n,t,e){return this.throwIfDisposed(),fw(this,n,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.reverse=function(n){return this.throwIfDisposed(),Qi(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.rfft=function(){return this.throwIfDisposed(),mw(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.round=function(){return this.throwIfDisposed(),gw(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.rsqrt=function(){return this.throwIfDisposed(),Ud(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.selu=function(){return this.throwIfDisposed(),Np(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.separableConv2d=function(n,t,e,s,i,o){return this.throwIfDisposed(),$p(this,n,t,e,s,i,o)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.sigmoid=function(){return this.throwIfDisposed(),Ws(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.sign=function(){return this.throwIfDisposed(),yw(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.sin=function(){return this.throwIfDisposed(),Ed(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.sinh=function(){return this.throwIfDisposed(),Ld(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.slice=function(n,t){return this.throwIfDisposed(),ue(this,n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.softmax=function(n){return this.throwIfDisposed(),Nu(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.softplus=function(){return this.throwIfDisposed(),Kr(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.spaceToBatchND=function(n,t){return this.throwIfDisposed(),zd(this,n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.split=function(n,t){return this.throwIfDisposed(),Kn(this,n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.sqrt=function(){return this.throwIfDisposed(),ns(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.square=function(){return this.throwIfDisposed(),Ie(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.squaredDifference=function(n){return this.throwIfDisposed(),bw(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.squeeze=function(n){return this.throwIfDisposed(),Xt(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.stack=function(n,t){this.throwIfDisposed();const e=n instanceof Ge?[this,n]:[this,...n];return lo(e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.step=function(n){return this.throwIfDisposed(),hr(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.stridedSlice=function(n,t,e,s,i,o,r,a){return this.throwIfDisposed(),xw(this,n,t,e,s,i,o,r,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.sub=function(n){return this.throwIfDisposed(),Lt(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.sum=function(n,t){return this.throwIfDisposed(),Et(this,n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.tan=function(){return this.throwIfDisposed(),ww(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.tanh=function(){return this.throwIfDisposed(),Xr(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.tile=function(n){return this.throwIfDisposed(),As(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.toBool=function(){return this.throwIfDisposed(),mt(this,"bool")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.toFloat=function(){return this.throwIfDisposed(),mt(this,"float32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.toInt=function(){return this.throwIfDisposed(),mt(this,"int32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.topk=function(n,t){return this.throwIfDisposed(),vw(this,n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.transpose=function(n){return this.throwIfDisposed(),Vt(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.unique=function(n){return this.throwIfDisposed(),Cw(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.unsortedSegmentSum=function(n,t){return this.throwIfDisposed(),Gd(this,n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.unstack=function(n){return this.throwIfDisposed(),Zi(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.where=function(n,t){return this.throwIfDisposed(),Zn(n,this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.zerosLike=function(){return this.throwIfDisposed(),ce(this)};/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class An extends Error{constructor(t){super(t),Object.setPrototypeOf(this,An.prototype)}}class an extends Error{constructor(t){super(t),Object.setPrototypeOf(this,an.prototype)}}class M extends Error{constructor(t){super(t),Object.setPrototypeOf(this,M.prototype)}}class At extends Error{constructor(t){super(t),Object.setPrototypeOf(this,At.prototype)}}class Ou extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Ou.prototype)}}/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class rm{constructor(t){this.maxEntries=t||100,this.cache=new Map}get(t){let e;return this.cache.has(t)&&(e=this.cache.get(t),this.cache.delete(t),this.cache.set(t,e)),e}put(t,e){if(this.cache.has(t))this.cache.delete(t);else if(this.cache.size>=this.maxEntries){const s=this.cache.keys().next().value;this.cache.delete(s)}this.cache.set(t,e)}getMaxEntries(){return this.maxEntries}setMaxEntries(t){if(t<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${t}.`);if(this.maxEntries>t)for(let e=0;e<this.maxEntries-t;e++){const s=this.cache.keys().next().value;this.cache.delete(s)}this.maxEntries=t}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Os(n,t){if(Array.isArray(n)){let e=[];for(let s=0;s<t;s++)e=e.concat(n);return e}else{const e=new Array(t);return e.fill(n),e}}function Tn(n,t){if(!n)throw new Ou(t)}function dh(n,t){let e=0;for(const s of n)s===t&&e++;return e}function Ee(n){return n.length===1?n[0]:n}function Kt(n){return Array.isArray(n)?n:[n]}function Hn(n){const e=n.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return e[0]!=="_"?e:"private"+e}function Ds(n){return n.length<=1||n.indexOf("_")===-1?n:n.replace(/[_]+(\w|$)/g,(t,e)=>e.toUpperCase())}let on={};function _u(n){if(n==null)return null;const t={};return t.className=n.getClassName(),t.config=n.getConfig(),t}function tl(n){if(!(n==null||typeof n!="object"))if(Array.isArray(n))n.forEach(t=>tl(t));else{const t=Object.keys(n);for(const e of t){const s=n[e];s!=null&&typeof s=="object"&&(!Array.isArray(s)&&s.type==="ndarray"&&typeof s.value=="number"?n[e]=s.value:tl(s))}}}function po(n,t={},e={},s="object",i=!1){if(typeof n=="string"){const o=n;let r;if(o in e)r=e[o];else if(o in on)r=on[o];else if(r=t[o],r==null)throw new M(`Unknown ${s}: ${n}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return r}else{const o=n;if(o.className==null||o.config==null)throw new M(`${s}: Improper config format: ${JSON.stringify(o)}.
'className' and 'config' must set.`);const r=o.className;let a,l;if(r in e?[a,l]=e[r]:r in on?[a,l]=on.className:r in t&&([a,l]=t[r]),a==null)throw new M(`Unknown ${s}: ${r}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(l!=null){const u={};for(const f of Object.keys(on))u[f]=on[f];for(const f of Object.keys(e))u[f]=e[f];const c=o.config;c.customObjects=u;const h=Object.assign({},on);for(const f of Object.keys(e))on[f]=e[f];tl(o.config);const p=l(a,o.config,e,i);return on=Object.assign({},h),p}else{const u=Object.assign({},on);for(const h of Object.keys(e))on[h]=e[h];const c=new a(o.config);return on=Object.assign({},u),c}}}function H2(n,t){return n<t?-1:n>t?1:0}function Eo(n,t){return-1*H2(n,t)}function hs(n){if(n==null)return n;const t=[];for(const e of n)t.indexOf(e)===-1&&t.push(e);return t}function j2(n){if(n==null)throw new M(`Invalid value in obj: ${JSON.stringify(n)}`);for(const t in n)if(n.hasOwnProperty(t))return!1;return!0}function Hs(n,t,e){if(e!=null&&n.indexOf(e)<0)throw new M(`${e} is not a valid ${t}.  Valid values are ${n} or null/undefined.`)}function Bu(n,t,e=0,s=1/0){return Tn(e>=0),Tn(s>=e),Array.isArray(n)&&n.length>=e&&n.length<=s&&n.every(i=>typeof i===t)}function Ce(n,t){Array.isArray(n)?(tt(n.length>0,()=>`${t} is unexpectedly an empty array.`),n.forEach((e,s)=>Ce(e,`element ${s+1} of ${t}`))):tt(Number.isInteger(n)&&n>0,()=>`Expected ${t} to be a positive integer, but got ${am(n)}.`)}function am(n){return n===null?"null":Array.isArray(n)?"["+n.map(t=>am(t)).join(",")+"]":typeof n=="string"?`"${n}"`:`${n}`}function K2(n,t,e){let s=e!=null?e():jo(),i;return(...r)=>{const a=e!=null?e():jo();return a-s<t||(s=a,i=n(...r)),i}}function lm(n){return n==="relu"?"relu":n==="linear"?"linear":n==="elu"?"elu":null}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let X2=0;function um(){return X2++}const Lo={};function ta(n=""){return n in Lo||(Lo[n]=0),Lo[n]+=1,n+Lo[n].toString()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const q2=["channelsFirst","channelsLast"],Y2=["nearest","bilinear"],Z2=["valid","same","causal"],Q2=["max","avg"],J2=["sum","mul","concat","ave"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const ti=new Map;function pe(n){Hs(q2,"DataFormat",n)}function tC(n){Hs(Y2,"InterpolationFormat",n)}function Qe(n){Hs(Z2,"PaddingMode",n)}function cm(n){Hs(Q2,"PoolMode",n)}const qi=[],ph="/";function Fs(n,t){qi.push(n);try{const e=t();return qi.pop(),e}catch(e){throw qi.pop(),e}}function eC(){return qi.length===0?"":qi.join(ph)+ph}function hm(n){if(!pm(n))throw new Error("Not a valid tensor name: '"+n+"'");return eC()+n}function dm(n){if(!pm(n))throw new Error("Not a valid tensor name: '"+n+"'");ti.has(n)||ti.set(n,0);const t=ti.get(n);if(ti.set(n,ti.get(n)+1),t>0){const e=`${n}_${t}`;return ti.set(e,1),e}else return n}const nC=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function pm(n){return!!n.match(nC)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function sC(n){return n===parseInt(n.toString(),10)}function ds(n,t,e){t==null&&(t=0),e==null&&(e=n.length);let s=1;for(let i=t;i<e;++i)s*=n[i];return s}function mi(n){if(n.length===0)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let e=0;e<n.length;e++){const s=n[e];s<t&&(t=s)}return t}function ms(n){if(n.length===0)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let e=0;e<n.length;e++){const s=n[e];s>t&&(t=s)}return t}function bn(n,t){if(t<n)throw new M(`end (${t}) < begin (${n}) is forbidden.`);const e=[];for(let s=n;s<t;++s)e.push(s);return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let Pa;function ge(){return Pa==null&&(Pa=hi().epsilon()),Pa}function xn(){return"channelsLast"}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Pn(n,t){return mt(n,t)}function fo(n,t=-1){const e=n.shape.slice();return t<0&&(t=e.length+t+1),e.splice(t,0,1),Q(n,e)}function iC(n,t){return B(()=>{if(n.shape.length!==2)throw new M(`repeat() expects a rank-2 tensor, but received a rank-${n.shape.length} tensor.`);const e=fo(n,1);return el(e,[1,t,1])})}function oC(n){const t=[ds(n.shape)];return Q(n,t)}function rC(n){if(n.rank<=1)throw new M(`batchFlatten requires a minimum rank of 2. Got rank: ${n.rank}.`);const t=[n.shape[0],ds(n.shape,1)];return Q(n,t)}function Ms(n,t,e){return B(()=>{switch(n.rank){case 1:return Du(n,t,e);case 2:return Dp(n,[t,0],[e,n.shape[1]]);case 3:return $u(n,[t,0,0],[e,n.shape[1],n.shape[2]]);case 4:return Ko(n,[t,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3]]);case 5:return ue(n,[t,0,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3],n.shape[4]]);case 6:return ue(n,[t,0,0,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3],n.shape[4],n.shape[5]]);default:throw new M(`sliceAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}})}function Ea(n,t,e){return B(()=>{switch(n.rank){case 1:return Du(n,t,e);case 2:return Dp(n,[0,t],[n.shape[0],e]);case 3:return $u(n,[0,0,t],[n.shape[0],n.shape[1],e]);case 4:return Ko(n,[0,0,0,t],[n.shape[0],n.shape[1],n.shape[2],e]);default:throw new M(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function Oo(n,t,e,s){return B(()=>{switch(n.rank){case 1:return Du(n,t,e);case 2:switch(s){case 1:return Ms(n,t,e);case 2:return Ea(n,t,e);default:throw new M(`The axis is not within the rank of the tensor ${s}`)}case 3:switch(s){case 1:return Ms(n,t,e);case 2:return $u(n,[0,t,0],[n.shape[0],e,n.shape[2]]);case 3:return Ea(n,t,e);default:throw new M(`The axis is not within the rank of the tensor ${s}`)}case 4:switch(s){case 1:return Ms(n,t,e);case 2:return Ko(n,[0,t,0,0],[n.shape[0],e,n.shape[2],n.shape[3]]);case 3:return Ko(n,[0,0,t,0],[n.shape[0],n.shape[1],e,n.shape[3]]);case 4:return Ea(n,t,e);default:throw new M(`The axis is not within the rank of the tensor ${s}`)}default:throw new M(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function Wu(n,t=-1){let e;return t<0&&(e=n[0].rank,e!==0?t=e:t=0),t===n[0].rank&&(t=-1),fs(n,t)}function fh(n,t){switch(n.rank){case 1:return $w([n,t]);case 2:return Nw([n,t],0);case 3:return Iw([n,t],0);case 4:return Sw([n,t],0);default:throw new M(`concatAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}}function el(n,t){if(Array.isArray(t)||(t=[t]),n.rank!==t.length)throw new M(`The length of input n (${t.length}) does not match the number of dimensions in input x (${n.rank})`);return As(n,t)}function ea(n,t=0,e=1,s,i){return kw(n,t,e,s,i)}function En(n,t,e,s){if(n.rank<2||t.rank<2)throw new At(`dot requires both inputs to be rank >= 2 but got x shape = ${n.shape} and y shape = ${t.shape}`);if(t.rank>=3){const i=n.shape.slice(-1)[0],o=t.shape.slice(-2)[0];if(i!==o)throw new At(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${n.shape} and  y shape = ${t.shape}`)}if(n.rank===2&&t.rank===2)return Yc({a:n,b:t,transposeA:!1,transposeB:!1,bias:s?nl(n.rank,s,xn()):null,activation:e});{const i=n.shape.slice(),o=i.pop();n=Q(n,[-1,o]);const r=t.shape.slice(),a=r.pop(),l=r.pop(),u=[...r,a],c=Array.from({length:t.rank},(m,g)=>g===0?t.rank-2:g<=t.rank-2?g-1:g);t=Q(Vt(t,c),[l,-1]);const h=[...i,...u];return Q(Yc({a:n,b:t,transposeA:!1,transposeB:!1,bias:s?nl(n.rank,s,xn()):null,activation:e}),h)}}function fm(n,t,e){return B(()=>(Array.isArray(t)?t=jn(t,"int32"):t=mt(t,"int32"),ku(n,t,e)))}function mo(n){return O(n,n)}function nl(n,t,e){const s=t.shape;if(t.rank!==1&&t.rank!==n)throw new M(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${n}`);if(n===5){if(e==="channelsFirst")return s.length===1?Q(t,[1,s[0],1,1,1]):Q(t,[1,s[3],s[0],s[1],s[2]]);if(e==="channelsLast")return s.length===1?Q(t,[1,1,1,1,s[0]]):Q(t,[1].concat(s))}else if(n===4){if(e==="channelsFirst")return s.length===1?Q(t,[1,s[0],1,1]):Q(t,[1,s[2],s[0],s[1]]);if(e==="channelsLast")return s.length===1?Q(t,[1,1,1,s[0]]):Q(t,[1].concat(s))}else if(n===3){if(e==="channelsFirst")return s.length===1?Q(t,[1,s[0],1]):Q(t,[1,s[1],s[0]]);if(e==="channelsLast")return s.length===1?Q(t,[1,1,s[0]]):Q(t,[1].concat(s))}else if(n<3)return t;throw new M(`Unsupported input rank by biasAdd: ${t.rank}`)}function wn(n,t,e){return B(()=>(e==null&&(e=xn()),pe(e),ct(n,nl(n.rank,t,e))))}function aC(n,t=1){if(t!==1)throw new At(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return Iu(n)}function lC(n){return B(()=>Ct(n,ct(Ls(n),1)))}function mm(n,t,e,s){return B(()=>Dw(n,t,e,s))}function uC(n){return B(()=>{const t=ct(.5,O(.2,n));return Ue(t,0,1)})}function go(n,t,e=!1){return e?n():t()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const cC=["fanIn","fanOut","fanAvg"],hC=["normal","uniform","truncatedNormal"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function dC(n){Hs(cC,"FanMode",n)}function pC(n){Hs(hC,"Distribution",n)}class cn extends uo{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class gm extends cn{apply(t,e){return Le(t,e)}}gm.className="Zeros";q(gm);class Vu extends cn{apply(t,e){return Bs(t,e)}}Vu.className="Ones";q(Vu);class ym extends cn{constructor(t){if(super(),typeof t!="object")throw new M(`Expected argument of type ConstantConfig but got ${t}`);if(t.value===void 0)throw new M(`config must have value set but got ${t}`);this.value=t.value}apply(t,e){return B(()=>O(se(this.value),Bs(t,e)))}getConfig(){return{value:this.value}}}ym.className="Constant";q(ym);class bm extends cn{constructor(t){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=t.minval||this.DEFAULT_MINVAL,this.maxval=t.maxval||this.DEFAULT_MAXVAL,this.seed=t.seed}apply(t,e){return qr(t,this.minval,this.maxval,e,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}bm.className="RandomUniform";q(bm);class xm extends cn{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if(e=e||"float32",e!=="float32"&&e!=="int32")throw new At(`randomNormal does not support dType ${e}.`);return ea(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}xm.className="RandomNormal";q(xm);class wm extends cn{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if(e=e||"float32",e!=="float32"&&e!=="int32")throw new At(`truncatedNormal does not support dType ${e}.`);return Rp(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}wm.className="TruncatedNormal";q(wm);class vm extends cn{constructor(t){super(),this.gain=t.gain!=null?t.gain:1}apply(t,e){return B(()=>{if(t.length!==2||t[0]!==t[1])throw new M("Identity matrix initializer can only be used for 2D square matrices.");return O(this.gain,Rw(t[0]))})}getConfig(){return{gain:this.gain}}}vm.className="Identity";q(vm);function fC(n,t="channelsLast"){let e,s;if(pe(t),n.length===2)e=n[0],s=n[1];else if([3,4,5].indexOf(n.length)!==-1){if(t==="channelsFirst"){const i=ds(n,2);e=n[1]*i,s=n[0]*i}else if(t==="channelsLast"){const i=ds(n,0,n.length-2);e=n[n.length-2]*i,s=n[n.length-1]*i}}else{const i=ds(n);e=Math.sqrt(i),s=Math.sqrt(i)}return[e,s]}class He extends cn{constructor(t){if(super(),t.scale<0)throw new M(`scale must be a positive float. Got: ${t.scale}`);this.scale=t.scale==null?1:t.scale,this.mode=t.mode==null?"fanIn":t.mode,dC(this.mode),this.distribution=t.distribution==null?"normal":t.distribution,pC(this.distribution),this.seed=t.seed}apply(t,e){const s=fC(t),i=s[0],o=s[1];let r=this.scale;if(this.mode==="fanIn"?r/=Math.max(1,i):this.mode==="fanOut"?r/=Math.max(1,o):r/=Math.max(1,(i+o)/2),this.distribution==="normal"){const a=Math.sqrt(r);if(e=e||"float32",e!=="float32"&&e!=="int32")throw new At(`${this.getClassName()} does not support dType ${e}.`);return Rp(t,0,a,e,this.seed)}else{const a=Math.sqrt(3*r);return qr(t,-a,a,e,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}He.className="VarianceScaling";q(He);class Uu extends He{constructor(t){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return He.className}}Uu.className="GlorotUniform";q(Uu);class Gu extends He{constructor(t){super({scale:1,mode:"fanAvg",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return He.className}}Gu.className="GlorotNormal";q(Gu);class Hu extends He{constructor(t){super({scale:2,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return He.className}}Hu.className="HeNormal";q(Hu);class ju extends He{constructor(t){super({scale:2,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return He.className}}ju.className="HeUniform";q(ju);class Ku extends He{constructor(t){super({scale:1,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return He.className}}Ku.className="LeCunNormal";q(Ku);class Xu extends He{constructor(t){super({scale:1,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return He.className}}Xu.className="LeCunUniform";q(Xu);class Cm extends cn{constructor(t){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=t.gain==null?this.DEFAULT_GAIN:t.gain,this.seed=t.seed}apply(t,e){return B(()=>{if(t.length<2)throw new At("Shape must be at least 2D.");if(e!=="int32"&&e!=="float32"&&e!==void 0)throw new TypeError(`Unsupported data type ${e}.`);e=e;const s=et(t.slice(0,-1)),i=t[t.length-1],o=s*i;o>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${o}) elements: Slowness may result.`);const r=[Math.max(i,s),Math.min(i,s)],a=ea(r,0,1,e,this.seed),l=Aw.qr(a,!1);let u=l[0];const h=l[1].flatten().stridedSlice([0],[Math.min(i,s)*Math.min(i,s)],[Math.min(i,s)+1]);return u=O(u,h.sign()),s<i&&(u=u.transpose()),O(se(this.gain),u.reshape(t))})}getConfig(){return{gain:this.gain,seed:this.seed}}}Cm.className="Orthogonal";q(Cm);const mh={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function gh(n,t={}){return po(n,co.getMap().classNameMap,t,"initializer")}function ae(n){return _u(n)}function oe(n){if(typeof n=="string"){const t=n in mh?mh[n]:n;if(t==="GlorotNormal")return new Gu;if(t==="GlorotUniform")return new Uu;if(t==="HeNormal")return new Hu;if(t==="HeUniform")return new ju;if(t==="LeCunNormal")return new Ku;if(t==="LeCunUniform")return new Xu;{const e={};return e.className=t,e.config={},gh(e)}}else return n instanceof cn?n:gh(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function sl(n){return Array.isArray(n)&&Array.isArray(n[0])}function qo(n){return n.length===0?[]:Array.isArray(n[0])?n:[n]}function kt(n){let t;if(Array.isArray(n)){if(n.length!==1)throw new M(`Expected Tensor length to be 1; got ${n.length}`);t=n[0]}else t=n;return t}function Wt(n){if(Array.isArray(n)&&Array.isArray(n[0])){if(n.length===1)return n=n,n[0];throw new M(`Expected exactly 1 Shape; got ${n.length}`)}else return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Yo(n){let t=0;for(const e of n)e.shape.length===0?t+=1:t+=e.shape.reduce((s,i)=>s*i);return t}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const yh="Variable";class mC{constructor(t,e="float32",s=yh,i=!0,o=null){this.dtype=e??"float32",this.shape=t.shape,this.id=um(),s=s??yh,this.originalName=hm(s),this.name=dm(this.originalName),this.trainable_=i,this.constraint=o,this.val=Tw(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),gC(this.val,t),this.val.id!==t.id&&(this.val.assign(t),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}}function gC(n,t){if(n.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(n.shape)+" vs. "+JSON.stringify(t.shape))}function il(n){return n.map(t=>t.read())}function qu(n){n.forEach(t=>{t[0].write(t[1])})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class ye{constructor(t){this.dtype=t.dtype,this.shape=t.shape,t.shape!=null?this.ndim=t.shape.length:this.ndim=t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}}class On{constructor(t,e,s,i,o,r,a){this.dtype=t,this.shape=e,this.sourceLayer=s,this.inputs=i,this.callArgs=o,this.outputTensorIndex=a,this.id=um(),r!=null&&(this.originalName=hm(r),this.name=dm(this.originalName)),this.rank=e.length}}let yC=0;class na{constructor(t,e){this.callArgs=e,this.id=yC++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(const s of t.inboundLayers)s!=null&&s.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){const t=[];for(const e of this.inboundLayers)e!=null?t.push(e.name):t.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let bC=0;class Ft extends uo{constructor(t={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=bC++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=t.name;if(!e){const s=this.getClassName();e=Hn(s)+"_"+ta(s)}if(this.name=e,this.trainable_=t.trainable==null?!0:t.trainable,t.inputShape!=null||t.batchInputShape!=null){let s;if(t.batchInputShape!=null)s=t.batchInputShape;else if(t.inputShape!=null){let o=null;t.batchSize!=null&&(o=t.batchSize),s=[o].concat(t.inputShape)}this.batchInputShape=s;let i=t.dtype;i==null&&(i=t.inputDType),i==null&&(i="float32"),this.dtype=i}t.weights!=null?this.initialWeights=t.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,e){return t.name+"_ib-"+e.toString()}getNodeAtIndex(t,e){if(this.inboundNodes.length===0)throw new an(`The layer has never been called and thus has no defined ${e}.`);if(this.inboundNodes.length<=t)throw new M(`Asked to get ${e} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[t]}getInputAt(t){return Ee(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return Ee(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new An(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new An(`Layer ${this.name} is not connected, no input to return.`);return Ee(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new An(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new An(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Ee(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(t=>t())}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach(e=>e.trainable=t),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(t=>t.trainable):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(t=>!t.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){const e=Kt(t);if(this.inputSpec==null||this.inputSpec.length===0)return;const s=Kt(this.inputSpec);if(e.length!==s.length)throw new M(`Layer ${this.name} expects ${s.length} inputs, but it received ${e.length} input tensors. Input received: ${t}`);for(let i=0;i<e.length;i++){const o=e[i],r=s[i];if(r==null)continue;const a=o.rank;if(r.ndim!=null&&a!==r.ndim)throw new M(`Input ${i} is incompatible with layer ${this.name}: expected ndim=${r.ndim}, found ndim=${a}`);if(r.maxNDim!=null&&a>r.maxNDim)throw new M(`Input ${i} is incompatible with layer ${this.name}: expected max_ndim=${r.maxNDim}, found ndim=${a}`);if(r.minNDim!=null&&a<r.minNDim)throw new M(`Input ${i} is incompatible with layer ${this.name}: expected min_ndim=${r.minNDim}, found ndim=${a}.`);if(r.dtype!=null&&o.dtype!==r.dtype)throw new M(`Input ${i} is incompatible with layer ${this.name} : expected dtype=${r.dtype}, found dtype=${o.dtype}.`);if(r.axes){const l=o.shape;for(const u in r.axes){const c=Number(u),h=r.axes[u],p=c>=0?l[c]:l[l.length+c];if(h!=null&&[h,null].indexOf(p)===-1)throw new M(`Input ${i} is incompatible with layer ${this.name}: expected axis ${c} of input shape to have value ${h} but got shape ${l}.`)}}if(r.shape!=null)for(let l=0;l<r.shape.length;++l){const u=r.shape[l],c=o.shape[l];if(u!=null&&c!=null&&u!==c)throw new M(`Input ${i} is incompatible with layer ${this.name}: expected shape=${r.shape}, found shape=${o.shape}.`)}}}call(t,e){return t}invokeCallHook(t,e){this._callHook!=null&&this._callHook(t,e)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,e){e=e||{},this.assertNotDisposed();const s=Kt(t),i=vC(t),o=CC(t);if(i===o)throw new M("Arguments to apply() must be all SymbolicTensors or all Tensors");return Fs(this.name,()=>{if(!this.built){this.assertInputCompatibility(t);const r=[];for(const a of Kt(t))r.push(a.shape);this.build(Ee(r)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&o&&(this._refCount=1)}if(this.assertInputCompatibility(t),o){let r=this.call(t,e);this.supportsMasking&&this.setMaskMetadata(t,r);const a=Kt(r),l=[];for(let u of a)s.indexOf(u)!==-1&&(u=u.clone()),l.push(u);if(r=Ee(l),this.activityRegularizer!=null)throw new At("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}else{const r=xC(t),a=this.computeOutputShape(r);let l;const u=wC(t);if(this.warnOnIncompatibleInputShape(Array.isArray(t)?r[0]:r),a!=null&&a.length>0&&Array.isArray(a[0])?l=a.map((c,h)=>new On(u,c,this,Kt(t),e,this.name,h)):l=new On(u,a,this,Kt(t),e,this.name),this.addInboundNode(t,l,null,null,r,a,e),this._refCount++,this.activityRegularizer!=null)throw new At("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}})}warnOnIncompatibleInputShape(t){if(this.batchInputShape!=null)if(t.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(t)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let e=!1;this.batchInputShape.forEach((s,i)=>{s!=null&&t[i]!=null&&t[i]!==s&&(e=!0)}),e&&console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new An(`The layer ${this.name} has never been called and thus has no defined output shape.`);const t=[];for(const e of this.inboundNodes){const s=JSON.stringify(e.outputShapes);t.indexOf(s)===-1&&t.push(s)}if(t.length===1){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&e.length===1?e[0]:e}else throw new An(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new an(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return Yo(this.weights)}build(t){this.built=!0}getWeights(t=!1){return il(t?this.trainableWeights:this.weights)}setWeights(t){B(()=>{const e=this.weights;if(e.length!==t.length)throw new M(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${e.length} weights. Provided weights: ${t}...`);if(e.length===0)return;const s=[],i=il(e);for(let o=0;o<i.length;++o){const r=i[o],a=e[o],l=t[o];if(!ke(r.shape,l.shape))throw new M(`Layer weight shape ${r.shape} not compatible with provided weight shape ${l.shape}`);s.push([a,l])}qu(s)})}addWeight(t,e,s,i,o,r,a,l){if(this._addedWeightNames.indexOf(t)!==-1)throw new M(`Duplicate weight name ${t} for layer ${this.name}`);this._addedWeightNames.push(t),s==null&&(s="float32"),this.fastWeightInitDuringBuild&&(i=l!=null?l():oe("zeros"));const u=i.apply(e,s),c=new mC(u,s,t,r,a);return u.dispose(),o!=null&&this.addLoss(()=>o.apply(c.read())),r==null&&(r=!0),r?this._trainableWeights.push(c):this._nonTrainableWeights.push(c),c}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){t==null||Array.isArray(t)&&t.length===0||(t=Kt(t),this._losses!==void 0&&this._losses!==null&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,e){if(!this.supportsMasking){if(e!=null)if(Array.isArray(e))e.forEach(s=>{if(s!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return e}setMaskMetadata(t,e,s){if(!this.supportsMasking)return;const i=this.computeMask(t,s),o=Kt(e),r=Kt(i);if(o.length!==r.length)throw new Error(`${this.name} outputs ${o.length} tensors but ${o.length} masks for those tensors`);for(let a=0;a<o.length;a++)o[a].kerasMask=r[a]}addInboundNode(t,e,s,i,o,r,a=null){const l=Kt(t);e=Kt(e),s=Kt(s),i=Kt(i),o=qo(o),r=qo(r);const u=[],c=[],h=[];for(const p of l)u.push(p.sourceLayer),c.push(p.nodeIndex),h.push(p.tensorIndex);new na({outboundLayer:this,inboundLayers:u,nodeIndices:c,tensorIndices:h,inputTensors:l,outputTensors:e,inputMasks:s,outputMasks:i,inputShapes:o,outputShapes:r},a);for(let p=0;p<e.length;p++)e[p].sourceLayer=this,e[p].nodeIndex=this.inboundNodes.length-1,e[p].tensorIndex=p}getConfig(){const t={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(t.batchInputShape=this.batchInputShape),this.dtype!=null&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach(t=>t.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let t=0;return--this._refCount===0&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}}function xC(n){n=Kt(n);const t=[];for(const e of n)t.push(e.shape);return Ee(t)}function wC(n){return"float32"}function km(n,t,e){if((t==null||e!=null&&e>0)&&(t=n.sourceLayer,e=n.nodeIndex),t.inboundNodes.length===0)return[n];{const s=t.inboundNodes[e];if(s.inboundLayers.length===0)return s.inputTensors;{const i=[];for(let o=0;o<s.inboundLayers.length;o++){const r=s.inputTensors[o],a=s.inboundLayers[o],l=s.nodeIndices[o],u=km(r,a,l);for(const c of u)i.indexOf(c)===-1&&i.push(c)}return i}}}function vC(n){let t=!0;for(const e of Kt(n))if(!(e instanceof On)){t=!1;break}return t}function CC(n){let t=!0;for(const e of Kt(n))if(e instanceof On){t=!1;break}return t}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class yo extends Ft{constructor(t){if(super({dtype:t.dtype,name:t.name!=null?t.name:ta("input").toString()}),t.batchSize==null&&(t.batchSize=null),t.sparse==null&&(t.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=t.sparse,t.inputShape!=null&&t.batchInputShape!=null)throw new M("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let e=t.batchInputShape;if(e==null){if(t.inputShape==null)throw new M("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");e=[t.batchSize].concat(t.inputShape)}else if(t.batchSize!=null)throw new M("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const s=t.dtype||"float32";this.batchInputShape=e,this.dtype=s,this.inputSpec=[{shape:e}];const i=new On(this.dtype,this.batchInputShape,this,[],{},this.name);i.nodeIndex=0,i.tensorIndex=0,new na({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[i],outputTensors:[i],inputMasks:[null],outputMasks:[null],inputShapes:[e],outputShapes:[e]})}apply(t,e){throw new M(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}yo.className="InputLayer";q(yo);function kC(n){if(n.batchShape==null&&n.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(n.batchShape!=null&&n.shape!=null)throw new M("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=n.batchShape;n.shape!=null&&t==null&&(t=[null].concat(n.shape));let e=n.dtype;return e==null&&(e="float32"),new yo({batchInputShape:t,name:n.name,dtype:e,sparse:n.sparse}).inboundNodes[0].outputTensors[0]}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function SC(n,t){if(n.dtype==null||n.dtype===t.dtype)return t;try{return mt(t,n.dtype)}catch{throw new M(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${n.name}' (${n.dtype}).`)}}class as{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof as)for(const e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(t==null)return;for(const e of t)this.add(e.key,e.value)}}add(t,e,s){if(this.id2Value[t.id]==null)this.id2Value[t.id]=SC(t,e),this.name2Id[t.name]=t.id,s!=null&&(this.id2Mask[t.id]=s);else throw new M(`Duplicate key: name=${t.name}, id=${t.id}`);return this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return this.id2Value[t.id]!=null}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof On){if(this.id2Value[t.id]==null)throw new M(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}else{const e=this.name2Id[t];if(e==null)throw new M(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[e]}}getMask(t){if(t instanceof On){if(this.id2Value[t.id]==null)throw new M(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}else{const e=this.name2Id[t];if(e==null)throw new M(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[e]}}disposeMasks(){this.id2Mask!=null&&zt(this.id2Mask)}}const Zo=new rm,Qo=new rm;function IC(n){Zo!=null&&Zo.setMaxEntries(n),Qo!=null&&Qo.setMaxEntries(n)}function Hi(n,t,e,s){const i=e==null?!1:e.training,o=Array.isArray(n),r=o?n:[n],a=r.map(m=>m.name),l=[],u=t.names();for(const m of a)u.indexOf(m)!==-1?l.push(t.getValue(m)):l.push(null);const c=a.join(",")+"|"+t.names().sort().join(",");let h=Zo.get(c),p;if(h==null){const m=NC(r,t);h=m.sorted,p=m.recipientCounts,Zo.put(c,h),Qo.put(c,p)}p={},i||Object.assign(p,Qo.get(c));const f=new as(t);for(let m=0;m<h.length;++m){const g=h[m],b=g.sourceLayer;if(b instanceof yo)continue;const v=[],w=[],k=[];let C=!1;for(const z of g.inputs){const F=f.getValue(z),E=f.getMask(z);v.push(F),w.push(E),E!=null&&(C=!0),i||(p[z.name]--,p[z.name]===0&&!t.hasKey(z)&&a.indexOf(z.name)===-1&&!F.isDisposed&&z.sourceLayer.stateful!==!0&&k.push(F))}C&&(e=e||{},e.mask=w[0]);const I=Kt(b.apply(v,e));let N=null;b.supportsMasking&&(N=b.computeMask(v,w));const $=DC(g),A=Array.isArray($)?$:[$];for(let z=0;z<A.length;++z){f.hasKey(A[z])||f.add(A[z],I[z],Array.isArray(N)?N[0]:N);const F=a.indexOf(A[z].name);F!==-1&&(l[F]=I[z])}i||zt(k)}return f.disposeMasks(),o?l:l[0]}function NC(n,t){tt(n!=null&&n.length>0,()=>"Expected at least one fetch, got none");let e=[],s={};if(n.length===1){const i=bh(n[0],t);e=i.sorted,s=i.recipientMap}else{const i=new Set;for(const o of n){const{sorted:r,recipientMap:a}=bh(o,t);for(const l of r)i.has(l.name)||(e.push(l),i.add(l.name));for(const l in a)s[l]==null&&(s[l]=new Set),a[l].forEach(u=>s[l].add(u))}}return{sorted:e,recipientCounts:$C(s)}}function $C(n){const t={};for(const e in n)t[e]=n[e].size;return t}function bh(n,t){const e=new Set,s=[],i={};for(const a of t.names())e.add(a);const o=[],r=[];for(o.push(n);o.length>0;){const a=o[o.length-1];if(e.has(a.name)){o.pop();continue}const l=r[r.length-1]===o.length-1;if(a.inputs.length===0||l)o.pop(),s.push(a),e.add(a.name),l&&r.pop();else{r.push(o.length-1);for(const u of a.inputs)i[u.name]==null&&(i[u.name]=new Set),i[u.name].add(a.name),!e.has(u.name)&&o.push(u)}}return{sorted:s,recipientMap:i}}function DC(n){let t;if(n.sourceLayer.inboundNodes.length===1)t=n.sourceLayer.output;else{let e=null;for(let s=0;s<n.sourceLayer.inboundNodes.length;++s)for(const i of n.sourceLayer.inboundNodes[s].outputTensors)if(i.id===n.id){e=s;break}t=n.sourceLayer.getOutputAt(e)}return t}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RC=he();RC.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,IC);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Yu(n,t){return B(()=>ns(Et(O(n,n),t,!0)))}class bo extends uo{getConfig(){return{}}}class Sm extends bo{constructor(t){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return B(()=>{const e=Yu(t,this.axis),s=Ue(e,0,this.maxValue);return O(t,Ct(s,ct(ge(),e)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}Sm.className="MaxNorm";q(Sm);class Im extends bo{constructor(t){super(),this.defaultAxis=0,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return B(()=>Ct(t,ct(ge(),Yu(t,this.axis))))}getConfig(){return{axis:this.axis}}}Im.className="UnitNorm";q(Im);class Nm extends bo{apply(t){return Si(t)}}Nm.className="NonNeg";q(Nm);class $m extends bo{constructor(t){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=t.minValue!=null?t.minValue:this.defaultMinValue,this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue,this.rate=t.rate!=null?t.rate:this.defaultRate,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return B(()=>{const e=Yu(t,this.axis),s=ct(O(this.rate,Ue(e,this.minValue,this.maxValue)),O(1-this.rate,e));return O(t,Ct(s,ct(ge(),e)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}$m.className="MinMaxNorm";q($m);const xh={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function be(n){return _u(n)}function wh(n,t={}){return po(n,co.getMap().classNameMap,t,"constraint")}function xe(n){if(n==null)return null;if(typeof n=="string"){const e={className:n in xh?xh[n]:n,config:{}};return wh(e)}else return n instanceof bo?n:wh(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */async function Ns(n){if(n==null)return;const t=[],e=[],s=[];for(const i in n){const o=n[i];if(typeof o!="number"){const r=o;t.push(r.data()),e.push(i),s.push(r)}}if(t.length>0){const i=await Promise.all(t);for(let o=0;o<i.length;++o)n[e[o]]=i[o][0];zt(s)}}function Dm(n){if(n!=null)for(const t in n){const e=n[t];typeof e!="number"&&e.dispose()}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var vh;(function(n){n[n.SILENT=0]="SILENT",n[n.VERBOSE=1]="VERBOSE"})(vh||(vh={}));const AC=125;class eo{constructor(){this.validationData=null}setParams(t){this.params=t}async onEpochBegin(t,e){}async onEpochEnd(t,e){}async onBatchBegin(t,e){}async onBatchEnd(t,e){}async onTrainBegin(t){}async onTrainEnd(t){}setModel(t){}}class TC{constructor(t,e=10){t==null&&(t=[]),this.callbacks=t,this.queueLength=e}append(t){this.callbacks.push(t)}setParams(t){for(const e of this.callbacks)e.setParams(t)}setModel(t){for(const e of this.callbacks)e.setModel(t)}async onEpochBegin(t,e){e==null&&(e={});for(const s of this.callbacks)await s.onEpochBegin(t,e)}async onEpochEnd(t,e){e==null&&(e={});for(const s of this.callbacks)await s.onEpochEnd(t,e)}async onBatchBegin(t,e){e==null&&(e={});for(const s of this.callbacks)await s.onBatchBegin(t,e)}async onBatchEnd(t,e){e==null&&(e={});for(const s of this.callbacks)await s.onBatchEnd(t,e)}async onTrainBegin(t){t==null&&(t={});for(const e of this.callbacks)await e.onTrainBegin(t)}async onTrainEnd(t){t==null&&(t={});for(const e of this.callbacks)await e.onTrainEnd(t)}}class zC extends eo{constructor(){super()}async onEpochBegin(t){this.seen=0,this.totals={}}async onBatchEnd(t,e){e==null&&(e={});const s=e.size==null?0:e.size;this.seen+=s;for(const i in e){const o=e[i];if(typeof o=="number")this.totals.hasOwnProperty(i)||(this.totals[i]=0),this.totals[i]=this.totals[i]+o*s;else{let r;i in this.totals?r=this.totals[i]:this.totals[i]=0;const a=B(()=>ct(this.totals[i],O(o,s)));this.totals[i]=a,r!=null&&r.dispose()}}}async onEpochEnd(t,e){if(e!=null)for(const s of this.params.metrics)this.totals[s]!=null&&(typeof this.totals[s]=="number"?e[s]=this.totals[s]/this.seen:B(()=>{const i=O(Ct(1,this.seen),this.totals[s]);e[s]=i,this.totals[s].dispose(),Xn(e[s])}))}}class FC extends eo{async onTrainBegin(t){this.epoch=[],this.history={}}async onEpochEnd(t,e){e==null&&(e={}),this.epoch.push(t);for(const s in e)this.history[s]==null&&(this.history[s]=[]),this.history[s].push(e[s])}async syncData(){const t=[],e=[],s=[];for(const o in this.history){const r=this.history[o];for(let a=0;a<r.length;++a)if(typeof r[a]!="number"){const l=r[a];t.push(l.data()),e.push(o),s.push(a)}}const i=await Promise.all(t);for(let o=0;o<i.length;++o)this.history[e[o]][s[o]].dispose(),this.history[e[o]][s[o]]=i[o][0]}}class MC extends eo{constructor(t,e){if(super(),this.currentEpoch=0,this.nowFunc=t.nowFunc,this.nextFrameFunc=t.nextFrameFunc||zw,this.yieldEvery=e||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=AC),this.yieldEvery==="never"&&t.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");Zc(this.yieldEvery)&&(this.maybeWait=K2(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}async maybeWait(t,e,s){const i=[];this.yield!=null&&(await Ns(s),i.push(this.yield(t,e,s))),i.push(this.nextFrameFunc()),await Promise.all(i)}async onEpochBegin(t,e){this.currentEpoch=t,this.epochBegin!=null&&(await Ns(e),await this.epochBegin(t,e))}async onEpochEnd(t,e){const s=[];this.epochEnd!=null&&(await Ns(e),s.push(this.epochEnd(t,e))),this.yieldEvery==="epoch"&&s.push(this.nextFrameFunc()),await Promise.all(s)}async onBatchBegin(t,e){this.batchBegin!=null&&(await Ns(e),await this.batchBegin(t,e))}async onBatchEnd(t,e){const s=[];this.batchEnd!=null&&(await Ns(e),s.push(this.batchEnd(t,e))),this.yieldEvery==="batch"?s.push(this.nextFrameFunc()):Zc(this.yieldEvery)&&s.push(this.maybeWait(this.currentEpoch,t,e)),await Promise.all(s)}async onTrainBegin(t){this.trainBegin!=null&&(await Ns(t),await this.trainBegin(t))}async onTrainEnd(t){this.trainEnd!=null&&(await Ns(t),await this.trainEnd(t))}}function Rm(n,t){return n==null&&(n={}),n instanceof eo?[n]:Array.isArray(n)&&n[0]instanceof eo?n:Kt(n).map(s=>new MC(s,t))}class rn{constructor(){}static registerCallbackConstructor(t,e){tt(t>=0&&Number.isInteger(t),()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`),rn.checkForDuplicate(e),rn.constructors[t]==null&&(rn.constructors[t]=[]),rn.constructors[t].push(e)}static checkForDuplicate(t){for(const e in rn.constructors)rn.constructors[+e].forEach(i=>{if(i===t)throw new M("Duplicate callback constructor.")})}static clear(){rn.constructors={}}static createCallbacks(t){const e=[];for(const s in rn.constructors){const i=+s;t>=i&&e.push(...rn.constructors[i])}return e.map(s=>new s)}}rn.constructors={};function Am(n,t,e,s,i,o,r,a,l){const u=new FC,c=[new zC,...rn.createCallbacks(t)];n!=null&&c.push(...n),c.push(u);const h=new TC(c);return h.setParams({epochs:e,initialEpoch:s,samples:i,steps:o,batchSize:r,verbose:t,doValidation:a,metrics:l}),{callbackList:h,history:u}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function qn(n,t={},e=!1){return po(n,co.getMap().classNameMap,t,"layer",e)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Jo(n,t){return B(()=>{n.dtype!=="float32"&&(n=mt(n,"float32"));const e=Et(mo(n),t,!0),s=Fw(e.shape,ge()),i=ns(Vs(e,s));return Ct(n,i)})}function sa(n,t){return B(()=>ve(mo(Lt(t,n)),-1))}function Zu(n,t){return B(()=>ve(Ls(Lt(t,n)),-1))}function Qu(n,t){return B(()=>{const e=Lt(n,t),s=Ue(Ls(n),ge(),Number.MAX_VALUE),i=Ls(Ct(e,s));return O(100,ve(i,-1))})}function PC(n,t){return B(()=>{const e=Ue(t,ge(),Number.MAX_VALUE),s=ps(ct(1,e)),i=Ue(n,ge(),Number.MAX_VALUE),o=ps(ct(1,i));return ve(mo(Lt(s,o)),-1)})}function EC(n,t){return B(()=>{const e=Vs(0,Lt(1,O(n,t)));return ve(mo(e),-1)})}function LC(n,t){return B(()=>{const e=Vs(0,Lt(1,O(n,t)));return ve(e,-1)})}function OC(n,t){return B(()=>{const e=Et(O(n,t),-1),s=ci(O(Lt(1,n),t),-1);return Vs(0,ct(1,Lt(s,e)))})}function _C(n,t){return B(()=>{const e=Math.log(2),s=Lt(t,n),i=Lt(ct(s,Kr(O(-2,s))),e);return ve(i,-1)})}function no(n,t,e=!1){return B(()=>{if(e)t=Nu(t);else{const s=Et(t,t.shape.length-1,!0);t=Ct(t,s)}return t=Ue(t,ge(),1-ge()),Me(Et(O(mt(n,"float32"),ps(t)),t.shape.length-1))})}function tr(n,t,e=!1){return B(()=>{const s=mt(Jl(oC(n)),"int32");t=Ue(t,ge(),1-ge());const i=t.shape,o=Q(Sp(s,i[i.length-1]),i);return no(o,t,e)})}function BC(n,t){if(!ke(n.shape,t.shape))throw new M(`logits and labels must have the same shape, but got shapes ${JSON.stringify(n.shape)} and ${JSON.stringify(t.shape)}`);return B(()=>{const e=Si(t),s=Me(Ls(t));return ct(Lt(e,O(t,n)),wp(Qn(s)))})}function ia(n,t){return B(()=>{let e;return e=Ue(t,ge(),1-ge()),e=ps(Ct(e,Lt(1,e))),ve(BC(n,e),-1)})}function WC(n,t){return B(()=>{const e=Ue(n,ge(),1),s=Ue(t,ge(),1);return Et(O(n,ps(Ct(e,s))),-1)})}function VC(n,t){return B(()=>{const e=ps(ct(ge(),t));return ve(Lt(t,O(n,e)),-1)})}function Tm(n,t){return B(()=>{const e=Jo(n,-1),s=Jo(t,-1),i=O(e,s);return Me(Et(i,-1))})}const er={meanSquaredError:sa,meanAbsoluteError:Zu,meanAbsolutePercentageError:Qu,meanSquaredLogarithmicError:PC,squaredHinge:EC,hinge:LC,categoricalHinge:OC,logcosh:_C,categoricalCrossentropy:no,sparseCategoricalCrossentropy:tr,binaryCrossentropy:ia,kullbackLeiblerDivergence:WC,poisson:VC,cosineProximity:Tm};function La(n){if(typeof n=="string"){if(n in er)return er[n];let t=`Unknown loss ${n}`;throw n.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${n}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new M(t)}else return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function zm(n,t){return B(()=>{const e=O(.5,ln(t)),s=Pn(Wn(t,e),n.dtype);return ve(ts(n,s),-1)})}function Fm(n,t){return B(()=>Pn(ts(ui(n,-1),ui(t,-1)),"float32"))}function UC(n,t){return B(()=>mt(Et(vi(ts(n,1),ts(t,1))),"float32"))}function GC(n,t){return B(()=>mt(Et(vi(ts(n,0),ts(t,1))),"float32"))}function HC(n,t){return B(()=>{const e=UC(n,t),s=GC(n,t),i=ct(e,s);return mt(Zn(Wn(i,0),Ct(e,i),0),"float32")})}function jC(n,t){return ia(n,t)}function KC(n,t){return n.rank===t.rank&&(n=Xt(n,[n.rank-1])),t=ui(t,-1),t.dtype!==n.dtype&&(t=mt(t,n.dtype)),mt(ts(n,t),"float32")}const XC=sa,qC=sa,YC=Zu,ZC=Zu,QC=Qu,JC=Qu,Mm=no,tk=Tm,Pm=tr,nr={binaryAccuracy:zm,categoricalAccuracy:Fm,precision:HC,categoricalCrossentropy:Mm,sparseCategoricalCrossentropy:Pm,mse:XC,MSE:qC,mae:YC,MAE:ZC,mape:QC,MAPE:JC,cosine:tk};function ek(n){if(typeof n=="string"&&n in nr)return nr[n];if(typeof n!="string"&&n!=null)return n;throw new M(`Unknown metric ${n}`)}function _o(n){if(Tn(n!==null,`Unknown LossOrMetricFn ${n}`),typeof n=="string")return n;{let t;for(const e of Object.keys(er))if(er[e]===n){t=e;break}if(t!==void 0)return t;for(const e of Object.keys(nr))if(nr[e]===n){t=e;break}return t!==void 0?t:n.name}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function nk(n){const t={Adagrad:()=>Js.adagrad(.01),Adadelta:()=>Js.adadelta(1,.95,ge()),Adam:()=>Js.adam(.001,.9,.999,ge()),Adamax:()=>Js.adamax(.002,.9,.999,ge(),0),RMSProp:()=>Js.rmsprop(.001,.9,0,ge()),SGD:()=>Js.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,n in t)return t[n]();throw new M(`Unknown Optimizer ${n}`)}/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Ch=1*1024*1024;function kh(n,t,e=!1){if(n==null||typeof n!="object"||Object.getPrototypeOf(n)!==Object.prototype||!ol(n))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(e){const s=JSON.stringify(n);s.length>Ch&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${s.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${Ch}.`)}}function ol(n){if(n===null)return!0;if(typeof n=="object")if(Object.getPrototypeOf(n)===Object.prototype){const t=Object.keys(n);for(const e of t)if(typeof e!="string"||!ol(n[e]))return!1;return!0}else if(Array.isArray(n)){for(const t of n)if(!ol(t))return!1;return!0}else return!1;else{const t=typeof n;return t==="string"||t==="number"||t==="boolean"}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function sk(n,t,e,s=console.log){const i=ok(n),o=["Layer (type)","Input Shape","Output shape","Param #"];i?(t=t||90,e=e||[.32,.61,.89,1]):(t=t||115,e=e||[.24,.48,.7,.8,1]),e[e.length-1]<=1&&(e=e.map(c=>Math.floor(t*c)));let r;if(!i){o.push("Receives inputs"),r=[];for(const c in n.nodesByDepth)r.push(...n.nodesByDepth[c])}s("_".repeat(t)),sr(o,e,s),s("=".repeat(t));const a=n.layers;for(let c=0;c<a.length;++c)i?rk(a[c],e,s):ak(a[c],e,r,s),s((c===a.length-1?"=":"_").repeat(t));n.checkTrainableWeightsConsistency();const l=ik(n),u=Yo(n.nonTrainableWeights);s(`Total params: ${l+u}`),s(`Trainable params: ${l}`),s(`Non-trainable params: ${u}`),s("_".repeat(t))}function ik(n){let t;return n.collectedTrainableWeights!=null?t=Yo(n.collectedTrainableWeights):t=Yo(n.trainableWeights),t}function ok(n){let t=!0;const e=[],s=[];for(const i in n.nodesByDepth)e.push(n.nodesByDepth[i]);for(const i of e){if(i.length>1||i.length===1&&i[0].inboundLayers.length>1){t=!1;break}s.push(...i)}if(t)for(const i of n.layers){let o=!1;for(const r of i.inboundNodes)if(s.indexOf(r)!==-1)if(o){t=!1;break}else o=!0;if(!t)break}return t}function sr(n,t,e=console.log){let s="";for(let i=0;i<n.length;++i)i>0&&(s=s.slice(0,s.length-1)+" "),s+=n[i],s=s.slice(0,t[i]),s+=" ".repeat(t[i]-s.length);e(s)}function rk(n,t,e){let s,i;try{i=n.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{i="multiple"}try{s=JSON.stringify(n.outputShape)}catch{s="multiple"}const o=n.name,r=n.getClassName(),a=[`${o} (${r})`,i,s,n.countParams().toString()];sr(a,t,e)}function ak(n,t,e,s){let i,o;try{o=n.inboundNodes.map(h=>JSON.stringify(h.inputShapes)).join(",")}catch{o="multiple"}try{i=JSON.stringify(n.outputShape)}catch{i="multiple"}const r=[];for(const h of n.inboundNodes)if(!(e!=null&&e.length>0&&e.indexOf(h)===-1))for(let p=0;p<h.inboundLayers.length;++p){const f=h.inboundLayers[p].name,m=h.nodeIndices[p],g=h.tensorIndices[p];r.push(`${f}[${m}][${g}]`)}const a=n.name,l=n.getClassName(),u=r.length===0?"":r[0],c=[`${a} (${l})`,o,i,n.countParams().toString(),u];sr(c,t,s);for(let h=1;h<r.length;++h)sr(["","","","",r[h]],t,s)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Em(n,t,e){return(n==="inboundNodes"||n==="outputLayers"||n==="inputLayers")&&t===0&&typeof e=="string"}function rl(n,t){if(n===null)return null;if(typeof n=="string")return Ds(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const e=[],s=n.length;for(let i=0;i<s;++i){const o=n[i];Em(t,i,o)?e.push(o):e.push(rl(o,t))}return e}else{const e={};for(const s of Object.keys(n)){const i=n[s];if(s==="name"&&typeof i=="string")e[s]=i;else{const o=Ds(s);e[o]=rl(i,o)}}return e}}function al(n,t){if(n==null)return null;if(typeof n=="string")return Hn(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const e=[],s=n.length;for(let i=0;i<s;++i){const o=n[i];Em(t,i,o)?e.push(o):e.push(al(o,t))}return e}else{const e={};for(const s of Object.keys(n)){const i=n[s],o=Hn(s);(s==="name"||s==="className")&&typeof i=="string"?e[o]=i:e[o]=al(i,s)}return e}}/** @license See the LICENSE file. */const Lm="4.20.0";/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const lk=n=>{const t=Object.keys(n);if(t.length===0)return!1;const e=t[0].split("/");return!isNaN(parseInt(e[e.length-1],10))};class mn extends Ft{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,this.name==null){const w=this.getClassName().toLowerCase();this.name=ta(w)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],hs(this.inputs).length!==this.inputs.length)throw new M(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(w=>w.name)}`);hs(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(w=>w.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const w of this.outputs){const k=w.sourceLayer,C=w.nodeIndex,I=w.tensorIndex;this.outputLayers.push(k),this.outputLayersNodeIndices.push(C),this.outputLayersTensorIndices.push(I)}for(const w of this.inputs){const k=w.sourceLayer,C=w.nodeIndex,I=w.tensorIndex;Tn(C===0,"input layer has >1 nodes"),Tn(I===0,"input layer has >1 tensors"),this.inputLayers.push(k),this.inputLayersNodeIndices.push(C),this.inputLayersTensorIndices.push(I)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let w=0;w<this.inputLayers.length;w++){const k=this.inputLayers[w];if(!(k instanceof yo))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${w} (0-based) originates from layer type ${k.getClassName()}.`);this.inputNames.push(k.name),this.feedInputShapes.push(k.batchInputShape),this.feedInputNames.push(k.name)}for(const w of this.outputLayers)this.outputNames.push(w.name);this.internalInputShapes=this.inputs.map(w=>w.shape),this.internalOutputShapes=this.outputs.map(w=>w.shape);const e={},s={},i={},o={},r={},a=[],l=(w,k,C,I,N,$)=>{(I==null||N==null||$==null)&&(I=w.sourceLayer,N=w.nodeIndex,$=w.tensorIndex);const A=I.inboundNodes[N];if(C.indexOf(A)!==-1)throw new an(`The tensor ${w.name} at layer "${I.name}" is part of a cycle.`);if(k.indexOf(A)!==-1)return;this.containerNodes.add(mn.nodeKey(I,N)),I.id in r||(r[I.id]=Object.keys(r).length),C.indexOf(A)===-1&&C.push(A);const z=A.inboundLayers.length;for(let F=0;F<z;F++){const E=A.inputTensors[F],U=A.inboundLayers[F],L=A.nodeIndices[F],W=A.tensorIndices[F];l(E,k,C,U,L,W)}for(k.push(A);C.indexOf(A)>=0;)C.splice(C.indexOf(A),1);a.push(A)},u=[],c=[];for(const w of this.outputs)l(w,u,c);const h=a.slice().reverse();for(const w of h){s[w.id]=w,w.id in e||(e[w.id]=0);let k=e[w.id];const C=i[w.outboundLayer.id]==null?0:i[w.outboundLayer.id];k=Math.max(k,C),i[w.outboundLayer.id]=k,o[w.outboundLayer.id]=w.outboundLayer,e[w.id]=k;for(let I=0;I<w.inboundLayers.length;I++){const N=w.inboundLayers[I],$=w.nodeIndices[I],A=N.inboundNodes[$],z=e[A.id]==null?0:e[A.id];e[A.id]=Math.max(k+1,z),s[A.id]=A}}const p={};for(const w in e){const k=e[w];k in p||(p[k]=[]),p[k].push(s[w])}const f={};for(const w in i){const k=i[w];k in f||(f[k]=[]),f[k].push(o[w])}let m=Object.keys(f).map(w=>parseInt(w,10)).sort(Eo);this.layers=[];for(const w of m){const k=f[w];k.sort((C,I)=>{const N=r[C.id],$=r[I.id];return N<$?-1:N>$?1:0});for(const C of k)C instanceof mn&&this.internalContainerRefs.push(C),this.layers.push(C)}this.layersByDepth=f,m=Object.keys(p).map(w=>parseInt(w,10)).sort(Eo);const g=this.inputs.slice(),b=[];for(const w of m)for(const k of p[w]){const C=k.outboundLayer;if(C!=null){for(const I of k.inputTensors)if(g.indexOf(I)===-1)throw new an(`Graph disconnected: cannot obtain value for tensor ${I} at layer "${C.name}". The following previous layers were accessed without issue: ${b}`);for(const I of k.outputTensors)g.push(I);b.push(C.name)}}this.nodesByDepth=p;const v=this.layers.map(w=>w.name);for(const w of v){const k=v.filter(C=>C===w).length;if(k!==1)throw new an(`The name "${w}" is used ${k} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(v))}this.outboundNodes=[],this.inboundNodes=[],new na({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(w=>null),outputMasks:this.outputs.map(w=>null),inputShapes:this.inputs.map(w=>w.shape),outputShapes:this.outputs.map(w=>w.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const t={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(const e of this.layers)t.numDisposedVariables+=e.dispose().numDisposedVariables;for(const e of this.internalContainerRefs)t.numDisposedVariables+=e.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(e=>{e._trainableWeights.forEach(s=>s.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new M("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(const e of this.layers)t=t.concat(e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.layers)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const s of this.layers)e.push(...s.trainableWeights);return e.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,e=!0){const s={};let i=0;const o=lk(t);o&&this.parseWeights(t);for(const a of this.layers)for(const[l,u]of a.weights.entries()){const c=o?`${u.name.split("/").slice(0,-1).join("/")+"/"}${l}`:u.originalName;if(s[c]!=null)throw new M(`Duplicate weight name: ${c}`);s[c]=u,i++}const r=[];for(const a in t){let l=a;if(s[a]==null){const u=a.split("/");l=u.slice(0,-2).concat([u[u.length-1]]).join("/")}if(s[l]!=null)r.push([s[l],t[a]]);else if(e)throw new M(`Provided weight data has no target variable: ${a}`);delete s[l]}if(e){const a=[];for(const l in s)a.push(l);if(a.length>0)throw new M(`${a.length} of ${i} weights are not set: ${a}`)}qu(r)}parseWeights(t){for(const e in Object.keys(t)){const s=e.split("/"),i=["vars","layer_checkpoint_dependencies"],o=s.map(r=>r.startsWith("_")?r.slice(1):r).filter(r=>!i.includes(r)).join("/");o!==e&&(t[o]=t[e],delete t[e])}}updatedConfig(){const t=this.getConfig(),e={};return e.className=this.getClassName(),e.config=t,e.kerasVersion=`tfjs-layers ${Lm}`,e.backend="TensorFlow.js",e}toJSON(t,e=!0){const s=al(this.updatedConfig());return e?JSON.stringify(s):s}call(t,e){return B(()=>{t=Kt(t);const s=new as;for(let i=0;i<this.inputs.length;++i)s.add(this.inputs[i],t[i]);return Hi(this.outputs,s,e)})}computeMask(t,e){return B(()=>{t=Kt(t);let s;return e==null?s=Os(null,t.length):s=Kt(e),this.runInternalGraph(t,s)[1]})}computeOutputShape(t){const e=qo(t);if(e.length!==this.inputLayers.length)throw new M(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);const s={};for(let a=0;a<e.length;a++){const l=this.inputLayers[a],u=e[a],c=l.name+"_0_0";s[c]=u}const i=Object.keys(this.nodesByDepth).map(a=>parseInt(a,10)).sort(Eo);if(i.length>1)for(const a of i){const l=this.nodesByDepth[a];for(const u of l){const c=u.outboundLayer;if(this.inputLayers.map(g=>g.id).indexOf(c.id)!==-1)continue;const h=[];for(let g=0;g<u.inboundLayers.length;g++){const b=u.inboundLayers[g],v=u.nodeIndices[g],w=u.tensorIndices[g],k=`${b.name}_${v}_${w}`,C=s[k];h.push(C)}const p=c.computeOutputShape(Ee(h)),f=qo(p),m=c.inboundNodes.indexOf(u);for(let g=0;g<f.length;g++){const b=`${c.name}_${m}_${g}`;s[b]=f[g]}}}const o=[],r=[];for(let a=0;a<this.outputLayers.length;a++){const l=this.outputLayers[a],u=this.outputLayersNodeIndices[a],c=this.outputLayersTensorIndices[a],h=`${l.name}_${u}_${c}`;r.push(h)}for(let a=0;a<r.length;a++){const l=r[a];Tn(l in s),o.push(s[l])}return Ee(o)}runInternalGraph(t,e){e==null&&(e=Os(null,t.length));const s={};for(let l=0;l<this.inputs.length;++l){const u=this.inputs[l],c=t[l],h=e[l];s[u.id]=[c,h]}const i=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(Eo);for(const l of i){const u=this.nodesByDepth[l];for(const c of u){const h=c.outboundLayer,p=c.inputTensors,f=c.outputTensors,m=new Array;for(const g of p)g.id in s&&m.push(s[g.id]);if(m.length===p.length){let g={},b,v,w,k;if(c.callArgs!=null&&(g=c.callArgs),m.length===1){const[C,I]=m[0];g.mask==null&&(g.mask=I),w=Kt(h.call(C,g)),k=Kt(h.computeMask(C,I)),b=[C],v=[I]}else b=m.map(C=>C[0]),v=m.map(C=>C[1]),g.mask==null&&(g.mask=v),w=Kt(h.call(b,g)),k=Kt(h.computeMask(b,v));if(h.activityRegularizer)throw new At("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let C=0;C<f.length;++C){const I=f[C],N=w[C],$=k[C];s[I.id]=[N,$]}}}}const o=[],r=[],a=[];for(const l of this.outputs){Tn(l.id in s,`Could not compute output ${l.name} : ${l.id}`);const[u,c]=s[l.id];a.push(u.shape),o.push(u),r.push(c)}return[o,r,a]}buildNodeConversionMap(t){const e={};let s;for(const i of this.layers){s=i instanceof mn?1:0;for(let o=0;o<i.inboundNodes.length;o++){const r=mn.nodeKey(i,o);this.containerNodes.has(r)&&(e[r]=s,s+=1)}}return e}getLayer(t,e){if(e!=null)return this.findLayer(e);if(t==null)throw new M("Provide either a layer name or layer index");if(typeof t=="number")return this.findLayer(t);for(const s of this.layers)if(s.name===t)return s;throw new M(`No such layer: ${t}`)}findLayer(t){if(this.layers.length<=t)throw new M(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}calculateLosses(){return B(()=>{const t=[];for(const e of this.layers)for(let s=0;s<e.inboundNodes.length;++s){const i=mn.nodeKey(e,s);this.containerNodes.has(i)&&t.push(...e.calculateLosses())}return t})}getConfig(){const t={name:this.name},e=this.buildNodeConversionMap(this.layers),s=[];for(const r of this.layers){const a=r.getClassName(),l=r.getConfig(),u=[];for(let h=0;h<r.inboundNodes.length;h++){const p=r.inboundNodes[h],f=mn.nodeKey(r,h);let m={};if(this.containerNodes.has(f)){if(p.callArgs)try{JSON.stringify(p.callArgs),m=p.callArgs}catch{console.warn(`Layer ${r.name} was passed non-serializable keyword arguments: ${p.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),m={}}if(p.inboundLayers.length>0){const g=[];for(let b=0;b<p.inboundLayers.length;b++){const v=p.inboundLayers[b],w=p.nodeIndices[b],k=p.tensorIndices[b],C=mn.nodeKey(v,w);let I=e[C];I==null&&(I=0),g.push([v.name,I,k,m])}u.push(g)}}}const c={};c.name=r.name,c.className=a,c.config=l,c.inboundNodes=u,s.push(c)}t.layers=s;const i=[];for(let r=0;r<this.inputLayers.length;r++){const a=this.inputLayers[r],l=this.inputLayersNodeIndices[r],u=mn.nodeKey(a,l);if(!this.containerNodes.has(u))continue;let c=e[u];c==null&&(c=0);const h=this.inputLayersTensorIndices[r];i.push([a.name,c,h])}t.inputLayers=i;const o=[];for(let r=0;r<this.outputLayers.length;r++){const a=this.outputLayers[r],l=this.outputLayersNodeIndices[r],u=mn.nodeKey(a,l);if(!this.containerNodes.has(u))continue;let c=e[u];c==null&&(c=0);const h=this.outputLayersTensorIndices[r];o.push([a.name,c,h])}return t.outputLayers=o,t}static fromConfig(t,e,s={},i=!1){const o={},r={};function a(b,v){b.name in r?r[b.name].push(v):r[b.name]=[v]}function l(b,v){const w=[];let k;for(const C of v){const I=C[0],N=C[1],$=C[2];if(k=C[3]==null?{}:C[3],!(I in o)){a(b,v);return}const A=o[I];if(A.inboundNodes.length<=N){a(b,v);return}const z=A.inboundNodes[N];w.push(z.outputTensors[$])}w.length>0&&b.apply(Ee(w),k)}function u(b){const v=b.name,w=qn(b,e.customObjects!=null?e.customObjects:{});w.setFastWeightInitDuringBuild(i),o[v]=w,b.inboundNodes.forEach(C=>{if(!(C instanceof Array))throw new M(`Corrupted configuration, expected array for nodeData: ${C}`);a(w,C)})}const c=e.name,h=e.layers;for(const b of h)u(b);for(;!j2(r);)for(const b of h){const v=o[b.name];if(v.name in r){const w=r[v.name];delete r[v.name];for(const k of w)l(v,k)}}const p=[],f=[],m=e.inputLayers;for(const b of m){const v=b[0],w=b[1],k=b[2];Tn(v in o);const I=o[v].inboundNodes[w].outputTensors;p.push(I[k])}const g=e.outputLayers;for(const b of g){const v=b[0],w=b[1],k=b[2];Tn(v in o);const I=o[v].inboundNodes[w].outputTensors;f.push(I[k])}return new t({inputs:p,outputs:f,name:c})}get stateful(){if(this._stateful)throw new M("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const t of this.layers)if(t.stateful)return!0;return!1}resetStates(){B(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function uk(n,t,e){const s=t.length;if(n==null||Array.isArray(n)&&n.length===0)return t.map(i=>null);if(s===1)return Array.isArray(n)&&n.length===1?n:typeof n=="object"&&t[0]in n?[n[t[0]]]:[n];if(Array.isArray(n)){if(n.length!==s)throw new Error(`Provided ${e} is an array of ${n.length} element(s), but the model has ${s} outputs. Make sure a set of weights is provided for each model output.`);return n}else if(typeof n=="object"&&Object.keys(n).length>0&&typeof n[Object.keys(n)[0]]=="object"){const i=[];return t.forEach(o=>{o in n?i.push(n[o]):i.push(null)}),i}else throw new Error(`The model has multiple (${s}) outputs, so ${e} must be either an array with ${s} elements or an object with ${t} keys. Provided ${e} not understood: ${JSON.stringify(n)}`)}function Om(n,t){return uk(n,t,"classWeight")}async function _m(n,t,e,s){if(e!=null){const i=B(()=>{if(n.shape.length===1)return Mw(n);if(n.shape.length===2){if(n.shape[1]>1)return ui(n,1);if(n.shape[1]===1)return Q(n,[n.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${n.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${n.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),o=Array.from(await i.data());zt(i);const r=[];return o.forEach(a=>{if(e[a]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${a} exists in the data but not in classWeight`);r.push(e[a])}),jn(r,"float32")}else return null}function ck(n,t){return O(n,t)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const hk=32;function Bm(n,t){let e,s;const i=t;e=i.xs,s=i.ys,tt(e!=null&&s!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);const o=Sh("input",n.inputNames,e),r=Sh("output",n.outputNames,s),a=o[0].shape[0];tt(o.length===n.inputs.length,()=>`LayersModel has ${n.inputs.length} inputs, but the dataset provides ${o.length} inputs.  (Expected input keys: ${JSON.stringify(n.inputNames)})`),tt(r.length===n.outputs.length,()=>`LayersModel has ${n.outputs.length} outputs, but the dataset provides ${r.length} outputs.  (Expected output keys: ${JSON.stringify(n.outputNames)})`);for(let l=0;l<o.length;l++)tt(o[l].shape[0]===a,()=>`Batch size mismatch: input ${n.inputNames[l]} has ${o[l].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);for(let l=0;l<r.length;l++)tt(r[l].shape[0]===a,()=>`Batch size mismatch: output ${n.outputNames[l]} has ${r[l].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);return{xs:o,ys:r}}function Sh(n,t,e){if(e instanceof Ge)return[e];if(Array.isArray(e))return tt(e.length===t.length,()=>`Received an array of ${e.length} Tensors, but expected ${t.length} to match the ${n} keys ${t}.`),e;{const s=[];for(const i of t){if(e[i]==null)throw new M(`The feature data generated by the dataset lacks the required ${n} key '${i}'.`);s.push(e[i])}return s}}function dk(n){if(n.length===3)throw new At("Validation with sample weights is not implemented yet.");return{xs:n[0],ys:n[1]}}async function pk(n,t,e){const s=e.batchesPerEpoch!=null;if(tt(n.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),tt(e!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),tt(e.epochs!=null&&e.epochs>0&&Number.isInteger(e.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${e.epochs}`),tt(!s||e.batchesPerEpoch>0&&Number.isInteger(e.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${e.batchesPerEpoch}`),tt(e.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),n.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");n.isTraining=!0;try{const i=e.validationData!=null;let o,r;if(i)if(Ih(e.validationData))tt(e.validationBatches==null||e.validationBatches>0&&Number.isInteger(e.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${e.validationBatches}`);else{const b=dk(e.validationData);o=b.xs,r=b.ys}const a=n.makeTrainFunction(),l=n.getDedupedMetricsNames();let u;i?u=l.slice().concat(l.map(b=>"val_"+b)):u=l.slice();const c=Rm(e.callbacks,e.yieldEvery),h=e.verbose==null?1:e.verbose,{callbackList:p,history:f}=Am(c,h,e.epochs,null,null,fk(t,e),null,i,u);p.setModel(n),n.history=f,await p.onTrainBegin(),n.stopTraining_=!1;let m=e.initialEpoch==null?0:e.initialEpoch,g=await t.iterator();for(;m<e.epochs;){const b={};await p.onEpochBegin(m);let v=0,w=0;for(s||(g=await t.iterator());!s||v<e.batchesPerEpoch;){const k=await g.next();if(s&&k.done){console.warn(`You provided \`batchesPerEpoch\` as ${e.batchesPerEpoch}, but your dataset iterator ran out of data after ${v} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${e.batchesPerEpoch*e.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(k.value!=null){const{xs:C,ys:I}=Bm(n,k.value),N={};N.batch=w,N.size=C[0].shape[0],await p.onBatchBegin(w,N);const $=[];if(e.classWeight!=null){const F=Om(e.classWeight,n.outputNames);for(let E=0;E<F.length;++E)$.push(await _m(I[E],null,F[E]))}const A=C.concat(I).concat($),z=a(A);zt(A);for(let F=0;F<l.length;++F){const E=l[F],U=z[F];N[E]=U,Xn(U)}await p.onBatchEnd(w,N),Dm(N),w++,v++}if(s?v>=e.batchesPerEpoch:k.done){if(i){let C;Ih(e.validationData)?C=Kt(await n.evaluateDataset(e.validationData,{batches:e.validationBatches})):C=Kt(n.evaluate(o,r,{batchSize:e.validationBatchSize==null?hk:e.validationBatchSize,verbose:0}));for(let I=0;I<n.metricsNames.length;++I)b[`val_${n.metricsNames[I]}`]=C[I]}break}if(n.stopTraining_)break}if(await p.onEpochEnd(m,b),m++,n.stopTraining_)break}return await p.onTrainEnd(),await n.history.syncData(),n.history}finally{n.isTraining=!1}}function fk(n,t){let e=null;return t.batchesPerEpoch!=null?e=t.batchesPerEpoch:Number.isFinite(n.size)&&(e=n.size),e}function Ih(n){return typeof n.iterator=="function"}function mk(n){return typeof n.next=="function"}async function gk(n,t,e){e=e||{};const s=e.batches!=null,i=n.testFunction;let o=[];if(e.verbose>0)throw new At("Verbose mode is not implemented yet.");tt(!s||e.batches>0&&Number.isInteger(e.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(e.batches)}`);const r=mk(t)?t:await t.iterator();let a=0,l=0;for(;!s||l<e.batches;){const u=await r.next();if(o=B(()=>{if(u.value){const{xs:c,ys:h}=Bm(n,u.value),p=c.concat(h),f=B(()=>i(p));if(zt(p),l===0)for(let g=0;g<f.length;++g)o.push(se(0));const m=p[0].shape[0];for(let g=0;g<f.length;++g){const b=f[g],v=o[g];o[g]=B(()=>ct(o[g],O(m,b))),l>0&&zt(v)}zt(f),a+=m,++l}return o}),u.done){s&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${e.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<o.length;++u){const c=o[u];o[u]=Ct(o[u],a),zt(c)}return Ee(o)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Oa(n){tt(n>0&&Number.isInteger(n),()=>`batchSize is required to be a positive integer, but got ${n}`)}function Vi(n,t,e){return n==null?[null]:Array.isArray(n)?n.map(s=>Ms(s,t,e-t)):Ms(n,t,e-t)}function ll(n,t){return B(()=>n==null?null:Array.isArray(n)?n.map(e=>ll(e,t)):fm(n,t.dtype==="int32"?t:mt(t,"int32")))}function _a(n,t){const e=[];let s=0,i=null;for(;s<n;)i=s+t,i>=n&&(i=n),e.push([s,i]),s=i;return e}function Wm(n){const t=[];n instanceof Ge&&(n=[n]);for(let e=0;e<n.length;++e){const s=n[e];if(s.rank===1)t.push(fo(s,1));else{if(s.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(s)}}return t}function fn(n,t){if(n==null)return;const e=[];if(t instanceof Ge)e.push(t.id);else if(Array.isArray(t))t.forEach(i=>e.push(i.id));else if(t!=null)for(const i in t){const o=t[i];e.push(o.id)}const s=[];if(n instanceof Ge)e.indexOf(n.id)===-1&&s.push(n);else if(Array.isArray(n))n.forEach(i=>{e.indexOf(i.id)===-1&&s.push(i)});else if(n!=null)for(const i in n){const o=n[i];e.indexOf(o.id)===-1&&s.push(o)}s.forEach(i=>{i.isDisposed||i.dispose()})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function yk(n){return n instanceof Ge}function ul(n){return Array.isArray(n)}function Nh(n){return!yk(n)&&!ul(n)}function $h(n,t,e,s=!0,i=""){if(t==null||t.length===0){if(n!=null){let r=!1;if(ul(n)&&n.length>0)r=!0;else if(Nh(n)){for(const a in n)if(n.hasOwnProperty(a)){r=!0;break}}else r=!0;if(r)throw new M(`Error when checking model ${i} expected no data, but got ${n}`)}return[]}if(n==null)return t.map(r=>null);let o;if(Nh(n)){n=n,o=[];for(const r of t){if(n[r]==null)throw new M(`No data provided for "${r}". Need data for each key in: ${t}`);o.push(n[r])}}else if(ul(n)){if(n=n,n.length!==t.length)throw new M(`Error when checking model ${i}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${n}`);o=n}else{if(n=n,t.length>1)throw new M(`The model ${i} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${n.shape}`);o=[n]}if(o=Wm(o),e!=null)for(let r=0;r<t.length;++r){if(e[r]==null)continue;const a=o[r];if(a.shape.length!==e[r].length)throw new M(`Error when checking ${i}: expected ${t[r]} to have ${e[r].length} dimension(s). but got array with shape ${a.shape}`);for(let l=0;l<e[r].length;++l){if(l===0&&!s)continue;const u=a.shape[l],c=e[r][l];if(c!=null&&c>=0&&u!==c)throw new M(`${i} expected a batch of elements where each example has shape [${e[r].slice(1,e[r].length)}] (i.e.,tensor shape [*,${e[r].slice(1,e[r].length)}]) but the ${i} received an input with ${a.shape[0]} examples, each with shape [${a.shape.slice(1,a.shape.length)}] (tensor shape [${a.shape}])`)}}return o}function bk(n,t,e){const s=hs(n.map(o=>o.shape[0]));s.sort();const i=hs(t.map(o=>o.shape[0]));if(i.sort(),s.length>1)throw new M(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(o=>o.shape))}`);if(i.length>1)throw new M(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(o=>o.shape))}`);if(s.length>0&&i.length>0&&!ke(s,i))throw new M(`Input Tensors should have the same number of samples as target Tensors. Found ${s[0]} input sample(s) and ${i[0]} target sample(s).`)}function xk(n,t,e){const s=[sa,ia,no];for(let i=0;i<n.length;++i){const o=n[i],r=t[i],a=e[i];if(r!=null){if(r===no&&o.shape[o.shape.length-1]===1)throw new M(`You are passing a target array of shape ${o.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(s.indexOf(r)!==-1){const l=o.shape.slice(1),u=a.slice(1);for(let c=0;c<l.length;++c){const h=l[c],p=u[c];if(p!=null&&h!==p)throw new M(`A target Tensor with shape ${o.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function Dh(n,t,e,s=!0,i=""){let o;if(Array.isArray(n)){if(n.length!==t.length)throw new M(`Error when checking model ${i}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${n.length} Tensors(s).`);o=n}else{if(t.length>1)throw new M(`The model expects ${t.length} ${i} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(n.shape)}.`);o=[n]}if(e!=null)for(let r=0;r<t.length;++r){if(e[r]==null)continue;const a=o[r];if(a.shape.length!==e[r].length)throw new M(`Error when checking ${i}: expected ${t[r]} to have ${e[r].length} dimension(s), but got array with shape ${JSON.stringify(a.shape)}`);for(let l=0;l<e[r].length;++l){if(l===0&&!s)continue;const u=a.shape[l],c=e[r][l];if(c!=null&&c!==u)throw new M(`Error when checking ${i}: expected ${t[r]} to have shape ${JSON.stringify(e[r])} but got array with shape ${JSON.stringify(a.shape)}.`)}}}function wk(n,t){if(n==null||Array.isArray(n)&&n.length===0)return t.map(s=>[]);let e;if(typeof n=="string"||typeof n=="function")e=[n];else if(Array.isArray(n)||typeof n=="object")e=n;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${n}`);if(Array.isArray(e))return t.map(s=>e);{const s=[];for(const i of t){let o=e.hasOwnProperty(i)?e[i]:[];Array.isArray(o)||(o=[o]),s.push(o)}return s}}const vk="layers-model";class ri extends mn{constructor(t){super(t),this.isTraining=!1}summary(t,e,s=console.log){if(!this.built)throw new M("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");sk(this,t,e,s)}compile(t){if(t.loss==null&&(t.loss=[]),this.loss=t.loss,typeof t.optimizer=="string")this.optimizer_=nk(t.optimizer),this.isOptimizerOwned=!0;else{if(!(t.optimizer instanceof Pw))throw new M("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=t.optimizer,this.isOptimizerOwned=!1}let e=[];if(!Array.isArray(t.loss)&&typeof t.loss!="string"&&typeof t.loss!="function"){t.loss=t.loss;for(const r in t.loss)if(this.outputNames.indexOf(r)===-1)throw new M(`Unknown entry in loss dictionary: "${r}". Only expected the following keys: ${this.outputNames}`);for(const r of this.outputNames)t.loss[r]==null&&console.warn(`Output "${r}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${r} during training`),e.push(La(t.loss[r]))}else if(Array.isArray(t.loss)){if(t.loss.length!==this.outputs.length)throw new M(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${t.loss}.`);e=t.loss.map(a=>La(a))}else{const r=La(t.loss);this.outputs.forEach(a=>{e.push(r)})}this.lossFunctions=e,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let r=0;r<this.outputs.length;++r){const a=this.internalOutputShapes[r],l=this.outputNames[r];this.feedOutputNames.push(l),this.feedOutputShapes.push(a),this.feedLossFns.push(this.lossFunctions[r])}const s=[];this.metrics=t.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Fs("loss",()=>{for(let r=0;r<this.outputs.length;++r){if(s.indexOf(r)!==-1)continue;const a=this.lossFunctions[r];this.outputs.length>1&&(this.metricsTensors.push([a,r]),this.metricsNames.push(this.outputNames[r]+"_loss"))}});const i=wk(t.metrics,this.outputNames),o=(r,a,l)=>{this.outputNames.length>1&&(a=this.outputNames[r]+"_"+a),this.metricsNames.push(a),this.metricsTensors.push([l,r])};Fs("metric",()=>{for(let r=0;r<this.outputs.length;++r){if(s.indexOf(r)!==-1)continue;const a=i[r];(u=>{const c="";let h,p,f;for(const m of u){if(typeof m=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(m)!==-1){const b=this.internalOutputShapes[r];b[b.length-1]===1||this.lossFunctions[r]===ia?["accuracy","acc"].indexOf(m)!==-1?p=zm:["crossentropy","ce"].indexOf(m)!==-1&&(p=jC):this.lossFunctions[r]===tr?["accuracy","acc"].indexOf(m)!==-1?p=KC:["crossentropy","ce"].indexOf(m)!==-1&&(p=Pm):["accuracy","acc"].indexOf(m)!==-1?p=Fm:["crossentropy","ce"].indexOf(m)!==-1&&(p=Mm);let v;["accuracy","acc"].indexOf(m)!==-1?v="acc":["crossentropy","ce"].indexOf(m)!==-1&&(v="ce"),f=p,h=c+v}else f=ek(m),h=c+_o(m);let g;Fs(h,()=>{g=f}),o(r,h,g)}})(a)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(t,e,s={}){const i=s.batchSize==null?32:s.batchSize;Oa(i);const r=this.standardizeUserDataXY(t,e,!0,i);try{const a=r[0].concat(r[1]);this.makeTestFunction();const l=this.testFunction,u=this.testLoop(l,a,i,s.verbose,s.steps);return Ee(u)}finally{fn(r[0],t),fn(r[1],e)}}async evaluateDataset(t,e){return this.makeTestFunction(),gk(this,t,e)}checkNumSamples(t,e,s,i="steps"){let o;if(s!=null){if(o=null,e!=null)throw new M(`If ${i} is set, batchSize must be null or undefined.Got batchSize = ${e}`)}else if(t!=null)Array.isArray(t)?o=t[0].shape[0]:o=t.shape[0];else throw new M(`Either the input data should have a defined shape, or ${i} shoud be specified.`);return o}execute(t,e){if(Array.isArray(e)&&e.length===0)throw new M("`outputs` is an empty Array, which is not allowed.");const s=Array.isArray(e),i=s?e:[e],o=this.retrieveSymbolicTensors(i),r=new as;if(t instanceof Ge&&(t=[t]),Array.isArray(t)){if(t.length!==this.inputs.length)throw new M(`The number of inputs provided (${t.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let l=0;l<this.inputs.length;++l)r.add(this.inputs[l],t[l])}else for(const l of this.inputs){const u=t[l.name];if(u==null)throw new M(`No value is provided for the model's input ${l.name}`);r.add(l,u)}const a=Hi(o,r);return s?a:a[0]}retrieveSymbolicTensors(t){const e=Os(null,t.length);let s=t.length;for(const i of this.layers){const o=Array.isArray(i.output)?i.output:[i.output],r=o.map(a=>a.name);for(let a=0;a<t.length;++a){const l=r.indexOf(t[a]);if(l!==-1&&(e[a]=o[l],s--),s===0)break}if(s===0)break}if(s>0){const i=[];throw e.forEach((o,r)=>{o==null&&i.push(t[r])}),new M(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(i)}`)}return e}predictLoop(t,e=32,s=!1){return B(()=>{const i=this.checkNumSamples(t);if(s)throw new At("Verbose predictLoop() is not implemented yet.");const o=_a(i,e),r=this.outputs.map(a=>[]);for(let a=0;a<o.length;++a)B(()=>{const u=o[a][0],c=o[a][1],h=Vi(t,u,c),p=[];if(Array.isArray(h))for(let m=0;m<h.length;++m)p.push({key:this.inputs[m],value:h[m]});else p.push({key:this.inputs[0],value:h});const f=new as(p);return Hi(this.outputs,f)}).forEach((u,c)=>r[c].push(u));return Ee(r.map(a=>fs(a,0)))})}predict(t,e={}){const s=Wm(t);Dh(s,this.inputNames,this.feedInputShapes,!1);try{const i=e.batchSize==null?32:e.batchSize;return Oa(i),this.predictLoop(s,i)}finally{fn(s,t)}}predictOnBatch(t){Dh(t,this.inputNames,this.feedInputShapes,!0);const e=(Array.isArray(t)?t[0]:t).shape[0];return this.predictLoop(t,e)}standardizeUserDataXY(t,e,s=!0,i){if(this.optimizer_==null)throw new an("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const o=[];for(let r=0;r<this.feedOutputShapes.length;++r){const a=this.feedOutputShapes[r];this.feedLossFns[r]===tr?o.push(a.slice(0,a.length-1).concat([1])):o.push(a)}if(t=$h(t,this.feedInputNames,this.feedInputShapes,!1,"input"),e=$h(e,this.feedOutputNames,o,!1,"target"),bk(t,e),xk(e,this.feedLossFns,this.feedOutputShapes),this.stateful&&i!=null&&i>0&&t[0].shape[0]%i!==0)throw new M(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${i}. Found: ${t[0].shape[0]} sample(s).`);return[t,e]}async standardizeUserData(t,e,s,i,o=!0,r){const[a,l]=this.standardizeUserDataXY(t,e,o,r);if(s!=null)throw new Error("sample weight is not supported yet.");let u=null;if(i!=null){const c=Om(i,this.outputNames);u=[];for(let h=0;h<c.length;++h)u.push(await _m(l[h],null,c[h]))}return[a,l,u]}testLoop(t,e,s,i=0,o){return B(()=>{const r=this.checkNumSamples(e,s,o,"steps"),a=[];if(i>0)throw new At("Verbose mode is not implemented yet.");if(o!=null)throw new At("steps mode in testLoop() is not implemented yet");{const l=_a(r,s),u=jn(bn(0,r));for(let c=0;c<l.length;++c){const h=l[c][0],p=l[c][1],f=Ms(u,h,p-h),m=ll(e,f),g=t(m);if(c===0)for(let b=0;b<g.length;++b)a.push(se(0));for(let b=0;b<g.length;++b){const v=g[b];a[b]=ct(a[b],O(p-h,v))}}for(let c=0;c<a.length;++c)a[c]=Ct(a[c],r)}return a})}getDedupedMetricsNames(){const t=this.metricsNames,e=[];for(let s=0;s<t.length;++s){const i=t[s];let o=i;if(dh(t,i)>1){const r=dh(t.slice(0,s),i);o+=`_${r}`}e.push(o)}return e}makeTrainFunction(){return t=>{const e=[],s=t.slice(0,this.inputs.length),i=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),o=t.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),r=[],a=()=>{const h=[];for(let g=0;g<this.inputs.length;++g)h.push({key:this.inputs[g],value:s[g]});const p=new as(h),f=Hi(this.outputs,p,{training:!0});let m;for(let g=0;g<this.lossFunctions.length;++g){const b=this.lossFunctions[g];let v=b(i[g],f[g]);o[g]!=null&&(v=ck(v,o[g]));const w=ve(v);e.push(w),g===0?m=v:m=ct(m,v)}for(let g=0;g<this.metricsTensors.length;++g){let b;if(this.outputs.length>1&&g<this.outputs.length)b=e[g];else{const v=this.metricsTensors[g][0],w=this.metricsTensors[g][1];b=ve(v(i[w],f[w]))}Xn(b),r.push(b)}return m=ve(m),this.calculateLosses().forEach(g=>{m=ct(m,g)}),m},l=this.collectedTrainableWeights.map(h=>h.read());return[this.optimizer_.minimize(a,!0,l)].concat(r)}}makeTestFunction(){this.testFunction=t=>B(()=>{const e=[];let s;const i=t.slice(0,this.inputs.length),o=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),r=[];for(let u=0;u<this.inputs.length;++u)r.push({key:this.inputs[u],value:i[u]});const a=new as(r),l=Hi(this.outputs,a);for(let u=0;u<this.lossFunctions.length;++u){const c=this.lossFunctions[u],h=ve(c(o[u],l[u]));u===0?s=h:s=ct(s,h),e.push(s)}for(let u=0;u<this.metricsTensors.length;++u){const c=this.metricsTensors[u][0],h=this.metricsTensors[u][1],p=ve(c(o[h],l[h]));e.push(p)}return e})}async fit(t,e,s={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let i,o,r,a,l,u,c,h,p;try{const f=s.batchSize==null?32:s.batchSize;Oa(f);const g=await this.standardizeUserData(t,e,s.sampleWeight,s.classWeight,!1,f);i=g[0],o=g[1],p=g[2];let b=!1,v;if(s.validationData!=null&&s.validationData.length>0){if(b=!0,s.validationData.length===2)l=s.validationData[0],u=s.validationData[1];else throw s.validationData.length===3?new At("validationData including sample weights is not supported yet."):new M(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${s.validationData} is invalid.`);const F=await this.standardizeUserData(l,u,null,null,!0,f);c=F[0],h=F[1],v=c.concat(h)}else if(s.validationSplit!=null&&s.validationSplit>0&&s.validationSplit<1){b=!0;const z=Math.floor(i[0].shape[0]*(1-s.validationSplit)),F=i[0].shape[0];c=Vi(i,z,F),r=i,i=Vi(i,0,z),h=Vi(o,z,F),a=o,o=Vi(o,0,z),v=c.concat(h)}else s.validationSteps!=null&&(b=!0);const w=i.concat(o).concat(p);this.checkTrainableWeightsConsistency();const k=this.makeTrainFunction(),C=this.getDedupedMetricsNames();let I,N;b?(this.makeTestFunction(),I=this.testFunction,N=C.slice().concat(C.map(z=>"val_"+z))):(I=null,v=[],N=C.slice());const $=Rm(s.callbacks,s.yieldEvery);return await this.fitLoop(k,w,C,f,s.epochs,s.verbose,$,I,v,s.shuffle,N,s.initialEpoch,null,null)}finally{this.isTraining=!1,fn(i,t),fn(o,e),fn(r,t),fn(a,e),fn(c,l),fn(h,u),p!=null&&zt(p)}}async fitLoop(t,e,s,i,o,r,a,l,u,c,h,p,f,m){i==null&&(i=32),o==null&&(o=1),c==null&&(c=!0),p==null&&(p=0);let g=!1;if(l!=null&&u!=null&&(g=!0),m!=null&&(g=!0,f==null))throw new M("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const b=this.checkNumSamples(e,i,f,"steps_per_epoch");let v;b!=null&&(v=bn(0,b)),r==null&&(r=1);const{callbackList:w,history:k}=Am(a,r,o,p,b,f,i,g,h);w.setModel(this),this.history=k,await w.onTrainBegin(),this.stopTraining_=!1;for(let C=p;C<o;++C){await w.onEpochBegin(C);const I={};if(f!=null)throw new At("stepsPerEpoch mode is not implemented yet.");{if(c==="batch")throw new At("batch shuffling is not implemneted yet");c&&Ew(v);const N=jn(v),$=_a(b,i);for(let A=0;A<$.length;++A){const z={};if(await w.onBatchBegin(A,z),B(()=>{const F=$[A][0],E=$[A][1],U=Ms(N,F,E-F);z.batch=A,z.size=E-F;const L=ll(e,U),W=t(L);for(let _=0;_<s.length;++_){const V=s[_],X=W[_];z[V]=X,Xn(X)}if(A===$.length-1&&g){const _=this.testLoop(l,u,i);for(let V=0;V<s.length;++V){const X=s[V],j=_[V];Xn(j),I["val_"+X]=j}}}),await w.onBatchEnd(A,z),Dm(z),this.stopTraining_)break}N.dispose()}if(await w.onEpochEnd(C,I),this.stopTraining_)break}return await w.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(t,e){return pk(this,t,e)}async trainOnBatch(t,e){const s=await this.standardizeUserData(t,e),i=s[0],o=s[1],a=this.makeTrainFunction()(i.concat(o)),l=[];for(const u of a){const c=await u.data();l.push(c[0])}return zt(a),fn(s[0],t),fn(s[1],e),Ee(l)}getNamedWeights(t){const e=[],s=t!=null&&t.trainableOnly,i=s?this.trainableWeights:this.weights,o=this.getWeights(s);for(let r=0;r<i.length;++r)s&&!i[r].trainable||e.push({name:i[r].originalName,tensor:o[r]});return e}set stopTraining(t){this.stopTraining_=t}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(t){this.optimizer_!==t&&(this.optimizer_=t,this.isOptimizerOwned=!1)}dispose(){const t=super.dispose();if(t.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const e=Qc().numTensors;this.optimizer_.dispose(),t.numDisposedVariables+=e-Qc().numTensors}return t}getLossIdentifiers(){let t;if(typeof this.loss=="string")t=Hn(this.loss);else if(Array.isArray(this.loss)){for(const e of this.loss)if(typeof e!="string")throw new Error("Serialization of non-string loss is not supported.");t=this.loss.map(e=>Hn(e))}else{const e=Object.keys(this.loss);t={};const s=this.loss;for(const i of e)if(typeof s[i]=="string")t[i]=Hn(s[i]);else throw new Error("Serialization of non-string loss is not supported.")}return t}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[Hn(_o(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(t=>Hn(_o(t)));{const t={};for(const e in this.metrics)t[e]=Hn(_o(this.metrics[e]));return t}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(t){if(t.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(t.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(t.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");const e=rl(t.optimizer_config),s=qn(e);let i;if(typeof t.loss=="string")i=Ds(t.loss);else if(Array.isArray(t.loss))i=t.loss.map(r=>Ds(r));else if(t.loss!=null){i={};for(const r in t.loss)i[r]=Ds(t.loss[r])}let o;if(Array.isArray(t.metrics))o=t.metrics.map(r=>Ds(r));else if(t.metrics!=null){o={};for(const r in t.metrics)o[r]=Ds(t.metrics[r])}this.compile({loss:i,metrics:o,optimizer:s})}async save(t,e){if(typeof t=="string"){const u=Lw(t);if(u.length===0)throw new M(`Cannot find any save handlers for URL '${t}'`);if(u.length>1)throw new M(`Found more than one (${u.length}) save handlers for URL '${t}'`);t=u[0]}if(t.save==null)throw new M("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const s=await Jc(this.getNamedWeights(e)),a={modelTopology:this.toJSON(null,!1),format:vk,generatedBy:`TensorFlow.js tfjs-layers v${Lm}`,convertedBy:null};if((e==null?!1:e.includeOptimizer)&&this.optimizer!=null){a.trainingConfig=this.getTrainingConfig();const u="optimizer",{data:c,specs:h}=await Jc(await this.optimizer.getWeights(),u);s.specs.push(...h),s.data=Ow([s.data,c])}return this.userDefinedMetadata!=null&&(kh(this.userDefinedMetadata,this.name,!0),a.userDefinedMetadata=this.userDefinedMetadata),a.weightData=s.data,a.weightSpecs=s.specs,t.save(a)}setUserDefinedMetadata(t){kh(t,this.name),this.userDefinedMetadata=t}getUserDefinedMetadata(){return this.userDefinedMetadata}}ri.className="Model";q(ri);class Vm extends ri{}Vm.className="Functional";q(Vm);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class so extends ri{constructor(t){if(super({inputs:[],outputs:[]}),t=t||{},this.trainable=!0,this.built=!1,this.name=t.name!=null?t.name:ta("sequential_"),t.layers!=null)for(const e of t.layers)this.add(e)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some(s=>s<0))throw new M(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`)}add(t){const e=t instanceof so||t instanceof ri;let s;if(e){if(s=t,s.outputs.length!==1)throw new M("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(s.inputs.length!==1)throw new M("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(t.inboundNodes.length===0){if(t.batchInputShape==null)throw new M("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const i=kC({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(i)}if(e)this.outputs=s.outputs,this.inputs=s.inputs;else{if(t.inboundNodes.length!==1)throw new M(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(t.inboundNodes[0].outputTensors.length!==1)throw new M("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=km(this.outputs[0])}this.inboundNodes=[],new na({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Os(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(i=>i.shape),outputShapes:this.outputs[0].shape})}else{const i=t.apply(this.outputs[0]);if(Array.isArray(i))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[i],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,e){return this.model==null&&this.build(),this.model.call(t,e)}build(t){if(Wt(t),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new ri({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,e,s=console.log){this.built||this.build(),super.summary(t,e,s)}setWeights(t){this.model==null&&this.build(),this.model.setWeights(t)}evaluate(t,e,s={}){if(!this.built)throw new an("The model needs to be compiled before being used.");return this.model.evaluate(t,e,s)}async evaluateDataset(t,e){if(!this.built)throw new an("The model needs to be compiled before being used.");return this.model.evaluateDataset(t,e)}predict(t,e={}){return this.model==null&&this.build(),this.model.predict(t,e)}predictOnBatch(t){return this.model==null&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,e,s={}){if(!this.built)throw new an("The model needs to be compiled before being used.");return this.model.fit(t,e,s)}async fitDataset(t,e){if(!this.built)throw new an("The model needs to be compiled before being used.");return this.model.fitDataset(t,e)}async trainOnBatch(t,e){return this.model.trainOnBatch(t,e)}static fromConfig(t,e,s={},i=!1){let o,r={};if(e instanceof Array){if(e[0].className==null||e[0].className==="Merge")throw new M("Legacy serialization format not supported yet.");o=e}else tt(e.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),o=e.layers,delete e.layers,r=e;const a=new t(r);if(!(a instanceof so))throw new At(`Sequential.fromConfig called on non-Sequential input: ${a}`);for(const l of o){const c=qn(l,void 0,i);i&&c.setFastWeightInitDuringBuild(!0),a.add(c)}return a}set stopTraining(t){if(this.model==null)throw new M("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(this.model==null)throw new M("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const t=[];for(const e of this.layers){const s={};s.className=e.getClassName(),s.config=e.getConfig(),t.push(s)}return{name:this.name,layers:t}}}so.className="Sequential";q(so);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let Te=class extends uo{getConfig(){return{}}};class Um extends Te{apply(t,e=1){return aC(t,e)}}Um.className="elu";q(Um);class Gm extends Te{apply(t){return Np(t)}}Gm.className="selu";q(Gm);class Hm extends Te{apply(t){return Si(t)}}Hm.className="relu";q(Hm);class jm extends Te{apply(t){return B(()=>jr(6,Si(t)))}}jm.className="relu6";q(jm);class Km extends Te{apply(t){return t}}Km.className="linear";q(Km);class Xm extends Te{apply(t){return Ws(t)}}Xm.className="sigmoid";q(Xm);class qm extends Te{apply(t){return uC(t)}}qm.className="hardSigmoid";q(qm);class Ym extends Te{apply(t){return Kr(t)}}Ym.className="softplus";q(Ym);class Zm extends Te{apply(t){return lC(t)}}Zm.className="softsign";q(Zm);class Qm extends Te{apply(t){return Xr(t)}}Qm.className="tanh";q(Qm);let Ju=class extends Te{apply(t,e=-1){return Nu(t,e)}};Ju.className="softmax";q(Ju);class Jm extends Te{apply(t,e=-1){return bp(t,e)}}Jm.className="logSoftmax";q(Jm);class tg extends Te{apply(t){return B(()=>B(()=>{const e=Math.sqrt(2),s=O(.5,ct(1,gp(Ct(t,e))));return O(t,s)}))}}tg.className="gelu";q(tg);class eg extends Te{apply(t){return B(()=>O(.5,O(t,ct(1,Xr(O(ns(Ct(2,Math.PI)),ct(t,O(.044715,zr(t,3)))))))))}}eg.className="gelu_new";q(eg);class ng extends Te{apply(t){return B(()=>O(t,Xr(Kr(t))))}}ng.className="mish";q(ng);class sg extends Te{apply(t,e=1){return B(()=>O(Ws(O(t,e)),t))}}sg.className="swish";q(sg);function gs(n){return n.getClassName()}function Ba(n,t={}){return po(n,co.getMap().classNameMap,t,"activation")}function ys(n){if(n==null){const t={};return t.className="linear",t.config={},Ba(t)}if(typeof n=="string"){const t={};return t.className=n,t.config={},Ba(t)}else return n instanceof Te?n:Ba(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Ck(n){if(n!=null&&typeof n!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${n}`)}class ig extends uo{}class og extends ig{constructor(t){super(),Ck(t),this.l1=t==null||t.l1==null?.01:t.l1,this.l2=t==null||t.l2==null?.01:t.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(t){return B(()=>{let e=Le([1]);return this.hasL1&&(e=ct(e,Et(O(this.l1,Ls(t))))),this.hasL2&&(e=ct(e,Et(O(this.l2,mo(t))))),Q(e,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(t,e){return new t({l1:e.l1,l2:e.l2})}}og.className="L1L2";q(og);const Rh={l1l2:"L1L2"};function Yt(n){return _u(n)}function Ah(n,t={}){return po(n,co.getMap().classNameMap,t,"regularizer")}function re(n){if(n==null)return null;if(typeof n=="string"){const e={className:n in Rh?Rh[n]:n,config:{}};return Ah(e)}else return n instanceof ig?n:Ah(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class rg extends Ft{constructor(t){super(t??{}),this.supportsMasking=!0,t!=null&&(this.maxValue=t.maxValue)}call(t,e){t=kt(t);let s=Si(t);return this.maxValue!=null&&(s=Ue(s,0,this.maxValue)),s}computeOutputShape(t){return t}getConfig(){const t={maxValue:this.maxValue},e=super.getConfig();return Object.assign(t,e),t}}rg.className="ReLU";q(rg);class ag extends Ft{constructor(t){super(t??{}),this.DEFAULT_ALPHA=.3,t==null&&(t={}),this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,e){const s=kt(t);return yp(s,this.alpha)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}}ag.className="LeakyReLU";q(ag);class lg extends Ft{constructor(t){if(super(t??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",t==null&&(t={}),this.supportsMasking=!0,this.alphaInitializer=oe(t.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=re(t.alphaRegularizer),this.alphaConstraint=xe(t.alphaConstraint),t.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(t.sharedAxes))this.sharedAxes=t.sharedAxes;else if(typeof t.sharedAxes=="number")this.sharedAxes=[t.sharedAxes];else throw new M(`Expected sharedAxes to be a number or an array of numbers, but got ${t.sharedAxes}`)}build(t){t=Wt(t);const e=t.slice(1);if(this.sharedAxes!=null)for(const i of this.sharedAxes)e[i-1]=1;this.alpha=this.addWeight("alpha",e,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const s={};if(this.sharedAxes!=null)for(let i=1;i<t.length;++i)s[i]=t[i];this.inputSpec=[new ye({ndim:t.length,axes:s})],this.built=!0}call(t,e){return t=kt(t),Ip(t,this.alpha.read())}getConfig(){const t={alphaInitializer:ae(this.alphaInitializer),alphaRegularizer:Yt(this.alphaRegularizer),alphaConstraint:be(this.alphaConstraint),sharedAxes:this.sharedAxes},e=super.getConfig();return Object.assign(t,e),t}}lg.className="PReLU";q(lg);let ug=class extends Ft{constructor(t){if(super(t??{}),this.DEFAULT_ALPHA=1,t==null&&(t={}),t.alpha!=null&&t.alpha!==this.DEFAULT_ALPHA)throw new At(`Non-default alpha value (${t.alpha}) is not supported by the ELU layer yet.`);this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,e){const s=kt(t);return Iu(s)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}};ug.className="ELU";q(ug);class cg extends Ft{constructor(t){super(t??{}),this.DEFAULT_THETA=1,t==null&&(t={}),this.theta=t.theta==null?this.DEFAULT_THETA:t.theta}call(t,e){const s=kt(t);return O(s,mt(Wn(s,this.theta),"float32"))}computeOutputShape(t){return t}getConfig(){const t={theta:this.theta},e=super.getConfig();return Object.assign(t,e),t}}cg.className="ThresholdedReLU";q(cg);class hg extends Ft{constructor(t){super(t??{}),this.DEFAULT_AXIS=1,t==null&&(t={}),this.softmax=new Ju().apply,this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis}call(t,e){return B(()=>{let s=kt(t);const i=e.mask;if(i!=null){const o=O(Lt(Bs(s.shape),mt(i,s.dtype)),se(-1e9));s=ct(s,o)}return this.axis instanceof Array?this.axis.length>1?Qn(Lt(s,xp(s,this.axis,!0))):this.softmax(s,this.axis[0]):this.softmax(s,this.axis)})}computeOutputShape(t){return t}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}hg.className="Softmax";q(hg);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function ai(n,t,e){if(typeof n=="number")return Os(n,t);if(n.length!==t)throw new M(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${n.length} elements.`);for(let s=0;s<t;++s){const i=n[s];if(!sC(i))throw new M(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(n)} including a non-integer number ${i}`)}return n}function gn(n,t,e,s,i=1){if(n==null)return n;const o=t+(t-1)*(i-1);let r;return e==="same"?r=n:r=n-o+1,Math.floor((r+s-1)/s)}function zn(n,t,e,s){if(n==null)return null;if(s==="valid")n=n*t+ms([e-t,0]);else if(s==="same")n=n*t;else throw new M(`Unsupport padding mode: ${s}.`);return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function tc(n,t){return B(()=>(pe(t),t==="channelsFirst"?Vt(n,[0,2,3,1]):n))}function dg(n,t){return B(()=>(pe(t),t==="channelsFirst"?Vt(n,[0,2,3,4,1]):n))}function kk(n,t,e,s=1,i="valid",o,r=1){return B(()=>{if(o==null&&(o=xn()),pe(o),n.shape.length!==3)throw new M(`The input of a conv1dWithBias operation should be 3, but is ${n.shape.length} instead.`);if(t.shape.length!==3)throw new M(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(e!=null&&e.shape.length!==1)throw new M(`The bias for a conv1dWithBias operation should be 1, but is ${e.shape.length} instead`);if(o==="channelsFirst"&&(n=Vt(n,[0,2,1])),i==="causal")throw new At("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let a=pp(n,t,s,i==="same"?"same":"valid","NWC",r);return e!=null&&(a=wn(a,e)),a})}function Th(n,t,e,s=[1,1],i="valid",o,r,a=null){return B(()=>{if(o==null&&(o=xn()),pe(o),n.rank!==3&&n.rank!==4)throw new M(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${n.rank}.`);if(t.rank!==3&&t.rank!==4)throw new M(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${n.rank}.`);let l=tc(n,o);if(i==="causal")throw new At("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=Bw({x:l,filter:t,strides:s,pad:i==="same"?"same":"valid",dilations:r,dataFormat:"NHWC",bias:e,activation:a}),o==="channelsFirst"&&(l=Vt(l,[0,3,1,2])),l})}function Sk(n,t,e,s=[1,1,1],i="valid",o,r){return B(()=>{if(o==null&&(o=xn()),pe(o),n.rank!==4&&n.rank!==5)throw new M(`conv3dWithBias expects input to be of rank 4 or 5, but received ${n.rank}.`);if(t.rank!==4&&t.rank!==5)throw new M(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${n.rank}.`);let a=dg(n,o);if(i==="causal")throw new At("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return a=Ww(a,t,s,i==="same"?"same":"valid","NDHWC",r),e!=null&&(a=wn(a,e)),o==="channelsFirst"&&(a=Vt(a,[0,4,1,2,3])),a})}class oa extends Ft{constructor(t,e){if(super(e),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",oa.verifyArgs(e),this.rank=t,Ce(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new At(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=ai(e.kernelSize,t,"kernelSize"),this.strides=ai(e.strides==null?1:e.strides,t,"strides"),this.padding=e.padding==null?"valid":e.padding,Qe(this.padding),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,pe(this.dataFormat),this.activation=ys(e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.biasInitializer=oe(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=xe(e.biasConstraint),this.biasRegularizer=re(e.biasRegularizer),this.activityRegularizer=re(e.activityRegularizer),this.dilationRate=ai(e.dilationRate==null?1:e.dilationRate,t,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new M(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new M(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new M(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(t){if(Tn("kernelSize"in t,"required key 'kernelSize' not in config"),typeof t.kernelSize!="number"&&!Bu(t.kernelSize,"number",1,3))throw new M(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){const t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:gs(this.activation),useBias:this.useBias,biasInitializer:ae(this.biasInitializer),biasRegularizer:Yt(this.biasRegularizer),activityRegularizer:Yt(this.activityRegularizer),biasConstraint:be(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}class Ri extends oa{constructor(t,e){super(t,e),this.kernel=null,Ri.verifyArgs(e),this.filters=e.filters,Ce(this.filters,"filters"),this.kernelInitializer=oe(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=xe(e.kernelConstraint),this.kernelRegularizer=re(e.kernelRegularizer)}build(t){t=Wt(t);const e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null)throw new M(`The channel dimension of the input should be defined. Found ${t[e]}`);const s=t[e],i=this.kernelSize.concat([s,this.filters]);this.kernel=this.addWeight("kernel",i,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:s}}],this.built=!0}call(t,e){return B(()=>{t=kt(t);let s;const i=this.bias==null?null:this.bias.read(),o=lm(this.activation.getClassName());if(o!=null&&this.rank===2)s=Th(t,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate,o);else{if(this.rank===1)s=kk(t,this.kernel.read(),i,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)s=Th(t,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)s=Sk(t,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new At("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(s=this.activation.apply(s))}return s})}computeOutputShape(t){t=Wt(t);const e=[],s=this.dataFormat==="channelsLast"?t.slice(1,t.length-1):t.slice(2);for(let o=0;o<s.length;++o){const r=gn(s[o],this.kernelSize[o],this.padding,this.strides[o],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[o]);e.push(r)}let i=[t[0]];return this.dataFormat==="channelsLast"?(i=i.concat(e),i.push(this.filters)):(i.push(this.filters),i=i.concat(e)),i}getConfig(){const t={filters:this.filters,kernelInitializer:ae(this.kernelInitializer),kernelRegularizer:Yt(this.kernelRegularizer),kernelConstraint:be(this.kernelConstraint)},e=super.getConfig();return Object.assign(t,e),t}static verifyArgs(t){if(!("filters"in t)||typeof t.filters!="number"||t.filters<1)throw new M(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}}class xo extends Ri{constructor(t){super(2,t),xo.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!Bu(t.kernelSize,"number",1,2))throw new M(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}}xo.className="Conv2D";q(xo);class wo extends Ri{constructor(t){super(3,t),wo.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!(Array.isArray(t.kernelSize)&&(t.kernelSize.length===1||t.kernelSize.length===3)))throw new M(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}}wo.className="Conv3D";q(wo);class pg extends xo{constructor(t){if(super(t),this.inputSpec=[new ye({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new M(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(t=Wt(t),t.length!==4)throw new M("Input should have rank 4; Received input shape: "+JSON.stringify(t));const e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null)throw new M("The channel dimension of the inputs should be defined. Found `None`.");const s=t[e],i=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",i,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new ye({ndim:4,axes:{[e]:s}})],this.built=!0}call(t,e){return B(()=>{let s=kt(t);if(s.shape.length!==4)throw new M(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const i=s.shape,o=i[0];let r,a;this.dataFormat==="channelsFirst"?(r=2,a=3):(r=1,a=2);const l=i[r],u=i[a],c=this.kernelSize[0],h=this.kernelSize[1],p=this.strides[0],f=this.strides[1],m=zn(l,p,c,this.padding),g=zn(u,f,h,this.padding),b=[o,m,g,this.filters];this.dataFormat!=="channelsLast"&&(s=Vt(s,[0,2,3,1]));let v=fp(s,this.kernel.read(),b,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(v=Vt(v,[0,3,1,2])),this.bias!=null&&(v=wn(v,this.bias.read(),this.dataFormat)),this.activation!=null&&(v=this.activation.apply(v)),v})}computeOutputShape(t){t=Wt(t);const e=t.slice();let s,i,o;this.dataFormat==="channelsFirst"?(s=1,i=2,o=3):(s=3,i=1,o=2);const r=this.kernelSize[0],a=this.kernelSize[1],l=this.strides[0],u=this.strides[1];return e[s]=this.filters,e[i]=zn(e[i],l,r,this.padding),e[o]=zn(e[o],u,a,this.padding),e}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}pg.className="Conv2DTranspose";q(pg);class fg extends wo{constructor(t){if(super(t),this.inputSpec=[new ye({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new M(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(t=Wt(t),t.length!==5)throw new M("Input should have rank 5; Received input shape: "+JSON.stringify(t));const e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null)throw new M("The channel dimension of the inputs should be defined. Found `None`.");const s=t[e],i=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",i,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new ye({ndim:5,axes:{[e]:s}})],this.built=!0}call(t,e){return B(()=>{let s=kt(t);if(s.shape.length!==5)throw new M(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const i=s.shape,o=i[0];let r,a,l;this.dataFormat==="channelsFirst"?(l=2,r=3,a=4):(l=1,r=2,a=3);const u=i[l],c=i[r],h=i[a],p=this.kernelSize[0],f=this.kernelSize[1],m=this.kernelSize[2],g=this.strides[0],b=this.strides[1],v=this.strides[2],w=zn(u,g,p,this.padding),k=zn(c,b,f,this.padding),C=zn(h,v,m,this.padding),I=[o,w,k,C,this.filters];this.dataFormat!=="channelsLast"&&(s=Vt(s,[0,2,3,4,1]));let N=_w(s,this.kernel.read(),I,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(N=Vt(N,[0,4,1,2,3])),this.bias!==null&&(N=wn(N,this.bias.read(),this.dataFormat)),this.activation!==null&&(N=this.activation.apply(N)),N})}computeOutputShape(t){t=Wt(t);const e=t.slice();let s,i,o,r;this.dataFormat==="channelsFirst"?(s=1,i=2,o=3,r=4):(s=4,i=1,o=2,r=3);const a=this.kernelSize[0],l=this.kernelSize[1],u=this.kernelSize[2],c=this.strides[0],h=this.strides[1],p=this.strides[2];return e[s]=this.filters,e[i]=zn(e[i],c,a,this.padding),e[o]=zn(e[o],h,l,this.padding),e[r]=zn(e[r],p,u,this.padding),e}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}fg.className="Conv3DTranspose";q(fg);class mg extends Ri{constructor(t,e){if(super(t,e),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,e.filters==null)throw new M("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(e.kernelInitializer!=null||e.kernelRegularizer!=null||e.kernelConstraint!=null)throw new M("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(e.padding!=null&&e.padding!=="same"&&e.padding!=="valid")throw new M(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(e.padding)}`);this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=oe(e.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=re(e.depthwiseRegularizer),this.depthwiseConstraint=xe(e.depthwiseConstraint),this.pointwiseInitializer=oe(e.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=re(e.pointwiseRegularizer),this.pointwiseConstraint=xe(e.pointwiseConstraint)}build(t){if(t=Wt(t),t.length<this.rank+2)throw new M(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(t)}`);const e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null||t[e]<0)throw new M(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(t[e])}`);const s=t[e],i=this.kernelSize.concat([s,this.depthMultiplier]),o=[];for(let a=0;a<this.rank;++a)o.push(1);o.push(s*this.depthMultiplier,this.filters);const r=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",i,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,r,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",o,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,r,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,r,this.biasConstraint):this.bias=null,this.inputSpec=[new ye({ndim:this.rank+2,axes:{[e]:s}})],this.built=!0}call(t,e){return B(()=>{t=kt(t);let s;if(this.rank===1)throw new At("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(t=Vt(t,[0,2,3,1])),s=$p(t,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(s=wn(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),this.dataFormat==="channelsFirst"&&(s=Vt(s,[0,3,1,2])),s})}getConfig(){const t=super.getConfig();return delete t.rank,delete t.kernelInitializer,delete t.kernelRegularizer,delete t.kernelConstraint,t.depthwiseInitializer=ae(this.depthwiseInitializer),t.pointwiseInitializer=ae(this.pointwiseInitializer),t.depthwiseRegularizer=Yt(this.depthwiseRegularizer),t.pointwiseRegularizer=Yt(this.pointwiseRegularizer),t.depthwiseConstraint=be(this.depthwiseConstraint),t.pointwiseConstraint=be(this.pointwiseConstraint),t}}mg.className="SeparableConv";class gg extends mg{constructor(t){super(2,t)}}gg.className="SeparableConv2D";q(gg);class ra extends Ri{constructor(t){super(1,t),ra.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){const t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!Bu(t.kernelSize,"number",1,1))throw new M(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}}ra.className="Conv1D";q(ra);class yg extends Ft{constructor(t){super(t),typeof t.cropping=="number"?this.cropping=[[t.cropping,t.cropping],[t.cropping,t.cropping]]:typeof t.cropping[0]=="number"?this.cropping=[[t.cropping[0],t.cropping[0]],[t.cropping[1],t.cropping[1]]]:this.cropping=t.cropping,this.dataFormat=t.dataFormat===void 0?"channelsLast":t.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(t){return this.dataFormat==="channelsFirst"?[t[0],t[1],t[2]-this.cropping[0][0]-this.cropping[0][1],t[3]-this.cropping[1][0]-this.cropping[1][1]]:[t[0],t[1]-this.cropping[0][0]-this.cropping[0][1],t[2]-this.cropping[1][0]-this.cropping[1][1],t[3]]}call(t,e){return B(()=>{if(t=kt(t),this.dataFormat==="channelsLast"){const s=Oo(t,this.cropping[0][0],t.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Oo(s,this.cropping[1][0],t.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{const s=Oo(t,this.cropping[0][0],t.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Oo(s,this.cropping[1][0],t.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const t={cropping:this.cropping,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}yg.className="Cropping2D";q(yg);class bg extends Ft{constructor(t){super(t),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=t.size==null?this.DEFAULT_SIZE:t.size,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,pe(this.dataFormat),this.interpolation=t.interpolation==null?"nearest":t.interpolation,tC(this.interpolation)}computeOutputShape(t){if(this.dataFormat==="channelsFirst"){const e=t[2]==null?null:this.size[0]*t[2],s=t[3]==null?null:this.size[1]*t[3];return[t[0],t[1],e,s]}else{const e=t[1]==null?null:this.size[0]*t[1],s=t[2]==null?null:this.size[1]*t[2];return[t[0],e,s,t[3]]}}call(t,e){return B(()=>{let s=kt(t);const i=s.shape;if(this.dataFormat==="channelsFirst"){s=Vt(s,[0,2,3,1]);const o=this.size[0]*i[2],r=this.size[1]*i[3],a=this.interpolation==="nearest"?Oe.resizeNearestNeighbor(s,[o,r]):Oe.resizeBilinear(s,[o,r]);return Vt(a,[0,3,1,2])}else{const o=this.size[0]*i[1],r=this.size[1]*i[2];return this.interpolation==="nearest"?Oe.resizeNearestNeighbor(s,[o,r]):Oe.resizeBilinear(s,[o,r])}})}getConfig(){const t={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},e=super.getConfig();return Object.assign(t,e),t}}bg.className="UpSampling2D";q(bg);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Ik(n,t,e=[1,1],s="valid",i,o){return B(()=>{i==null&&(i=xn()),pe(i);let r=tc(n,i);if(n.rank!==4)throw new M(`Input for depthwiseConv2d is required to be 4-D, but is instead ${n.rank}-D`);if(t.rank!==4)throw new M(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return r=mp(r,t,e,s==="same"?"same":"valid","NHWC",o),i==="channelsFirst"&&(r=Vt(r,[0,3,1,2])),r})}class xg extends oa{constructor(t){super(2,t),this.depthwiseKernel=null,this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=oe(t.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=xe(t.depthwiseConstraint),this.depthwiseRegularizer=re(t.depthwiseRegularizer)}build(t){if(t=Wt(t),t.length<4)throw new M(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(t)}.`);const e=this.dataFormat==="channelsFirst"?1:3;if(t[e]==null||t[e]<0)throw new M(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${t[e]}).`);const s=t[e],i=[this.kernelSize[0],this.kernelSize[1],s,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",i,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[s*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return B(()=>{t=kt(t);let s=Ik(t,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(s=wn(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),s})}computeOutputShape(t){t=Wt(t);const e=this.dataFormat==="channelsFirst"?t[2]:t[1],s=this.dataFormat==="channelsFirst"?t[3]:t[2],i=this.dataFormat==="channelsFirst"?t[1]*this.depthMultiplier:t[3]*this.depthMultiplier,o=gn(e,this.kernelSize[0],this.padding,this.strides[0]),r=gn(s,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[t[0],i,o,r]:[t[0],o,r,i]}getConfig(){const t=super.getConfig();return t.depthMultiplier=this.depthMultiplier,t.depthwiseInitializer=ae(this.depthwiseInitializer),t.depthwiseRegularizer=Yt(this.depthwiseRegularizer),t.depthwiseConstraint=be(this.depthwiseRegularizer),t}}xg.className="DepthwiseConv2D";q(xg);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function wg(n,t,e,s){if(Array.isArray(n)){if(t!=null||e!=null)throw new M("When inputs is an array, neither initialState or constants should be provided");s!=null&&(e=n.slice(n.length-s,n.length),n=n.slice(0,n.length-s)),n.length>1&&(t=n.slice(1,n.length)),n=n[0]}function i(o){return o==null||Array.isArray(o)?o:[o]}return t=i(t),e=i(e),{inputs:n,initialState:t,constants:e}}function vg(n,t,e,s=!1,i,o,r=!1,a=!1){return B(()=>{const l=t.shape.length;if(l<3)throw new M(`Input should be at least 3D, but is ${l}D.`);const u=[1,0].concat(bn(2,l));t=Vt(t,u),r&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),i!=null&&(i=mt(mt(i,"bool"),"float32"),i.rank===l-1&&(i=Ye(i,-1)),i=Vt(i,u)),s&&(t=Qi(t,0),i!=null&&(i=Qi(i,0)));const c=[];let h,p=e;const f=t.shape[0],m=Zi(t);let g;i!=null&&(g=Zi(i));for(let v=0;v<f;++v){const w=m[v],k=B(()=>n(w,p));if(i==null)h=k[0],p=k[1];else{const C=B(()=>{const I=g[v],N=Lt(ln(I),I),$=ct(O(k[0],I),O(p[0],N)),A=p.map((z,F)=>ct(O(k[1][F],I),O(z,N)));return{output:$,newStates:A}});h=C.output,p=C.newStates}a&&c.push(h)}let b;return a&&(b=lo(c,1)),[h,b,p]})}class vs extends Ft{constructor(t){super(t);let e;if(t.cell==null)throw new M("cell property is missing for the constructor of RNN.");if(Array.isArray(t.cell)?e=new sc({cells:t.cell}):e=t.cell,e.stateSize==null)throw new M("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=e,this.returnSequences=t.returnSequences==null?!1:t.returnSequences,this.returnState=t.returnState==null?!1:t.returnState,this.goBackwards=t.goBackwards==null?!1:t.goBackwards,this._stateful=t.stateful==null?!1:t.stateful,this.unroll=t.unroll==null?!1:t.unroll,this.supportsMasking=!0,this.inputSpec=[new ye({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return bn(0,t).map(e=>null)}else return this.states_}setStates(t){this.states_=t}computeOutputShape(t){sl(t)&&(t=t[0]),t=t;let e=this.cell.stateSize;Array.isArray(e)||(e=[e]);const s=e[0];let i;if(this.returnSequences?i=[t[0],t[1],s]:i=[t[0],s],this.returnState){const o=[];for(const r of e)o.push([t[0],r]);return[i].concat(o)}else return i}computeMask(t,e){return B(()=>{Array.isArray(e)&&(e=e[0]);const s=this.returnSequences?e:null;if(this.returnState){const i=this.states.map(o=>null);return[s].concat(i)}else return s})}get states(){if(this.states_==null){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,e=[];for(let s=0;s<t;++s)e.push(null);return e}else return this.states_}set states(t){this.states_=t}build(t){if(this.numConstants!=null)throw new At("Constants support is not implemented in RNN yet.");sl(t)&&(t=t[0]),t=t;const e=this.stateful?t[0]:null,s=t.slice(2);this.inputSpec[0]=new ye({shape:[e,null,...s]});const i=[t[0]].concat(t.slice(2));this.cell.build(i);let o;if(Array.isArray(this.cell.stateSize)?o=this.cell.stateSize:o=[this.cell.stateSize],this.stateSpec!=null){if(!ke(this.stateSpec.map(r=>r.shape[r.shape.length-1]),o))throw new M(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=o.map(r=>new ye({shape:[null,r]}));this.stateful&&this.resetStates()}resetStates(t,e=!1){B(()=>{if(!this.stateful)throw new An("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape[0];if(s==null)throw new M("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(i=>Le([s,i])):this.states_=[Le([s,this.cell.stateSize])];else if(t==null)zt(this.states_),this.keptStates!=null&&(zt(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(i=>Le([s,i])):this.states_[0]=Le([s,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new M(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);e===!0?this.keptStates.push(this.states_.slice()):zt(this.states_);for(let i=0;i<this.states_.length;++i){const o=t[i],r=Array.isArray(this.cell.stateSize)?this.cell.stateSize[i]:this.cell.stateSize,a=[s,r];if(!ke(o.shape,a))throw new M(`State ${i} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${o.shape}`);this.states_[i]=o}}this.states_=this.states_.map(i=>Xn(i.clone()))})}apply(t,e){let s=e==null?null:e.initialState,i=e==null?null:e.constants;e==null&&(e={});const o=wg(t,s,i,this.numConstants);t=o.inputs,s=o.initialState,i=o.constants;let r=[],a=[];if(s!=null){e.initialState=s,r=r.concat(s),this.stateSpec=[];for(const u of s)this.stateSpec.push(new ye({shape:u.shape}));a=a.concat(this.stateSpec)}if(i!=null&&(e.constants=i,r=r.concat(i),this.numConstants=i.length),r[0]instanceof On){const u=[t].concat(r),c=this.inputSpec.concat(a),h=this.inputSpec;this.inputSpec=c;const p=super.apply(u,e);return this.inputSpec=h,p}else return super.apply(t,e)}call(t,e){return B(()=>{const s=e==null?null:e.mask,i=e==null?null:e.training;let o=e==null?null:e.initialState;t=kt(t),o==null&&(this.stateful?o=this.states_:o=this.getInitialState(t));const r=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(o.length!==r)throw new M(`RNN Layer has ${r} state(s) but was passed ${o.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const a={training:i},u=vg((m,g)=>{const b=this.cell.call([m].concat(g),a);return[b[0],b.slice(1)]},t,o,this.goBackwards,s,null,this.unroll,this.returnSequences),c=u[0],h=u[1],p=u[2];this.stateful&&this.resetStates(p,i);const f=this.returnSequences?h:c;return this.returnState?[f].concat(p):f})}getInitialState(t){return B(()=>{let e=Le(t.shape);return e=Et(e,[1,2]),e=fo(e),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(s=>s>1?el(e,[1,s]):e):this.cell.stateSize>1?[el(e,[1,this.cell.stateSize])]:[e]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){const t=super.getConfig(),e={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(e.numConstants=this.numConstants);const s=this.cell.getConfig();return this.getClassName()===vs.className&&(e.cell={className:this.cell.getClassName(),config:s}),Object.assign(Object.assign(Object.assign({},s),t),e)}static fromConfig(t,e,s={}){const i=e.cell,o=qn(i,s);return new t(Object.assign(e,{cell:o}))}}vs.className="RNN";q(vs);class aa extends Ft{}class ec extends aa{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,Ce(this.units,"units"),this.activation=ys(t.activation==null?this.DEFAULT_ACTIVATION:t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=oe(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=oe(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=oe(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=re(t.kernelRegularizer),this.recurrentRegularizer=re(t.recurrentRegularizer),this.biasRegularizer=re(t.biasRegularizer),this.kernelConstraint=xe(t.kernelConstraint),this.recurrentConstraint=xe(t.recurrentConstraint),this.biasConstraint=xe(t.biasConstraint),this.dropout=mi([1,ms([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=mi([1,ms([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=Wt(t),this.kernel=this.addWeight("kernel",[t[t.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return B(()=>{if(t=t,t.length!==2)throw new M(`SimpleRNNCell expects 2 input Tensors, got ${t.length}.`);let s=t[1];t=t[0];const i=e.training==null?!1:e.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=bs({ones:()=>ln(t),rate:this.dropout,training:i,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=bs({ones:()=>ln(s),rate:this.recurrentDropout,training:i,dropoutFunc:this.dropoutFunc}));let o;const r=this.dropoutMask,a=this.recurrentDropoutMask;r!=null?o=En(O(t,r),this.kernel.read()):o=En(t,this.kernel.read()),this.bias!=null&&(o=wn(o,this.bias.read())),a!=null&&(s=O(s,a));let l=ct(o,En(s,this.recurrentKernel.read()));return this.activation!=null&&(l=this.activation.apply(l)),[l,l]})}getConfig(){const t=super.getConfig(),e={units:this.units,activation:gs(this.activation),useBias:this.useBias,kernelInitializer:ae(this.kernelInitializer),recurrentInitializer:ae(this.recurrentInitializer),biasInitializer:ae(this.biasInitializer),kernelRegularizer:Yt(this.kernelRegularizer),recurrentRegularizer:Yt(this.recurrentRegularizer),biasRegularizer:Yt(this.biasRegularizer),activityRegularizer:Yt(this.activityRegularizer),kernelConstraint:be(this.kernelConstraint),recurrentConstraint:be(this.recurrentConstraint),biasConstraint:be(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},t),e)}}ec.className="SimpleRNNCell";q(ec);class Cg extends vs{constructor(t){t.cell=new ec(t),super(t)}call(t,e){return B(()=>{this.cell.dropoutMask!=null&&(zt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(zt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=e==null?null:e.mask,i=e==null?null:e.training,o=e==null?null:e.initialState;return super.call(t,{mask:s,training:i,initialState:o})})}static fromConfig(t,e){return new t(e)}}Cg.className="SimpleRNN";q(Cg);class nc extends aa{constructor(t){if(super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.resetAfter)throw new M("GRUCell does not support reset_after parameter set to true.");this.units=t.units,Ce(this.units,"units"),this.activation=ys(t.activation===void 0?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=ys(t.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=oe(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=oe(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=oe(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=re(t.kernelRegularizer),this.recurrentRegularizer=re(t.recurrentRegularizer),this.biasRegularizer=re(t.biasRegularizer),this.kernelConstraint=xe(t.kernelConstraint),this.recurrentConstraint=xe(t.recurrentConstraint),this.biasConstraint=xe(t.biasConstraint),this.dropout=mi([1,ms([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=mi([1,ms([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=Wt(t);const e=t[t.length-1];this.kernel=this.addWeight("kernel",[e,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return B(()=>{if(t=t,t.length!==2)throw new M(`GRUCell expects 2 input Tensors (inputs, h, c), got ${t.length}.`);const s=e.training==null?!1:e.training;let i=t[1];t=t[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=bs({ones:()=>ln(t),rate:this.dropout,training:s,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=bs({ones:()=>ln(i),rate:this.recurrentDropout,training:s,count:3,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,r=this.recurrentDropoutMask;let a,l,u;0<this.dropout&&this.dropout<1&&(t=O(t,o[0]));let c=En(t,this.kernel.read());this.useBias&&(c=wn(c,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(i=O(i,r[0]));const h=this.recurrentKernel.read(),[p,f]=Kn(h,[2*this.units,this.units],h.rank-1),m=En(i,p),[g,b,v]=Kn(c,3,c.rank-1),[w,k]=Kn(m,2,m.rank-1);a=this.recurrentActivation.apply(ct(g,w)),l=this.recurrentActivation.apply(ct(b,k));const C=En(O(l,i),f);u=this.activation.apply(ct(v,C));const I=ct(O(a,i),O(ct(1,Me(a)),u));return[I,I]})}getConfig(){const t=super.getConfig(),e={units:this.units,activation:gs(this.activation),recurrentActivation:gs(this.recurrentActivation),useBias:this.useBias,kernelInitializer:ae(this.kernelInitializer),recurrentInitializer:ae(this.recurrentInitializer),biasInitializer:ae(this.biasInitializer),kernelRegularizer:Yt(this.kernelRegularizer),recurrentRegularizer:Yt(this.recurrentRegularizer),biasRegularizer:Yt(this.biasRegularizer),activityRegularizer:Yt(this.activityRegularizer),kernelConstraint:be(this.kernelConstraint),recurrentConstraint:be(this.recurrentConstraint),biasConstraint:be(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},t),e)}}nc.className="GRUCell";q(nc);class kg extends vs{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new nc(t),super(t)}call(t,e){return B(()=>{this.cell.dropoutMask!=null&&(zt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(zt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=e==null?null:e.mask,i=e==null?null:e.training,o=e==null?null:e.initialState;return super.call(t,{mask:s,training:i,initialState:o})})}static fromConfig(t,e){return e.implmentation===0&&(e.implementation=1),new t(e)}}kg.className="GRU";q(kg);class la extends aa{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,Ce(this.units,"units"),this.activation=ys(t.activation===void 0?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=ys(t.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=oe(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=oe(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=oe(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=t.unitForgetBias,this.kernelRegularizer=re(t.kernelRegularizer),this.recurrentRegularizer=re(t.recurrentRegularizer),this.biasRegularizer=re(t.biasRegularizer),this.kernelConstraint=xe(t.kernelConstraint),this.recurrentConstraint=xe(t.recurrentConstraint),this.biasConstraint=xe(t.biasConstraint),this.dropout=mi([1,ms([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=mi([1,ms([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){var e;t=Wt(t);const s=t[t.length-1];this.kernel=this.addWeight("kernel",[s,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let i;if(this.useBias){if(this.unitForgetBias){const o=this.biasInitializer,r=this.units;i=new(e=class extends cn{apply(l,u){const c=o.apply([r]),h=new Vu().apply([r]),p=o.apply([r*2]);return fh(fh(c,h),p)}},e.className="CustomInit",e)}else i=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,i,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(t,e){return B(()=>{const s=e.training==null?!1:e.training;if(t=t,t.length!==3)throw new M(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);let i=t[1];const o=t[2];t=t[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=bs({ones:()=>ln(t),rate:this.dropout,training:s,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=bs({ones:()=>ln(i),rate:this.recurrentDropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const r=this.dropoutMask,a=this.recurrentDropoutMask;let l,u,c,h;0<this.dropout&&this.dropout<1&&(t=O(t,r[0]));let p=En(t,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(i=O(i,a[0])),p=ct(p,En(i,this.recurrentKernel.read())),this.useBias&&(p=wn(p,this.bias.read()));const[f,m,g,b]=Kn(p,4,p.rank-1);l=this.recurrentActivation.apply(f),u=this.recurrentActivation.apply(m),c=ct(O(u,o),O(l,this.activation.apply(g))),h=this.recurrentActivation.apply(b);const v=O(h,this.activation.apply(c));return[v,v,c]})}getConfig(){const t=super.getConfig(),e={units:this.units,activation:gs(this.activation),recurrentActivation:gs(this.recurrentActivation),useBias:this.useBias,kernelInitializer:ae(this.kernelInitializer),recurrentInitializer:ae(this.recurrentInitializer),biasInitializer:ae(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Yt(this.kernelRegularizer),recurrentRegularizer:Yt(this.recurrentRegularizer),biasRegularizer:Yt(this.biasRegularizer),activityRegularizer:Yt(this.activityRegularizer),kernelConstraint:be(this.kernelConstraint),recurrentConstraint:be(this.recurrentConstraint),biasConstraint:be(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},t),e)}}la.className="LSTMCell";q(la);class Sg extends vs{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new la(t),super(t)}call(t,e){return B(()=>{this.cell.dropoutMask!=null&&(zt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(zt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=e==null?null:e.mask,i=e==null?null:e.training,o=e==null?null:e.initialState;return super.call(t,{mask:s,training:i,initialState:o})})}static fromConfig(t,e){return e.implmentation===0&&(e.implementation=1),new t(e)}}Sg.className="LSTM";q(Sg);class sc extends aa{constructor(t){super(t),this.cells=t.cells}get stateSize(){const t=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?t.push(...e.stateSize):t.push(e.stateSize);return t}call(t,e){return B(()=>{t=t;let s=t.slice(1);const i=[];for(const a of this.cells.slice().reverse())Array.isArray(a.stateSize)?i.push(s.splice(0,a.stateSize.length)):i.push(s.splice(0,1));i.reverse();const o=[];let r;for(let a=0;a<this.cells.length;++a){const l=this.cells[a];s=i[a],a===0?r=[t[0]].concat(s):r=[r[0]].concat(s),r=l.call(r,e),o.push(r.slice(1))}s=[];for(const a of o.slice().reverse())s.push(...a);return[r[0]].concat(s)})}build(t){sl(t)&&(t=t[0]),t=t;let e;this.cells.forEach((s,i)=>{Fs(`RNNCell_${i}`,()=>{s.build(t),Array.isArray(s.stateSize)?e=s.stateSize[0]:e=s.stateSize,t=[t[0],e]})}),this.built=!0}getConfig(){const t=super.getConfig(),e=o=>({className:o.getClassName(),config:o.getConfig()}),i={cells:this.cells.map(e)};return Object.assign(Object.assign({},t),i)}static fromConfig(t,e,s={}){const i=[];for(const o of e.cells)i.push(qn(o,s));return new t({cells:i})}get trainableWeights(){if(!this.trainable)return[];const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.cells)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const s of this.cells)e.push(...s.trainableWeights);return e.concat(t)}return t}getWeights(){const t=[];for(const e of this.cells)t.push(...e.weights);return il(t)}setWeights(t){const e=[];for(const s of this.cells){const i=s.weights.length,o=t.splice(i);for(let r=0;r<s.weights.length;++r)e.push([s.weights[r],o[r]])}qu(e)}}sc.className="StackedRNNCells";q(sc);function bs(n){const{ones:t,rate:e,training:s=!1,count:i=1,dropoutFunc:o}=n,r=()=>o!=null?o(t(),e):mm(t(),e),a=()=>go(r,t,s);return!i||i<=1?Xn(a().clone()):Array(i).fill(void 0).map(a).map(u=>Xn(u.clone()))}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var Nk=function(n,t){var e={};for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&t.indexOf(s)<0&&(e[s]=n[s]);if(n!=null&&typeof Object.getOwnPropertySymbols=="function")for(var i=0,s=Object.getOwnPropertySymbols(n);i<s.length;i++)t.indexOf(s[i])<0&&Object.prototype.propertyIsEnumerable.call(n,s[i])&&(e[s[i]]=n[s[i]]);return e};class Ig extends vs{constructor(t){if(t.unroll)throw new At("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(t.cell))throw new At("It is not possible at the moment to stack convolutional cells.");super(t),this.inputSpec=[new ye({ndim:5})]}call(t,e){return B(()=>{if(this.cell.dropoutMask!=null&&(zt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(zt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),e&&e.constants)throw new M("ConvRNN2D cell does not support constants");const s=e==null?null:e.mask,i=e==null?null:e.training,o=e==null?null:e.initialState;return super.call(t,{mask:s,training:i,initialState:o})})}computeOutputShape(t){let e=this.computeSingleOutputShape(t);return this.returnSequences||(e=[e[0],...e.slice(2)]),this.returnState&&(e=[e,...Array(2).fill([t[0],...e.slice(-3)])]),e}getInitialState(t){return B(()=>{const{stateSize:e}=this.cell,s=t.shape,i=this.computeSingleOutputShape(s),o=[i[0],...i.slice(2)],r=Le(o);return Array.isArray(e)?Array(e.length).fill(r):[r]})}resetStates(t,e=!1){B(()=>{if(!this.stateful)throw new An("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape,i=this.computeSingleOutputShape(s),o=[i[0],...i.slice(2)];if(s[0]==null)throw new M("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Le(o)):this.states_=[Le(o)];else if(t==null)zt(this.states_),this.keptStates!=null&&(zt(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Le(o)):this.states_[0]=Le(o);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new M(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);e?this.keptStates.push(this.states_.slice()):zt(this.states_);for(let a=0;a<this.states_.length;++a){const l=t[a],u=o;if(!ke(l.shape,u))throw new M(`State ${a} is incompatible with layer ${this.name}: expected shape=${u}, received shape=${l.shape}`);this.states_[a]=l}}this.states_=this.states_.map(a=>Xn(a.clone()))})}computeSingleOutputShape(t){const{dataFormat:e,filters:s,kernelSize:i,padding:o,strides:r,dilationRate:a}=this.cell,l=e==="channelsFirst",u=t[l?3:2],c=t[l?4:3],h=gn(u,i[0],o,r[0],a[0]),p=gn(c,i[1],o,r[1],a[1]);return[...t.slice(0,2),...l?[s,h,p]:[h,p,s]]}}Ig.className="ConvRNN2D";class ic extends la{constructor(t){const{filters:e,kernelSize:s,strides:i,padding:o,dataFormat:r,dilationRate:a}=t;super(Object.assign(Object.assign({},t),{units:e})),this.filters=e,Ce(this.filters,"filters"),this.kernelSize=ai(s,2,"kernelSize"),this.kernelSize.forEach(l=>Ce(l,"kernelSize")),this.strides=ai(i||1,2,"strides"),this.strides.forEach(l=>Ce(l,"strides")),this.padding=o||"valid",Qe(this.padding),this.dataFormat=r||"channelsLast",pe(this.dataFormat),this.dilationRate=ai(a||1,2,"dilationRate"),this.dilationRate.forEach(l=>Ce(l,"dilationRate"))}build(t){var e;t=Wt(t);const s=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[s]==null)throw new M(`The channel dimension of the input should be defined. Found ${t[s]}`);const i=t[s],o=4,r=this.kernelSize.concat([i,this.filters*o]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const a=this.kernelSize.concat([this.filters,this.filters*o]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",a,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let l;if(this.unitForgetBias){const u=this.biasInitializer,c=this.filters;l=new(e=class extends cn{apply(p,f){const m=u.apply([c]),g=Bs([c]),b=u.apply([c*2]);return Wu([m,g,b])}},e.className="CustomInit",e)}else l=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*o],null,l,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(t,e){return B(()=>{if(t.length!==3)throw new M(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);const s=e.training||!1,i=t[0],o=t[1],r=t[2],a=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=bs({ones:()=>ln(i),rate:this.dropout,training:s,count:a,dropoutFunc:this.dropoutFunc}));const l=this.dropoutMask,u=(Z,Y,it)=>!Y||!Y[it]?Z:O(Y[it],Z);let c=u(i,l,0),h=u(i,l,1),p=u(i,l,2),f=u(i,l,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=bs({ones:()=>ln(o),rate:this.recurrentDropout,training:s,count:a,dropoutFunc:this.dropoutFunc}));const m=this.recurrentDropoutMask;let g=u(o,m,0),b=u(o,m,1),v=u(o,m,2),w=u(o,m,3);const k=3,[C,I,N,$]=Kn(this.kernel.read(),a,k),[A,z,F,E]=this.useBias?Kn(this.bias.read(),a):[null,null,null,null];c=this.inputConv(c,C,A,this.padding),h=this.inputConv(h,I,z,this.padding),p=this.inputConv(p,N,F,this.padding),f=this.inputConv(f,$,E,this.padding);const[U,L,W,_]=Kn(this.recurrentKernel.read(),a,k);g=this.recurrentConv(g,U),b=this.recurrentConv(b,L),v=this.recurrentConv(v,W),w=this.recurrentConv(w,_);const V=this.recurrentActivation.apply(ct(c,g)),X=this.recurrentActivation.apply(ct(h,b)),j=ct(O(X,r),O(V,this.activation.apply(ct(p,v)))),K=O(this.recurrentActivation.apply(ct(f,w)),this.activation.apply(j));return[K,K,j]})}getConfig(){const t=super.getConfig(),e=Nk(t,["units"]),s={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},e),s)}inputConv(t,e,s,i){const o=Vo(t,e,this.strides,i||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return s?wn(o,s,this.dataFormat):o}recurrentConv(t,e){return Vo(t,e,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}ic.className="ConvLSTM2DCell";q(ic);class Ng extends Ig{constructor(t){const e=new ic(t);super(Object.assign(Object.assign({},t),{cell:e}))}static fromConfig(t,e){return new t(e)}}Ng.className="ConvLSTM2D";q(Ng);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class oc extends Ft{constructor(t){super(t),this.rate=Math.max(Math.min(t.rate,1),0),this.noiseShape=t.noiseShape,this.seed=t.seed,this.supportsMasking=!0}getNoiseShape(t){if(this.noiseShape==null)return this.noiseShape;const e=t.shape,s=[];for(let i=0;i<this.noiseShape.length;++i)s.push(this.noiseShape[i]==null?e[i]:this.noiseShape[i]);return s}call(t,e){return B(()=>{this.invokeCallHook(t,e);const s=kt(t);if(0<this.rate&&this.rate<1){const i=e.training==null?!1:e.training,o=this.getNoiseShape(s);return go(()=>mm(s,this.rate,o,this.seed),()=>s,i)}return t})}getConfig(){const t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},e=super.getConfig();return Object.assign(t,e),t}dispose(){return super.dispose()}}oc.className="Dropout";q(oc);class $g extends oc{constructor(t){super(t),this.inputSpec=[{ndim:3}]}getNoiseShape(t){const e=t.shape;return[e[0],1,e[2]]}}$g.className="SpatialDropout1D";q($g);class Dg extends Ft{constructor(t){if(super(t),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.batchInputShape==null&&t.inputShape==null&&t.inputDim!=null){let e=null;t.batchSize!=null&&(e=t.batchSize),this.batchInputShape=[e,t.inputDim]}this.units=t.units,Ce(this.units,"units"),this.activation=ys(t.activation),t.useBias!=null&&(this.useBias=t.useBias),this.kernelInitializer=oe(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=oe(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=xe(t.kernelConstraint),this.biasConstraint=xe(t.biasConstraint),this.kernelRegularizer=re(t.kernelRegularizer),this.biasRegularizer=re(t.biasRegularizer),this.activityRegularizer=re(t.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(t){t=Wt(t);const e=t[t.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[e,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:e}}],this.built=!0}computeOutputShape(t){t=Wt(t);const e=t.slice();return e[e.length-1]=this.units,e}call(t,e){return B(()=>{this.invokeCallHook(t,e);const s=kt(t),i=lm(this.activation.getClassName());let o;return i!=null?o=En(s,this.kernel.read(),i,this.bias?this.bias.read():null):(o=En(s,this.kernel.read()),this.bias!=null&&(o=wn(o,this.bias.read())),this.activation!=null&&(o=this.activation.apply(o))),o})}getConfig(){const t={units:this.units,activation:gs(this.activation),useBias:this.useBias,kernelInitializer:ae(this.kernelInitializer),biasInitializer:ae(this.biasInitializer),kernelRegularizer:Yt(this.kernelRegularizer),biasRegularizer:Yt(this.biasRegularizer),activityRegularizer:Yt(this.activityRegularizer),kernelConstraint:be(this.kernelConstraint),biasConstraint:be(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}Dg.className="Dense";q(Dg);class Rg extends Ft{constructor(t){t=t||{},super(t),this.inputSpec=[{minNDim:3}],this.dataFormat=t.dataFormat}computeOutputShape(t){t=Wt(t);for(const e of t.slice(1))if(e==null)throw new M(`The shape of the input to "Flatten" is not fully defined (got ${t.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[t[0],ds(t,1)]}call(t,e){return B(()=>{this.invokeCallHook(t,e);let s=kt(t);if(this.dataFormat==="channelsFirst"&&s.rank>1){const i=[0];for(let o=2;o<s.rank;++o)i.push(o);i.push(1),s=Vt(s,i)}return rC(s)})}getConfig(){const t={};this.dataFormat!=null&&(t.dataFormat=this.dataFormat);const e=super.getConfig();return Object.assign(t,e),t}}Rg.className="Flatten";q(Rg);class Ag extends Ft{constructor(t){super(t),this.supportsMasking=!0,this.activation=ys(t.activation)}call(t,e){return B(()=>{this.invokeCallHook(t,e);const s=kt(t);return this.activation.apply(s)})}getConfig(){const t={activation:gs(this.activation)},e=super.getConfig();return Object.assign(t,e),t}}Ag.className="Activation";q(Ag);class Tg extends Ft{constructor(t){super(t),this.n=t.n,this.inputSpec=[{ndim:2}]}computeOutputShape(t){return[t[0],this.n,t[1]]}call(t,e){return B(()=>(t=kt(t),iC(t,this.n)))}getConfig(){const t={n:this.n},e=super.getConfig();return Object.assign(t,e),t}}Tg.className="RepeatVector";q(Tg);class zg extends Ft{constructor(t){super(t),this.targetShape=t.targetShape;for(let e=0;e<this.targetShape.length;++e)this.isUnknown(this.targetShape[e])&&(this.targetShape[e]=null)}isUnknown(t){return t<0||t==null}fixUnknownDimension(t,e){const s="Total size of new array must be unchanged.",i=e.slice();let o=1,r=null;for(let l=0;l<i.length;++l){const u=i[l];if(this.isUnknown(u))if(r===null)r=l;else throw new M("Can only specifiy one unknown dimension.");else o*=u}const a=ds(t);if(r!==null){if(o===0||a%o!==0)throw new M(s);i[r]=a/o}else if(a!==o)throw new M(s);return i}computeOutputShape(t){let e=!1;for(let s=0;s<t.length;++s)if(this.isUnknown(t[s])){e=!0;break}return e?t.slice(0,1).concat(this.targetShape):t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape))}call(t,e){return B(()=>{this.invokeCallHook(t,e);const s=kt(t),i=s.shape,o=i.slice(0,1).concat(this.fixUnknownDimension(i.slice(1),this.targetShape));return Q(s,o)})}getConfig(){const t={targetShape:this.targetShape},e=super.getConfig();return Object.assign(t,e),t}}zg.className="Reshape";q(zg);class Fg extends Ft{constructor(t){if(super(t),t.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(t.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${t.dims} instead.`);const e=bn(1,t.dims.length+1);if(!ke(t.dims.slice().sort(),e))throw new Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=t.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new ye({ndim:this.dims.length+1})]}computeOutputShape(t){t=Wt(t);const e=t.slice();return this.dims.forEach((s,i)=>{e[i+1]=t[s]}),e}call(t,e){return Vt(kt(t),this.dimsIncludingBatch)}getConfig(){const t={dims:this.dims},e=super.getConfig();return Object.assign(t,e),t}}Fg.className="Permute";q(Fg);class Mg extends Ft{constructor(t){super(t??{}),this.supportsMasking=!0,t!=null?this.maskValue=t.maskValue==null?0:t.maskValue:this.maskValue=0}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={maskValue:this.maskValue};return Object.assign(e,t),e}computeMask(t,e){const s=kt(t);return Ja(Ho(s,this.maskValue),-1)}call(t,e){return B(()=>{this.invokeCallHook(t,e);const s=kt(t),r=Ja(Ho(s,this.maskValue),-1,!0);return O(s,mt(r,s.dtype))})}}Mg.className="Masking";q(Mg);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Pg extends Ft{constructor(t){if(super(t),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",t.batchInputShape==null&&t.inputShape==null){let e=null;t.batchSize!=null&&(e=t.batchSize),t.inputLength==null?this.batchInputShape=[e,null]:this.batchInputShape=[e].concat(Kt(t.inputLength))}this.inputDim=t.inputDim,Ce(this.inputDim,"inputDim"),this.outputDim=t.outputDim,Ce(this.outputDim,"outputDim"),this.embeddingsInitializer=oe(t.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=re(t.embeddingsRegularizer),this.activityRegularizer=re(t.activityRegularizer),this.embeddingsConstraint=xe(t.embeddingsConstraint),this.maskZero=t.maskZero,this.supportsMasking=t.maskZero,this.inputLength=t.inputLength}build(t){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(t){}computeMask(t,e){return B(()=>this.maskZero?(t=kt(t),Ho(t,ce(t))):null)}computeOutputShape(t){if(t=Wt(t),this.inputLength==null)return[...t,this.outputDim];const e=Kt(this.inputLength);if(e.length!==t.length-1)throw new M(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);{let s=0;for(let i=0;i<e.length;++i){const o=e[i],r=t[i+1];if(o!=null&&r!=null&&o!==r)throw new M(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);o==null&&(e[s]=r),s++}}return[t[0],...e,this.outputDim]}call(t,e){return B(()=>{this.invokeCallHook(t,e);let s=kt(t);s.dtype!=="int32"&&(s=Pn(s,"int32"));const i=fm(this.embeddings.read(),Q(s,[s.size]));return Q(i,Wt(this.computeOutputShape(s.shape)))})}getConfig(){const t={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:ae(this.embeddingsInitializer),embeddingsRegularizer:Yt(this.embeddingsRegularizer),activityRegularizer:Yt(this.activityRegularizer),embeddingsConstraint:be(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},e=super.getConfig();return Object.assign(t,e),t}}Pg.className="Embedding";q(Pg);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class js extends Ft{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new At}computeElementwiseOpOutputShape(t,e){if(t==null||e==null)return null;if(t.length<e.length)return this.computeElementwiseOpOutputShape(e,t);if(e.length===0)return t;const s=t.slice(0,t.length-e.length);for(let i=0;i<e.length;++i){const o=t[t.length-e.length+i],r=e[i];if(o==null||r==null||o<0||r<0)s.push(null);else if(o===1)s.push(r);else if(r===1)s.push(o);else{if(o!==r)throw new M("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(e));s.push(o)}}return s}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[Wt(t)]),t=t,t.length<2)throw new M(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let e=[];for(const o of t)o!=null&&o[0]!==null&&e.push(o[0]);if(e=hs(e),e.length>1)throw new M(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let s=t[0]==null?null:t[0].slice(1);for(let o=1;o<t.length;++o){const r=t[o]==null?null:t[o].slice(1);s=this.computeElementwiseOpOutputShape(s,r)}const i=t.map(o=>o.length);t.indexOf(null)===-1&&hs(i).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(t,e){return B(()=>{if(t=t,this.reshapeRequired){const s=[],i=t.map(o=>o.rank);if(i.indexOf(null)===-1){const o=ms(i);for(let r of t){const a=r.rank;for(let l=0;l<o-a;++l)r=fo(r,1);s.push(r)}return this.mergeFunction(s)}else{let o=!1;for(const l of t){const u=l.rank;if(u==null){const c=l.shape,h=c[0],p=c.slice(1).concat([h]);let f=Q(l,[h].concat(ds(c.slice(1))));f=Vt(f,[1,0]),f=Q(f,p),s.push(f),o=!0}else if(u>1){const c=bn(1,u).concat([0]);s.push(Vt(l,c)),o=!0}else s.push(l)}let r=this.mergeFunction(s);const a=r.rank;if(o){if(a==null){const l=r.shape,u=l.length,c=l[u-1],h=[c].concat(l.slice(0,l.length-1));r=Q(Vt(Q(r,[-1,c]),[1,0]),h)}else if(a>1){const l=[a-1].concat(bn(0,a-1));r=Vt(r,l)}}return r}}else return this.mergeFunction(t)})}computeOutputShape(t){t=t;let e;t[0]==null?e=null:e=t[0].slice(1);for(let i=1;i<t.length;++i){const o=t[i]==null?null:t[i].slice(1);e=this.computeElementwiseOpOutputShape(e,o)}let s=[];for(const i of t)i!=null&&i[0]!==null&&s.push(i[0]);return s=hs(s),s.length===1?e=s.concat(e):e=[null].concat(e),e}computeMask(t,e){return B(()=>{if(e==null)return null;if(!Array.isArray(e))throw new M("`mask` should be an Array");if(!Array.isArray(t))throw new M("`inputs` should be an Array");if(e.length!==t.length)throw new M(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${e.length})`);if(e.every(i=>i==null))return null;e=e.map(i=>i==null?i:Ye(i,0));let s=e[0];for(let i=1;i<e.length-1;++i)s=vi(s,e[i]);return s})}}class Eg extends js{constructor(t){super(t)}mergeFunction(t){return B(()=>{let e=t[0].clone();for(let s=1;s<t.length;++s)e=ct(e,t[s]);return e})}}Eg.className="Add";q(Eg);class Lg extends js{constructor(t){super(t)}mergeFunction(t){return B(()=>{let e=t[0].clone();for(let s=1;s<t.length;++s)e=O(e,t[s]);return e})}}Lg.className="Multiply";q(Lg);class Og extends js{constructor(t){super(t)}mergeFunction(t){return B(()=>{let e=t[0].clone();for(let s=1;s<t.length;++s)e=ct(e,t[s]);return O(1/t.length,e)})}}Og.className="Average";q(Og);class _g extends js{constructor(t){super(t)}mergeFunction(t){return B(()=>{let e=t[0];for(let s=1;s<t.length;++s)e=Vs(e,t[s]);return e})}}_g.className="Maximum";q(_g);class Bg extends js{constructor(t){super(t)}mergeFunction(t){return B(()=>{let e=t[0];for(let s=1;s<t.length;++s)e=jr(e,t[s]);return e})}}Bg.className="Minimum";q(Bg);class Wg extends js{constructor(t){super(t),this.DEFAULT_AXIS=-1,t==null&&(t={}),this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){if(!(Array.isArray(t)&&Array.isArray(t[0]))||t.length===1)throw new M("A `Concatenate` layer should be called on a list of at least 2 inputs");t=t;let e=!0;for(const i of t)if(i!=null){e=!1;break}if(e)return;const s=[];for(let i=0;i<t.length;++i){const o=t[i].slice();o.splice(this.axis,1);let r=!1;for(const a of s)if(ke(a,o)){r=!0;break}r||s.push(o)}if(s.length>1)throw new M("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(t))}mergeFunction(t){return B(()=>Wu(t,this.axis))}computeOutputShape(t){if(!(Array.isArray(t)&&Array.isArray(t[0])))throw new M("A `Concatenate` layer should be called on a list of inputs.");const e=t,s=e[0].slice(),i=this.axis<0?s.length+this.axis:this.axis;for(const o of e.slice(1)){if(s[i]==null||o[i]==null){s[i]=null;break}s[i]+=o[i]}return s}computeMask(t,e){if(e==null)return null;if(!Array.isArray(e))throw new M("`mask` should be an array for Concatenate");if(!Array.isArray(t))throw new M("`inputs` should be an array for Concatenate");if(e.length!==t.length)throw new M(`Mismatch in the length of mask (${e.length}) and the legnth of inputs (${t.length})`);return B(()=>{let s=!0;if(e.forEach(r=>{if(r!=null){s=!1;return}}),s)return null;const i=[];for(let r=0;r<t.length;++r)e[r]==null?i.push(mt(ln(t[r]),"bool")):e[r].rank<t[r].rank?i.push(Ye(e[r],-1)):i.push(e[r]);const o=fs(i,this.axis);return hp(o,-1,!1)})}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}Wg.className="Concatenate";q(Wg);function Ui(n,t){for(;n<0;)n+=t;return n}function $k(n,t,e){if(n.shape.length>3||t.shape.length>3)throw new At("batchDot is not implemented for tensors of 4D or higher rank yet");if(tt(n.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${n.shape.length}`),tt(n.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),typeof e=="number"&&(e=[e,e]),n.dtype==="complex64"||t.dtype==="complex64")throw new At("batchDot is not implemented for complex64-type Tensors yet.");const s=n.shape.length,i=t.shape.length;e==null&&(e=[s-1,i-2]);const o=e;return B(()=>{let r;if(s>i){r=s-i;const l=[];for(let u=0;u<r;++u)l.push(1);t=Q(t,t.shape.concat(l))}else if(i>s){r=i-s;const l=[];for(let u=0;u<r;++u)l.push(1);n=Q(n,n.shape.concat(l))}else r=0;let a;if(n.shape.length===2&&t.shape.length===2)o[0]===o[1]?a=Et(O(n,t),o[0]):a=Et(O(Vt(n,[1,0]),t),o[1]);else{const l=o[0]!==n.shape.length-1,u=o[1]===t.shape.length-1;a=Dn(n,t,l,u)}if(r>0){let l;s>i?l=s+i-3:l=s-1;const u=[];for(let c=l;c<l+r;++c)u.push(c);a=Xt(a,u)}return a.shape.length===1&&(a=Ye(a,1)),a})}class Vg extends js{constructor(t){super(t),this.axes=t.axes,this.normalize=t.normalize==null?!1:t.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){tt(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const e=t[0],s=t[1];if(e.length>3||s.length>3)throw new At("Dot layer does not support tensors of 4D or higher rank yet.");const i=this.interpretAxes(e,s);if(e[i[0]]!==s[i[1]])throw new M(`Dimension incompatibility: ${e[i[0]]} !== ${s[i[1]]}`)}mergeFunction(t){if(t.length!==2)throw new M(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${t.length} input(s).`);let e=t[0],s=t[1],i;return Array.isArray(this.axes)?i=this.axes.map((o,r)=>Ui(o,t[r].shape.length)):i=[Ui(this.axes,e.shape.length),Ui(this.axes,s.shape.length)],this.normalize&&(e=Jo(e,i[0]),s=Jo(s,i[1])),$k(e,s,i)}interpretAxes(t,e){let s;return Array.isArray(this.axes)?s=this.axes:s=[Ui(this.axes,t.length),Ui(this.axes,e.length)],s}computeOutputShape(t){tt(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const e=t[0].slice(),s=t[1].slice();if(e.length>3||s.length>3)throw new At("Dot layer does not support tensors of 4D or higher rank yet.");const i=this.interpretAxes(e,s);e.splice(i[0],1),s.splice(i[1],1),s.splice(0,1);const o=e.concat(s);return o.length===1&&o.push(1),o}computeMask(t,e){return null}getConfig(){const t={axes:this.axes,normalize:this.normalize},e=super.getConfig();return Object.assign(t,e),t}}Vg.className="Dot";q(Vg);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Ug extends Ft{constructor(t){super(t),this.supportsMasking=!0,this.stddev=t.stddev}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={stddev:this.stddev};return Object.assign(e,t),e}call(t,e){return B(()=>{this.invokeCallHook(t,e);const s=kt(t);return go(()=>ct(ea(s.shape,0,this.stddev),s),()=>s,e.training||!1)})}}Ug.className="GaussianNoise";q(Ug);class Gg extends Ft{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return B(()=>{this.invokeCallHook(t,e);const s=kt(t);return this.rate>0&&this.rate<1?go(()=>{const o=Math.sqrt(this.rate/(1-this.rate));return O(s,ea(s.shape,1,o))},()=>s,e.training||!1):s})}}Gg.className="GaussianDropout";q(Gg);class Hg extends Ft{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate,this.noiseShape=t.noiseShape}_getNoiseShape(t){return this.noiseShape||kt(t).shape}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return B(()=>{if(this.rate<1&&this.rate>0){const s=this._getNoiseShape(t);return go(()=>{const o=kt(t),l=-1.6732632423543772*1.0507009873554805;let u=Ci(qr(s),this.rate);u=Pn(u,"float32");const c=((1-this.rate)*(1+this.rate*l**2))**-.5,h=-c*l*this.rate,p=ct(O(o,u),O(ct(u,-1),l));return ct(O(p,c),h)},()=>kt(t),e.training||!1)}return t})}}Hg.className="AlphaDropout";q(Hg);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function io(n,t,e,s,i,o=.001){let r;if(n.rank===2)r=Vw(n,t,e,s,i,o);else if(n.rank===3)r=Uw(n,t,e,s,i,o);else if(n.rank===4)r=Gw(n,t,e,s,i,o);else throw new At(`batchNormalization is not implemented for array of rank ${n.rank} yet`);return r}function Dk(n,t,e,s,i=.001){return B(()=>{const o=Ru(n,s),r=o.mean,a=o.variance;return[io(n,r,a,e,t,i),r,a]})}function Rk(n,t,e,s,i=.001){return B(()=>{const o=Ru(n,s),r=o.mean,a=o.variance,l=[];for(const m of bn(0,n.rank))s.indexOf(m)!==-1?l.push(1):l.push(n.shape[m]);const u=Q(r,l),c=Q(a,l),h=t==null?null:Q(t,l),p=e==null?null:Q(e,l);return[io(n,u,c,p,h,i),r,a]})}function Ak(n,t,e,s,i=.001){return ke(s.slice().sort(),bn(0,n.rank-1))?Dk(n,t,e,s,i):Rk(n,t,e,s,i)}class jg extends Ft{constructor(t){t==null&&(t={}),super(t),this.supportsMasking=!0,this.axis=t.axis==null?-1:t.axis,this.momentum=t.momentum==null?.99:t.momentum,this.epsilon=t.epsilon==null?.001:t.epsilon,this.center=t.center==null?!0:t.center,this.scale=t.scale==null?!0:t.scale,this.betaInitializer=oe(t.betaInitializer||"zeros"),this.gammaInitializer=oe(t.gammaInitializer||"ones"),this.movingMeanInitializer=oe(t.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=oe(t.movingVarianceInitializer||"ones"),this.betaConstraint=xe(t.betaConstraint),this.gammaConstraint=xe(t.gammaConstraint),this.betaRegularizer=re(t.betaRegularizer),this.gammaRegularizer=re(t.gammaRegularizer)}build(t){t=Wt(t);const e=this.axis>=0?this.axis:this.axis+t.length,s=t[e];if(s==null)throw new M(`Axis ${e} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(t)}.`);this.inputSpec=[new ye({ndim:t.length,axes:{[e]:s}})];const i=[s];this.scale&&(this.gamma=this.addWeight("gamma",i,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",i,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",i,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",i,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(t,e){return B(()=>{const s=e.training==null?!1:e.training,i=kt(t),o=i.shape,r=o.length,a=bn(0,r),l=this.axis>=0?this.axis:this.axis+r;a.splice(l,1);const u=Os(1,r);u[l]=o[l];const c=a.slice();c.sort();const h=!ke(c,bn(0,r).slice(0,r-1)),p=()=>{if(h){const w=Q(this.movingMean.read(),u),k=Q(this.movingVariance.read(),u),C=this.center?Q(this.beta.read(),u):null,I=this.scale?Q(this.gamma.read(),u):null;return io(i,w,k,C,I,this.epsilon)}else return io(i,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!s)return p();const[f,m,g]=Ak(i,this.gamma.read(),this.beta.read(),a,this.epsilon),b=(w,k,C)=>{B(()=>{const I=1-C,N=w.read(),$=O(Lt(N,k),I);w.write(Lt(N,$))})};return(()=>{b(this.movingMean,m,this.momentum),b(this.movingVariance,g,this.momentum)})(),f})}getConfig(){const t={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:ae(this.betaInitializer),gammaInitializer:ae(this.gammaInitializer),movingMeanInitializer:ae(this.movingMeanInitializer),movingVarianceInitializer:ae(this.movingVarianceInitializer),betaRegularizer:Yt(this.betaRegularizer),gammaRegularizer:Yt(this.gammaRegularizer),betaConstraint:be(this.betaConstraint),gammaConstraint:be(this.gammaConstraint)},e=super.getConfig();return Object.assign(t,e),t}}jg.className="BatchNormalization";q(jg);class Kg extends Ft{constructor(t){if(t==null&&(t={}),super(t),this.axis=t.axis==null?-1:t.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const e of this.axis)if(!Number.isInteger(e))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=t.epsilon==null?.001:t.epsilon,this.center=t.center==null?!0:t.center,this.scale=t.scale==null?!0:t.scale,this.betaInitializer=oe(t.betaInitializer||"zeros"),this.gammaInitializer=oe(t.gammaInitializer||"ones"),this.betaRegularizer=re(t.betaRegularizer),this.gammaRegularizer=re(t.gammaRegularizer),this.supportsMasking=!0}build(t){t=Wt(t);const e=t.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let o=0;o<this.axis.length;++o)this.axis[o]<0&&(this.axis[o]+=e);for(const o of this.axis)if(o<0||o>=e)throw new Error(`Invalid axis: ${o}`);if(this.axis.length!==hs(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const s=this.axis.map(o=>t[o]),i=!0;this.scale?this.gamma=this.addWeight("gamma",s,"float32",this.gammaInitializer,this.gammaRegularizer,i):this.gamma=null,this.center?this.beta=this.addWeight("beta",s,"float32",this.betaInitializer,this.betaRegularizer,i):this.beta=null,this.built=!0}call(t,e){const s=kt(t),i=s.shape,o=i.length;return B(()=>{let{mean:a,variance:l}=Ru(s,this.axis,!0);const u=Os(1,o);for(const g of this.axis)u[g]=i[g];const c=g=>g!=null&&g.shape.length!==o?Q(g,u):g;let h=this.scale?c(this.gamma.read()):null,p=this.center?c(this.beta.read()):null;const f=[],m=[];for(let g=0;g<o;++g)this.axis.indexOf(g)!==-1?(f.push(i[g]),m.push(1)):(f.push(1),m.push(i[g]));return a=As(a,f),l=As(l,f),h!=null&&(h=As(h,m)),p!=null&&(p=As(p,m)),io(s,a,l,p,h,this.epsilon)})}getConfig(){const t={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:ae(this.betaInitializer),gammaInitializer:ae(this.gammaInitializer),betaRegularizer:Yt(this.betaRegularizer),gammaRegularizer:Yt(this.gammaRegularizer)},e=super.getConfig();return Object.assign(t,e),t}}Kg.className="LayerNormalization";q(Kg);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Tk(n,t,e){return B(()=>{if(n.rank!==4)throw new M(`temporalPadding expects input tensor to be 4-D, but received a ${n.rank}-D tensor.`);if(t==null&&(t=[[1,1],[1,1]]),t.length!==2||t[0].length!==2||t[1].length!==2)throw new M("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(e==null&&(e=xn()),e!=="channelsLast"&&e!=="channelsFirst")throw new M(`Unknown data format: ${e}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let s;return e==="channelsFirst"?s=[[0,0],[0,0],t[0],t[1]]:s=[[0,0],t[0],t[1],[0,0]],li(n,s)})}class Xg extends Ft{constructor(t){if(t==null&&(t={}),super(t),this.dataFormat=t.dataFormat==null?xn():t.dataFormat,t.padding==null)this.padding=[[1,1],[1,1]];else if(typeof t.padding=="number")this.padding=[[t.padding,t.padding],[t.padding,t.padding]];else{if(t.padding=t.padding,t.padding.length!==2)throw new M(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${t.padding.length} array.`);let e,s;if(typeof t.padding[0]=="number")e=[t.padding[0],t.padding[0]],s=[t.padding[1],t.padding[1]];else{if(t.padding=t.padding,t.padding[0].length!==2)throw new M(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${t.padding[0].length} array.`);if(e=t.padding[0],t.padding[1].length!==2)throw new M(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${t.padding[1].length} array.`);s=t.padding[1]}this.padding=[e,s]}this.inputSpec=[new ye({ndim:4})]}computeOutputShape(t){t=Wt(t);let e,s;return this.dataFormat==="channelsFirst"?(t[2]!=null&&t[2]>=0?e=t[2]+this.padding[0][0]+this.padding[0][1]:e=null,t[3]!=null&&t[3]>=0?s=t[3]+this.padding[1][0]+this.padding[1][1]:s=null,[t[0],t[1],e,s]):(t[1]!=null&&t[1]>=0?e=t[1]+this.padding[0][0]+this.padding[0][1]:e=null,t[2]!=null&&t[2]>=0?s=t[2]+this.padding[1][0]+this.padding[1][1]:s=null,[t[0],e,s,t[3]])}call(t,e){return B(()=>Tk(kt(t),this.padding,this.dataFormat))}getConfig(){const t={padding:this.padding,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}Xg.className="ZeroPadding2D";q(Xg);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function ua(n,t,e,s,i,o){return B(()=>{pe(i),cm(o),Qe(s),e==null&&(e=[1,1]),s==null&&(s="valid"),i==null&&(i=xn()),o==null&&(o="max"),n=tc(n,i);let r;const a=s==="same"?"same":"valid";return o==="max"?r=vp(n,t,e,a):r=dp(n,t,e,a),i==="channelsFirst"&&(r=Vt(r,[0,3,1,2])),r})}function qg(n,t,e,s,i,o){return B(()=>{pe(i),cm(o),Qe(s),e==null&&(e=[1,1,1]),s==null&&(s="valid"),i==null&&(i=xn()),o==null&&(o="max"),n=dg(n,i);let r;const a=s==="same"?"same":"valid";return o==="max"?r=Hw(n,t,e,a):r=jw(n,t,e,a),i==="channelsFirst"&&(r=Vt(r,[0,4,1,2,3])),r})}class Yg extends Ft{constructor(t){if(t.poolSize==null&&(t.poolSize=2),super(t),typeof t.poolSize=="number")this.poolSize=[t.poolSize];else if(Array.isArray(t.poolSize)&&t.poolSize.length===1&&typeof t.poolSize[0]=="number")this.poolSize=t.poolSize;else throw new M(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);if(Ce(this.poolSize,"poolSize"),t.strides==null)this.strides=this.poolSize;else if(typeof t.strides=="number")this.strides=[t.strides];else if(Array.isArray(t.strides)&&t.strides.length===1&&typeof t.strides[0]=="number")this.strides=t.strides;else throw new M(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);Ce(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,Qe(this.padding),this.inputSpec=[new ye({ndim:3})]}computeOutputShape(t){t=Wt(t);const e=gn(t[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],e,t[2]]}call(t,e){return B(()=>{this.invokeCallHook(t,e),t=fo(kt(t),2);const s=this.poolingFunction(kt(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Xt(s,[2])})}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(t,e),t}}class Zg extends Yg{constructor(t){super(t)}poolingFunction(t,e,s,i,o){return pe(o),Qe(i),ua(t,e,s,i,o,"max")}}Zg.className="MaxPooling1D";q(Zg);class Qg extends Yg{constructor(t){super(t)}poolingFunction(t,e,s,i,o){return pe(o),Qe(i),ua(t,e,s,i,o,"avg")}}Qg.className="AveragePooling1D";q(Qg);class Jg extends Ft{constructor(t){if(t.poolSize==null&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==2)throw new M(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides];Ce(this.poolSize,"poolSize"),Ce(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,pe(this.dataFormat),Qe(this.padding),this.inputSpec=[new ye({ndim:4})]}computeOutputShape(t){t=Wt(t);let e=this.dataFormat==="channelsFirst"?t[2]:t[1],s=this.dataFormat==="channelsFirst"?t[3]:t[2];return e=gn(e,this.poolSize[0],this.padding,this.strides[0]),s=gn(s,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[t[0],t[1],e,s]:[t[0],e,s,t[3]]}call(t,e){return B(()=>(this.invokeCallHook(t,e),this.poolingFunction(kt(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class ty extends Jg{constructor(t){super(t)}poolingFunction(t,e,s,i,o){return pe(o),Qe(i),ua(t,e,s,i,o,"max")}}ty.className="MaxPooling2D";q(ty);class ey extends Jg{constructor(t){super(t)}poolingFunction(t,e,s,i,o){return pe(o),Qe(i),ua(t,e,s,i,o,"avg")}}ey.className="AveragePooling2D";q(ey);class ny extends Ft{constructor(t){if(t.poolSize==null&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==3)throw new M(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];Ce(this.poolSize,"poolSize"),Ce(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,pe(this.dataFormat),Qe(this.padding),this.inputSpec=[new ye({ndim:5})]}computeOutputShape(t){t=Wt(t);let e=this.dataFormat==="channelsFirst"?t[2]:t[1],s=this.dataFormat==="channelsFirst"?t[3]:t[2],i=this.dataFormat==="channelsFirst"?t[4]:t[3];return e=gn(e,this.poolSize[0],this.padding,this.strides[0]),s=gn(s,this.poolSize[1],this.padding,this.strides[1]),i=gn(i,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[t[0],t[1],e,s,i]:[t[0],e,s,i,t[4]]}call(t,e){return B(()=>(this.invokeCallHook(t,e),this.poolingFunction(kt(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class sy extends ny{constructor(t){super(t)}poolingFunction(t,e,s,i,o){return pe(o),Qe(i),qg(t,e,s,i,o,"max")}}sy.className="MaxPooling3D";q(sy);class iy extends ny{constructor(t){super(t)}poolingFunction(t,e,s,i,o){return pe(o),Qe(i),qg(t,e,s,i,o,"avg")}}iy.className="AveragePooling3D";q(iy);class oy extends Ft{constructor(t){super(t),this.inputSpec=[new ye({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,e){throw new At}}class ry extends oy{constructor(t){super(t||{})}call(t,e){return B(()=>{const s=kt(t);return ve(s,1)})}}ry.className="GlobalAveragePooling1D";q(ry);class ay extends oy{constructor(t){super(t||{})}call(t,e){return B(()=>{const s=kt(t);return ci(s,1)})}}ay.className="GlobalMaxPooling1D";q(ay);class ly extends Ft{constructor(t){super(t),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,pe(this.dataFormat),this.inputSpec=[new ye({ndim:4})]}computeOutputShape(t){return t=t,this.dataFormat==="channelsLast"?[t[0],t[3]]:[t[0],t[1]]}call(t,e){throw new At}getConfig(){const t={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class uy extends ly{call(t,e){return B(()=>{const s=kt(t);return this.dataFormat==="channelsLast"?ve(s,[1,2]):ve(s,[2,3])})}}uy.className="GlobalAveragePooling2D";q(uy);class cy extends ly{call(t,e){return B(()=>{const s=kt(t);return this.dataFormat==="channelsLast"?ci(s,[1,2]):ci(s,[2,3])})}}cy.className="GlobalMaxPooling2D";q(cy);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class hy extends Ft{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(t){this.layer!=null&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){const t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(t,e),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,e,s={}){const i=e.layer,o=qn(i,s);delete e.layer;const r={layer:o};return Object.assign(r,e),new t(r)}}class dy extends hy{constructor(t){super(t),this.supportsMasking=!0}build(t){if(t=Wt(t),t.length<3)throw new M(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(t)}`);this.inputSpec=[{shape:t}];const e=[t[0]].concat(t.slice(2));this.layer.built||(this.layer.build(e),this.layer.built=!0),super.build(t)}computeOutputShape(t){t=Wt(t);const e=[t[0]].concat(t.slice(2)),s=this.layer.computeOutputShape(e),i=t[1];return[s[0],i].concat(s.slice(1))}call(t,e){return B(()=>(t=kt(t),vg((r,a)=>[kt(this.layer.call(r,e)),[]],t,[],!1,null,null,!1,!0)[1]))}}dy.className="TimeDistributed";q(dy);function zk(n){Hs(J2,"BidirectionalMergeMode",n)}const Fk="concat";class py extends hy{constructor(t){super(t);const e=t.layer.getConfig(),s={};s.className=t.layer.getClassName(),s.config=e,this.forwardLayer=qn(s),e.goBackwards=e.goBackwards!==!0;const i={};if(i.className=t.layer.getClassName(),i.config=e,this.backwardLayer=qn(i),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=t.mergeMode===void 0?Fk:t.mergeMode,zk(this.mergeMode),t.weights)throw new At("weights support is not implemented for Bidirectional layer yet.");this._stateful=t.layer.stateful,this.returnSequences=t.layer.returnSequences,this.returnState=t.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=t.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(t){this._trainable=t,this.forwardLayer!=null&&(this.forwardLayer.trainable=t),this.backwardLayer!=null&&(this.backwardLayer.trainable=t)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(t){const e=t.length,s=Math.floor(e/2);this.forwardLayer.setWeights(t.slice(0,s)),this.backwardLayer.setWeights(t.slice(s))}computeOutputShape(t){let e=this.forwardLayer.computeOutputShape(t);Array.isArray(e)&&Array.isArray(e[0])||(e=[e]),e=e;let s,i,o;return this.returnState&&(o=e.slice(1)),s=e[0],s=s,this.mergeMode==="concat"?(s[s.length-1]*=2,i=[s]):this.mergeMode==null?i=[s,s.slice()]:i=[s],this.returnState?this.mergeMode==null?i.concat(o).concat(o.slice()):[s].concat(o).concat(o.slice()):Ee(i)}apply(t,e){let s=e==null?null:e.initialState,i=e==null?null:e.constants;e==null&&(e={});const o=wg(t,s,i,this.numConstants);if(t=o.inputs,s=o.initialState,i=o.constants,Array.isArray(t)&&(s=t.slice(1),t=t[0]),(s==null||s.length===0)&&i==null)return super.apply(t,e);const r=[],a=[];if(s!=null){const u=s.length;if(u%2>0)throw new M("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");e.initialState=s,r.push(...s);const c=s.map(h=>new ye({shape:h.shape}));this.forwardLayer.stateSpec=c.slice(0,u/2),this.backwardLayer.stateSpec=c.slice(u/2),a.push(...c)}if(i!=null)throw new At("Support for constants in Bidirectional layers is not implemented yet.");const l=r[0]instanceof On;for(const u of r)if(u instanceof On!==l)throw new M("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(l){const u=[t].concat(r),c=this.inputSpec.concat(a),h=this.inputSpec;this.inputSpec=c;const p=super.apply(u,e);return this.inputSpec=h,p}else return super.apply(t,e)}call(t,e){return B(()=>{const s=e.initialState;let i,o;if(s==null)i=this.forwardLayer.call(t,e),o=this.backwardLayer.call(t,e);else{const l=s.slice(0,s.length/2),u=s.slice(s.length/2);i=this.forwardLayer.call(t,Object.assign(e,{initialState:l})),o=this.backwardLayer.call(t,Object.assign(e,{initialState:u}))}let r;this.returnState&&(Array.isArray(i)&&(r=i.slice(1).concat(o.slice(1))),i=i[0],o=o[0]),this.returnSequences&&(o=Qi(o,1));let a;return this.mergeMode==="concat"?a=Wu([i,o]):this.mergeMode==="sum"?a=ct(i,o):this.mergeMode==="ave"?a=O(.5,ct(i,o)):this.mergeMode==="mul"?a=O(i,o):this.mergeMode==null&&(a=[i,o]),this.returnState?this.mergeMode==null?a.concat(r):[a].concat(r):a})}resetStates(t){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(t){Fs(this.forwardLayer.name,()=>{this.forwardLayer.build(t)}),Fs(this.backwardLayer.name,()=>{this.backwardLayer.build(t)}),this.built=!0}computeMask(t,e){Array.isArray(e)&&(e=e[0]);let s;if(this.returnSequences?this.mergeMode==null?s=[e,e]:s=e:this.mergeMode==null?s=[null,null]:s=null,this.returnState){const o=this.forwardLayer.states.map(r=>null);return Array.isArray(s)?s.concat(o).concat(o):[s].concat(o).concat(o)}else return s}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(t),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(t)}getConfig(){const t={mergeMode:this.mergeMode},e=super.getConfig();return Object.assign(t,e),t}static fromConfig(t,e){const s=qn(e.layer);if(delete e.layer,e.numConstants!=null)throw new At("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const i=e;return i.layer=s,new t(i)}}py.className="Bidirectional";q(py);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class fy extends Ft{constructor(t){super(t),this.scale=t.scale,t.offset?this.offset=t.offset:this.offset=0}getConfig(){const t={scale:this.scale,offset:this.offset},e=super.getConfig();return Object.assign(t,e),t}call(t,e){return B(()=>(t=kt(t),t.dtype!=="float32"&&(t=Pn(t,"float32")),ct(O(t,this.scale),this.offset)))}}fy.className="Rescaling";q(fy);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const{resizeBilinear:Mk,cropAndResize:Pk}=Oe;class my extends Ft{constructor(t){super(t),this.height=t.height,this.width=t.width}centerCrop(t,e,s,i,o,r,a,l){return B(()=>{let u,c=!1;const h=e/r,p=s/a,f=(i+e)/r,m=(o+s)/a,g=[h,p,f,m],b=[];t.rank===3?(c=!0,u=lo([t])):u=t;for(let I=0;I<u.shape[0];I++)b.push(g);const v=Kw(b,[b.length,4]),w=Xw(0,b.length,1,"int32"),C=Pk(u,v,w,[i,o],"nearest");return Pn(c?kt(Zi(C)):C,l)})}upsize(t,e,s,i){return B(()=>{const o=Mk(t,[e,s]);return Pn(o,i)})}call(t,e){return B(()=>{const s=kt(t),i=s.dtype,o=s.shape,r=o[o.length-3],a=o[o.length-2];let l=0;r!==this.height&&(l=Math.floor((r-this.height)/2));let u=0;return a!==this.width&&(u=Math.floor((a-this.width)/2),u===0&&(u=1)),l>=0&&u>=0?this.centerCrop(s,l,u,this.height,this.width,r,a,i):this.upsize(t,this.height,this.width,i)})}getConfig(){const t={height:this.height,width:this.width},e=super.getConfig();return Object.assign(t,e),t}computeOutputShape(t){t=Wt(t);const e=t.length-3,s=t.length-2;return t[e]=this.height,t[s]=this.width,t}}my.className="CenterCrop";q(my);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Ek(n,t,e,s){let i=kt(n);if(i.dtype!=="int32"&&(i=Pn(i,"int32")),t==="int")return i;const o=i.shape;if(i.rank===0&&(i=Ye(i,-1)),t==="oneHot"&&i.shape[i.shape.length-1]!==1&&(i=Ye(i,-1)),i.rank>2)throw new M(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${o} which would result in output rank ${i.rank}.`);const r=["multiHot","oneHot"].includes(t),a=i;let l;if(typeof s<"u"&&t==="count"?l=th(a,s,e,r):l=th(a,[],e,r),t!=="tfIdf")return l;if(s)return O(l,s);throw new M("When outputMode is 'tfIdf', weights must be provided.")}/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class gy extends Ft{constructor(t){super(t),this.numTokens=t.numTokens,t.outputMode?this.outputMode=t.outputMode:this.outputMode="multiHot"}getConfig(){const t={numTokens:this.numTokens,outputMode:this.outputMode},e=super.getConfig();return Object.assign(t,e),t}computeOutputShape(t){return t=Wt(t),t==null?[this.numTokens]:this.outputMode==="oneHot"&&t[t.length-1]!==1?(t.push(this.numTokens),t):(t[t.length-1]=this.numTokens,t)}call(t,e){return B(()=>{t=kt(t),t.dtype!=="int32"&&(t=Pn(t,"int32"));let s;if(typeof e.countWeights<"u"){if(this.outputMode!=="count")throw new M(`countWeights is not used when outputMode !== count.
              Received countWeights=${e.countWeights}`);s=kt(e.countWeights)}const i=ci(t),o=Cp(t),r=Wn(this.numTokens,i).bufferSync().get(0),a=Ci(o,0).bufferSync().get(0);if(!(r&&a))throw new M(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return Ek(t,this.outputMode,this.numTokens,s)})}}gy.className="CategoryEncoding";q(gy);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Lk=["bilinear","nearest"],zh=new Set(Lk);class yy extends Ft{constructor(t){if(super(t),this.height=t.height,this.width=t.width,t.interpolation)if(zh.has(t.interpolation))this.interpolation=t.interpolation;else throw new M(`Invalid interpolation parameter: ${t.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!t.cropToAspectRatio}computeOutputShape(t){t=Wt(t);const e=t[2];return[this.height,this.width,e]}getConfig(){const t={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},e=super.getConfig();return Object.assign(t,e),t}call(t,e){return B(()=>{const s=[this.height,this.width];if(this.interpolation==="bilinear")return Oe.resizeBilinear(t,s,!this.cropToAspectRatio);if(this.interpolation==="nearest")return Oe.resizeNearestNeighbor(t,s,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...zh]} are supported`)})}}yy.className="Resizing";q(yy);/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class by{constructor(t){this.seed=t}next(){if(this.seed!==void 0)return this.seed++}}by.className="RandomSeed";/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class xy extends Ft{constructor(t){super(t),this.randomGenerator=new by(t.seed)}getConfig(){const t={seed:this.randomGenerator.seed},e=super.getConfig();return Object.assign(t,e),t}}xy.className="BaseRandomLayer";/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Ok=["bilinear","nearest"],Fh=new Set(Ok);class wy extends xy{constructor(t){super(t);const{factor:e,interpolation:s="bilinear"}=t;if(this.factor=e,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new M(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new M(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new M(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(s)if(Fh.has(s))this.interpolation=s;else throw new M(`Invalid interpolation parameter: ${s} is not implemented`)}getConfig(){const t={factor:this.factor,interpolation:this.interpolation},e=super.getConfig();return Object.assign(t,e),t}computeOutputShape(t){t=Wt(t);const e=t[2];return[this.imgHeight,-1,e]}call(t,e){return B(()=>{const s=kt(t);this.imgHeight=s.shape[s.shape.length-3];const i=s.shape[s.shape.length-2];this.widthFactor=qr([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let o=this.widthFactor.dataSync()[0]*i;o=Math.round(o);const r=[this.imgHeight,o];switch(this.interpolation){case"bilinear":return Oe.resizeBilinear(t,r);case"nearest":return Oe.resizeNearestNeighbor(t,r);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...Fh]} are supported`)}})}}wy.className="RandomWidth";q(wy);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var Mh;(function(n){n[n.FAIL=0]="FAIL",n[n.SHORTEST=1]="SHORTEST",n[n.LONGEST=2]="LONGEST"})(Mh||(Mh={}));/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _k=Yw;class ca extends Ap{nextDataId(){return ca.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new Tp(this,us())}write(t,e,s){this.firstUse&&(this.firstUse=!1,he().get("IS_NODE")&&qw(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const i={id:this.nextDataId()};return this.data.set(i,{values:t,dtype:s,refCount:1}),i}makeTensorInfo(t,e,s){let i;if(e==="string"&&s!=null&&s.length>0&&zp(s[0])){const o=s.map(r=>Fp(r));i=this.write(o,t,e)}else i=this.write(s,t,e);return{dataId:i,shape:t,dtype:e}}refCount(t){return this.data.has(t)?this.data.get(t).refCount:0}incRef(t){const e=this.data.get(t);e.refCount++}decRef(t){if(this.data.has(t)){const e=this.data.get(t);e.refCount--}}move(t,e,s,i,o){this.data.set(t,{values:e,dtype:i,refCount:o})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){const{dtype:e,complexTensorInfos:s}=this.data.get(t);if(e==="complex64"){const i=this.readSync(s.real.dataId),o=this.readSync(s.imag.dataId);return di(i,o)}return Bo(this.data.get(t).values,e)}bufferSync(t){const e=this.readSync(t.dataId);if(t.dtype==="string")try{const s=e.map(i=>ho(i));return le(t.shape,t.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return le(t.shape,t.dtype,e)}makeOutput(t,e,s){return us().makeTensorFromTensorInfo(this.makeTensorInfo(e,s,t),this)}disposeData(t,e=!1){if(this.data.has(t)){if(this.data.get(t).refCount--,!e&&this.data.get(t).refCount>0)return!1;const{complexTensorInfos:s}=this.data.get(t);s!=null&&(this.disposeData(s.real.dataId,!0),this.disposeData(s.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}async time(t){const e=jo();return t(),{kernelMs:jo()-e}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){yt([t],"where");const e=this.readSync(t.dataId);return _k(t.shape,e)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}ca.nextDataId=0;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Mp("cpu",()=>new ca,1);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vy=Qt(Sr,n=>n>=0?n:Math.exp(n)-1),Bk={kernelName:Sr,backendName:"cpu",kernelFunc:vy};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cy(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{alpha:o}=s;yt([i],"leakyRelu");const r=et(i.shape),a=e.data.get(i.dataId).values,l=Ln("float32",r);for(let u=0;u<a.length;u++)l[u]=a[u]<0?o*a[u]:a[u];return e.makeTensorInfo(i.shape,"float32",l)}const Wk={kernelName:Vl,backendName:"cpu",kernelFunc:Cy};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vk=Us((n,t)=>n<0?t*n:n);function ky(n){const{inputs:t,backend:e}=n,{x:s,alpha:i}=t;yt([s,i],"prelu");const o=e.data.get(s.dataId).values,r=e.data.get(i.dataId).values,[a,l]=Vk(s.shape,i.shape,o,r,"float32");return e.makeTensorInfo(l,"float32",a)}const Uk={kernelName:iu,backendName:"cpu",kernelFunc:ky};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sy=Qt(Er,n=>Math.max(0,n)),Gk={kernelName:Er,backendName:"cpu",kernelFunc:Sy};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Iy=Qt(Pr,n=>Math.min(Math.max(0,n),6)),Hk={kernelName:Pr,backendName:"cpu",kernelFunc:Iy};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ir(n,t,e,s,i){if(e==="linear")return Gs({inputs:{x:t},backend:n});if(e==="relu")return Sy({inputs:{x:t},backend:n});if(e==="elu")return vy({inputs:{x:t},backend:n});if(e==="relu6")return Iy({inputs:{x:t},backend:n});if(e==="prelu")return ky({inputs:{x:t,alpha:s},backend:n});if(e==="leakyrelu")return Cy({inputs:{x:t},backend:n,attrs:{alpha:i}});if(e==="sigmoid")return Zw({inputs:{x:t},backend:n});throw new Error(`Activation ${e} has not been implemented for the CPU backend.`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function te(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{shape:o}=s,r=et(i.shape),a=Pp(o,r),l=et(a);tt(r===l,()=>`The new shape (${a}) has ${l} elements and the old shape (${i.shape}) has ${r} elements. The new shape and old shape must have the same number of elements.`),e.incRef(i.dataId);const u=e.data.get(i.dataId);if(u.complexTensorInfos!=null){const c=u.complexTensorInfos.real,h=u.complexTensorInfos.imag;c.shape=a,h.shape=a}return{dataId:i.dataId,shape:a,dtype:i.dtype}}const jk={kernelName:ou,backendName:"cpu",kernelFunc:te};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ny(n){const{inputs:t,backend:e,attrs:s}=n,{a:i,b:o}=t,{transposeA:r,transposeB:a}=s;yt([i,o],"matMul");const l=i.shape.length,u=o.shape.length,c=r?i.shape[l-2]:i.shape[l-1],h=a?o.shape[u-1]:o.shape[u-2],p=r?i.shape[l-1]:i.shape[l-2],f=a?o.shape[u-2]:o.shape[u-1],m=i.shape.slice(0,-2),g=o.shape.slice(0,-2),b=et(m),v=et(g),k=Ne(i.shape.slice(0,-2),o.shape.slice(0,-2)).concat([p,f]);tt(c===h,()=>`Error in matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${i.shape} and ${o.shape} and transposeA=${r} and transposeB=${a} must match.`);const C=r?[b,c,p]:[b,p,c],I=a?[v,f,h]:[v,h,f],N=te({inputs:{x:i},backend:e,attrs:{shape:C}}),$=te({inputs:{x:o},backend:e,attrs:{shape:I}}),A=r?N.shape[1]:N.shape[2],z=r?N.shape[2]:N.shape[1],F=a?$.shape[1]:$.shape[2],E=Math.max(b,v),U=e.data.get(N.dataId).values,L=e.data.get($.dataId).values,W=Tt(N.shape),_=Tt($.shape),[V,X,j]=r?[W[0],1,W[1]]:[W[0],W[1],1],[K,Z,Y]=a?[1,_[1],_[0]]:[_[1],1,_[0]],it=z*F,nt=le([E,z,F],N.dtype),lt=nt.values,at=e.blockSize;for(let pt=0;pt<E;pt++){const gt=pt%b,wt=pt%v;for(let xt=0;xt<z;xt+=at){const Dt=Math.min(xt+at,z);for(let Nt=0;Nt<F;Nt+=at){const Ut=Math.min(Nt+at,F);for(let $t=0;$t<A;$t+=at){const Mt=Math.min($t+at,A);for(let jt=xt;jt<Dt;jt++)for(let Ht=Nt;Ht<Ut;Ht++){let Jt=0;for(let qt=$t;qt<Mt;qt++){const tn=U[gt*V+jt*X+qt*j],fe=L[qt*K+Ht*Z+wt*Y];Jt+=tn*fe}lt[pt*it+(jt*F+Ht)]+=Jt}}}}}return e.disposeIntermediateTensorInfo(N),e.disposeIntermediateTensorInfo($),e.makeTensorInfo(k,nt.dtype,nt.values)}const Kk={kernelName:Nl,backendName:"cpu",kernelFunc:Ny};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xk(n){const{inputs:t,backend:e,attrs:s}=n,{a:i,b:o,bias:r,preluActivationWeights:a}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:h}=s;let p,f,m;const g=[];p=Ny({inputs:{a:i,b:o},attrs:{transposeA:l,transposeB:u},backend:e}),r&&(f=Ji({inputs:{a:p,b:r},backend:e}),g.push(p),p=f),c&&(m=ir(e,p,c,a,h),g.push(p),p=m);for(const v of g)e.disposeIntermediateTensorInfo(v);return p}const qk={kernelName:Ep,backendName:"cpu",kernelFunc:Xk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yk=Qt(dr,n=>Math.acos(n)),Zk={kernelName:dr,backendName:"cpu",kernelFunc:Yk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qk=Qt(pr,n=>Math.acosh(n)),Jk={kernelName:pr,backendName:"cpu",kernelFunc:Qk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tS(n){const{inputs:t,backend:e}=n,s=t;yt(t,"addN");const i=s.map(a=>e.data.get(a.dataId).values),o=le(s[0].shape,s[0].dtype),r=o.values;for(let a=0;a<s.length;a++){const l=i[a];for(let u=0;u<r.length;u++)r[u]+=l[u]}return e.makeTensorInfo(o.shape,o.dtype,o.values)}const eS={kernelName:xl,backendName:"cpu",kernelFunc:tS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nS(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:o,keepDims:r}=s;yt(i,"all");const a=ee(o,i.shape);let l=a;const u=Pe(l,i.shape.length);let c=i;u!=null&&(c=Ze({inputs:{x:i},backend:e,attrs:{perm:u}}),l=Ke(l.length,i.shape.length)),Vn("all",l,c.shape.length);const[h,p]=un(c.shape,l),f=et(p),m=ss(et(h),c.dtype),g=e.data.get(c.dataId).values;for(let v=0;v<m.length;++v){const w=v*f;let k=g[w];for(let C=0;C<f;++C){const I=g[w+C];k=k&&I}m[v]=k}u!=null&&e.disposeIntermediateTensorInfo(c);const b=e.makeTensorInfo(h,c.dtype,m);if(r){const v=Jn(h,a),w=te({inputs:{x:b},backend:e,attrs:{shape:v}});return e.disposeIntermediateTensorInfo(b),w}return b}const sS={kernelName:Lp,backendName:"cpu",kernelFunc:nS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iS(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:o,keepDims:r}=s;yt(i,"any");const a=ee(o,i.shape);let l=a;const u=Pe(l,i.shape.length);let c=i;u!=null&&(c=Ze({inputs:{x:i},backend:e,attrs:{perm:u}}),l=Ke(l.length,i.shape.length)),Vn("any",l,c.shape.length);const[h,p]=un(c.shape,l),f=et(p),m=ss(et(h),c.dtype),g=e.data.get(c.dataId).values;for(let v=0;v<m.length;++v){const w=v*f;let k=g[w];for(let C=0;C<f;++C){const I=g[w+C];k=k||I}m[v]=k}u!=null&&e.disposeIntermediateTensorInfo(c);const b=e.makeTensorInfo(h,c.dtype,m);if(r){const v=Jn(h,a),w=te({inputs:{x:b},backend:e,attrs:{shape:v}});return e.disposeIntermediateTensorInfo(b),w}return b}const oS={kernelName:Op,backendName:"cpu",kernelFunc:iS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rS(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:o}=s;yt(i,"argMax");let r=ee(o,i.shape);const a=Pe(r,i.shape.length);let l=i;const u=[];a!=null&&(l=Ze({inputs:{x:i},backend:e,attrs:{perm:a}}),u.push(l),r=Ke(r.length,l.shape.length)),r=[r[0]],Vn("argMax",r,l.shape.length);const[c,h]=un(l.shape,r),p=et(c),f=ss(p,"int32"),m=et(h),g=e.data.get(l.dataId).values;for(let b=0;b<f.length;++b){const v=b*m;let w=g[v],k=0;for(let C=0;C<m;++C){const I=g[v+C];I>w&&(w=I,k=C)}f[b]=k}return u.forEach(b=>e.disposeIntermediateTensorInfo(b)),e.makeTensorInfo(c,"int32",f)}const aS={kernelName:wl,backendName:"cpu",kernelFunc:rS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lS(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:o}=s;yt(i,"argMin");let r=ee(o,i.shape);const a=Pe(r,i.shape.length);let l=i;const u=[];a!=null&&(l=Ze({inputs:{x:i},backend:e,attrs:{perm:a}}),u.push(l),r=Ke(r.length,l.shape.length)),r=[r[0]],Vn("argMin",r,l.shape.length);const[c,h]=un(l.shape,r),p=et(c),f=ss(p,"int32"),m=et(h),g=e.data.get(l.dataId).values;for(let b=0;b<f.length;++b){const v=b*m;let w=g[v],k=0;for(let C=0;C<m;++C){const I=g[v+C];I<w&&(w=I,k=C)}f[b]=k}return u.forEach(b=>e.disposeIntermediateTensorInfo(b)),e.makeTensorInfo(c,"int32",f)}const uS={kernelName:vl,backendName:"cpu",kernelFunc:lS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cS=Qt(fr,n=>Math.asin(n)),hS={kernelName:fr,backendName:"cpu",kernelFunc:cS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dS=Qt(mr,n=>Math.asinh(n)),pS={kernelName:mr,backendName:"cpu",kernelFunc:dS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fS=Qt(yr,n=>Math.atan(n)),mS={kernelName:yr,backendName:"cpu",kernelFunc:fS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gS=Us((n,t)=>Math.atan2(n,t)),yS=Ii(gr,gS),bS={kernelName:gr,backendName:"cpu",kernelFunc:yS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xS=Qt(br,n=>Math.atanh(n)),wS={kernelName:br,backendName:"cpu",kernelFunc:xS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rc(n,t,e,s,i,o){const r=i.strideHeight,a=i.strideWidth,l=i.dilationHeight,u=i.dilationWidth,c=i.effectiveFilterHeight,h=i.effectiveFilterWidth,p=i.padInfo.top,f=i.padInfo.left,m=o==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,g=le(i.outShape,e),b=g.values,v=i.outShape[1]*i.outShape[2]*i.outShape[3],w=i.outShape[2]*i.outShape[3],k=i.outShape[3];for(let C=0;C<i.batchSize;++C){const I=C*v,N=C*s[0];for(let $=0;$<i.inChannels;++$)for(let A=0;A<i.outHeight;++A){const z=A*r-p,F=Math.max(0,z),E=Math.min(i.inHeight,c+z),U=I+A*w;for(let L=0;L<i.outWidth;++L){const W=L*a-f,_=Math.max(0,W),V=Math.min(i.inWidth,h+W);let X=m,j=0,K=0;for(let Y=F;Y<E;Y+=l){const it=N+Y*s[1];for(let nt=_;nt<V;nt+=u){const lt=it+nt*s[2],at=n[lt+$];o==="max"&&at>X?X=at:o==="avg"&&(j+=at,K++)}if(isNaN(X))break}const Z=U+L*k+$;b[Z]=o==="avg"?j/K:X}}}return g}function $y(n,t,e,s,i=!1,o=!1){const r=le(s.outShape,"int32"),a=s.strideHeight,l=s.strideWidth,u=s.dilationHeight,c=s.dilationWidth,h=s.effectiveFilterHeight,p=s.effectiveFilterWidth,f=s.padInfo.top,m=s.padInfo.left,g=le(t,e,n);for(let b=0;b<s.batchSize;++b)for(let v=0;v<s.inChannels;++v)for(let w=0;w<s.outHeight;++w){const k=w*a-f;let C=k;for(;C<0;)C+=u;const I=Math.min(s.inHeight,h+k);for(let N=0;N<s.outWidth;++N){const $=N*l-m;let A=$;for(;A<0;)A+=c;const z=Math.min(s.inWidth,p+$);let F=Number.NEGATIVE_INFINITY,E=-1;for(let U=C;U<I;U+=u){const L=U-k;for(let W=A;W<z;W+=c){const _=W-$,V=g.get(b,U,W,v);V>F&&(F=V,i?E=o?((b*s.inHeight+U)*s.inWidth+W)*s.inChannels+v:(U*s.inWidth+W)*s.inChannels+v:E=L*p+_)}}r.set(E,b,w,N,v)}}return r}function Dy(n,t,e,s,i,o){const r=i.strideDepth,a=i.strideHeight,l=i.strideWidth,u=i.dilationDepth,c=i.dilationHeight,h=i.dilationWidth,p=i.effectiveFilterDepth,f=i.effectiveFilterHeight,m=i.effectiveFilterWidth,g=i.padInfo.front,b=i.padInfo.top,v=i.padInfo.left,w=o==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,k=le(i.outShape,e),C=k.values,I=i.outShape[1]*i.outShape[2]*i.outShape[3]*i.outShape[4],N=i.outShape[2]*i.outShape[3]*i.outShape[4],$=i.outShape[3]*i.outShape[4],A=i.outShape[4];for(let z=0;z<i.batchSize;++z){const F=z*I,E=z*s[0];for(let U=0;U<i.inChannels;++U)for(let L=0;L<i.outDepth;++L){const W=L*r-g;let _=W;for(;_<0;)_+=u;const V=Math.min(i.inDepth,p+W),X=F+L*N;for(let j=0;j<i.outHeight;++j){const K=j*a-b;let Z=K;for(;Z<0;)Z+=c;const Y=Math.min(i.inHeight,f+K),it=X+j*$;for(let nt=0;nt<i.outWidth;++nt){const lt=nt*l-v;let at=lt;for(;at<0;)at+=h;const pt=Math.min(i.inWidth,m+lt),gt=it+nt*A;let wt=w,xt=0,Dt=0;for(let Ut=_;Ut<V;Ut+=u){const $t=E+Ut*s[1];for(let Mt=Z;Mt<Y;Mt+=c){const jt=$t+Mt*s[2];for(let Ht=at;Ht<pt;Ht+=h){const Jt=jt+Ht*s[3],qt=n[Jt+U];if(o==="max"&&qt>wt?wt=qt:o==="avg"&&(xt+=qt,Dt++),isNaN(wt))break}if(isNaN(wt))break}if(isNaN(wt))break}const Nt=gt+U;C[Nt]=o==="avg"?xt/Math.max(Dt,1):wt}}}}return k}function vS(n,t){const e=le(t.outShape,"int32"),s=t.strideDepth,i=t.strideHeight,o=t.strideWidth,r=t.dilationDepth,a=t.dilationHeight,l=t.dilationWidth,u=t.effectiveFilterDepth,c=t.effectiveFilterHeight,h=t.effectiveFilterWidth,p=t.padInfo.front,f=t.padInfo.top,m=t.padInfo.left;for(let g=0;g<t.batchSize;++g)for(let b=0;b<t.inChannels;++b)for(let v=0;v<t.outDepth;++v){const w=v*s-p;let k=w;for(;k<0;)k+=r;const C=Math.min(t.inDepth,u+w);for(let I=0;I<t.outHeight;++I){const N=I*i-f;let $=N;for(;$<0;)$+=a;const A=Math.min(t.inHeight,c+N);for(let z=0;z<t.outWidth;++z){const F=z*o-m;let E=F;for(;E<0;)E+=l;const U=Math.min(t.inWidth,h+F);let L=Number.NEGATIVE_INFINITY,W=-1;for(let _=k;_<C;_+=r){const V=_-w;for(let X=$;X<A;X+=a){const j=X-N;for(let K=E;K<U;K+=l){const Z=K-F,Y=n.get(g,_,X,K,b);Y>=L&&(L=Y,W=V*c*h+j*c+Z)}}}e.set(W,g,v,I,z,b)}}}return e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CS(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t;yt(i,"avgPool");const{filterSize:o,strides:r,pad:a,dimRoundingMode:l}=s,u=1;tt(ki(r,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${r} and dilations '${u}'`);const c=Un(i.shape,o,r,u,a,l);let h;if(c.filterWidth===1&&c.filterHeight===1&&ke(c.inShape,c.outShape))h=Gs({inputs:{x:i},backend:e});else{const p=e.data.get(i.dataId).values,f=Tt(i.shape),m=rc(p,i.shape,i.dtype,f,c,"avg");h=e.makeTensorInfo(c.outShape,i.dtype,m.values)}return h}const kS={kernelName:Il,backendName:"cpu",kernelFunc:CS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SS(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{filterSize:o,strides:r,pad:a,dimRoundingMode:l,dataFormat:u}=s;yt(i,"avgPool3d");const c=xs(i.shape,o,r,1,a,l,u),h=e.data.get(i.dataId).values,p=Dy(h,i.shape,i.dtype,Tt(i.shape),c,"avg");return e.makeTensorInfo(p.shape,"float32",p.values)}const IS={kernelName:kl,backendName:"cpu",kernelFunc:SS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NS(n){const{inputs:t,backend:e,attrs:s}=n,{dy:i,input:o}=t,{filterSize:r,strides:a,pad:l,dimRoundingMode:u}=s;yt([i,o],"avgPool3DGrad");const c=xs(o.shape,r,a,1,l,u),h=c.strideDepth,p=c.strideHeight,f=c.strideWidth,m=c.filterDepth,g=c.filterHeight,b=c.filterWidth,v=c.dilationDepth,w=c.dilationHeight,k=c.dilationWidth,C=c.effectiveFilterDepth,I=c.effectiveFilterHeight,N=c.effectiveFilterWidth,$=C-1-c.padInfo.front,A=N-1-c.padInfo.left,z=I-1-c.padInfo.top,F=le(o.shape,"float32"),E=1/(m*g*b),U=e.bufferSync(i);for(let L=0;L<c.batchSize;++L)for(let W=0;W<c.inChannels;++W)for(let _=0;_<c.inDepth;++_)for(let V=0;V<c.inHeight;++V)for(let X=0;X<c.inWidth;++X){const j=_-$,K=V-z,Z=X-A;let Y=0;for(let it=0;it<C;it+=v){const nt=(j+it)/h;if(!(nt<0||nt>=c.outDepth||Math.floor(nt)!==nt))for(let lt=0;lt<I;lt+=w){const at=(K+lt)/p;if(!(at<0||at>=c.outHeight||Math.floor(at)!==at))for(let pt=0;pt<N;pt+=k){const gt=(Z+pt)/f;if(gt<0||gt>=c.outWidth||Math.floor(gt)!==gt)continue;const wt=U.get(L,nt,at,gt,W);Y+=wt}}}F.set(Y*E,L,_,V,X,W)}return e.makeTensorInfo(F.shape,F.dtype,F.values)}const $S={kernelName:Cl,backendName:"cpu",kernelFunc:NS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DS(n){const{inputs:t,backend:e,attrs:s}=n,{dy:i,input:o}=t,r=o;yt([i,o],"avgPoolGrad");const{filterSize:a,strides:l,pad:u}=s,c=Un(r.shape,a,l,1,u),h=c.strideHeight,p=c.strideWidth,f=c.filterHeight,m=c.filterWidth,g=c.dilationHeight,b=c.dilationWidth,v=c.effectiveFilterHeight,w=c.effectiveFilterWidth,k=w-1-c.padInfo.left,C=v-1-c.padInfo.top,I=le(r.shape,"float32"),N=1/(f*m),$=e.data.get(i.dataId).values,A=le(i.shape,"float32",$);for(let z=0;z<c.batchSize;++z)for(let F=0;F<c.inChannels;++F)for(let E=0;E<c.inHeight;++E)for(let U=0;U<c.inWidth;++U){const L=E-C,W=U-k;let _=0;for(let V=0;V<v;V+=g){const X=(L+V)/h;if(!(X<0||X>=c.outHeight||Math.floor(X)!==X))for(let j=0;j<w;j+=b){const K=(W+j)/p;if(K<0||K>=c.outWidth||Math.floor(K)!==K)continue;const Z=A.get(z,X,K,F);_+=Z}}I.set(_*N,z,E,U,F)}return e.makeTensorInfo(I.shape,I.dtype,I.values)}const RS={kernelName:Sl,backendName:"cpu",kernelFunc:DS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AS(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,scale:o,offset:r,mean:a,variance:l}=t;tt(a.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),tt(r==null||a.shape.length===r.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),tt(o==null||a.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),yt([i,a,l,o,r],"batchNorm");let{varianceEpsilon:u}=s;u==null&&(u=.001);const c=e.data.get(i.dataId).values,h=e.data.get(a.dataId).values,p=e.data.get(l.dataId).values,f=o?e.data.get(o.dataId).values:new Float32Array([1]),m=r?e.data.get(r.dataId).values:new Float32Array([0]),g=new Float32Array(c.length),b=m.length,v=f.length,w=p.length,k=h.length;let C=0,I=0,N=0,$=0;for(let A=0;A<c.length;++A)g[A]=m[C++]+(c[A]-h[I++])*f[N++]/Math.sqrt(p[$++]+u),C>=b&&(C=0),I>=k&&(I=0),N>=v&&(N=0),$>=w&&($=0);return e.makeTensorInfo(i.shape,i.dtype,g)}const TS={kernelName:Bl,backendName:"cpu",kernelFunc:AS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zS(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{blockShape:o,crops:r}=s;yt([i],"batchToSpaceND");const a=o.reduce((v,w)=>v*w),l=Yr(i.shape,o,a),u=Zr(l.length,o.length),c=Qr(i.shape,o,a),h=_p(r,o.length),p=Bp(c,r,o.length),f=te({inputs:{x:i},backend:e,attrs:{shape:l}}),m=Ze({inputs:{x:f},backend:e,attrs:{perm:u}}),g=te({inputs:{x:m},backend:e,attrs:{shape:c}}),b=pi({inputs:{x:g},backend:e,attrs:{begin:h,size:p}});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(g),b}const FS={kernelName:$l,backendName:"cpu",kernelFunc:zS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MS(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,weights:o}=t,{size:r}=s,a=e.data.get(i.dataId).values,l=e.data.get(o.dataId).values,u=Vp(a,l,o.dtype,o.shape,r);return e.makeTensorInfo([r],o.dtype,u)}const PS={kernelName:Wp,backendName:"cpu",kernelFunc:MS};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ES(n){const{inputs:t,backend:e}=n,{s0:s,s1:i}=t,o=e.data.get(s.dataId).values,r=e.data.get(i.dataId).values,a=Ne(Array.from(o),Array.from(r));return e.makeTensorInfo([a.length],"int32",Int32Array.from(a))}const LS={kernelName:Up,backendName:"cpu",kernelFunc:ES};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OS=Qt(wr,(n,t)=>{const e=t;return n>e.clipValueMax?e.clipValueMax:n<e.clipValueMin?e.clipValueMin:n}),_S={kernelName:wr,backendName:"cpu",kernelFunc:OS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BS=n=>{const{x:t}=n.inputs,e=n.backend,s=new Float32Array(et(t.shape)),i=e.data.get(t.dataId),o=i.complexTensorInfos.real,r=i.complexTensorInfos.imag,a=e.data.get(o.dataId).values,l=e.data.get(r.dataId).values;for(let u=0;u<a.length;u++){const c=a[u],h=l[u];s[u]=Math.hypot(c,h)}return e.makeOutput(s,t.shape,"float32")},WS={kernelName:Dl,backendName:"cpu",kernelFunc:BS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gi(n){const{inputs:t,backend:e}=n,{input:s}=t,i=e.data.get(s.dataId).complexTensorInfos.imag,o=e.data.get(i.dataId).values;return e.makeTensorInfo(i.shape,i.dtype,o)}const VS={kernelName:Gp,backendName:"cpu",kernelFunc:gi};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yi(n){const{inputs:t,backend:e,attrs:s}=n,{axis:i}=s,o=ee(i,t[0].shape)[0],r=t.map(g=>g.shape);Hp(r,o);let a=cs(t.map(g=>g.shape),o);if(et(a)===0)return e.makeTensorInfo(a,t[0].dtype,[]);const l=t.filter(g=>et(g.shape)>0);if(l.length===1)return Gs({inputs:{x:l[0]},backend:e});if(l[0].dtype==="complex64"){const g=l.map(C=>to({inputs:{input:C},backend:e})),b=l.map(C=>gi({inputs:{input:C},backend:e})),v=yi({inputs:g,backend:e,attrs:{axis:o}}),w=yi({inputs:b,backend:e,attrs:{axis:o}}),k=Fn({inputs:{real:v,imag:w},backend:e});return g.forEach(C=>e.disposeIntermediateTensorInfo(C)),b.forEach(C=>e.disposeIntermediateTensorInfo(C)),e.disposeIntermediateTensorInfo(v),e.disposeIntermediateTensorInfo(w),k}const u=l.map(g=>{const v=[-1,et(g.shape.slice(o))];return te({inputs:{x:g},backend:e,attrs:{shape:v}})}),c=u.map(g=>({vals:e.data.get(g.dataId).values,shape:g.shape}));a=cs(u.map(g=>g.shape),1);const h=u[0].shape[0]===1,p=Qw(c,a,t[0].dtype,h),f=cs(l.map(g=>g.shape),o),m=e.makeTensorInfo(f,t[0].dtype,p);return u.forEach(g=>e.disposeIntermediateTensorInfo(g)),m}const US={kernelName:Rl,backendName:"cpu",kernelFunc:yi};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ry(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,filter:o}=t,{strides:r,pad:a,dataFormat:l,dilations:u,dimRoundingMode:c}=s;yt([i,o],"conv2d");const h=ws(l),p=Xe(i.shape,o.shape,r,u,a,c,!1,h),f=p.filterHeight,m=p.filterWidth,g=p.dilationHeight,b=p.dilationWidth,v=p.padInfo.left,w=p.padInfo.top,k=p.dataFormat==="channelsLast",C=new Ve(p.outShape,i.dtype),I=Tt(i.shape),N=Tt(o.shape),$=I[0],A=k?I[1]:I[2],z=k?I[2]:1,F=k?1:I[1],E=C.strides[0],U=k?C.strides[1]:C.strides[2],L=k?C.strides[2]:1,W=k?1:C.strides[1],_=e.data.get(i.dataId).values,V=e.data.get(o.dataId).values,X=C.values;for(let j=0;j<p.batchSize;++j){const K=j*$,Z=j*E;for(let Y=0;Y<p.outHeight;++Y){const it=Z+Y*U,nt=Y*p.strideHeight-w;for(let lt=0;lt<f;++lt){const at=nt+lt*g;if(at<0||at>=p.inHeight)continue;const pt=lt*N[0],gt=K+at*A;for(let wt=0;wt<p.outWidth;++wt){const xt=it+wt*L,Dt=wt*p.strideWidth-v;for(let Nt=0;Nt<m;++Nt){const Ut=Dt+Nt*b;if(Ut<0||Ut>=p.inWidth)continue;const $t=pt+Nt*N[1],Mt=gt+Ut*z;let jt=$t;for(let Ht=0;Ht<p.inChannels;++Ht){const Jt=_[Mt+Ht*F];for(let qt=0;qt<p.outChannels;++qt)X[xt+qt*W]+=Jt*V[jt+qt];jt+=p.outChannels}}}}}}return e.makeTensorInfo(C.shape,C.dtype,X)}const GS={kernelName:Al,backendName:"cpu",kernelFunc:Ry};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HS(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,dy:o}=t,{strides:r,pad:a,dataFormat:l,dimRoundingMode:u,filterShape:c}=s;yt([i,o],"conv2dBackpropFilter");const h=ws(l),p=Xe(i.shape,c,r,1,a,u,!1,h),{strideHeight:f,strideWidth:m,filterHeight:g,filterWidth:b}=p,v=p.dataFormat==="channelsLast",w=new Ve(p.filterShape,"float32"),k=p.padInfo.left,C=p.padInfo.top,I=e.data.get(i.dataId).values,N=e.data.get(o.dataId).values,$=new Ve(i.shape,i.dtype,I),A=new Ve(o.shape,o.dtype,N);for(let z=0;z<g;++z){const F=Math.max(0,Math.ceil((C-z)/f)),E=Math.min(p.outHeight,(p.inHeight+C-z)/f);for(let U=0;U<b;++U){const L=Math.max(0,Math.ceil((k-U)/m)),W=Math.min(p.outWidth,(p.inWidth+k-U)/m);for(let _=0;_<p.inChannels;++_)for(let V=0;V<p.outChannels;++V){let X=0;for(let j=0;j<p.batchSize;++j)for(let K=F;K<E;++K){const Z=z+K*f-C;for(let Y=L;Y<W;++Y){const it=U+Y*m-k;v?X+=$.get(j,Z,it,_)*A.get(j,K,Y,V):X+=$.get(j,_,Z,it)*A.get(j,V,K,Y)}}w.set(X,z,U,_,V)}}}return e.makeTensorInfo(w.shape,w.dtype,w.values)}const jS={kernelName:jp,backendName:"cpu",kernelFunc:HS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KS(n){const{inputs:t,backend:e,attrs:s}=n,{dy:i,filter:o}=t,{inputShape:r,strides:a,pad:l,dataFormat:u,dimRoundingMode:c}=s;yt([i,o],"conv2dBackpropInput");const h=Tt(o.shape),p=Tt(i.shape);let f=ws(u);const m=Xe(r,o.shape,a,1,l,c,!1,f),g=new Ve(m.inShape,"float32"),b=g.values,v=e.data.get(i.dataId).values,w=e.data.get(o.dataId).values,[k,C,I]=h,{batchSize:N,filterHeight:$,filterWidth:A,inChannels:z,inHeight:F,inWidth:E,outChannels:U,outHeight:L,outWidth:W,strideHeight:_,strideWidth:V}=m;f=m.dataFormat;const X=$-1-m.padInfo.top,j=A-1-m.padInfo.left,K=f==="channelsLast",Z=g.strides[0],Y=K?g.strides[1]:g.strides[2],it=K?g.strides[2]:1,nt=K?1:g.strides[1],lt=p[0],at=K?p[1]:p[2],pt=K?p[2]:1,gt=K?1:p[1];for(let wt=0;wt<N;++wt)for(let xt=0;xt<z;++xt)for(let Dt=0;Dt<F;++Dt){const Nt=Dt-X,Ut=Math.max(0,Math.ceil(Nt/_)),$t=Math.min(L,($+Nt)/_);for(let Mt=0;Mt<E;++Mt){const jt=Mt-j,Ht=Math.max(0,Math.ceil(jt/V)),Jt=Math.min(W,(A+jt)/V);let qt=0;for(let fe=Ut;fe<$t;++fe){const hn=fe*_-Nt;for(let De=Ht;De<Jt;++De){const vn=De*V-jt,we=lt*wt+at*fe+pt*De,en=k*($-1-hn)+C*(A-1-vn)+I*xt;for(let qe=0;qe<U;++qe){const nn=v[we+gt*qe],Cn=w[en+qe];qt+=nn*Cn}}}const tn=Z*wt+Y*Dt+it*Mt+nt*xt;b[tn]=qt}}return e.makeTensorInfo(g.shape,g.dtype,g.values)}const XS={kernelName:zl,backendName:"cpu",kernelFunc:KS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qS(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,filter:o}=t,{strides:r,pad:a,dilations:l}=s;yt([i,o],"conv3d");const u=Ni(i.shape,o.shape,r,l,a),{filterDepth:c,filterHeight:h,filterWidth:p,dilationDepth:f,dilationHeight:m,dilationWidth:g,padInfo:b}=u,v=b.front,w=b.left,k=b.top,C=new Ve(u.outShape,i.dtype),I=e.data.get(i.dataId).values,N=e.data.get(o.dataId).values,$=C.values,A=Tt(i.shape),z=Tt(o.shape);for(let F=0;F<u.batchSize;++F){const E=F*A[0],U=F*C.strides[0];for(let L=0;L<u.outDepth;++L){const W=U+L*C.strides[1],_=L*u.strideDepth-v;for(let V=0;V<c;++V){const X=_+V*f;if(X<0||X>=u.inDepth)continue;const j=V*z[0],K=E+X*A[1];for(let Z=0;Z<u.outHeight;++Z){const Y=W+Z*C.strides[2],it=Z*u.strideHeight-k;for(let nt=0;nt<h;++nt){const lt=it+nt*m;if(lt<0||lt>=u.inHeight)continue;const at=j+nt*z[1],pt=K+lt*A[2];for(let gt=0;gt<u.outWidth;++gt){const wt=Y+gt*u.outChannels,xt=gt*u.strideWidth-w;for(let Dt=0;Dt<p;++Dt){const Nt=xt+Dt*g;if(Nt<0||Nt>=u.inWidth)continue;const Ut=at+Dt*z[2],$t=pt+Nt*u.inChannels;let Mt=Ut;for(let jt=0;jt<u.inChannels;++jt){const Ht=I[$t+jt];for(let Jt=0;Jt<u.outChannels;++Jt)$[wt+Jt]+=Ht*N[Mt+Jt];Mt+=u.outChannels}}}}}}}}return e.makeTensorInfo(C.shape,C.dtype,C.values)}const YS={kernelName:Ml,backendName:"cpu",kernelFunc:qS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZS(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,dy:o}=t,{strides:r,pad:a,filterShape:l}=s;yt([i,o],"conv3dBackpropFilterV2");const u=Tt(i.shape),c=Tt(o.shape),h=Ni(i.shape,l,r,1,a),p=h.strideDepth,f=h.strideHeight,m=h.strideWidth,g=h.filterDepth,b=h.filterHeight,v=h.filterWidth,w=new Ve(h.filterShape,"float32"),k=w.values,[C,I,N,$]=w.strides,A=e.data.get(o.dataId).values,[z,F,E,U]=c,L=e.data.get(i.dataId).values,[W,_,V,X]=u,j=h.padInfo.front,K=h.padInfo.left,Z=h.padInfo.top;for(let Y=0;Y<g;++Y){const it=Math.max(0,Math.ceil((j-Y)/p)),nt=Math.min(h.outDepth,(h.inDepth+j-Y)/p),lt=Y*C;for(let at=0;at<b;++at){const pt=Math.max(0,Math.ceil((Z-at)/f)),gt=Math.min(h.outHeight,(h.inHeight+Z-at)/f),wt=at*I+lt;for(let xt=0;xt<v;++xt){const Dt=Math.max(0,Math.ceil((K-xt)/m)),Nt=Math.min(h.outWidth,(h.inWidth+K-xt)/m),Ut=xt*N+wt;for(let $t=0;$t<h.inChannels;++$t){const Mt=$t*$+Ut;for(let jt=0;jt<h.outChannels;++jt){let Ht=0;for(let Jt=0;Jt<h.batchSize;++Jt){const qt=Jt*W,tn=Jt*z;for(let fe=it;fe<nt;++fe){const De=(Y+fe*p-j)*_+qt,vn=fe*F+tn;for(let we=pt;we<gt;++we){const qe=(at+we*f-Z)*V+De,nn=we*E+vn;for(let Cn=Dt;Cn<Nt;++Cn){const Fi=(xt+Cn*m-K)*X+qe,Ys=Cn*U+nn;Ht+=L[Fi+$t]*A[Ys+jt]}}}}k[Mt+jt]=Ht}}}}}return e.makeTensorInfo(w.shape,w.dtype,w.values)}const QS={kernelName:Fl,backendName:"cpu",kernelFunc:ZS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JS(n){const{inputs:t,backend:e,attrs:s}=n,{dy:i,filter:o}=t,{pad:r,strides:a,inputShape:l}=s;yt([i],"conv3dBackpropInputV2");const u=Tt(i.shape),c=Tt(o.shape),h=Ni(l,o.shape,a,1,r),p=new Ve(h.inShape,"float32"),f=p.values,[m,g,b,v]=p.strides,w=e.data.get(i.dataId).values,[k,C,I,N]=u,$=e.data.get(o.dataId).values,[A,z,F,E]=c,{batchSize:U,filterDepth:L,filterHeight:W,filterWidth:_,inChannels:V,inDepth:X,inHeight:j,inWidth:K,outChannels:Z,outDepth:Y,outHeight:it,outWidth:nt,strideDepth:lt,strideHeight:at,strideWidth:pt}=h,gt=L-1-h.padInfo.front,wt=W-1-h.padInfo.top,xt=_-1-h.padInfo.left;for(let Dt=0;Dt<U;++Dt)for(let Nt=0;Nt<V;++Nt)for(let Ut=0;Ut<X;++Ut){const $t=Ut-gt,Mt=Math.max(0,Math.ceil($t/lt)),jt=Math.min(Y,(L+$t)/lt);for(let Ht=0;Ht<j;++Ht){const Jt=Ht-wt,qt=Math.max(0,Math.ceil(Jt/at)),tn=Math.min(it,(W+Jt)/at);for(let fe=0;fe<K;++fe){const hn=fe-xt,De=Math.max(0,Math.ceil(hn/pt)),vn=Math.min(nt,(_+hn)/pt);let we=0;for(let en=Mt;en<jt;++en){const qe=en*lt-$t;for(let nn=qt;nn<tn;++nn){const Cn=nn*at-Jt;for(let os=De;os<vn;++os){const Fi=os*pt-hn,Ys=k*Dt+C*en+I*nn+N*os,ko=A*(L-1-qe)+z*(W-1-Cn)+F*(_-1-Fi)+E*Nt;for(let kn=0;kn<Z;++kn){const Mi=w[Ys+kn],So=$[ko+kn];we+=Mi*So}}}}f[m*Dt+g*Ut+b*Ht+v*fe+Nt]=we}}}return e.makeTensorInfo(p.shape,p.dtype,p.values)}const tI={kernelName:Kp,backendName:"cpu",kernelFunc:JS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eI=Qt(Cr,n=>Math.cos(n)),nI={kernelName:Cr,backendName:"cpu",kernelFunc:eI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sI=Qt(kr,n=>Math.cosh(n)),iI={kernelName:kr,backendName:"cpu",kernelFunc:sI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oI(n){const{inputs:t,backend:e,attrs:s}=n,{image:i,boxes:o,boxInd:r}=t,{cropSize:a,method:l,extrapolationValue:u}=s,[c,h,p,f]=i.shape,m=o.shape[0],[g,b]=a,v=le([m,g,b,f],"float32"),w=e.data.get(o.dataId).values,k=e.data.get(r.dataId).values,C=e.data.get(i.dataId).values,I=Tt(i.shape),N=Tt(v.shape);for(let $=0;$<m;$++){const A=$*4,z=w[A],F=w[A+1],E=w[A+2],U=w[A+3],L=k[$];if(L>=c)continue;const W=g>1?(E-z)*(h-1)/(g-1):0,_=b>1?(U-F)*(p-1)/(b-1):0;for(let V=0;V<g;V++){const X=g>1?z*(h-1)+V*W:.5*(z+E)*(h-1);if(X<0||X>h-1){for(let j=0;j<b;j++)for(let K=0;K<f;K++){const Z=K+j*N[2]+V*N[1]+$*N[0];v.values[Z]=u}continue}if(l==="bilinear"){const j=Math.floor(X),K=Math.ceil(X),Z=X-j;for(let Y=0;Y<b;Y++){const it=b>1?F*(p-1)+Y*_:.5*(F+U)*(p-1);if(it<0||it>p-1){for(let pt=0;pt<f;pt++){const gt=pt+Y*N[2]+V*N[1]+$*N[0];v.values[gt]=u}continue}const nt=Math.floor(it),lt=Math.ceil(it),at=it-nt;for(let pt=0;pt<f;pt++){let gt=pt+nt*I[2]+j*I[1]+L*I[0];const wt=C[gt];gt=pt+lt*I[2]+j*I[1]+L*I[0];const xt=C[gt];gt=pt+nt*I[2]+K*I[1]+L*I[0];const Dt=C[gt];gt=pt+lt*I[2]+K*I[1]+L*I[0];const Nt=C[gt],Ut=wt+(xt-wt)*at,$t=Dt+(Nt-Dt)*at;gt=pt+Y*N[2]+V*N[1]+$*N[0],v.values[gt]=Ut+($t-Ut)*Z}}}else for(let j=0;j<b;++j){const K=b>1?F*(p-1)+j*_:.5*(F+U)*(p-1);if(K<0||K>p-1){for(let it=0;it<f;it++){const nt=it+j*N[2]+V*N[1]+$*N[0];v.values[nt]=u}continue}const Z=Math.round(K),Y=Math.round(X);for(let it=0;it<f;it++){const nt=it+Z*I[2]+Y*I[1]+L*I[0],lt=it+j*N[2]+V*N[1]+$*N[0];v.values[lt]=C[nt]}}}}return e.makeTensorInfo(v.shape,v.dtype,v.values)}const rI={kernelName:Xp,backendName:"cpu",kernelFunc:oI};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aI(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:o,exclusive:r,reverse:a}=s;yt(i,"cumprod");const l=Pe([o],i.shape.length);let u=i;l!=null&&(u=Ze({inputs:{x:i},backend:e,attrs:{perm:l}}));const c=Ke(1,i.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const h=es(u.dtype,"int32"),p=Jw(et(u.shape),h),f=e.data.get(u.dataId).values,m=u.shape[u.shape.length-1],g=a?(v,w)=>v+m-w-1:(v,w)=>v+w;for(let v=0;v<f.length;v+=m)for(let w=0;w<m;w++){const k=g(v,w);if(w===0)p[k]=r?1:f[k];else{const C=g(v,w-1);p[k]=r?f[C]*p[C]:f[k]*p[C]}}const b=e.makeTensorInfo(u.shape,h,p);if(l!=null){const v=_s(l),w=Ze({inputs:{x:b},backend:e,attrs:{perm:v}});return e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(u),w}return b}const lI={kernelName:qp,backendName:"cpu",kernelFunc:aI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uI(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:o,exclusive:r,reverse:a}=s;yt(i,"cumsum");const l=Pe([o],i.shape.length);let u=i;l!=null&&(u=Ze({inputs:{x:i},backend:e,attrs:{perm:l}}));const c=Ke(1,i.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const h=es(u.dtype,"int32"),p=ss(et(u.shape),h),f=e.data.get(u.dataId).values,m=u.shape[u.shape.length-1],g=a?(v,w)=>v+m-w-1:(v,w)=>v+w;for(let v=0;v<f.length;v+=m)for(let w=0;w<m;w++){const k=g(v,w);if(w===0)p[k]=r?0:f[k];else{const C=g(v,w-1);p[k]=r?f[C]+p[C]:f[k]+p[C]}}const b=e.makeTensorInfo(u.shape,h,p);if(l!=null){const v=_s(l),w=Ze({inputs:{x:b},backend:e,attrs:{perm:v}});return e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(u),w}return b}const cI={kernelName:Pl,backendName:"cpu",kernelFunc:uI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hI(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,weights:o}=t,{size:r,binaryOutput:a}=s;if(i.shape.length===1){const l=e.data.get(i.dataId).values,u=e.data.get(o.dataId).values,c=Vp(l,u,o.dtype,o.shape,r);return e.makeTensorInfo([r],o.dtype,c)}else if(i.shape.length===2){const l=e.bufferSync(i),u=e.bufferSync(o),c=t0(l,u,r,a);return e.makeTensorInfo(c.shape,o.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${i.shape.length}.`)}const dI={kernelName:Yp,backendName:"cpu",kernelFunc:hI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pI(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{blockSize:o,dataFormat:r}=s;tt(r==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${r}`);const a=i.shape[0],l=i.shape[1],u=i.shape[2],c=i.shape[3],h=l*o,p=u*o,f=c/(o*o),m=e.data.get(i.dataId).values,g=new Float32Array(a*h*p*f);let b=0;for(let v=0;v<a;++v)for(let w=0;w<h;++w){const k=Math.floor(w/o),C=w%o;for(let I=0;I<p;++I){const N=Math.floor(I/o),$=I%o,A=(C*o+$)*f;for(let z=0;z<f;++z){const E=z+A+c*(N+u*(k+l*v));g[b++]=m[E]}}}return e.makeTensorInfo([a,h,p,f],i.dtype,g)}const fI={kernelName:Zp,backendName:"cpu",kernelFunc:pI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ay(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,filter:o}=t,{strides:r,pad:a,dilations:l,dimRoundingMode:u}=s;yt([i,o],"depthwiseConv2DNative");const c=Tt(i.shape),h=Tt(o.shape);let p=l;p==null&&(p=[1,1]),tt(ki(r,p),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${r} and dilations '${p}'`);const f=Xe(i.shape,o.shape,r,p,a,u,!0),{filterHeight:m,filterWidth:g,dilationHeight:b,dilationWidth:v,padInfo:w}=f,k=w.left,C=w.top,I=f.outChannels/f.inChannels,N=new Ve(f.outShape,i.dtype),$=e.data.get(i.dataId).values,A=e.data.get(o.dataId).values,z=N.values;for(let F=0;F<f.batchSize;++F){const E=F*c[0],U=F*N.strides[0];for(let L=0;L<f.outHeight;++L){const W=U+L*N.strides[1],_=L*f.strideHeight-C;for(let V=0;V<m;++V){const X=_+V*b;if(X<0||X>=f.inHeight)continue;const j=V*h[0],K=E+X*c[1];for(let Z=0;Z<f.outWidth;++Z){const Y=W+Z*N.strides[2],it=Z*f.strideWidth-k;for(let nt=0;nt<g;++nt){const lt=it+nt*v;if(lt<0||lt>=f.inWidth)continue;const at=j+nt*h[1],pt=K+lt*f.inChannels;let gt=Y,wt=at;for(let xt=0;xt<f.inChannels;++xt){const Dt=$[pt+xt];for(let Nt=0;Nt<I;++Nt)z[gt+Nt]+=Dt*A[wt+Nt];gt+=I,wt+=I}}}}}}return e.makeTensorInfo(N.shape,N.dtype,N.values)}const mI={kernelName:El,backendName:"cpu",kernelFunc:Ay};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gI(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,dy:o}=t,{strides:r,dilations:a,pad:l,dimRoundingMode:u,filterShape:c}=s;yt([i,o],"depthwiseConv2dNativeBackpropFilter");const h=Xe(i.shape,c,r,a,l,u,!0),{strideHeight:p,strideWidth:f,filterHeight:m,filterWidth:g}=h,b=new Ve(h.filterShape,"float32"),v=h.padInfo.left,w=h.padInfo.top,k=h.outChannels/h.inChannels,C=e.data.get(i.dataId).values,I=new Ve(i.shape,i.dtype,C),N=e.data.get(o.dataId).values,$=new Ve(o.shape,o.dtype,N);for(let A=0;A<m;++A){const z=Math.max(0,Math.ceil((w-A)/p)),F=Math.min(h.outHeight,(h.inHeight+w-A)/p);for(let E=0;E<g;++E){const U=Math.max(0,Math.ceil((v-E)/f)),L=Math.min(h.outWidth,(h.inWidth+v-E)/f);for(let W=0;W<h.outChannels;++W){const _=Math.trunc(W/k),V=W%k;let X=0;for(let j=0;j<h.batchSize;++j)for(let K=z;K<F;++K){const Z=A+K*p-w;for(let Y=U;Y<L;++Y){const it=E+Y*f-v;X+=I.get(j,Z,it,_)*$.get(j,K,Y,W)}}b.set(X,A,E,_,V)}}}return e.makeTensorInfo(b.shape,b.dtype,b.values)}const yI={kernelName:Qp,backendName:"cpu",kernelFunc:gI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bI(n){const{inputs:t,backend:e,attrs:s}=n,{dy:i,filter:o}=t,{strides:r,dilations:a,pad:l,dimRoundingMode:u,inputShape:c}=s;yt([i,o],"depthwiseConv2DNativeBackpropInput");const h=Tt(i.shape),p=Tt(o.shape),f=Xe(c,o.shape,r,a,l,u,!0),m=new Ve(f.inShape,"float32"),g=m.values,[b,v,w]=m.strides,k=e.data.get(i.dataId).values,[C,I,N]=h,$=e.data.get(o.dataId).values,[A,z,F]=p,{batchSize:E,filterHeight:U,filterWidth:L,inChannels:W,inHeight:_,inWidth:V,outChannels:X,outHeight:j,outWidth:K,strideHeight:Z,strideWidth:Y}=f,it=U-1-f.padInfo.top,nt=L-1-f.padInfo.left,lt=X/W;for(let at=0;at<E;++at)for(let pt=0;pt<W;++pt)for(let gt=0;gt<_;++gt){const wt=gt-it,xt=Math.max(0,Math.ceil(wt/Z)),Dt=Math.min(j,(U+wt)/Z);for(let Nt=0;Nt<V;++Nt){const Ut=Nt-nt,$t=Math.max(0,Math.ceil(Ut/Y)),Mt=Math.min(K,(L+Ut)/Y);let jt=0;for(let Ht=xt;Ht<Dt;++Ht){const Jt=Ht*Z-wt;for(let qt=$t;qt<Mt;++qt){const tn=qt*Y-Ut,fe=C*at+I*Ht+N*qt,hn=A*(U-1-Jt)+z*(L-1-tn)+F*pt;for(let De=0;De<lt;++De){const vn=pt*lt+De,we=k[fe+vn],en=$[hn+De];jt+=we*en}}}g[b*at+v*gt+w*Nt+pt]=jt}}return e.makeTensorInfo(m.shape,m.dtype,m.values)}const xI={kernelName:Jp,backendName:"cpu",kernelFunc:bI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wI(n){const{inputs:t,backend:e}=n,{x:s}=t,i=et(s.shape),o=e.data.get(s.dataId).values,r=le([i,i],s.dtype),a=r.values;for(let u=0;u<o.length;u++)a[u*i+u]=o[u];const l=[...s.shape,...s.shape];return e.makeTensorInfo(l,r.dtype,r.values)}const vI={kernelName:tf,backendName:"cpu",kernelFunc:wI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CI={kernelName:Ll,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:s,filter:i}=n,{strides:o,pad:r,dilations:a}=e,l=t,u=l.data.get(s.dataId).values,c=s.shape.length,h=l.data.get(i.dataId).values,p=i.shape.length,{batchSize:f,inHeight:m,inWidth:g,inChannels:b,outHeight:v,outWidth:w,padInfo:k,strideHeight:C,strideWidth:I,filterHeight:N,filterWidth:$,dilationHeight:A,dilationWidth:z,outShape:F}=$i(s.shape,i.shape,o,r,"NHWC",a),E=et(F),U=F.length,L=Jr(s.dtype,E);for(let _=0;_<f;++_)for(let V=0;V<v;++V){const X=V*C-k.top;for(let j=0;j<w;++j){const K=j*I-k.left;for(let Z=0;Z<b;++Z){let Y=Number.MIN_SAFE_INTEGER;for(let nt=0;nt<N;++nt){const lt=X+nt*A;if(lt>=0&&lt<m)for(let at=0;at<$;++at){const pt=K+at*z;if(pt>=0&&pt<g){const gt=Xi([_,lt,pt,Z],c,Tt(s.shape)),wt=Xi([nt,at,Z],p,Tt(i.shape)),xt=u[gt]+h[wt];xt>Y&&(Y=xt)}}}const it=Xi([_,V,j,Z],U,Tt(F));L[it]=Y}}}return{dataId:l.write(Au(L,s.dtype),F,s.dtype),shape:F,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kI={kernelName:Go,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:s,filter:i,dy:o}=n,{strides:r,pad:a,dilations:l}=e,u=t,c=oi(s.shape,u.data.get(s.dataId).values),h=oi(i.shape,u.data.get(i.dataId).values),{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:b,outWidth:v,padInfo:w,strideHeight:k,strideWidth:C,filterHeight:I,filterWidth:N,dilationHeight:$,dilationWidth:A,outShape:z}=$i(s.shape,i.shape,r,a,"NHWC",l);tt(o.rank===z.length,()=>`Error in ${Go}, dy must have the same rank as output ${z.length}, but got ${o.rank}`);const F=oi(z,u.data.get(o.dataId).values),E=ef(i.shape,i.dtype);for(let L=0;L<p;++L)for(let W=0;W<b;++W){const _=W*k-w.top;for(let V=0;V<v;++V){const X=V*C-w.left;for(let j=0;j<g;++j){let K=Number.MIN_SAFE_INTEGER,Z=0,Y=0;for(let it=0;it<I;++it){const nt=_+it*$;if(nt>=0&&nt<f)for(let lt=0;lt<N;++lt){const at=X+lt*A;if(at>=0&&at<m){const pt=c[L][nt][at][j]+h[it][lt][j];pt>K&&(K=pt,Z=it,Y=lt)}}}E[Z][Y][j]+=F[L][W][V][j]}}}return{dataId:u.write(Au(E,s.dtype),i.shape,i.dtype),shape:i.shape,dtype:i.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SI={kernelName:Uo,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:s,filter:i,dy:o}=n,{strides:r,pad:a,dilations:l}=e,u=t,c=oi(s.shape,u.data.get(s.dataId).values),h=oi(i.shape,u.data.get(i.dataId).values),{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:b,outWidth:v,padInfo:w,strideHeight:k,strideWidth:C,filterHeight:I,filterWidth:N,dilationHeight:$,dilationWidth:A,outShape:z}=$i(s.shape,i.shape,r,a,"NHWC",l);tt(o.rank===z.length,()=>`Error in ${Uo}, dy must have the same rank as output ${z.length}, but got ${o.rank}`);const F=oi(z,u.data.get(o.dataId).values),E=ef(s.shape,s.dtype);for(let L=0;L<p;++L)for(let W=0;W<b;++W){const _=W*k-w.top;for(let V=0;V<v;++V){const X=V*C-w.left;for(let j=0;j<g;++j){let K=Number.MIN_SAFE_INTEGER,Z=_<0?0:_,Y=X<0?0:X;for(let it=0;it<I;++it){const nt=_+it*$;if(nt>=0&&nt<f)for(let lt=0;lt<N;++lt){const at=X+lt*A;if(at>=0&&at<m){const pt=c[L][nt][at][j]+h[it][lt][j];pt>K&&(K=pt,Z=nt,Y=at)}}}E[L][Z][Y][j]+=F[L][W][V][j]}}}return{dataId:u.write(Au(E,s.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function II(n){const{inputs:t,backend:e,attrs:s}=n,{image:i}=t,{canvas:o,options:r}=s,{contextOptions:a,imageOptions:l}=r||{},u=(l==null?void 0:l.alpha)||1,c=(a==null?void 0:a.contextType)||"2d";if(c!=="2d")throw new Error(`Context type ${a.contextType} is not supported by the CPU backend.`);const h=o.getContext(c,(a==null?void 0:a.contextAttributes)||{});if(h==null)throw new Error(`Could not get the context with ${c} type.`);const[p,f]=i.shape.slice(0,2),m=i.shape.length===2?1:i.shape[2],g=e.data.get(i.dataId).values,b=i.dtype==="float32"?255:1,v=new Uint8ClampedArray(f*p*4);for(let k=0;k<p*f;++k){const C=[0,0,0,255*u];for(let N=0;N<m;N++){const $=g[k*m+N];if(i.dtype==="float32"){if($<0||$>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${$}.`)}else if(i.dtype==="int32"&&($<0||$>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${$}.`);m===1?(C[0]=$*b,C[1]=$*b,C[2]=$*b):C[N]=$*b}const I=k*4;v[I+0]=Math.round(C[0]),v[I+1]=Math.round(C[1]),v[I+2]=Math.round(C[2]),v[I+3]=Math.round(C[3])}o.width=f,o.height=p;const w=new ImageData(v,f,p);return h.putImageData(w,0,0),i}const NI={kernelName:nf,backendName:"cpu",kernelFunc:II};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vo(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:o,keepDims:r}=s;yt(i,"sum");let a;i.dtype==="bool"?a=Tu({inputs:{x:i},backend:e,attrs:{dtype:"int32"}}):a=Gs({inputs:{x:i},backend:e});const l=a.shape.length,u=ee(o,a.shape),c=Pe(u,l);let h=u,p=a;c!=null&&(p=Ze({inputs:{x:a},backend:e,attrs:{perm:c}}),h=Ke(h.length,l)),Vn("sum",h,p.shape.length);const[f,m]=un(p.shape,h),g=es(p.dtype,"int32");let b=e0(e,f,g);const v=et(m),w=e.data.get(b.dataId).values,k=e.data.get(p.dataId).values;for(let C=0;C<w.length;++C){const I=C*v;let N=0;for(let $=0;$<v;++$)N+=k[I+$];w[C]=N}if(r){const C=Jn(b.shape,u),I=b;b=te({inputs:{x:b},backend:e,attrs:{shape:C}}),e.disposeIntermediateTensorInfo(I)}return e.disposeIntermediateTensorInfo(a),c!=null&&e.disposeIntermediateTensorInfo(p),b}const $I={kernelName:xu,backendName:"cpu",kernelFunc:vo};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DI(n){const{inputs:t,backend:e,attrs:s}=n,{equation:i}=s,o=t,{allDims:r,summedDims:a,idDims:l}=of(i,o.length);rf(r.length,l,o);const{path:u,steps:c}=af(a,l),h=c.length;let p=null,f=r.length;const m=[];for(let g=0;g<h;++g){for(const b of c[g]){const{permutationIndices:v,expandDims:w}=lf(f,l[b]);let k;uf(v)?k=o[b]:(k=Ze({inputs:{x:o[b]},backend:e,attrs:{perm:v}}),m.push(k));const C=k.shape.slice();for(let I=0;I<w.length;++I)C.splice(w[I],0,1);ke(k.shape,C)||(k=te({inputs:{x:k},backend:e,attrs:{shape:C}}),m.push(k)),p===null?p=k:(p=zu({inputs:{a:k,b:p},backend:e}),m.push(p))}g<h-1&&(u[g]>=0&&(p=vo({inputs:{x:p},backend:e,attrs:{axis:u[g]-(r.length-f),keepDims:!1}}),m.push(p)),f--)}for(const g of m)g!==p&&e.disposeIntermediateTensorInfo(g);return p}const RI={kernelName:sf,backendName:"cpu",kernelFunc:DI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AI(n){const{inputs:t,backend:e}=n,{dy:s,y:i}=t;yt([s,i],"eluGrad");const o=new Float32Array(et(i.shape)),r=e.data.get(i.dataId).values,a=e.data.get(s.dataId).values;for(let l=0;l<r.length;++l){const u=r[l];u>=0?o[l]=a[l]:o[l]=a[l]*(u+1)}return e.makeTensorInfo(i.shape,"float32",o)}const TI={kernelName:Ol,backendName:"cpu",kernelFunc:AI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zI=mf,FI=cf,MI=hf,PI=df,EI=pf,LI=ff,OI=Qt(Ir,n=>{const t=Math.sign(n),e=Math.abs(n),s=1/(1+zI*e);return t*(1-((((LI*s+EI)*s+PI)*s+MI)*s+FI)*s*Math.exp(-e*e))}),_I={kernelName:Ir,backendName:"cpu",kernelFunc:OI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function or(n){const{inputs:t,backend:e,attrs:s}=n,{input:i}=t,{dim:o}=s,r=i.shape.length,a=i.shape.slice();let l=o;return o<0&&(tt(-(r+1)<=o,()=>`Axis must be in the interval [${-(r+1)}, ${r}]`),l=r+o+1),a.splice(l,0,1),te({inputs:{x:i},backend:e,attrs:{shape:a}})}const BI={kernelName:_l,backendName:"cpu",kernelFunc:or};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WI=Us((n,t)=>n/t),ac=Ii(Fr,WI),cl={kernelName:Fr,backendName:"cpu",kernelFunc:ac};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ty(n,t,e){const s=n.shape,i=s[0],o=s[1],r=e.data.get(n.dataId),a=r.complexTensorInfos.real,l=r.complexTensorInfos.imag,u=[i,o],c=et(u),h=Ln("float32",c),p=Ln("float32",c);for(let b=0;b<i;b++){const v=pi({inputs:{x:a},backend:e,attrs:{begin:[b,0],size:[1,o]}}),w=pi({inputs:{x:l},backend:e,attrs:{begin:[b,0],size:[1,o]}}),k=Fn({inputs:{real:v,imag:w},backend:e}),{real:C,imag:I}=VI(k,t,e),N=di(C,I);for(let $=0;$<o;$++){const A=gf(N,$);h[b*o+$]=A.real,p[b*o+$]=A.imag}e.disposeIntermediateTensorInfo(v),e.disposeIntermediateTensorInfo(w),e.disposeIntermediateTensorInfo(k)}const f=e.makeTensorInfo(u,"float32",h),m=e.makeTensorInfo(u,"float32",p),g=Fn({inputs:{real:f,imag:m},backend:e});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(m),g}function VI(n,t,e){const s=et(n.shape),i=e.data.get(n.dataId),o=e.data.get(i.complexTensorInfos.real.dataId).values,r=e.data.get(i.complexTensorInfos.imag.dataId).values;if(UI(s)){const a=hl(o,r,s,t,e),l=[n.shape[0],n.shape[1]];if(t){const u=e.makeTensorInfo(l,"float32",a.real),c=e.makeTensorInfo(l,"float32",a.imag),h=e.makeTensorInfo([],"float32",yf(s,"float32")),p=Gs({inputs:{x:h},backend:e}),f=cl.kernelFunc({inputs:{a:u,b:h},backend:e}),m=cl.kernelFunc({inputs:{a:c,b:p},backend:e}),g=e.data.get(f.dataId).values,b=e.data.get(m.dataId).values;return e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(m),{real:g,imag:b}}return a}else{const a=di(o,r),l=GI(a,s,t);return n0(l)}}function UI(n){return(n&n-1)===0}function hl(n,t,e,s,i){if(e===1)return{real:n,imag:t};const o=di(n,t),r=e/2,a=s0(o),l=a.real,u=a.imag,c=[l.length],h=i.makeTensorInfo(c,"float32",l),p=i.makeTensorInfo(c,"float32",u),f=Fn({inputs:{real:h,imag:p},backend:i}),m=i0(o),g=m.real,b=m.imag,v=[g.length],w=i.makeTensorInfo(v,"float32",g),k=i.makeTensorInfo(v,"float32",b),C=Fn({inputs:{real:w,imag:k},backend:i}),I=hl(l,u,r,s,i),N=I.real,$=I.imag,A=[N.length],z=i.makeTensorInfo(A,"float32",N),F=i.makeTensorInfo(A,"float32",$),E=Fn({inputs:{real:z,imag:F},backend:i}),U=hl(g,b,r,s,i),L=U.real,W=U.imag,_=[L.length],V=i.makeTensorInfo(_,"float32",L),X=i.makeTensorInfo(_,"float32",W),j=Fn({inputs:{real:V,imag:X},backend:i}),K=o0(e,s),Z=[K.real.length],Y=i.makeTensorInfo(Z,"float32",K.real),it=i.makeTensorInfo(Z,"float32",K.imag),nt=Fn({inputs:{real:Y,imag:it},backend:i}),lt=zu({inputs:{a:nt,b:j},backend:i}),at=Ji({inputs:{a:E,b:lt},backend:i}),pt=bf({inputs:{a:E,b:lt},backend:i}),gt=to({inputs:{input:at},backend:i}),wt=to({inputs:{input:pt},backend:i}),xt=gi({inputs:{input:at},backend:i}),Dt=gi({inputs:{input:pt},backend:i}),Nt=yi({inputs:[gt,wt],backend:i,attrs:{axis:0}}),Ut=yi({inputs:[xt,Dt],backend:i,attrs:{axis:0}}),$t=i.data.get(Nt.dataId).values,Mt=i.data.get(Ut.dataId).values;return i.disposeIntermediateTensorInfo(h),i.disposeIntermediateTensorInfo(p),i.disposeIntermediateTensorInfo(f),i.disposeIntermediateTensorInfo(w),i.disposeIntermediateTensorInfo(k),i.disposeIntermediateTensorInfo(C),i.disposeIntermediateTensorInfo(z),i.disposeIntermediateTensorInfo(F),i.disposeIntermediateTensorInfo(E),i.disposeIntermediateTensorInfo(V),i.disposeIntermediateTensorInfo(X),i.disposeIntermediateTensorInfo(j),i.disposeIntermediateTensorInfo(Y),i.disposeIntermediateTensorInfo(it),i.disposeIntermediateTensorInfo(nt),i.disposeIntermediateTensorInfo(lt),i.disposeIntermediateTensorInfo(at),i.disposeIntermediateTensorInfo(pt),i.disposeIntermediateTensorInfo(gt),i.disposeIntermediateTensorInfo(xt),i.disposeIntermediateTensorInfo(wt),i.disposeIntermediateTensorInfo(Dt),i.disposeIntermediateTensorInfo(Nt),i.disposeIntermediateTensorInfo(Ut),{real:$t,imag:Mt}}function GI(n,t,e){const s=new Float32Array(t*2);for(let i=0;i<t;i++){let o=0,r=0;for(let a=0;a<t;a++){const l=a0(i*a,t,e),u=gf(n,a);o+=u.real*l.real-u.imag*l.imag,r+=u.real*l.imag+u.imag*l.real}e&&(o/=t,r/=t),r0(s,o,r,i)}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HI(n){const{inputs:t,backend:e}=n,{input:s}=t,i=et(s.shape),o=s.shape[s.shape.length-1],r=i/o,a=te({inputs:{x:s},backend:e,attrs:{shape:[r,o]}}),l=Ty(a,!1,e),u=te({inputs:{x:l},backend:e,attrs:{shape:s.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(l),u}const jI={kernelName:xf,backendName:"cpu",kernelFunc:HI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lc(n){const{backend:t,attrs:e}=n,{shape:s,value:i,dtype:o}=e,r=o||vf(i),a=Jr(r,et(s));return XI(a,i,r),t.makeTensorInfo(s,r,a)}const KI={kernelName:wf,backendName:"cpu",kernelFunc:lc};function XI(n,t,e){n.fill(t)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qI={kernelName:Cf,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:s}=n,i=e,o=Ln(s.dtype,et(s.shape)),[r,a,l,u]=s.shape,c=i.data.get(s.dataId).values;for(let p=0;p<r;p++){const f=p*l*a*u;for(let m=0;m<a;m++){const g=m*(l*u);for(let b=0;b<l;b++){const v=b*u;for(let w=0;w<u;w++){const k=Math.round(l-b-1),C=f+g+v+w;let I=c[C];if(k>=0&&k<l){const N=k*u,$=f+g+N+w;I=c[$]}o[C]=I}}}}return{dataId:i.write(o,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YI(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,filter:o,bias:r,preluActivationWeights:a}=t,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:p,activation:f,leakyreluAlpha:m}=s;let g=Ry({inputs:{x:i,filter:o},backend:e,attrs:{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:p}});if(r){const b=g;if(c==="NCHW"&&r.shape.length===1&&r.shape[0]!==1){const v=te({inputs:{x:r},backend:e,attrs:{shape:[r.shape[0],1,1]}});g=Ji({inputs:{a:g,b:v},backend:e}),e.disposeIntermediateTensorInfo(v)}else g=Ji({inputs:{a:g,b:r},backend:e});e.disposeIntermediateTensorInfo(b)}if(f){const b=g;if(c==="NCHW"&&f==="prelu"&&a.shape.length===1&&a.shape[0]!==1){const v=te({inputs:{x:a},backend:e,attrs:{shape:[a.shape[0],1,1]}});g=ir(e,g,f,v,m),e.disposeIntermediateTensorInfo(v)}else g=ir(e,g,f,a,m);e.disposeIntermediateTensorInfo(b)}return g}const ZI={kernelName:kf,backendName:"cpu",kernelFunc:YI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QI(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,filter:o,bias:r,preluActivationWeights:a}=t,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:p,activation:f,leakyreluAlpha:m}=s;let g=Ay({inputs:{x:i,filter:o},backend:e,attrs:{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:p}});if(r){const b=g;g=Ji({inputs:{a:g,b:r},backend:e}),e.disposeIntermediateTensorInfo(b)}if(f){const b=g;g=ir(e,g,f,a,m),e.disposeIntermediateTensorInfo(b)}return g}const JI={kernelName:Sf,backendName:"cpu",kernelFunc:QI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t3(n){const{inputs:t,backend:e}=n,{params:s,indices:i}=t,o=et(s.shape),r=i.shape,a=r[r.length-1],[l,u,c,h]=Nf(s,i);if(u===0)return e.makeTensorInfo(l,s.dtype,[]);const p=e.data.get(i.dataId).values,f=e.bufferSync(s),m=l0(p,f,s.dtype,u,a,c,h,s.shape,o);return e.makeTensorInfo(l,s.dtype,m.values)}const e3={kernelName:If,backendName:"cpu",kernelFunc:t3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n3(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,indices:o}=t,{axis:r,batchDims:a}=s;yt([i,o],"gatherV2");const l=ee(r,i.shape)[0],u=e.data.get(o.dataId).values,c=i.shape[l];for(let C=0;C<u.length;++C){const I=u[C];tt(I<=c-1&&I>=0,()=>`GatherV2: the index value ${I} is not in [0, ${c-1}]`)}let h=a;a==null&&(h=0);const p=et(o.shape),f=$f(i,o,l,h),m=te({inputs:{x:i},backend:e,attrs:{shape:[f.batchSize,f.outerSize,f.dimSize,f.sliceSize]}}),g=te({inputs:{x:o},backend:e,attrs:{shape:[f.batchSize,p/f.batchSize]}}),b=[f.batchSize,f.outerSize,p/f.batchSize,f.sliceSize],v=e.bufferSync(g),w=e.bufferSync(m),k=u0(w,v,b);return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(g),e.makeTensorInfo(f.outputShape,k.dtype,k.values)}const s3={kernelName:Wl,backendName:"cpu",kernelFunc:n3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i3(n){const{inputs:t,backend:e}=n,{input:s}=t,i=et(s.shape),o=s.shape[s.shape.length-1],r=i/o,a=te({inputs:{x:s},backend:e,attrs:{shape:[r,o]}}),l=Ty(a,!0,e),u=te({inputs:{x:l},backend:e,attrs:{shape:s.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(l),u}const o3={kernelName:Df,backendName:"cpu",kernelFunc:i3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r3=Qt(Nr,n=>Number.isFinite(n)?1:0,"bool"),a3={kernelName:Nr,backendName:"cpu",kernelFunc:r3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const l3=Qt($r,n=>Math.abs(n)===1/0?1:0,"bool"),u3={kernelName:$r,backendName:"cpu",kernelFunc:l3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c3=Qt(Dr,n=>Number.isNaN(n)?1:0,"bool"),h3={kernelName:Dr,backendName:"cpu",kernelFunc:c3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d3(n){const{backend:t,attrs:e}=n,{start:s,stop:i,num:o}=e,r=c0(s,i,o);return t.makeTensorInfo([r.length],"float32",r)}const p3={kernelName:Rf,backendName:"cpu",kernelFunc:d3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const f3=Qt(Rr,n=>Math.log1p(n)),m3={kernelName:Rr,backendName:"cpu",kernelFunc:f3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const g3=Us((n,t)=>n&&t),y3=Ii(Fu,g3,null,"bool"),b3={kernelName:Fu,backendName:"cpu",kernelFunc:y3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const x3=Qt(Mu,n=>n?0:1,"bool"),w3={kernelName:Mu,backendName:"cpu",kernelFunc:x3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v3=Us((n,t)=>n||t),C3=Ii(Pu,v3,null,"bool"),k3={kernelName:Pu,backendName:"cpu",kernelFunc:C3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S3(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{depthRadius:o,bias:r,alpha:a,beta:l}=s;yt(i,"LRN");const u=i.shape[3],c=u-1,h=e.data.get(i.dataId).values,p=et(i.shape),f=new Float32Array(p);function m(g){const b=g%u;let v=g-b+Math.max(0,b-o);const w=g-b+Math.min(b+o,c);let k=0;for(;v<=w;v++){const C=h[v];k+=C*C}return k}for(let g=0;g<p;g++){const b=m(g),v=h[g]*Math.pow(r+a*b,-l);f[g]=v}return e.makeTensorInfo(i.shape,i.dtype,f)}const I3={kernelName:Gl,backendName:"cpu",kernelFunc:S3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N3(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,y:o,dy:r}=t,{depthRadius:a,bias:l,alpha:u,beta:c}=s;yt(r,"LRNGrad");const h=et(r.shape),p=r.shape[3],f=e.data.get(r.dataId).values,m=e.data.get(i.dataId).values,g=e.data.get(o.dataId).values,b=new Float32Array(h),v=h;for(let w=0;w<v;w++){const k=w%p,C=w-k+Math.max(0,k-a),I=w-k+Math.min(p,k+a+1);let N=0;for(let $=C;$<I;$++)N+=Math.pow(m[$],2);N=u*N+l;for(let $=C;$<I;$++){let A=-2*u*c*m[$]*g[w]/N;w===$&&(A+=Math.pow(N,-c)),A*=f[w],b[$]+=A}}return e.makeTensorInfo(r.shape,i.dtype,b)}const $3={kernelName:Ul,backendName:"cpu",kernelFunc:N3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zy(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{reductionIndices:o,keepDims:r}=s,a=e;let l=i.shape;const u=l.length,c=ee(o,l);let h=c;const p=Pe(h,u);let f=a.data.get(i.dataId).values;if(p!=null){const C=new Array(u);for(let I=0;I<C.length;I++)C[I]=l[p[I]];f=h0(f,l,i.dtype,p,C),h=Ke(h.length,u),l=C}yt(i,"max"),Vn("max",h,u);const[m,g]=un(l,h),b=et(g),v=d0(f,b,m,i.dtype),w=a.write(v,m,i.dtype);let k=m;return r&&(k=Jn(m,c)),{dataId:w,shape:k,dtype:i.dtype}}const D3={kernelName:Hl,backendName:"cpu",kernelFunc:zy};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R3(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t;yt(i,"maxPool");const{filterSize:o,strides:r,pad:a,dimRoundingMode:l}=s,u=1;tt(ki(r,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${r} and dilations '${u}'`);const c=Un(i.shape,o,r,u,a,l);let h;if(c.filterWidth===1&&c.filterHeight===1&&ke(c.inShape,c.outShape))h=Gs({inputs:{x:i},backend:e});else{const p=e.data.get(i.dataId).values,f=Tt(i.shape),m=rc(p,i.shape,i.dtype,f,c,"max");h=e.makeTensorInfo(c.outShape,i.dtype,m.values)}return h}const A3={kernelName:ql,backendName:"cpu",kernelFunc:R3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T3(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{filterSize:o,strides:r,pad:a,dimRoundingMode:l,dataFormat:u}=s;yt(i,"maxPool3d");const c=xs(i.shape,o,r,1,a,l,u),h=e.data.get(i.dataId).values,p=Dy(h,i.shape,i.dtype,Tt(i.shape),c,"max");return e.makeTensorInfo(p.shape,"float32",p.values)}const z3={kernelName:Kl,backendName:"cpu",kernelFunc:T3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F3(n){const{inputs:t,backend:e,attrs:s}=n,{dy:i,input:o}=t,{filterSize:r,strides:a,pad:l,dimRoundingMode:u}=s;yt([i,o],"maxPool3DGrad");const c=xs(o.shape,r,a,1,l,u),h=e.bufferSync(o),p=vS(h,c),f=c.strideDepth,m=c.strideHeight,g=c.strideWidth,b=c.dilationDepth,v=c.dilationHeight,w=c.dilationWidth,k=c.effectiveFilterDepth,C=c.effectiveFilterHeight,I=c.effectiveFilterWidth,N=k-1-c.padInfo.front,$=I-1-c.padInfo.left,A=C-1-c.padInfo.top,z=le(o.shape,"float32"),F=e.bufferSync(i);for(let E=0;E<c.batchSize;++E)for(let U=0;U<c.inChannels;++U)for(let L=0;L<c.inDepth;++L)for(let W=0;W<c.inHeight;++W)for(let _=0;_<c.inWidth;++_){const V=L-N,X=W-A,j=_-$;let K=0;for(let Z=0;Z<k;Z+=b){const Y=(V+Z)/f;if(!(Y<0||Y>=c.outDepth||Math.floor(Y)!==Y))for(let it=0;it<C;it+=v){const nt=(X+it)/m;if(!(nt<0||nt>=c.outHeight||Math.floor(nt)!==nt))for(let lt=0;lt<I;lt+=w){const at=(j+lt)/g;if(at<0||at>=c.outWidth||Math.floor(at)!==at)continue;const pt=k*C*I-1-p.get(E,Y,nt,at,U),gt=Z*C*I+it*I+lt,wt=pt===gt?1:0;if(wt===0)continue;const xt=F.get(E,Y,nt,at,U);K+=xt*wt}}}z.set(K,E,L,W,_,U)}return e.makeTensorInfo(z.shape,z.dtype,z.values)}const M3={kernelName:jl,backendName:"cpu",kernelFunc:F3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P3(n){const{inputs:t,backend:e,attrs:s}=n,{dy:i,input:o,output:r}=t,a=o;yt([o,r],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:h}=s,p=Un(a.shape,l,u,1,c,h),f=e.data.get(a.dataId).values,m=le(p.outShape,a.dtype,$y(f,a.shape,a.dtype,p).values),g=p.strideHeight,b=p.strideWidth,v=p.dilationHeight,w=p.dilationWidth,k=p.effectiveFilterHeight,C=p.effectiveFilterWidth,I=C-1-p.padInfo.left,N=k-1-p.padInfo.top,$=le(a.shape,"float32"),A=e.data.get(i.dataId).values,z=le(i.shape,"float32",A);for(let F=0;F<p.batchSize;++F)for(let E=0;E<p.inChannels;++E)for(let U=0;U<p.inHeight;++U)for(let L=0;L<p.inWidth;++L){const W=U-N,_=L-I;let V=0;for(let X=0;X<k;X+=v){const j=(W+X)/g;if(!(j<0||j>=p.outHeight||Math.floor(j)!==j))for(let K=0;K<C;K+=w){const Z=(_+K)/b;if(Z<0||Z>=p.outWidth||Math.floor(Z)!==Z)continue;const Y=k*C-1-m.get(F,j,Z,E),it=X*C+K,nt=Y===it?1:0;if(nt===0)continue;const lt=z.get(F,j,Z,E);V+=lt*nt}}$.set(V,F,U,L,E)}return e.makeTensorInfo($.shape,$.dtype,$.values)}const E3={kernelName:Xl,backendName:"cpu",kernelFunc:P3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L3(n,t,e,s,i){const o=Tt(t),r=rc(n,t,e,o,i,"max"),a=$y(n,t,e,i,!0,s);return[r.values,a.values]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const O3={kernelName:Af,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:s}=n,{filterSize:i,strides:o,pad:r,includeBatchInIndex:a}=t,l=e;yt(s,"MaxPoolWithArgmax");const u=l.data.get(s.dataId).values,c=Un(s.shape,i,o,[1,1],r),[h,p]=L3(u,s.shape,s.dtype,a,c),f=l.write(h,c.outShape,s.dtype),m=l.write(p,c.outShape,s.dtype);return[{dataId:f,shape:c.outShape,dtype:s.dtype},{dataId:m,shape:c.outShape,dtype:"int32"}]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _3(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:o,keepDims:r}=s,a=ee(o,i.shape),u=un(i.shape,a)[1],c=et(u),h=[],p=e.makeTensorInfo([],"float32",new Float32Array([c]));h.push(p);const f=Tu({inputs:{x:i},backend:e,attrs:{dtype:"float32"}});h.push(f);const m=ac({inputs:{a:f,b:p},backend:e});h.push(m);const g=vo({inputs:{x:m},backend:e,attrs:{axis:o,keepDims:r}});return h.forEach(b=>e.disposeIntermediateTensorInfo(b)),g}const B3={kernelName:Yl,backendName:"cpu",kernelFunc:_3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W3(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:o,keepDims:r}=s;yt(i,"min");const a=ee(o,i.shape);let l=a;const u=Pe(l,i.shape.length);let c=i;u!=null&&(c=Ze({inputs:{x:i},backend:e,attrs:{perm:u}}),l=Ke(l.length,i.shape.length)),Vn("min",l,c.shape.length);const[h,p]=un(c.shape,l),f=et(p),m=ss(et(h),c.dtype),g=e.data.get(c.dataId).values;for(let v=0;v<m.length;++v){const w=v*f;let k=g[w];for(let C=0;C<f;++C){const I=g[w+C];(Number.isNaN(I)||I<k)&&(k=I)}m[v]=k}u!=null&&e.disposeIntermediateTensorInfo(c);const b=e.makeTensorInfo(h,c.dtype,m);if(r){const v=Jn(h,a),w=te({inputs:{x:b},backend:e,attrs:{shape:v}});return e.disposeIntermediateTensorInfo(b),w}return b}const V3={kernelName:Zl,backendName:"cpu",kernelFunc:W3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U3(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{paddings:o,mode:r}=s;yt(i,"mirrorPad");const a=o.map((k,C)=>k[0]+i.shape[C]+k[1]),l=o.map(k=>k[0]),u=o.map((k,C)=>k[0]+i.shape[C]),c=r==="reflect"?0:1,h=e.data.get(i.dataId).values,p=i.shape.length,f=Tt(i.shape),m=et(a),g=a.length,b=Tt(a),v=Ln(i.dtype,m);for(let k=0;k<m;k++){let C=Tf(k,g,b);for(let N=0;N<g;N++)C[N]<l[N]?C[N]=l[N]*2-C[N]-c:C[N]>=u[N]&&(C[N]=(u[N]-1)*2-C[N]+c);C=C.map((N,$)=>N-l[$]);const I=Xi(C,p,f);v[k]=h[I]}return{dataId:e.write(v,a,i.dtype),shape:a,dtype:i.dtype}}const G3={kernelName:Ql,backendName:"cpu",kernelFunc:U3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H3=Us((n,t)=>{const e=n%t;return n<0&&t<0||n>=0&&t>=0?e:(e+t)%t}),j3=Ii(Ar,H3),K3={kernelName:Ar,backendName:"cpu",kernelFunc:j3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fy(n){const{inputs:t,backend:e,attrs:s}=n,{logits:i}=t,{dim:o}=s,r=i.shape.length;let a=o;if(a===-1&&(a=r-1),a!==r-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${r} and dim was ${a}`);const l=ee([a],i.shape),u=zy({inputs:{x:i},backend:e,attrs:{reductionIndices:l,keepDims:!1}}),c=Jn(u.shape,l),h=te({inputs:{x:u},backend:e,attrs:{shape:c}}),p=bf({inputs:{a:i,b:h},backend:e}),f=p0({inputs:{x:p},backend:e}),m=vo({inputs:{x:f},backend:e,attrs:{axis:l,keepDims:!1}}),g=te({inputs:{x:m},backend:e,attrs:{shape:c}}),b=ac({inputs:{a:f,b:g},backend:e});return e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(g),b}const X3={kernelName:mu,backendName:"cpu",kernelFunc:Fy};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q3(n){const{inputs:t,backend:e,attrs:s}=n,{logits:i}=t,{numSamples:o,seed:r,normalized:a}=s;yt(i,"multinomial");const l=a?i:Fy({inputs:{logits:i},backend:e,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],h=e.data.get(l.dataId).values,p=[u,o],f=ss(et(p),"int32");for(let m=0;m<u;++m){const g=m*c,b=new Float32Array(c-1);b[0]=h[g];for(let k=1;k<b.length;++k)b[k]=b[k-1]+h[g+k];const v=f0.alea(r.toString()),w=m*o;for(let k=0;k<o;++k){const C=v();f[w+k]=b.length;for(let I=0;I<b.length;I++)if(C<b[I]){f[w+k]=I;break}}}return a||e.disposeIntermediateTensorInfo(l),e.makeTensorInfo(p,"int32",f)}const Y3={kernelName:zf,backendName:"cpu",kernelFunc:q3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Z3=Mf;function Q3(n){const{inputs:t,backend:e,attrs:s}=n,{boxes:i,scores:o}=t,{maxOutputSize:r,iouThreshold:a,scoreThreshold:l}=s;yt(i,"NonMaxSuppression");const u=e.data.get(i.dataId).values,c=e.data.get(o.dataId).values,{selectedIndices:h}=Z3(u,c,r,a,l);return e.makeTensorInfo([h.length],"int32",new Int32Array(h))}const J3={kernelName:Ff,backendName:"cpu",kernelFunc:Q3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tN=g0;function eN(n){const{inputs:t,backend:e,attrs:s}=n,{boxes:i,scores:o}=t,{maxOutputSize:r,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:u}=s;yt(i,"NonMaxSuppressionPadded");const c=e.data.get(i.dataId).values,h=e.data.get(o.dataId).values,{selectedIndices:p,validOutputs:f}=tN(c,h,r,a,l,u);return[e.makeTensorInfo([p.length],"int32",new Int32Array(p)),e.makeTensorInfo([],"int32",new Int32Array([f]))]}const nN={kernelName:m0,backendName:"cpu",kernelFunc:eN};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sN=Ef;function iN(n){const{inputs:t,backend:e,attrs:s}=n,{boxes:i,scores:o}=t,{maxOutputSize:r,iouThreshold:a,scoreThreshold:l,softNmsSigma:u}=s;yt(i,"NonMaxSuppressionWithScore");const c=e.data.get(i.dataId).values,h=e.data.get(o.dataId).values,p=r,f=a,m=l,g=u,{selectedIndices:b,selectedScores:v}=sN(c,h,p,f,m,g);return[e.makeTensorInfo([b.length],"int32",new Int32Array(b)),e.makeTensorInfo([v.length],"float32",new Float32Array(v))]}const oN={kernelName:Pf,backendName:"cpu",kernelFunc:iN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rN(n){const{inputs:t,backend:e,attrs:s}=n,{indices:i}=t,{dtype:o,depth:r,onValue:a,offValue:l}=s;yt(i,"oneHot");const u=et(i.shape),c=new Float32Array(u*r);c.fill(l);const h=e.data.get(i.dataId).values;for(let p=0;p<u;++p)h[p]>=0&&h[p]<r&&(c[p*r+h[p]]=a);return e.makeTensorInfo([...i.shape,r],o,c)}const aN={kernelName:tu,backendName:"cpu",kernelFunc:rN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rr(n){const{inputs:t,backend:e}=n,{x:s}=t;if(s.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(s.dtype==="complex64"){const i=to({inputs:{input:s},backend:e}),o=rr({inputs:{x:i},backend:e}),r=gi({inputs:{input:s},backend:e}),a=rr({inputs:{x:r},backend:e}),l=Fn({inputs:{real:o,imag:a},backend:e});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(r),e.disposeIntermediateTensorInfo(a),l}else return lc({backend:e,attrs:{shape:s.shape,value:0,dtype:s.dtype}})}const lN={kernelName:Su,backendName:"cpu",kernelFunc:rr};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function My(n){const{inputs:t,backend:e}=n,{x:s}=t;if(s.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(s.dtype==="complex64"){const i=to({inputs:{input:s},backend:e}),o=My({inputs:{x:i},backend:e}),r=gi({inputs:{input:s},backend:e}),a=rr({inputs:{x:r},backend:e}),l=Fn({inputs:{real:o,imag:a},backend:e});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(r),e.disposeIntermediateTensorInfo(a),l}else return lc({backend:e,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}const uN={kernelName:eu,backendName:"cpu",kernelFunc:My};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Py(n){const{inputs:t,backend:e,attrs:s}=n,{axis:i}=s;if(t.length===1)return or({inputs:{input:t[0]},backend:e,attrs:{dim:i}});const o=t[0].shape,r=t[0].dtype;t.forEach(c=>{Lf(o,c.shape,"All tensors passed to stack must have matching shapes"),tt(r===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],l=t.map(c=>{const h=or({inputs:{input:c},backend:e,attrs:{dim:i}});return a.push(h),h}),u=yi({inputs:l,backend:e,attrs:{axis:i}});return a.forEach(c=>e.disposeIntermediateTensorInfo(c)),u}const cN={kernelName:nu,backendName:"cpu",kernelFunc:Py};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hN(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{paddings:o,constantValue:r}=s;yt(i,"pad");const a=o.map((w,k)=>w[0]+i.shape[k]+w[1]),l=o.map(w=>w[0]),u=e.data.get(i.dataId).values,c=et(i.shape),h=i.shape.length,p=Tt(i.shape),f=et(a),m=a.length,g=Tt(a),b=Ln(i.dtype,f);r!==0&&b.fill(r);for(let w=0;w<c;w++){const C=Tf(w,h,p).map((N,$)=>N+l[$]),I=Xi(C,m,g);b[I]=u[w]}return{dataId:e.write(b,a,i.dtype),shape:a,dtype:i.dtype}}const Ey={kernelName:su,backendName:"cpu",kernelFunc:hN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dN=Us((n,t)=>Math.pow(n,t)),pN=Ii(Tr,dN),fN={kernelName:Tr,backendName:"cpu",kernelFunc:pN};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mN(n){const{inputs:t,backend:e,attrs:s}=n,{paramsNestedSplits:i,paramsDenseValues:o,indices:r}=t,a=i.map(b=>e.data.get(b.dataId).values),l=i.map(b=>b.shape),u=e.data.get(o.dataId).values,c=e.data.get(r.dataId).values,[h,p,f]=b0(a,l,u,o.shape,o.dtype,c,r.shape),m=h.map(b=>e.makeTensorInfo([b.length],"int32",b)),g=e.makeTensorInfo(f,o.dtype,p);return m.concat([g])}const gN={kernelName:y0,backendName:"cpu",kernelFunc:mN};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yN(n){const{inputs:t,backend:e}=n,{starts:s,limits:i,deltas:o}=t,r=e.data.get(s.dataId).values,a=e.data.get(i.dataId).values,l=e.data.get(o.dataId).values,[u,c]=w0(r,s.shape,s.dtype,a,i.shape,l,o.shape),h=e.makeTensorInfo([u.length],"int32",u),p=e.makeTensorInfo([c.length],s.dtype,c);return[h,p]}const bN={kernelName:x0,backendName:"cpu",kernelFunc:yN};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xN(n){const{inputs:t,backend:e,attrs:s}=n,{shape:i,values:o,defaultValue:r,rowPartitionTensors:a}=t,{rowPartitionTypes:l}=s,u=e.data.get(i.dataId).values,c=e.data.get(o.dataId).values,h=e.data.get(r.dataId).values,p=a.map(b=>e.data.get(b.dataId).values),f=a.map(b=>b.shape),[m,g]=C0(u,i.shape,c,o.shape,o.dtype,h,r.shape,p,f,l);return e.makeTensorInfo(m,o.dtype,g)}const wN={kernelName:v0,backendName:"cpu",kernelFunc:xN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vN(n){const{backend:t,attrs:e}=n,{start:s,stop:i,dtype:o,step:r}=e,a=k0(s,i,r,o);return t.makeTensorInfo([a.length],o,a)}const CN={kernelName:Of,backendName:"cpu",kernelFunc:vN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kN=Qt(Mr,n=>1/n),SN={kernelName:Mr,backendName:"cpu",kernelFunc:kN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IN(n){const{inputs:t,backend:e,attrs:s}=n,{images:i}=t,{alignCorners:o,halfPixelCenters:r,size:a}=s;yt(i,"resizeBilinear");const l=Tt(i.shape),[u,c]=a,[h,p,f,m]=i.shape,g=e.data.get(i.dataId).values,b=new Float32Array(et([h,u,c,m])),v=[o&&u>1?p-1:p,o&&c>1?f-1:f],w=[o&&u>1?u-1:u,o&&c>1?c-1:c];let k=0;const C=v[0]/w[0],I=v[1]/w[1];for(let N=0;N<h;N++)for(let $=0;$<u;$++){let A;r?A=C*($+.5)-.5:A=C*$;const z=Math.max(0,Math.floor(A)),F=A-z,E=Math.min(p-1,Math.ceil(A)),U=N*l[0]+z*l[1],L=N*l[0]+E*l[1];for(let W=0;W<c;W++){let _;r?_=I*(W+.5)-.5:_=I*W;const V=Math.max(0,Math.floor(_)),X=_-V,j=Math.min(f-1,Math.ceil(_)),K=U+V*l[2],Z=L+V*l[2],Y=U+j*l[2],it=L+j*l[2];for(let nt=0;nt<m;nt++){const lt=g[K+nt],at=g[Z+nt],pt=g[Y+nt],gt=g[it+nt],wt=lt+(pt-lt)*X,xt=at+(gt-at)*X,Dt=wt+(xt-wt)*F;b[k++]=Dt}}}return e.makeTensorInfo([h,u,c,m],"float32",b)}const NN={kernelName:ru,backendName:"cpu",kernelFunc:IN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $N(n){const{inputs:t,backend:e,attrs:s}=n,{images:i,dy:o}=t,{alignCorners:r}=s;yt([o,i],"resizeBilinearGrad");const a=Tt(i.shape),[l,u,c,h]=i.shape,[,p,f]=o.shape,m=new Float32Array(l*u*c*h),g=[r&&p>1?u-1:u,r&&f>1?c-1:c],b=[r&&p>1?p-1:p,r&&f>1?f-1:f],v=g[0]/b[0],w=g[1]/b[1],k=e.data.get(o.dataId).values;let C=0;for(let I=0;I<l;I++){const N=I*a[0];for(let $=0;$<p;$++){const A=$*v,z=Math.floor(A),F=Math.min(Math.ceil(A),u-1),E=N+z*a[1],U=N+F*a[1],L=A-z,W=1-L;for(let _=0;_<f;_++){const V=_*w,X=Math.floor(V),j=Math.min(Math.ceil(V),c-1),K=V-X,Z=1-K,Y=E+X*a[2],it=E+j*a[2],nt=U+X*a[2],lt=U+j*a[2],at=W*Z,pt=W*K,gt=L*Z,wt=L*K;for(let xt=0;xt<h;xt++){const Dt=k[C++];m[Y+xt]+=Dt*at,m[it+xt]+=Dt*pt,m[nt+xt]+=Dt*gt,m[lt+xt]+=Dt*wt}}}}return e.makeTensorInfo([l,c,u,h],"float32",m)}const DN={kernelName:au,backendName:"cpu",kernelFunc:$N};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RN(n){const{inputs:t,backend:e,attrs:s}=n,{images:i}=t,{alignCorners:o,halfPixelCenters:r,size:a}=s;yt(i,"resizeNearestNeighbor");const l=Tt(i.shape),[u,c]=a,[h,p,f,m]=i.shape,g=e.data.get(i.dataId).values,b=new Float32Array(h*u*c*m),v=[o&&u>1?p-1:p,o&&c>1?f-1:f],w=[o&&u>1?u-1:u,o&&c>1?c-1:c],k=v[0]/w[0],C=v[1]/w[1];let I=0;for(let N=0;N<h;N++){const $=N*l[0];for(let A=0;A<u;A++){const z=r?k*(A+.5):k*A;let F=Math.min(p-1,o?Math.round(z):Math.floor(z));r&&(F=Math.max(0,F));const E=$+F*l[1];for(let U=0;U<c;U++){const L=r?C*(U+.5):C*U;let W=Math.min(f-1,o?Math.round(L):Math.floor(L));r&&(W=Math.max(0,W));const _=E+W*l[2];for(let V=0;V<m;V++){const X=g[_+V];b[I++]=X}}}}return e.makeTensorInfo([h,u,c,m],i.dtype,b)}const AN={kernelName:lu,backendName:"cpu",kernelFunc:RN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TN(n){const{inputs:t,backend:e,attrs:s}=n,{images:i,dy:o}=t,{alignCorners:r}=s;yt([o,i],"resizeNearestNeighborGrad");const a=Tt(i.shape),l=Tt(o.shape),[u,c,h,p]=i.shape,[,f,m]=o.shape,g=new Float32Array(u*c*h*p),b=e.data.get(o.dataId).values,v=[r&&f>1?c-1:c,r&&m>1?h-1:h],w=[r&&f>1?f-1:f,r&&m>1?m-1:m],k=v[0]/w[0],C=v[1]/w[1],I=1/k,N=1/C,$=Math.ceil(I)*2+2,A=Math.ceil(N)*2+2;for(let z=0;z<u;z++){const F=z*a[0];for(let E=0;E<c;E++){const U=F+E*a[1],L=Math.floor(E*I),W=Math.floor(L-$/2);for(let _=0;_<h;_++){const V=U+_*a[2],X=Math.floor(_*N),j=Math.floor(X-A/2);for(let K=0;K<p;K++){let Z=0;for(let Y=0;Y<$;Y++){const it=Y+W;if(it<0||it>=f)continue;const nt=F+it*l[1],lt=it*k,at=Math.min(c-1,r?Math.round(lt):Math.floor(lt));if(E===at)for(let pt=0;pt<A;pt++){const gt=pt+j;if(gt<0||gt>=m)continue;const wt=nt+gt*l[2],xt=gt*C,Dt=Math.min(h-1,r?Math.round(xt):Math.floor(xt));_===Dt&&(Z+=b[wt+K])}}g[V+K]=Z}}}}return e.makeTensorInfo(i.shape,i.dtype,g)}const zN={kernelName:uu,backendName:"cpu",kernelFunc:TN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FN(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{dims:o}=s;yt(i,"reverse");const r=i.shape.length,a=ee(o,i.shape);if(r===0)return Gs({inputs:{x:i},backend:e});const l=new Ve(i.shape,i.dtype),u=e.bufferSync(i);for(let c=0;c<l.size;c++){const h=l.indexToLoc(c),p=h.slice();a.forEach(f=>p[f]=i.shape[f]-1-p[f]),l.set(u.get(...p),...h)}return e.makeTensorInfo(l.shape,l.dtype,l.values)}const MN={kernelName:cu,backendName:"cpu",kernelFunc:FN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PN={kernelName:_f,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:s}=n,{radians:i,fillValue:o,center:r}=t,a=e,l=Ln(s.dtype,et(s.shape)),[u,c,h,p]=s.shape,[f,m]=Bf(r,c,h),g=255,b=Math.sin(i),v=Math.cos(i),w=a.data.get(s.dataId).values;for(let C=0;C<u;C++){const I=C*h*c*p;for(let N=0;N<c;N++){const $=N*(h*p);for(let A=0;A<h;A++){const z=A*p;for(let F=0;F<p;F++){const E=[u,N,A,F],U=E[2],L=E[1];let W=(U-f)*v-(L-m)*b,_=(U-f)*b+(L-m)*v;W=Math.round(W+f),_=Math.round(_+m);let V=o;if(typeof o!="number"&&(F===3?V=g:V=o[F]),W>=0&&W<h&&_>=0&&_<c){const j=_*(h*p),K=W*p,Z=I+j+K+F;V=w[Z]}const X=I+$+z+F;l[X]=V}}}}return{dataId:a.write(l,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EN=Qt(Lr,n=>{const t=Math.floor(n);return n-t<.5?Math.floor(n):n-t>.5?Math.ceil(n):t%2===0?t:t+1}),LN={kernelName:Lr,backendName:"cpu",kernelFunc:EN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ON(n){const{inputs:t,backend:e,attrs:s}=n,{indices:i,updates:o}=t,{shape:r}=s,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=Di(o,i,r),p=!0,f=e.bufferSync(i),m=e.bufferSync(o),g=ii(f,m,r,h,u,l,a,c,0,p);return e.makeTensorInfo(r,g.dtype,g.values)}const _N={kernelName:Wf,backendName:"cpu",kernelFunc:ON};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BN(n,t){let e=0,s=n.length,i=0;for(;e<s;)i=Math.floor((e+s)/2),n[i]<t?e=i+1:s=i;return s}function WN(n,t){let e=0,s=n.length,i=0;for(;e<s;)i=Math.floor((e+s)/2),n[i]<=t?e=i+1:s=i;return s}function VN(n,t,e,s,i,o){const r=Jr("int32",e*i);for(let a=0;a<e;++a){const l=n.slice(a*s,(a+1)*s),u=a*i;for(let c=0;c<i;++c)r[u+c]=o==="left"?BN(l,t[c+u]):WN(l,t[c+u])}return r}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UN(n){const{inputs:t,backend:e,attrs:s}=n,{sortedSequence:i,values:o}=t,{side:r}=s,a=e.data.get(i.dataId).values,l=e.data.get(o.dataId).values,u=VN(a,l,i.shape[0],i.shape[1],o.shape[1],r);return e.makeTensorInfo(o.shape,"int32",u)}const GN={kernelName:Vf,backendName:"cpu",kernelFunc:UN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HN(n){const{inputs:t,backend:e}=n,{condition:s,t:i,e:o}=t;yt([s,i,o],"select");const r=s.shape.length,a=e.data.get(s.dataId).values,l=e.data.get(i.dataId).values,u=e.data.get(o.dataId).values,c=es(i.dtype,o.dtype),h=ss(et(i.shape),c);let p=0;const f=r===0||r>1||i.shape.length===1?1:et(i.shape.slice(1));for(let m=0;m<a.length;m++)for(let g=0;g<f;g++)a[m]===1?h[p++]=l[m]:h[p++]=u[m];return e.makeTensorInfo(i.shape,c,h)}const jN={kernelName:hu,backendName:"cpu",kernelFunc:HN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KN=du,XN=pu,qN=Qt(Or,n=>n>=0?XN*n:KN*(Math.exp(n)-1)),YN={kernelName:Or,backendName:"cpu",kernelFunc:qN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZN=Qt(_r,n=>n<0?-1:n>0?1:0),QN={kernelName:_r,backendName:"cpu",kernelFunc:ZN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JN=Qt(Br,n=>Math.sin(n)),t$={kernelName:Br,backendName:"cpu",kernelFunc:JN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const e$=Qt(Wr,n=>Math.sinh(n)),n$={kernelName:Wr,backendName:"cpu",kernelFunc:e$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const s$=11920928955078125e-23,Ph=Math.log(s$)+2,i$=Qt(Vr,n=>{const t=n>-Ph,e=n<Ph,s=Math.exp(n);let i;return e?i=s:t?i=n:i=Math.log(1+s),i}),o$={kernelName:Vr,backendName:"cpu",kernelFunc:i$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r$(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{blockShape:o,paddings:r}=s;yt([i],"spaceToBatchND");const a=et(o),l=[[0,0]];l.push(...r);for(let N=1+o.length;N<i.shape.length;++N)l.push([0,0]);const u=Ey.kernelFunc({inputs:{x:i},backend:e,attrs:{paddings:l,constantValue:0}}),c=Yr(u.shape,o,a,!1),h=Zr(c.length,o.length,!1),p=Qr(u.shape,o,a,!1),g=te({inputs:{x:u},backend:e,attrs:{shape:c}}),w=Ze({inputs:{x:g},backend:e,attrs:{perm:h}}),I=te({inputs:{x:w},backend:e,attrs:{shape:p}});return e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(w),I}const a$={kernelName:gu,backendName:"cpu",kernelFunc:r$};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l$(n){const{inputs:t,backend:e}=n,{indices:s,values:i,denseShape:o,defaultValue:r}=t;if(o.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${o.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${s.shape}`);if(i.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${i.shape}`);if(r.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${r.shape}`);const a=e.data.get(s.dataId).values,l=e.data.get(i.dataId).values,u=e.data.get(o.dataId).values,c=e.data.get(r.dataId).values[0],[h,p,f,m,g]=I0(a,s.shape,s.dtype,l,i.dtype,u,c);return[e.makeTensorInfo(p,s.dtype,h),e.makeTensorInfo([p[0]],i.dtype,f),e.makeTensorInfo([m.length],"bool",new Uint8Array(m.map(b=>Number(b)))),e.makeTensorInfo([g.length],s.dtype,new Int32Array(g))]}const u$={kernelName:S0,backendName:"cpu",kernelFunc:l$};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c$(n){const{inputs:t,backend:e}=n,{inputIndices:s,inputShape:i,newShape:o}=t;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${s.shape}`);if(i.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${i.shape}`);if(o.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);const r=Array.from(e.data.get(i.dataId).values),a=e.data.get(s.dataId).values,l=Array.from(e.data.get(o.dataId).values),[u,c,h]=$0(a,s.shape,s.dtype,r,l);return[e.makeTensorInfo(c,s.dtype,u),e.makeTensorInfo([h.length],o.dtype,new Int32Array(h))]}const h$={kernelName:N0,backendName:"cpu",kernelFunc:c$};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d$(n){const{inputs:t,backend:e}=n,{data:s,indices:i,segmentIds:o}=t;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${i.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${o.shape}`);if(i.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const r=e.data.get(s.dataId).values,a=e.data.get(i.dataId).values,l=e.data.get(o.dataId).values,[u,c]=Gf(r,s.shape,s.dtype,a,l,!0);return e.makeTensorInfo(c,s.dtype,u)}const p$={kernelName:Uf,backendName:"cpu",kernelFunc:d$};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f$(n){const{inputs:t,backend:e}=n,{data:s,indices:i,segmentIds:o}=t;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${i.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${o.shape}`);if(i.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const r=e.data.get(s.dataId).values,a=e.data.get(i.dataId).values,l=e.data.get(o.dataId).values,[u,c]=Gf(r,s.shape,s.dtype,a,l);return e.makeTensorInfo(c,s.dtype,u)}const m$={kernelName:Hf,backendName:"cpu",kernelFunc:f$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g$(n){const{inputs:t,backend:e,attrs:s}=n,{sparseIndices:i,sparseValues:o,defaultValue:r}=t,{outputShape:a}=s,{sliceRank:l,numUpdates:u,sliceSize:c,strides:h,outputSize:p}=Di(o,i,a),f=!1,m=e.bufferSync(i);let g;switch(o.dtype){case"bool":{const b=e.bufferSync(o),v=!!e.data.get(r.dataId).values[0];g=ii(m,b,a,p,c,u,l,h,v,f);break}case"float32":{const b=e.bufferSync(o),v=e.data.get(r.dataId).values[0];g=ii(m,b,a,p,c,u,l,h,v,f);break}case"int32":{const b=e.bufferSync(o),v=e.data.get(r.dataId).values[0];g=ii(m,b,a,p,c,u,l,h,v,f);break}case"string":{const b=e.bufferSync(o),v=ho(e.data.get(r.dataId).values[0]);g=ii(m,b,a,p,c,u,l,h,v,f);break}default:throw new Error(`Unsupported type ${o.dtype}`)}return e.makeTensorInfo(a,g.dtype,g.values)}const y$={kernelName:jf,backendName:"cpu",kernelFunc:g$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b$(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{numOrSizeSplits:o,axis:r}=s,a=ee(r,i.shape)[0],l=Kf(i,o,a),u=new Array(i.shape.length).fill(0),c=i.shape.slice();return l.map(h=>{const p=[...c];p[a]=h;const f=pi({inputs:{x:i},backend:e,attrs:{begin:u,size:p}});return u[a]+=h,f})}const x$={kernelName:yu,backendName:"cpu",kernelFunc:b$};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const w$={kernelName:bu,backendName:"cpu",kernelFunc:({inputs:n,backend:t})=>{const{x:e}=n,s=t;yt(e,"square");const i=s.data.get(e.dataId).values,o=new Float32Array(i.length);for(let a=0;a<i.length;++a){const l=i[a];o[a]=l*l}return{dataId:s.write(o,e.shape,e.dtype),shape:e.shape,dtype:e.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v$=Qt(Ur,(n,t)=>{const e=t;return isNaN(n)?NaN:n>0?1:e.alpha}),C$={kernelName:Ur,backendName:"cpu",kernelFunc:v$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k$(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{begin:o,end:r,strides:a,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:p}=s;yt(i,"stridedSlice");const{finalShapeSparse:f,finalShape:m,isIdentity:g,sliceDim0:b,isSimpleSlice:v,begin:w,end:k,strides:C}=qf(i.shape,o,r,a,l,u,c,h,p);let I;if(g)I=te({inputs:{x:i},backend:e,attrs:{shape:m}});else if(b||v){tt(i.shape.length>=1,()=>`Input must have rank at least 1, got: ${i.shape.length}`);const N=Yf(w,k,C),$=pi({inputs:{x:i},backend:e,attrs:{begin:w,size:N}});I=te({inputs:{x:$},backend:e,attrs:{shape:m}}),e.disposeIntermediateTensorInfo($)}else{const N=e.bufferSync(i),$=D0(f,N,C,w);I=e.makeTensorInfo(m,$.dtype,$.values)}return I}const S$={kernelName:Xf,backendName:"cpu",kernelFunc:k$};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I$(n){const{inputs:t,backend:e,attrs:s}=n,{separator:i,nGramWidths:o,leftPad:r,rightPad:a,padWidth:l,preserveShortSequences:u}=s,{data:c,dataSplits:h}=t,p=e.data.get(c.dataId).values,f=e.data.get(h.dataId).values,[m,g]=R0(p,f,i,o,r,a,l,u);return[e.makeTensorInfo([m.length],"string",m),e.makeTensorInfo(h.shape,"int32",g)]}const N$={kernelName:Zf,backendName:"cpu",kernelFunc:I$};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $$(n){const{inputs:t,backend:e,attrs:s}=n,{skipEmpty:i}=s,{input:o,delimiter:r}=t;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(o.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(r.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${r.shape}`);const a=e.data.get(o.dataId).values,l=e.data.get(r.dataId).values[0],[u,c,h]=T0(a,l,i),p=c.length;return[e.makeTensorInfo([p,2],"int32",u),e.makeTensorInfo([p],"string",c),e.makeTensorInfo([2],"int32",new Int32Array(h))]}const D$={kernelName:A0,backendName:"cpu",kernelFunc:$$};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R$(n){const{inputs:t,backend:e,attrs:s}=n,{numBuckets:i}=s,{input:o}=t;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(i<=0)throw new Error("Number of buckets must be at least 1");const r=e.data.get(o.dataId).values,a=F0(r,i);return e.makeTensorInfo(o.shape,"int32",a)}const A$={kernelName:z0,backendName:"cpu",kernelFunc:R$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const T$=Qt(Gr,n=>Math.tan(n)),z$={kernelName:Gr,backendName:"cpu",kernelFunc:T$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const F$=Qt(Hr,n=>Math.tanh(n)),M$={kernelName:Hr,backendName:"cpu",kernelFunc:F$};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P$(n){const{inputs:t,backend:e}=n,{tensor:s,indices:i,updates:o}=t,{sliceRank:r,numUpdates:a,sliceSize:l,strides:u,outputSize:c}=Di(o,i,s.shape),h=!1,p=e.bufferSync(i),f=e.bufferSync(o),m=e.bufferSync(s),g=ii(p,f,s.shape,c,l,a,r,u,m,h);return e.makeTensorInfo(s.shape,g.dtype,g.values)}const E$={kernelName:Qf,backendName:"cpu",kernelFunc:P$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L$(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{reps:o}=s;yt(i,"tile");const r=M0(e.bufferSync(i),o);return e.makeTensorInfo(r.shape,r.dtype,r.values)}const O$={kernelName:wu,backendName:"cpu",kernelFunc:L$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _$(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{k:o,sorted:r}=s;yt(i,"topk");const a=e.data.get(i.dataId).values,[l,u]=P0(a,i.shape,i.dtype,o,r);return[e.makeTensorInfo(l.shape,l.dtype,l.values),e.makeTensorInfo(u.shape,u.dtype,u.values)]}const B$={kernelName:Jf,backendName:"cpu",kernelFunc:_$};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W$(n){const{inputs:t,attrs:e,backend:s}=n,{image:i,transforms:o}=t,{interpolation:r,fillMode:a,fillValue:l,outputShape:u}=e,[c,h,p,f]=i.shape,[m,g]=u??[h,p],b=[c,m,g,f],v=Tt(i.shape),w=v[0],k=v[1],C=v[2],I=Tt(b),N=I[0],$=I[1],A=I[2],z=Ln(i.dtype,et(b));z.fill(l);const F=s.data.get(i.dataId).values,E=s.data.get(o.dataId).values;for(let L=0;L<c;++L){const W=o.shape[0]===1?E:E.subarray(L*8,L*8+8);for(let _=0;_<m;++_)for(let V=0;V<g;++V)for(let X=0;X<f;++X){let j;const K=W[6]*V+W[7]*_+1;if(K===0)continue;const Z=(W[0]*V+W[1]*_+W[2])/K,Y=(W[3]*V+W[4]*_+W[5])/K,it=Eh(Z,p,a),nt=Eh(Y,h,a);switch(r){case"nearest":j=K$(F,h,p,w,k,C,L,nt,it,X,l);break;case"bilinear":j=X$(F,h,p,w,k,C,L,nt,it,X,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${r}`)}const lt=L*N+_*$+V*A+X;z[lt]=j}return s.makeTensorInfo(b,i.dtype,z)}return{dataId:s.write(z,b,i.dtype),shape:i.shape,dtype:i.dtype}}const V$={kernelName:tm,backendName:"cpu",kernelFunc:W$};function Eh(n,t,e){switch(e){case"reflect":return U$(n,t);case"wrap":return G$(n,t);case"nearest":return j$(n,t);case"constant":default:return H$(n)}}function U$(n,t){let e=n;if(e<0)if(t<=1)e=0;else{const s=2*t;e<s&&(e=s*Math.trunc(-e/s)+e),e=e<-t?e+s:-e-1}else if(e>t-1)if(t<=1)e=0;else{const s=2*t;e-=s*Math.trunc(e/s),e>=t&&(e=s-e-1)}return Eu(0,e,t-1)}function G$(n,t){let e=n;if(e<0)if(t<=1)e=0;else{const s=t-1;e+=t*(Math.trunc(-e/s)+1)}else if(e>t-1)if(t<=1)e=0;else{const s=t-1;e-=t*Math.trunc(e/s)}return Eu(0,e,t-1)}function H$(n,t){return n}function j$(n,t){return Eu(0,n,t-1)}function ji(n,t,e,s,i,o,r,a,l,u,c){const h=r*s+a*i+l*o+u;return 0<=a&&a<t&&0<=l&&l<e?n[h]:c}function K$(n,t,e,s,i,o,r,a,l,u,c){const h=Math.round(a),p=Math.round(l);return ji(n,t,e,s,i,o,r,h,p,u,c)}function X$(n,t,e,s,i,o,r,a,l,u,c){const h=Math.floor(a),p=Math.floor(l),f=h+1,m=p+1,g=(m-l)*ji(n,t,e,s,i,o,r,h,p,u,c)+(l-p)*ji(n,t,e,s,i,o,r,h,m,u,c),b=(m-l)*ji(n,t,e,s,i,o,r,f,p,u,c)+(l-p)*ji(n,t,e,s,i,o,r,f,m,u,c);return(f-a)*g+(a-h)*b}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q$(n){const{inputs:t,attrs:e,backend:s}=n,{axis:i}=e,{x:o}=t;yt(o,"unique");const r=s.data.get(o.dataId).values,{outputValues:a,outputShape:l,indices:u}=L0(r,i,o.shape,o.dtype);return[s.makeTensorInfo(l,o.dtype,a),s.makeTensorInfo([u.length],"int32",u)]}const Y$={kernelName:E0,backendName:"cpu",kernelFunc:q$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z$(n){const{inputs:t,backend:e,attrs:s}=n,{value:i}=t;let{axis:o}=s;o<0&&(o+=i.shape.length);const r=i.shape.length,a=i.shape[o],l=new Array(r-1);let u=0;for(let f=0;f<r;f++)f!==o&&(l[u++]=i.shape[f]);const c=new Array(r).fill(0),h=i.shape.slice();h[o]=1;const p=new Array(a);for(let f=0;f<p.length;f++){c[o]=f;const m=pi({inputs:{x:i},backend:e,attrs:{begin:c,size:h}});p[f]=te({inputs:{x:m},backend:e,attrs:{shape:l}}),e.disposeIntermediateTensorInfo(m)}return p}const Q$={kernelName:vu,backendName:"cpu",kernelFunc:Z$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J$(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,segmentIds:o}=t,{numSegments:r}=s;yt(i,"unsortedSegmentSum");const a=i.shape.length,l=o.shape.length,u=[],c=[],h=a-l;let p=o;for(let m=0;m<h;++m){const g=or({inputs:{input:p},backend:e,attrs:{dim:m+1}});p=g,c.push(g)}for(let m=0;m<r;++m){const g=yf(m,"int32"),b=e.makeTensorInfo([],"int32",g),v=O0({inputs:{a:b,b:p},backend:e}),w=Tu({inputs:{x:v},backend:e,attrs:{dtype:"float32"}}),k=zu({inputs:{a:w,b:i},backend:e}),C=vo({inputs:{x:k},backend:e,attrs:{axis:0,keepDims:!1}});u.push(C),c.push(b),c.push(v),c.push(w),c.push(k),c.push(C)}const f=Py({inputs:u,backend:e,attrs:{axis:0}});return c.forEach(m=>e.disposeIntermediateTensorInfo(m)),f}const tD={kernelName:Cu,backendName:"cpu",kernelFunc:J$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eD=[qk,_0,Zk,Jk,B0,eS,sS,oS,aS,uS,hS,pS,mS,bS,wS,kS,IS,$S,RS,Kk,TS,FS,PS,W0,LS,V0,U0,_S,G0,WS,US,GS,jS,XS,YS,QS,tI,nI,iI,rI,lI,cI,dI,fI,mI,yI,xI,vI,CI,kI,SI,NI,RI,Bk,TI,H0,_I,j0,BI,K0,jI,KI,qI,X0,q0,ZI,JI,e3,s3,Y0,Z0,Q0,o3,VS,a3,u3,h3,Wk,J0,t1,p3,e1,m3,b3,w3,k3,I3,$3,D3,n1,A3,z3,M3,E3,O3,B3,V3,s1,G3,K3,Y3,i1,o1,J3,nN,oN,r1,aN,uN,cN,Ey,fN,Uk,a1,gN,bN,wN,CN,l1,cl,SN,Gk,Hk,jk,NN,DN,AN,zN,MN,PN,LN,u1,_N,GN,jN,YN,c1,QN,t$,n$,h1,X3,o$,a$,u$,h$,p$,m$,y$,x$,d1,w$,p1,f1,C$,S$,N$,D$,A$,m1,$I,z$,M$,E$,O$,B$,V$,g1,Y$,Q$,tD,lN];for(const n of eD)em(n);var nD={};(function(){var n;function t(d){var y=0;return function(){return y<d.length?{done:!1,value:d[y++]}:{done:!0}}}var e=typeof Object.defineProperties=="function"?Object.defineProperty:function(d,y,x){return d==Array.prototype||d==Object.prototype||(d[y]=x.value),d};function s(d){d=[typeof globalThis=="object"&&globalThis,d,typeof window=="object"&&window,typeof self=="object"&&self,typeof Ma=="object"&&Ma];for(var y=0;y<d.length;++y){var x=d[y];if(x&&x.Math==Math)return x}throw Error("Cannot find global object")}var i=s(this);function o(d,y){if(y)t:{var x=i;d=d.split(".");for(var S=0;S<d.length-1;S++){var D=d[S];if(!(D in x))break t;x=x[D]}d=d[d.length-1],S=x[d],y=y(S),y!=S&&y!=null&&e(x,d,{configurable:!0,writable:!0,value:y})}}o("Symbol",function(d){function y(T){if(this instanceof y)throw new TypeError("Symbol is not a constructor");return new x(S+(T||"")+"_"+D++,T)}function x(T,R){this.h=T,e(this,"description",{configurable:!0,writable:!0,value:R})}if(d)return d;x.prototype.toString=function(){return this.h};var S="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",D=0;return y}),o("Symbol.iterator",function(d){if(d)return d;d=Symbol("Symbol.iterator");for(var y="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),x=0;x<y.length;x++){var S=i[y[x]];typeof S=="function"&&typeof S.prototype[d]!="function"&&e(S.prototype,d,{configurable:!0,writable:!0,value:function(){return r(t(this))}})}return d});function r(d){return d={next:d},d[Symbol.iterator]=function(){return this},d}function a(d){var y=typeof Symbol<"u"&&Symbol.iterator&&d[Symbol.iterator];return y?y.call(d):{next:t(d)}}function l(d){if(!(d instanceof Array)){d=a(d);for(var y,x=[];!(y=d.next()).done;)x.push(y.value);d=x}return d}var u=typeof Object.assign=="function"?Object.assign:function(d,y){for(var x=1;x<arguments.length;x++){var S=arguments[x];if(S)for(var D in S)Object.prototype.hasOwnProperty.call(S,D)&&(d[D]=S[D])}return d};o("Object.assign",function(d){return d||u});var c=typeof Object.create=="function"?Object.create:function(d){function y(){}return y.prototype=d,new y},h;if(typeof Object.setPrototypeOf=="function")h=Object.setPrototypeOf;else{var p;t:{var f={a:!0},m={};try{m.__proto__=f,p=m.a;break t}catch{}p=!1}h=p?function(d,y){if(d.__proto__=y,d.__proto__!==y)throw new TypeError(d+" is not extensible");return d}:null}var g=h;function b(d,y){if(d.prototype=c(y.prototype),d.prototype.constructor=d,g)g(d,y);else for(var x in y)if(x!="prototype")if(Object.defineProperties){var S=Object.getOwnPropertyDescriptor(y,x);S&&Object.defineProperty(d,x,S)}else d[x]=y[x];d.za=y.prototype}function v(){this.m=!1,this.j=null,this.i=void 0,this.h=1,this.v=this.s=0,this.l=null}function w(d){if(d.m)throw new TypeError("Generator is already running");d.m=!0}v.prototype.u=function(d){this.i=d};function k(d,y){d.l={ma:y,na:!0},d.h=d.s||d.v}v.prototype.return=function(d){this.l={return:d},this.h=this.v};function C(d,y,x){return d.h=x,{value:y}}function I(d){this.h=new v,this.i=d}function N(d,y){w(d.h);var x=d.h.j;return x?$(d,"return"in x?x.return:function(S){return{value:S,done:!0}},y,d.h.return):(d.h.return(y),A(d))}function $(d,y,x,S){try{var D=y.call(d.h.j,x);if(!(D instanceof Object))throw new TypeError("Iterator result "+D+" is not an object");if(!D.done)return d.h.m=!1,D;var T=D.value}catch(R){return d.h.j=null,k(d.h,R),A(d)}return d.h.j=null,S.call(d.h,T),A(d)}function A(d){for(;d.h.h;)try{var y=d.i(d.h);if(y)return d.h.m=!1,{value:y.value,done:!1}}catch(x){d.h.i=void 0,k(d.h,x)}if(d.h.m=!1,d.h.l){if(y=d.h.l,d.h.l=null,y.na)throw y.ma;return{value:y.return,done:!0}}return{value:void 0,done:!0}}function z(d){this.next=function(y){return w(d.h),d.h.j?y=$(d,d.h.j.next,y,d.h.u):(d.h.u(y),y=A(d)),y},this.throw=function(y){return w(d.h),d.h.j?y=$(d,d.h.j.throw,y,d.h.u):(k(d.h,y),y=A(d)),y},this.return=function(y){return N(d,y)},this[Symbol.iterator]=function(){return this}}function F(d){function y(S){return d.next(S)}function x(S){return d.throw(S)}return new Promise(function(S,D){function T(R){R.done?S(R.value):Promise.resolve(R.value).then(y,x).then(T,D)}T(d.next())})}function E(d){return F(new z(new I(d)))}o("Promise",function(d){function y(R){this.i=0,this.j=void 0,this.h=[],this.u=!1;var P=this.l();try{R(P.resolve,P.reject)}catch(G){P.reject(G)}}function x(){this.h=null}function S(R){return R instanceof y?R:new y(function(P){P(R)})}if(d)return d;x.prototype.i=function(R){if(this.h==null){this.h=[];var P=this;this.j(function(){P.m()})}this.h.push(R)};var D=i.setTimeout;x.prototype.j=function(R){D(R,0)},x.prototype.m=function(){for(;this.h&&this.h.length;){var R=this.h;this.h=[];for(var P=0;P<R.length;++P){var G=R[P];R[P]=null;try{G()}catch(J){this.l(J)}}}this.h=null},x.prototype.l=function(R){this.j(function(){throw R})},y.prototype.l=function(){function R(J){return function(ut){G||(G=!0,J.call(P,ut))}}var P=this,G=!1;return{resolve:R(this.I),reject:R(this.m)}},y.prototype.I=function(R){if(R===this)this.m(new TypeError("A Promise cannot resolve to itself"));else if(R instanceof y)this.L(R);else{t:switch(typeof R){case"object":var P=R!=null;break t;case"function":P=!0;break t;default:P=!1}P?this.F(R):this.s(R)}},y.prototype.F=function(R){var P=void 0;try{P=R.then}catch(G){this.m(G);return}typeof P=="function"?this.M(P,R):this.s(R)},y.prototype.m=function(R){this.v(2,R)},y.prototype.s=function(R){this.v(1,R)},y.prototype.v=function(R,P){if(this.i!=0)throw Error("Cannot settle("+R+", "+P+"): Promise already settled in state"+this.i);this.i=R,this.j=P,this.i===2&&this.K(),this.H()},y.prototype.K=function(){var R=this;D(function(){if(R.D()){var P=i.console;typeof P<"u"&&P.error(R.j)}},1)},y.prototype.D=function(){if(this.u)return!1;var R=i.CustomEvent,P=i.Event,G=i.dispatchEvent;return typeof G>"u"?!0:(typeof R=="function"?R=new R("unhandledrejection",{cancelable:!0}):typeof P=="function"?R=new P("unhandledrejection",{cancelable:!0}):(R=i.document.createEvent("CustomEvent"),R.initCustomEvent("unhandledrejection",!1,!0,R)),R.promise=this,R.reason=this.j,G(R))},y.prototype.H=function(){if(this.h!=null){for(var R=0;R<this.h.length;++R)T.i(this.h[R]);this.h=null}};var T=new x;return y.prototype.L=function(R){var P=this.l();R.T(P.resolve,P.reject)},y.prototype.M=function(R,P){var G=this.l();try{R.call(P,G.resolve,G.reject)}catch(J){G.reject(J)}},y.prototype.then=function(R,P){function G(bt,dt){return typeof bt=="function"?function(It){try{J(bt(It))}catch(Pt){ut(Pt)}}:dt}var J,ut,St=new y(function(bt,dt){J=bt,ut=dt});return this.T(G(R,J),G(P,ut)),St},y.prototype.catch=function(R){return this.then(void 0,R)},y.prototype.T=function(R,P){function G(){switch(J.i){case 1:R(J.j);break;case 2:P(J.j);break;default:throw Error("Unexpected state: "+J.i)}}var J=this;this.h==null?T.i(G):this.h.push(G),this.u=!0},y.resolve=S,y.reject=function(R){return new y(function(P,G){G(R)})},y.race=function(R){return new y(function(P,G){for(var J=a(R),ut=J.next();!ut.done;ut=J.next())S(ut.value).T(P,G)})},y.all=function(R){var P=a(R),G=P.next();return G.done?S([]):new y(function(J,ut){function St(It){return function(Pt){bt[It]=Pt,dt--,dt==0&&J(bt)}}var bt=[],dt=0;do bt.push(void 0),dt++,S(G.value).T(St(bt.length-1),ut),G=P.next();while(!G.done)})},y});function U(d,y){d instanceof String&&(d+="");var x=0,S=!1,D={next:function(){if(!S&&x<d.length){var T=x++;return{value:y(T,d[T]),done:!1}}return S=!0,{done:!0,value:void 0}}};return D[Symbol.iterator]=function(){return D},D}o("Array.prototype.keys",function(d){return d||function(){return U(this,function(y){return y})}}),o("Array.prototype.fill",function(d){return d||function(y,x,S){var D=this.length||0;for(0>x&&(x=Math.max(0,D+x)),(S==null||S>D)&&(S=D),S=Number(S),0>S&&(S=Math.max(0,D+S)),x=Number(x||0);x<S;x++)this[x]=y;return this}});function L(d){return d||Array.prototype.fill}o("Int8Array.prototype.fill",L),o("Uint8Array.prototype.fill",L),o("Uint8ClampedArray.prototype.fill",L),o("Int16Array.prototype.fill",L),o("Uint16Array.prototype.fill",L),o("Int32Array.prototype.fill",L),o("Uint32Array.prototype.fill",L),o("Float32Array.prototype.fill",L),o("Float64Array.prototype.fill",L),o("Object.is",function(d){return d||function(y,x){return y===x?y!==0||1/y===1/x:y!==y&&x!==x}}),o("Array.prototype.includes",function(d){return d||function(y,x){var S=this;S instanceof String&&(S=String(S));var D=S.length;for(x=x||0,0>x&&(x=Math.max(x+D,0));x<D;x++){var T=S[x];if(T===y||Object.is(T,y))return!0}return!1}}),o("String.prototype.includes",function(d){return d||function(y,x){if(this==null)throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");if(y instanceof RegExp)throw new TypeError("First argument to String.prototype.includes must not be a regular expression");return this.indexOf(y,x||0)!==-1}});var W=this||self;function _(d,y){d=d.split(".");var x=W;d[0]in x||typeof x.execScript>"u"||x.execScript("var "+d[0]);for(var S;d.length&&(S=d.shift());)d.length||y===void 0?x[S]&&x[S]!==Object.prototype[S]?x=x[S]:x=x[S]={}:x[S]=y}function V(d){var y;t:{if((y=W.navigator)&&(y=y.userAgent))break t;y=""}return y.indexOf(d)!=-1}var X=Array.prototype.map?function(d,y){return Array.prototype.map.call(d,y,void 0)}:function(d,y){for(var x=d.length,S=Array(x),D=typeof d=="string"?d.split(""):d,T=0;T<x;T++)T in D&&(S[T]=y.call(void 0,D[T],T,d));return S},j={},K=null;function Z(d){var y=d.length,x=3*y/4;x%3?x=Math.floor(x):"=.".indexOf(d[y-1])!=-1&&(x="=.".indexOf(d[y-2])!=-1?x-2:x-1);var S=new Uint8Array(x),D=0;return Y(d,function(T){S[D++]=T}),D!==x?S.subarray(0,D):S}function Y(d,y){function x(G){for(;S<d.length;){var J=d.charAt(S++),ut=K[J];if(ut!=null)return ut;if(!/^[\s\xa0]*$/.test(J))throw Error("Unknown base64 encoding at char: "+J)}return G}it();for(var S=0;;){var D=x(-1),T=x(0),R=x(64),P=x(64);if(P===64&&D===-1)break;y(D<<2|T>>4),R!=64&&(y(T<<4&240|R>>2),P!=64&&y(R<<6&192|P))}}function it(){if(!K){K={};for(var d="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""),y=["+/=","+/","-_=","-_.","-_"],x=0;5>x;x++){var S=d.concat(y[x].split(""));j[x]=S;for(var D=0;D<S.length;D++){var T=S[D];K[T]===void 0&&(K[T]=D)}}}}var nt=typeof Uint8Array<"u",lt=!(V("Trident")||V("MSIE"))&&typeof W.btoa=="function";function at(d){if(!lt){var y;y===void 0&&(y=0),it(),y=j[y];for(var x=Array(Math.floor(d.length/3)),S=y[64]||"",D=0,T=0;D<d.length-2;D+=3){var R=d[D],P=d[D+1],G=d[D+2],J=y[R>>2];R=y[(R&3)<<4|P>>4],P=y[(P&15)<<2|G>>6],G=y[G&63],x[T++]=J+R+P+G}switch(J=0,G=S,d.length-D){case 2:J=d[D+1],G=y[(J&15)<<2]||S;case 1:d=d[D],x[T]=y[d>>2]+y[(d&3)<<4|J>>4]+G+S}return x.join("")}for(y="";10240<d.length;)y+=String.fromCharCode.apply(null,d.subarray(0,10240)),d=d.subarray(10240);return y+=String.fromCharCode.apply(null,d),btoa(y)}var pt=RegExp("[-_.]","g");function gt(d){switch(d){case"-":return"+";case"_":return"/";case".":return"=";default:return""}}function wt(d){if(!lt)return Z(d);pt.test(d)&&(d=d.replace(pt,gt)),d=atob(d);for(var y=new Uint8Array(d.length),x=0;x<d.length;x++)y[x]=d.charCodeAt(x);return y}var xt;function Dt(){return xt||(xt=new Uint8Array(0))}var Nt={},Ut=typeof Uint8Array.prototype.slice=="function",$t=0,Mt=0;function jt(d){var y=0>d;d=Math.abs(d);var x=d>>>0;d=Math.floor((d-x)/4294967296),y&&(x=a(Jt(x,d)),y=x.next().value,d=x.next().value,x=y),$t=x>>>0,Mt=d>>>0}var Ht=typeof BigInt=="function";function Jt(d,y){return y=~y,d?d=~d+1:y+=1,[d,y]}function qt(d,y){this.i=d>>>0,this.h=y>>>0}function tn(d){if(!d)return fe||(fe=new qt(0,0));if(!/^-?\d+$/.test(d))return null;if(16>d.length)jt(Number(d));else if(Ht)d=BigInt(d),$t=Number(d&BigInt(4294967295))>>>0,Mt=Number(d>>BigInt(32)&BigInt(4294967295));else{var y=+(d[0]==="-");Mt=$t=0;for(var x=d.length,S=y,D=(x-y)%6+y;D<=x;S=D,D+=6)S=Number(d.slice(S,D)),Mt*=1e6,$t=1e6*$t+S,4294967296<=$t&&(Mt+=$t/4294967296|0,$t%=4294967296);y&&(y=a(Jt($t,Mt)),d=y.next().value,y=y.next().value,$t=d,Mt=y)}return new qt($t,Mt)}var fe;function hn(d,y){return Error("Invalid wire type: "+d+" (at position "+y+")")}function De(){return Error("Failed to read varint, encoding is invalid.")}function vn(d,y){return Error("Tried to read past the end of the data "+y+" > "+d)}function we(){throw Error("Invalid UTF8")}function en(d,y){return y=String.fromCharCode.apply(null,y),d==null?y:d+y}var qe=void 0,nn,Cn=typeof TextDecoder<"u",os,Fi=typeof TextEncoder<"u",Ys;function ko(d){if(d!==Nt)throw Error("illegal external caller")}function kn(d,y){if(ko(y),this.V=d,d!=null&&d.length===0)throw Error("ByteString should be constructed with non-empty values")}function Mi(){return Ys||(Ys=new kn(null,Nt))}function So(d){ko(Nt);var y=d.V;return y=y==null||nt&&y!=null&&y instanceof Uint8Array?y:typeof y=="string"?wt(y):null,y==null?y:d.V=y}function Ab(d){if(typeof d=="string")return{buffer:wt(d),C:!1};if(Array.isArray(d))return{buffer:new Uint8Array(d),C:!1};if(d.constructor===Uint8Array)return{buffer:d,C:!1};if(d.constructor===ArrayBuffer)return{buffer:new Uint8Array(d),C:!1};if(d.constructor===kn)return{buffer:So(d)||Dt(),C:!0};if(d instanceof Uint8Array)return{buffer:new Uint8Array(d.buffer,d.byteOffset,d.byteLength),C:!1};throw Error("Type not convertible to a Uint8Array, expected a Uint8Array, an ArrayBuffer, a base64 encoded string, a ByteString or an Array of numbers")}function fc(d,y){this.i=null,this.m=!1,this.h=this.j=this.l=0,ma(this,d,y)}function ma(d,y,x){x=x===void 0?{}:x,d.S=x.S===void 0?!1:x.S,y&&(y=Ab(y),d.i=y.buffer,d.m=y.C,d.l=0,d.j=d.i.length,d.h=d.l)}fc.prototype.reset=function(){this.h=this.l};function ks(d,y){if(d.h=y,y>d.j)throw vn(d.j,y)}function Pi(d){var y=d.i,x=d.h,S=y[x++],D=S&127;if(S&128&&(S=y[x++],D|=(S&127)<<7,S&128&&(S=y[x++],D|=(S&127)<<14,S&128&&(S=y[x++],D|=(S&127)<<21,S&128&&(S=y[x++],D|=S<<28,S&128&&y[x++]&128&&y[x++]&128&&y[x++]&128&&y[x++]&128&&y[x++]&128)))))throw De();return ks(d,x),D}function mc(d,y){if(0>y)throw Error("Tried to read a negative byte length: "+y);var x=d.h,S=x+y;if(S>d.j)throw vn(y,d.j-x);return d.h=S,x}var gc=[];function ga(){this.h=[]}ga.prototype.length=function(){return this.h.length},ga.prototype.end=function(){var d=this.h;return this.h=[],d};function yc(d,y,x){for(;0<x||127<y;)d.h.push(y&127|128),y=(y>>>7|x<<25)>>>0,x>>>=7;d.h.push(y)}function Ss(d,y){for(;127<y;)d.h.push(y&127|128),y>>>=7;d.h.push(y)}function ya(d,y){if(gc.length){var x=gc.pop();ma(x,d,y),d=x}else d=new fc(d,y);this.h=d,this.j=this.h.h,this.i=this.l=-1,this.setOptions(y)}ya.prototype.setOptions=function(d){d=d===void 0?{}:d,this.ca=d.ca===void 0?!1:d.ca},ya.prototype.reset=function(){this.h.reset(),this.j=this.h.h,this.i=this.l=-1};function bc(d){var y=d.h;if(y.h==y.j)return!1;d.j=d.h.h;var x=Pi(d.h)>>>0;if(y=x>>>3,x&=7,!(0<=x&&5>=x))throw hn(x,d.j);if(1>y)throw Error("Invalid field number: "+y+" (at position "+d.j+")");return d.l=y,d.i=x,!0}function Io(d){switch(d.i){case 0:if(d.i!=0)Io(d);else t:{d=d.h;for(var y=d.h,x=y+10,S=d.i;y<x;)if(!(S[y++]&128)){ks(d,y);break t}throw De()}break;case 1:d=d.h,ks(d,d.h+8);break;case 2:d.i!=2?Io(d):(y=Pi(d.h)>>>0,d=d.h,ks(d,d.h+y));break;case 5:d=d.h,ks(d,d.h+4);break;case 3:y=d.l;do{if(!bc(d))throw Error("Unmatched start-group tag: stream EOF");if(d.i==4){if(d.l!=y)throw Error("Unmatched end-group tag");break}Io(d)}while(!0);break;default:throw hn(d.i,d.j)}}var No=[];function Tb(){this.j=[],this.i=0,this.h=new ga}function Zs(d,y){y.length!==0&&(d.j.push(y),d.i+=y.length)}function zb(d,y){if(y=y.R){Zs(d,d.h.end());for(var x=0;x<y.length;x++)Zs(d,So(y[x])||Dt())}}var Gn=typeof Symbol=="function"&&typeof Symbol()=="symbol"?Symbol():void 0;function Is(d,y){return Gn?d[Gn]|=y:d.A!==void 0?d.A|=y:(Object.defineProperties(d,{A:{value:y,configurable:!0,writable:!0,enumerable:!1}}),y)}function xc(d,y){Gn?d[Gn]&&(d[Gn]&=~y):d.A!==void 0&&(d.A&=~y)}function me(d){var y;return Gn?y=d[Gn]:y=d.A,y??0}function Sn(d,y){Gn?d[Gn]=y:d.A!==void 0?d.A=y:Object.defineProperties(d,{A:{value:y,configurable:!0,writable:!0,enumerable:!1}})}function ba(d){return Is(d,1),d}function Fb(d,y){Sn(y,(d|0)&-51)}function $o(d,y){Sn(y,(d|18)&-41)}var xa={};function Do(d){return d!==null&&typeof d=="object"&&!Array.isArray(d)&&d.constructor===Object}var Ei,wc=[];Sn(wc,23),Ei=Object.freeze(wc);function wa(d){if(me(d.o)&2)throw Error("Cannot mutate an immutable Message")}function va(d){var y=d.length;(y=y?d[y-1]:void 0)&&Do(y)?y.g=1:(y={},d.push((y.g=1,y)))}function vc(d){var y=d.i+d.G;return d.B||(d.B=d.o[y]={})}function dn(d,y){return y===-1?null:y>=d.i?d.B?d.B[y]:void 0:d.o[y+d.G]}function In(d,y,x,S){wa(d),Li(d,y,x,S)}function Li(d,y,x,S){d.j&&(d.j=void 0),y>=d.i||S?vc(d)[y]=x:(d.o[y+d.G]=x,(d=d.B)&&y in d&&delete d[y])}function Ca(d,y,x,S){var D=dn(d,y);Array.isArray(D)||(D=Ei);var T=me(D);if(T&1||ba(D),S)T&2||Is(D,2),x&1||Object.freeze(D);else{S=!(x&2);var R=T&2;x&1||!R?S&&T&16&&!R&&xc(D,16):(D=ba(Array.prototype.slice.call(D)),Li(d,y,D))}return D}function ka(d,y){var x=dn(d,y),S=x==null?x:typeof x=="number"||x==="NaN"||x==="Infinity"||x==="-Infinity"?Number(x):void 0;return S!=null&&S!==x&&Li(d,y,S),S}function Cc(d,y,x,S,D){d.h||(d.h={});var T=d.h[x],R=Ca(d,x,3,D);if(!T){var P=R;T=[];var G=!!(me(d.o)&16);R=!!(me(P)&2);var J=P;!D&&R&&(P=Array.prototype.slice.call(P));for(var ut=R,St=0;St<P.length;St++){var bt=P[St],dt=y,It=!1;if(It=It===void 0?!1:It,bt=Array.isArray(bt)?new dt(bt):It?new dt:void 0,bt!==void 0){dt=bt.o;var Pt=It=me(dt);R&&(Pt|=2),G&&(Pt|=16),Pt!=It&&Sn(dt,Pt),dt=Pt,ut=ut||!!(2&dt),T.push(bt)}}return d.h[x]=T,G=me(P),y=G|33,y=ut?y&-9:y|8,G!=y&&(ut=P,Object.isFrozen(ut)&&(ut=Array.prototype.slice.call(ut)),Sn(ut,y),P=ut),J!==P&&Li(d,x,P),(D||S&&R)&&Is(T,2),S&&Object.freeze(T),T}return D||(D=Object.isFrozen(T),S&&!D?Object.freeze(T):!S&&D&&(T=Array.prototype.slice.call(T),d.h[x]=T)),T}function Sa(d,y,x){var S=!!(me(d.o)&2);if(y=Cc(d,y,x,S,S),d=Ca(d,x,3,S),!(S||me(d)&8)){for(S=0;S<y.length;S++){if(x=y[S],me(x.o)&2){var D=Dc(x,!1);D.j=x}else D=x;x!==D&&(y[S]=D,d[S]=D.o)}Is(d,8)}return y}function Nn(d,y,x){if(x!=null&&typeof x!="number")throw Error("Value of float/double field must be a number|null|undefined, found "+typeof x+": "+x);In(d,y,x)}function kc(d,y,x,S,D){wa(d);var T=Cc(d,x,y,!1,!1);return x=S??new x,d=Ca(d,y,2,!1),D!=null?(T.splice(D,0,x),d.splice(D,0,x.o)):(T.push(x),d.push(x.o)),x.C()&&xc(d,8),x}function Ro(d,y){return d??y}function $n(d,y,x){return x=x===void 0?0:x,Ro(ka(d,y),x)}var Ao;function Mb(d){switch(typeof d){case"number":return isFinite(d)?d:String(d);case"object":if(d)if(Array.isArray(d)){if(me(d)&128)return d=Array.prototype.slice.call(d),va(d),d}else{if(nt&&d!=null&&d instanceof Uint8Array)return at(d);if(d instanceof kn){var y=d.V;return y==null?"":typeof y=="string"?y:d.V=at(y)}}}return d}function Sc(d,y,x,S){if(d!=null){if(Array.isArray(d))d=Ia(d,y,x,S!==void 0);else if(Do(d)){var D={},T;for(T in d)D[T]=Sc(d[T],y,x,S);d=D}else d=y(d,S);return d}}function Ia(d,y,x,S){var D=me(d);S=S?!!(D&16):void 0,d=Array.prototype.slice.call(d);for(var T=0;T<d.length;T++)d[T]=Sc(d[T],y,x,S);return x(D,d),d}function Pb(d){return d.ja===xa?d.toJSON():Mb(d)}function Eb(d,y){d&128&&va(y)}function Ic(d,y,x){if(x=x===void 0?$o:x,d!=null){if(nt&&d instanceof Uint8Array)return d.length?new kn(new Uint8Array(d),Nt):Mi();if(Array.isArray(d)){var S=me(d);return S&2?d:y&&!(S&32)&&(S&16||S===0)?(Sn(d,S|2),d):(d=Ia(d,Ic,S&4?$o:x,!0),y=me(d),y&4&&y&2&&Object.freeze(d),d)}return d.ja===xa?$c(d):d}}function Nc(d,y,x,S,D,T,R){if(d=d.h&&d.h[x]){if(S=me(d),S&2?S=d:(T=X(d,$c),$o(S,T),Object.freeze(T),S=T),wa(y),R=S==null?Ei:ba([]),S!=null){for(T=!!S.length,d=0;d<S.length;d++){var P=S[d];T=T&&!(me(P.o)&2),R[d]=P.o}T=(T?8:0)|1,d=me(R),(d&T)!==T&&(Object.isFrozen(R)&&(R=Array.prototype.slice.call(R)),Sn(R,d|T)),y.h||(y.h={}),y.h[x]=S}else y.h&&(y.h[x]=void 0);Li(y,x,R,D)}else In(y,x,Ic(S,T,R),D)}function $c(d){return me(d.o)&2||(d=Dc(d,!0),Is(d.o,2)),d}function Dc(d,y){var x=d.o,S=[];Is(S,16);var D=d.constructor.h;if(D&&S.push(D),D=d.B,D){S.length=x.length,S.fill(void 0,S.length,x.length);var T={};S[S.length-1]=T}me(x)&128&&va(S),y=y||d.C()?$o:Fb,T=d.constructor,Ao=S,S=new T(S),Ao=void 0,d.R&&(S.R=d.R.slice()),T=!!(me(x)&16);for(var R=D?x.length-1:x.length,P=0;P<R;P++)Nc(d,S,P-d.G,x[P],!1,T,y);if(D)for(var G in D)Nc(d,S,+G,D[G],!0,T,y);return S}function Be(d,y,x){d==null&&(d=Ao),Ao=void 0;var S=this.constructor.i||0,D=0<S,T=this.constructor.h,R=!1;if(d==null){d=T?[T]:[];var P=48,G=!0;D&&(S=0,P|=128),Sn(d,P)}else{if(!Array.isArray(d)||T&&T!==d[0])throw Error();var J=P=Is(d,0);if((G=(16&J)!==0)&&((R=(32&J)!==0)||(J|=32)),D){if(128&J)S=0;else if(0<d.length){var ut=d[d.length-1];if(Do(ut)&&"g"in ut){S=0,J|=128,delete ut.g;var St=!0,bt;for(bt in ut){St=!1;break}St&&d.pop()}}}else if(128&J)throw Error();P!==J&&Sn(d,J)}this.G=(T?0:-1)-S,this.h=void 0,this.o=d;t:{if(T=this.o.length,S=T-1,T&&(T=this.o[S],Do(T))){this.B=T,this.i=S-this.G;break t}y!==void 0&&-1<y?(this.i=Math.max(y,S+1-this.G),this.B=void 0):this.i=Number.MAX_VALUE}if(!D&&this.B&&"g"in this.B)throw Error('Unexpected "g" flag in sparse object of message that is not a group type.');if(x){y=G&&!R&&!0,D=this.i;var dt;for(G=0;G<x.length;G++)R=x[G],R<D?(R+=this.G,(S=d[R])?Rc(S,y):d[R]=Ei):(dt||(dt=vc(this)),(S=dt[R])?Rc(S,y):dt[R]=Ei)}}Be.prototype.toJSON=function(){return Ia(this.o,Pb,Eb)},Be.prototype.C=function(){return!!(me(this.o)&2)};function Rc(d,y){if(Array.isArray(d)){var x=me(d),S=1;!y||x&2||(S|=16),(x&S)!==S&&Sn(d,x|S)}}Be.prototype.ja=xa,Be.prototype.toString=function(){return this.o.toString()};function Ac(d,y,x){if(x){var S={},D;for(D in x){var T=x[D],R=T.ra;R||(S.J=T.xa||T.oa.W,T.ia?(S.aa=Pc(T.ia),R=function(P){return function(G,J,ut){return P.J(G,J,ut,P.aa)}}(S)):T.ka?(S.Z=Ec(T.da.P,T.ka),R=function(P){return function(G,J,ut){return P.J(G,J,ut,P.Z)}}(S)):R=S.J,T.ra=R),R(y,d,T.da),S={J:S.J,aa:S.aa,Z:S.Z}}}zb(y,d)}var To=Symbol();function Tc(d,y,x){return d[To]||(d[To]=function(S,D){return y(S,D,x)})}function zc(d){var y=d[To];if(!y){var x=$a(d);y=function(S,D){return Lc(S,D,x)},d[To]=y}return y}function Lb(d){var y=d.ia;if(y)return zc(y);if(y=d.wa)return Tc(d.da.P,y,d.ka)}function Ob(d){var y=Lb(d),x=d.da,S=d.oa.U;return y?function(D,T){return S(D,T,x,y)}:function(D,T){return S(D,T,x)}}function Fc(d,y){var x=d[y];return typeof x=="function"&&x.length===0&&(x=x(),d[y]=x),Array.isArray(x)&&(_i in x||Oi in x||0<x.length&&typeof x[0]=="function")?x:void 0}function Mc(d,y,x,S,D,T){y.P=d[0];var R=1;if(d.length>R&&typeof d[R]!="number"){var P=d[R++];x(y,P)}for(;R<d.length;){x=d[R++];for(var G=R+1;G<d.length&&typeof d[G]!="number";)G++;switch(P=d[R++],G-=R,G){case 0:S(y,x,P);break;case 1:(G=Fc(d,R))?(R++,D(y,x,P,G)):S(y,x,P,d[R++]);break;case 2:G=R++,G=Fc(d,G),D(y,x,P,G,d[R++]);break;case 3:T(y,x,P,d[R++],d[R++],d[R++]);break;case 4:T(y,x,P,d[R++],d[R++],d[R++],d[R++]);break;default:throw Error("unexpected number of binary field arguments: "+G)}}return y}var zo=Symbol();function Pc(d){var y=d[zo];if(!y){var x=Na(d);y=function(S,D){return Oc(S,D,x)},d[zo]=y}return y}function Ec(d,y){var x=d[zo];return x||(x=function(S,D){return Ac(S,D,y)},d[zo]=x),x}var Oi=Symbol();function _b(d,y){d.push(y)}function Bb(d,y,x){d.push(y,x.W)}function Wb(d,y,x,S){var D=Pc(S),T=Na(S).P,R=x.W;d.push(y,function(P,G,J){return R(P,G,J,T,D)})}function Vb(d,y,x,S,D,T){var R=Ec(S,T),P=x.W;d.push(y,function(G,J,ut){return P(G,J,ut,S,R)})}function Na(d){var y=d[Oi];return y||(y=Mc(d,d[Oi]=[],_b,Bb,Wb,Vb),_i in d&&Oi in d&&(d.length=0),y)}var _i=Symbol();function Ub(d,y){d[0]=y}function Gb(d,y,x,S){var D=x.U;d[y]=S?function(T,R,P){return D(T,R,P,S)}:D}function Hb(d,y,x,S,D){var T=x.U,R=zc(S),P=$a(S).P;d[y]=function(G,J,ut){return T(G,J,ut,P,R,D)}}function jb(d,y,x,S,D,T,R){var P=x.U,G=Tc(S,D,T);d[y]=function(J,ut,St){return P(J,ut,St,S,G,R)}}function $a(d){var y=d[_i];return y||(y=Mc(d,d[_i]={},Ub,Gb,Hb,jb),_i in d&&Oi in d&&(d.length=0),y)}function Lc(d,y,x){for(;bc(y)&&y.i!=4;){var S=y.l,D=x[S];if(!D){var T=x[0];T&&(T=T[S])&&(D=x[S]=Ob(T))}if(!D||!D(y,d,S)){D=y,S=d,T=D.j,Io(D);var R=D;if(!R.ca){if(D=R.h.h-T,R.h.h=T,R=R.h,D==0)D=Mi();else{if(T=mc(R,D),R.S&&R.m)D=R.i.subarray(T,T+D);else{R=R.i;var P=T;D=T+D,D=P===D?Dt():Ut?R.slice(P,D):new Uint8Array(R.subarray(P,D))}D=D.length==0?Mi():new kn(D,Nt)}(T=S.R)?T.push(D):S.R=[D]}}}return d}function Oc(d,y,x){for(var S=x.length,D=S%2==1,T=D?1:0;T<S;T+=2)(0,x[T+1])(y,d,x[T]);Ac(d,y,D?x[0]:void 0)}function Bi(d,y){return{U:d,W:y}}var pn=Bi(function(d,y,x){if(d.i!==5)return!1;d=d.h;var S=d.i,D=d.h,T=S[D],R=S[D+1],P=S[D+2];return S=S[D+3],ks(d,d.h+4),R=(T<<0|R<<8|P<<16|S<<24)>>>0,d=2*(R>>31)+1,T=R>>>23&255,R&=8388607,In(y,x,T==255?R?NaN:1/0*d:T==0?d*Math.pow(2,-149)*R:d*Math.pow(2,T-150)*(R+Math.pow(2,23))),!0},function(d,y,x){if(y=ka(y,x),y!=null){Ss(d.h,8*x+5),d=d.h;var S=+y;S===0?0<1/S?$t=Mt=0:(Mt=0,$t=2147483648):isNaN(S)?(Mt=0,$t=2147483647):(S=(x=0>S?-2147483648:0)?-S:S,34028234663852886e22<S?(Mt=0,$t=(x|2139095040)>>>0):11754943508222875e-54>S?(S=Math.round(S/Math.pow(2,-149)),Mt=0,$t=(x|S)>>>0):(y=Math.floor(Math.log(S)/Math.LN2),S*=Math.pow(2,-y),S=Math.round(8388608*S),16777216<=S&&++y,Mt=0,$t=(x|y+127<<23|S&8388607)>>>0)),x=$t,d.h.push(x>>>0&255),d.h.push(x>>>8&255),d.h.push(x>>>16&255),d.h.push(x>>>24&255)}}),Kb=Bi(function(d,y,x){if(d.i!==0)return!1;var S=d.h,D=0,T=d=0,R=S.i,P=S.h;do{var G=R[P++];D|=(G&127)<<T,T+=7}while(32>T&&G&128);for(32<T&&(d|=(G&127)>>4),T=3;32>T&&G&128;T+=7)G=R[P++],d|=(G&127)<<T;if(ks(S,P),128>G)S=D>>>0,G=d>>>0,(d=G&2147483648)&&(S=~S+1>>>0,G=~G>>>0,S==0&&(G=G+1>>>0)),S=4294967296*G+(S>>>0);else throw De();return In(y,x,d?-S:S),!0},function(d,y,x){y=dn(y,x),y!=null&&(typeof y=="string"&&tn(y),y!=null&&(Ss(d.h,8*x),typeof y=="number"?(d=d.h,jt(y),yc(d,$t,Mt)):(x=tn(y),yc(d.h,x.i,x.h))))}),Xb=Bi(function(d,y,x){return d.i!==0?!1:(In(y,x,Pi(d.h)),!0)},function(d,y,x){if(y=dn(y,x),y!=null&&y!=null)if(Ss(d.h,8*x),d=d.h,x=y,0<=x)Ss(d,x);else{for(y=0;9>y;y++)d.h.push(x&127|128),x>>=7;d.h.push(1)}}),_c=Bi(function(d,y,x){if(d.i!==2)return!1;var S=Pi(d.h)>>>0;d=d.h;var D=mc(d,S);if(d=d.i,Cn){var T=d,R;(R=nn)||(R=nn=new TextDecoder("utf-8",{fatal:!0})),d=D+S,T=D===0&&d===T.length?T:T.subarray(D,d);try{var P=R.decode(T)}catch(St){if(qe===void 0){try{R.decode(new Uint8Array([128]))}catch{}try{R.decode(new Uint8Array([97])),qe=!0}catch{qe=!1}}throw!qe&&(nn=void 0),St}}else{P=D,S=P+S,D=[];for(var G=null,J,ut;P<S;)J=d[P++],128>J?D.push(J):224>J?P>=S?we():(ut=d[P++],194>J||(ut&192)!==128?(P--,we()):D.push((J&31)<<6|ut&63)):240>J?P>=S-1?we():(ut=d[P++],(ut&192)!==128||J===224&&160>ut||J===237&&160<=ut||((T=d[P++])&192)!==128?(P--,we()):D.push((J&15)<<12|(ut&63)<<6|T&63)):244>=J?P>=S-2?we():(ut=d[P++],(ut&192)!==128||(J<<28)+(ut-144)>>30||((T=d[P++])&192)!==128||((R=d[P++])&192)!==128?(P--,we()):(J=(J&7)<<18|(ut&63)<<12|(T&63)<<6|R&63,J-=65536,D.push((J>>10&1023)+55296,(J&1023)+56320))):we(),8192<=D.length&&(G=en(G,D),D.length=0);P=en(G,D)}return In(y,x,P),!0},function(d,y,x){if(y=dn(y,x),y!=null){var S=!1;if(S=S===void 0?!1:S,Fi){if(S&&/(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])/.test(y))throw Error("Found an unpaired surrogate");y=(os||(os=new TextEncoder)).encode(y)}else{for(var D=0,T=new Uint8Array(3*y.length),R=0;R<y.length;R++){var P=y.charCodeAt(R);if(128>P)T[D++]=P;else{if(2048>P)T[D++]=P>>6|192;else{if(55296<=P&&57343>=P){if(56319>=P&&R<y.length){var G=y.charCodeAt(++R);if(56320<=G&&57343>=G){P=1024*(P-55296)+G-56320+65536,T[D++]=P>>18|240,T[D++]=P>>12&63|128,T[D++]=P>>6&63|128,T[D++]=P&63|128;continue}else R--}if(S)throw Error("Found an unpaired surrogate");P=65533}T[D++]=P>>12|224,T[D++]=P>>6&63|128}T[D++]=P&63|128}}y=D===T.length?T:T.subarray(0,D)}Ss(d.h,8*x+2),Ss(d.h,y.length),Zs(d,d.h.end()),Zs(d,y)}}),Bc=Bi(function(d,y,x,S,D){if(d.i!==2)return!1;y=kc(y,x,S),x=d.h.j,S=Pi(d.h)>>>0;var T=d.h.h+S,R=T-x;if(0>=R&&(d.h.j=T,D(y,d,void 0,void 0,void 0),R=T-d.h.h),R)throw Error("Message parsing ended unexpectedly. Expected to read "+(S+" bytes, instead read "+(S-R)+" bytes, either the data ended unexpectedly or the message misreported its own length"));return d.h.h=T,d.h.j=x,!0},function(d,y,x,S,D){if(y=Sa(y,S,x),y!=null)for(S=0;S<y.length;S++){var T=d;Ss(T.h,8*x+2);var R=T.h.end();Zs(T,R),R.push(T.i),T=R,D(y[S],d),R=d;var P=T.pop();for(P=R.i+R.h.length()-P;127<P;)T.push(P&127|128),P>>>=7,R.i++;T.push(P),R.i++}});function Da(d){return function(y,x){t:{if(No.length){var S=No.pop();S.setOptions(x),ma(S.h,y,x),y=S}else y=new ya(y,x);try{var D=$a(d),T=Lc(new D.P,y,D);break t}finally{D=y.h,D.i=null,D.m=!1,D.l=0,D.j=0,D.h=0,D.S=!1,y.l=-1,y.i=-1,100>No.length&&No.push(y)}T=void 0}return T}}function Ra(d){return function(){var y=new Tb;Oc(this,y,Na(d)),Zs(y,y.h.end());for(var x=new Uint8Array(y.i),S=y.j,D=S.length,T=0,R=0;R<D;R++){var P=S[R];x.set(P,T),T+=P.length}return y.j=[x],x}}function Qs(d){Be.call(this,d)}b(Qs,Be);var Wc=[Qs,1,Xb,2,pn,3,_c,4,_c];Qs.prototype.l=Ra(Wc);function Aa(d){Be.call(this,d,-1,qb)}b(Aa,Be),Aa.prototype.addClassification=function(d,y){return kc(this,1,Qs,d,y),this};var qb=[1],Yb=Da([Aa,1,Bc,Wc]);function Wi(d){Be.call(this,d)}b(Wi,Be);var Vc=[Wi,1,pn,2,pn,3,pn,4,pn,5,pn];Wi.prototype.l=Ra(Vc);function Uc(d){Be.call(this,d,-1,Zb)}b(Uc,Be);var Zb=[1],Qb=Da([Uc,1,Bc,Vc]);function Fo(d){Be.call(this,d)}b(Fo,Be);var Gc=[Fo,1,pn,2,pn,3,pn,4,pn,5,pn,6,Kb],Jb=Da(Gc);Fo.prototype.l=Ra(Gc);function Hc(d,y,x){if(x=d.createShader(x===0?d.VERTEX_SHADER:d.FRAGMENT_SHADER),d.shaderSource(x,y),d.compileShader(x),!d.getShaderParameter(x,d.COMPILE_STATUS))throw Error(`Could not compile WebGL shader.

`+d.getShaderInfoLog(x));return x}function tx(d){return Sa(d,Qs,1).map(function(y){var x=dn(y,1);return{index:x??0,qa:$n(y,2),label:dn(y,3)!=null?Ro(dn(y,3),""):void 0,displayName:dn(y,4)!=null?Ro(dn(y,4),""):void 0}})}function ex(d){return{x:$n(d,1),y:$n(d,2),z:$n(d,3),visibility:ka(d,4)!=null?$n(d,4):void 0}}function Ta(d){return Sa(Qb(d),Wi,1).map(ex)}function za(d,y){this.i=d,this.h=y,this.m=0}function jc(d,y,x){return nx(d,y),typeof d.h.canvas.transferToImageBitmap=="function"?Promise.resolve(d.h.canvas.transferToImageBitmap()):x?Promise.resolve(d.h.canvas):typeof createImageBitmap=="function"?createImageBitmap(d.h.canvas):(d.j===void 0&&(d.j=document.createElement("canvas")),new Promise(function(S){d.j.height=d.h.canvas.height,d.j.width=d.h.canvas.width,d.j.getContext("2d",{}).drawImage(d.h.canvas,0,0,d.h.canvas.width,d.h.canvas.height),S(d.j)}))}function nx(d,y){var x=d.h;if(d.s===void 0){var S=Hc(x,`
  attribute vec2 aVertex;
  attribute vec2 aTex;
  varying vec2 vTex;
  void main(void) {
    gl_Position = vec4(aVertex, 0.0, 1.0);
    vTex = aTex;
  }`,0),D=Hc(x,`
  precision mediump float;
  varying vec2 vTex;
  uniform sampler2D sampler0;
  void main(){
    gl_FragColor = texture2D(sampler0, vTex);
  }`,1),T=x.createProgram();if(x.attachShader(T,S),x.attachShader(T,D),x.linkProgram(T),!x.getProgramParameter(T,x.LINK_STATUS))throw Error(`Could not compile WebGL program.

`+x.getProgramInfoLog(T));S=d.s=T,x.useProgram(S),D=x.getUniformLocation(S,"sampler0"),d.l={O:x.getAttribLocation(S,"aVertex"),N:x.getAttribLocation(S,"aTex"),ya:D},d.v=x.createBuffer(),x.bindBuffer(x.ARRAY_BUFFER,d.v),x.enableVertexAttribArray(d.l.O),x.vertexAttribPointer(d.l.O,2,x.FLOAT,!1,0,0),x.bufferData(x.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),x.STATIC_DRAW),x.bindBuffer(x.ARRAY_BUFFER,null),d.u=x.createBuffer(),x.bindBuffer(x.ARRAY_BUFFER,d.u),x.enableVertexAttribArray(d.l.N),x.vertexAttribPointer(d.l.N,2,x.FLOAT,!1,0,0),x.bufferData(x.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),x.STATIC_DRAW),x.bindBuffer(x.ARRAY_BUFFER,null),x.uniform1i(D,0)}S=d.l,x.useProgram(d.s),x.canvas.width=y.width,x.canvas.height=y.height,x.viewport(0,0,y.width,y.height),x.activeTexture(x.TEXTURE0),d.i.bindTexture2d(y.glName),x.enableVertexAttribArray(S.O),x.bindBuffer(x.ARRAY_BUFFER,d.v),x.vertexAttribPointer(S.O,2,x.FLOAT,!1,0,0),x.enableVertexAttribArray(S.N),x.bindBuffer(x.ARRAY_BUFFER,d.u),x.vertexAttribPointer(S.N,2,x.FLOAT,!1,0,0),x.bindFramebuffer(x.DRAW_FRAMEBUFFER?x.DRAW_FRAMEBUFFER:x.FRAMEBUFFER,null),x.clearColor(0,0,0,0),x.clear(x.COLOR_BUFFER_BIT),x.colorMask(!0,!0,!0,!0),x.drawArrays(x.TRIANGLE_FAN,0,4),x.disableVertexAttribArray(S.O),x.disableVertexAttribArray(S.N),x.bindBuffer(x.ARRAY_BUFFER,null),d.i.bindTexture2d(0)}function sx(d){this.h=d}var ix=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]);function ox(d,y){return y+d}function Kc(d,y){window[d]=y}function rx(d){var y=document.createElement("script");return y.setAttribute("src",d),y.setAttribute("crossorigin","anonymous"),new Promise(function(x){y.addEventListener("load",function(){x()},!1),y.addEventListener("error",function(){x()},!1),document.body.appendChild(y)})}function ax(){return E(function(d){switch(d.h){case 1:return d.s=2,C(d,WebAssembly.instantiate(ix),4);case 4:d.h=3,d.s=0;break;case 2:return d.s=0,d.l=null,d.return(!1);case 3:return d.return(!0)}})}function Fa(d){if(this.h=d,this.listeners={},this.l={},this.L={},this.s={},this.v={},this.M=this.u=this.ga=!0,this.I=Promise.resolve(),this.fa="",this.D={},this.locateFile=d&&d.locateFile||ox,typeof window=="object")var y=window.location.pathname.toString().substring(0,window.location.pathname.toString().lastIndexOf("/"))+"/";else if(typeof location<"u")y=location.pathname.toString().substring(0,location.pathname.toString().lastIndexOf("/"))+"/";else throw Error("solutions can only be loaded on a web page or in a web worker");if(this.ha=y,d.options){y=a(Object.keys(d.options));for(var x=y.next();!x.done;x=y.next()){x=x.value;var S=d.options[x].default;S!==void 0&&(this.l[x]=typeof S=="function"?S():S)}}}n=Fa.prototype,n.close=function(){return this.j&&this.j.delete(),Promise.resolve()};function lx(d){var y,x,S,D,T,R,P,G,J,ut,St;return E(function(bt){switch(bt.h){case 1:return d.ga?(y=d.h.files===void 0?[]:typeof d.h.files=="function"?d.h.files(d.l):d.h.files,C(bt,ax(),2)):bt.return();case 2:if(x=bt.i,typeof window=="object")return Kc("createMediapipeSolutionsWasm",{locateFile:d.locateFile}),Kc("createMediapipeSolutionsPackedAssets",{locateFile:d.locateFile}),R=y.filter(function(dt){return dt.data!==void 0}),P=y.filter(function(dt){return dt.data===void 0}),G=Promise.all(R.map(function(dt){var It=Mo(d,dt.url);if(dt.path!==void 0){var Pt=dt.path;It=It.then(function(ie){return d.overrideFile(Pt,ie),Promise.resolve(ie)})}return It})),J=Promise.all(P.map(function(dt){return dt.simd===void 0||dt.simd&&x||!dt.simd&&!x?rx(d.locateFile(dt.url,d.ha)):Promise.resolve()})).then(function(){var dt,It,Pt;return E(function(ie){if(ie.h==1)return dt=window.createMediapipeSolutionsWasm,It=window.createMediapipeSolutionsPackedAssets,Pt=d,C(ie,dt(It),2);Pt.i=ie.i,ie.h=0})}),ut=function(){return E(function(dt){return d.h.graph&&d.h.graph.url?dt=C(dt,Mo(d,d.h.graph.url),0):(dt.h=0,dt=void 0),dt})}(),C(bt,Promise.all([J,G,ut]),7);if(typeof importScripts!="function")throw Error("solutions can only be loaded on a web page or in a web worker");return S=y.filter(function(dt){return dt.simd===void 0||dt.simd&&x||!dt.simd&&!x}).map(function(dt){return d.locateFile(dt.url,d.ha)}),importScripts.apply(null,l(S)),D=d,C(bt,createMediapipeSolutionsWasm(Module),6);case 6:D.i=bt.i,d.m=new OffscreenCanvas(1,1),d.i.canvas=d.m,T=d.i.GL.createContext(d.m,{antialias:!1,alpha:!1,va:typeof WebGL2RenderingContext<"u"?2:1}),d.i.GL.makeContextCurrent(T),bt.h=4;break;case 7:if(d.m=document.createElement("canvas"),St=d.m.getContext("webgl2",{}),!St&&(St=d.m.getContext("webgl",{}),!St))return alert("Failed to create WebGL canvas context when passing video frame."),bt.return();d.K=St,d.i.canvas=d.m,d.i.createContext(d.m,!0,!0,{});case 4:d.j=new d.i.SolutionWasm,d.ga=!1,bt.h=0}})}function ux(d){var y,x,S,D,T,R,P,G;return E(function(J){if(J.h==1){if(d.h.graph&&d.h.graph.url&&d.fa===d.h.graph.url)return J.return();if(d.u=!0,!d.h.graph||!d.h.graph.url){J.h=2;return}return d.fa=d.h.graph.url,C(J,Mo(d,d.h.graph.url),3)}for(J.h!=2&&(y=J.i,d.j.loadGraph(y)),x=a(Object.keys(d.D)),S=x.next();!S.done;S=x.next())D=S.value,d.j.overrideFile(D,d.D[D]);if(d.D={},d.h.listeners)for(T=a(d.h.listeners),R=T.next();!R.done;R=T.next())P=R.value,px(d,P);G=d.l,d.l={},d.setOptions(G),J.h=0})}n.reset=function(){var d=this;return E(function(y){d.j&&(d.j.reset(),d.s={},d.v={}),y.h=0})},n.setOptions=function(d,y){var x=this;if(y=y||this.h.options){for(var S=[],D=[],T={},R=a(Object.keys(d)),P=R.next();!P.done;T={X:T.X,Y:T.Y},P=R.next())if(P=P.value,!(P in this.l&&this.l[P]===d[P])){this.l[P]=d[P];var G=y[P];G!==void 0&&(G.onChange&&(T.X=G.onChange,T.Y=d[P],S.push(function(J){return function(){var ut;return E(function(St){if(St.h==1)return C(St,J.X(J.Y),2);ut=St.i,ut===!0&&(x.u=!0),St.h=0})}}(T))),G.graphOptionXref&&(P=Object.assign({},{calculatorName:"",calculatorIndex:0},G.graphOptionXref,{valueNumber:G.type===1?d[P]:0,valueBoolean:G.type===0?d[P]:!1,valueString:G.type===2?d[P]:""}),D.push(P)))}(S.length!==0||D.length!==0)&&(this.u=!0,this.H=(this.H===void 0?[]:this.H).concat(D),this.F=(this.F===void 0?[]:this.F).concat(S))}};function cx(d){var y,x,S,D,T,R,P;return E(function(G){switch(G.h){case 1:if(!d.u)return G.return();if(!d.F){G.h=2;break}y=a(d.F),x=y.next();case 3:if(x.done){G.h=5;break}return S=x.value,C(G,S(),4);case 4:x=y.next(),G.h=3;break;case 5:d.F=void 0;case 2:if(d.H){for(D=new d.i.GraphOptionChangeRequestList,T=a(d.H),R=T.next();!R.done;R=T.next())P=R.value,D.push_back(P);d.j.changeOptions(D),D.delete(),d.H=void 0}d.u=!1,G.h=0}})}n.initialize=function(){var d=this;return E(function(y){return y.h==1?C(y,lx(d),2):y.h!=3?C(y,ux(d),3):C(y,cx(d),0)})};function Mo(d,y){var x,S;return E(function(D){return y in d.L?D.return(d.L[y]):(x=d.locateFile(y,""),S=fetch(x).then(function(T){return T.arrayBuffer()}),d.L[y]=S,D.return(S))})}n.overrideFile=function(d,y){this.j?this.j.overrideFile(d,y):this.D[d]=y},n.clearOverriddenFiles=function(){this.D={},this.j&&this.j.clearOverriddenFiles()},n.send=function(d,y){var x=this,S,D,T,R,P,G,J,ut,St;return E(function(bt){switch(bt.h){case 1:return x.h.inputs?(S=1e3*(y??performance.now()),C(bt,x.I,2)):bt.return();case 2:return C(bt,x.initialize(),3);case 3:for(D=new x.i.PacketDataList,T=a(Object.keys(d)),R=T.next();!R.done;R=T.next())if(P=R.value,G=x.h.inputs[P]){t:{var dt=d[P];switch(G.type){case"video":var It=x.s[G.stream];if(It||(It=new za(x.i,x.K),x.s[G.stream]=It),It.m===0&&(It.m=It.i.createTexture()),typeof HTMLVideoElement<"u"&&dt instanceof HTMLVideoElement)var Pt=dt.videoWidth,ie=dt.videoHeight;else typeof HTMLImageElement<"u"&&dt instanceof HTMLImageElement?(Pt=dt.naturalWidth,ie=dt.naturalHeight):(Pt=dt.width,ie=dt.height);ie={glName:It.m,width:Pt,height:ie},Pt=It.h,Pt.canvas.width=ie.width,Pt.canvas.height=ie.height,Pt.activeTexture(Pt.TEXTURE0),It.i.bindTexture2d(It.m),Pt.texImage2D(Pt.TEXTURE_2D,0,Pt.RGBA,Pt.RGBA,Pt.UNSIGNED_BYTE,dt),It.i.bindTexture2d(0),It=ie;break t;case"detections":for(It=x.s[G.stream],It||(It=new sx(x.i),x.s[G.stream]=It),It.data||(It.data=new It.h.DetectionListData),It.data.reset(dt.length),ie=0;ie<dt.length;++ie){Pt=dt[ie];var ne=It.data,Re=ne.setBoundingBox,sn=ie,We=Pt.la,Gt=new Fo;if(Nn(Gt,1,We.sa),Nn(Gt,2,We.ta),Nn(Gt,3,We.height),Nn(Gt,4,We.width),Nn(Gt,5,We.rotation),In(Gt,6,We.pa),We=Gt.l(),Re.call(ne,sn,We),Pt.ea)for(ne=0;ne<Pt.ea.length;++ne){Gt=Pt.ea[ne],Re=It.data,sn=Re.addNormalizedLandmark,We=ie,Gt=Object.assign({},Gt,{visibility:Gt.visibility?Gt.visibility:0});var Ae=new Wi;Nn(Ae,1,Gt.x),Nn(Ae,2,Gt.y),Nn(Ae,3,Gt.z),Gt.visibility&&Nn(Ae,4,Gt.visibility),Gt=Ae.l(),sn.call(Re,We,Gt)}if(Pt.ba)for(ne=0;ne<Pt.ba.length;++ne)Re=It.data,sn=Re.addClassification,We=ie,Gt=Pt.ba[ne],Ae=new Qs,Nn(Ae,2,Gt.qa),Gt.index&&In(Ae,1,Gt.index),Gt.label&&In(Ae,3,Gt.label),Gt.displayName&&In(Ae,4,Gt.displayName),Gt=Ae.l(),sn.call(Re,We,Gt)}It=It.data;break t;default:It={}}}switch(J=It,ut=G.stream,G.type){case"video":D.pushTexture2d(Object.assign({},J,{stream:ut,timestamp:S}));break;case"detections":St=J,St.stream=ut,St.timestamp=S,D.pushDetectionList(St);break;default:throw Error("Unknown input config type: '"+G.type+"'")}}return x.j.send(D),C(bt,x.I,4);case 4:D.delete(),bt.h=0}})};function hx(d,y,x){var S,D,T,R,P,G,J,ut,St,bt,dt,It,Pt,ie;return E(function(ne){switch(ne.h){case 1:if(!x)return ne.return(y);for(S={},D=0,T=a(Object.keys(x)),R=T.next();!R.done;R=T.next())P=R.value,G=x[P],typeof G!="string"&&G.type==="texture"&&y[G.stream]!==void 0&&++D;1<D&&(d.M=!1),J=a(Object.keys(x)),R=J.next();case 2:if(R.done){ne.h=4;break}if(ut=R.value,St=x[ut],typeof St=="string")return Pt=S,ie=ut,C(ne,dx(d,ut,y[St]),14);if(bt=y[St.stream],St.type==="detection_list"){if(bt){for(var Re=bt.getRectList(),sn=bt.getLandmarksList(),We=bt.getClassificationsList(),Gt=[],Ae=0;Ae<Re.size();++Ae){var rs=Jb(Re.get(Ae)),fx=$n(rs,1),mx=$n(rs,2),gx=$n(rs,3),yx=$n(rs,4),bx=$n(rs,5,0),Po=void 0;Po=Po===void 0?0:Po,rs={la:{sa:fx,ta:mx,height:gx,width:yx,rotation:bx,pa:Ro(dn(rs,6),Po)},ea:Ta(sn.get(Ae)),ba:tx(Yb(We.get(Ae)))},Gt.push(rs)}Re=Gt}else Re=[];S[ut]=Re,ne.h=7;break}if(St.type==="proto_list"){if(bt){for(Re=Array(bt.size()),sn=0;sn<bt.size();sn++)Re[sn]=bt.get(sn);bt.delete()}else Re=[];S[ut]=Re,ne.h=7;break}if(bt===void 0){ne.h=3;break}if(St.type==="float_list"){S[ut]=bt,ne.h=7;break}if(St.type==="proto"){S[ut]=bt,ne.h=7;break}if(St.type!=="texture")throw Error("Unknown output config type: '"+St.type+"'");return dt=d.v[ut],dt||(dt=new za(d.i,d.K),d.v[ut]=dt),C(ne,jc(dt,bt,d.M),13);case 13:It=ne.i,S[ut]=It;case 7:St.transform&&S[ut]&&(S[ut]=St.transform(S[ut])),ne.h=3;break;case 14:Pt[ie]=ne.i;case 3:R=J.next(),ne.h=2;break;case 4:return ne.return(S)}})}function dx(d,y,x){var S;return E(function(D){return typeof x=="number"||x instanceof Uint8Array||x instanceof d.i.Uint8BlobList?D.return(x):x instanceof d.i.Texture2dDataOut?(S=d.v[y],S||(S=new za(d.i,d.K),d.v[y]=S),D.return(jc(S,x,d.M))):D.return(void 0)})}function px(d,y){for(var x=y.name||"$",S=[].concat(l(y.wants)),D=new d.i.StringList,T=a(y.wants),R=T.next();!R.done;R=T.next())D.push_back(R.value);T=d.i.PacketListener.implement({onResults:function(P){for(var G={},J=0;J<y.wants.length;++J)G[S[J]]=P.get(J);var ut=d.listeners[x];ut&&(d.I=hx(d,G,y.outs).then(function(St){St=ut(St);for(var bt=0;bt<y.wants.length;++bt){var dt=G[S[bt]];typeof dt=="object"&&dt.hasOwnProperty&&dt.hasOwnProperty("delete")&&dt.delete()}St&&(d.I=St)}))}}),d.j.attachMultiListener(D,T),D.delete()}n.onResults=function(d,y){this.listeners[y||"$"]=d},_("Solution",Fa),_("OptionType",{BOOL:0,NUMBER:1,ua:2,0:"BOOL",1:"NUMBER",2:"STRING"});function Xc(d){switch(d===void 0&&(d=0),d){case 1:return"pose_landmark_full.tflite";case 2:return"pose_landmark_heavy.tflite";default:return"pose_landmark_lite.tflite"}}function qc(d){var y=this;d=d||{},this.h=new Fa({locateFile:d.locateFile,files:function(x){return[{url:"pose_solution_packed_assets_loader.js"},{simd:!1,url:"pose_solution_wasm_bin.js"},{simd:!0,url:"pose_solution_simd_wasm_bin.js"},{data:!0,url:Xc(x.modelComplexity)}]},graph:{url:"pose_web.binarypb"},listeners:[{wants:["pose_landmarks","world_landmarks","segmentation_mask","image_transformed"],outs:{image:{type:"texture",stream:"image_transformed"},poseLandmarks:{type:"proto",stream:"pose_landmarks",transform:Ta},poseWorldLandmarks:{type:"proto",stream:"world_landmarks",transform:Ta},segmentationMask:{type:"texture",stream:"segmentation_mask"}}}],inputs:{image:{type:"video",stream:"input_frames_gpu"}},options:{useCpuInference:{type:0,graphOptionXref:{calculatorType:"InferenceCalculator",fieldName:"use_cpu_inference"},default:typeof window!="object"||window.navigator===void 0?!1:"iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document},selfieMode:{type:0,graphOptionXref:{calculatorType:"GlScalerCalculator",calculatorIndex:1,fieldName:"flip_horizontal"}},modelComplexity:{type:1,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorModelComplexity",fieldName:"int_value"},onChange:function(x){var S,D,T;return E(function(R){return R.h==1?(S=Xc(x),D="third_party/mediapipe/modules/pose_landmark/"+S,C(R,Mo(y.h,S),2)):(T=R.i,y.h.overrideFile(D,T),R.return(!0))})}},smoothLandmarks:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothLandmarks",fieldName:"bool_value"}},enableSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorEnableSegmentation",fieldName:"bool_value"}},smoothSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothSegmentation",fieldName:"bool_value"}},minDetectionConfidence:{type:1,graphOptionXref:{calculatorType:"TensorsToDetectionsCalculator",calculatorName:"poselandmarkgpu__posedetectiongpu__TensorsToDetectionsCalculator",fieldName:"min_score_thresh"}},minTrackingConfidence:{type:1,graphOptionXref:{calculatorType:"ThresholdingCalculator",calculatorName:"poselandmarkgpu__poselandmarkbyroigpu__tensorstoposelandmarksandsegmentation__ThresholdingCalculator",fieldName:"threshold"}}}})}n=qc.prototype,n.reset=function(){this.h.reset()},n.close=function(){return this.h.close(),Promise.resolve()},n.onResults=function(d){this.h.onResults(d)},n.initialize=function(){var d=this;return E(function(y){return C(y,d.h.initialize(),0)})},n.send=function(d,y){var x=this;return E(function(S){return C(S,x.h.send(d,y),0)})},n.setOptions=function(d){this.h.setOptions(d)},_("Pose",qc),_("POSE_CONNECTIONS",[[0,1],[1,2],[2,3],[3,7],[0,4],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[13,15],[15,17],[15,19],[15,21],[17,19],[12,14],[14,16],[16,18],[16,20],[16,22],[18,20],[11,23],[12,24],[23,24],[23,25],[24,26],[25,27],[26,28],[27,29],[28,30],[29,31],[30,32],[27,31],[28,32]]),_("POSE_LANDMARKS",{NOSE:0,LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,LEFT_EAR:7,RIGHT_EAR:8,LEFT_RIGHT:9,RIGHT_LEFT:10,LEFT_SHOULDER:11,RIGHT_SHOULDER:12,LEFT_ELBOW:13,RIGHT_ELBOW:14,LEFT_WRIST:15,RIGHT_WRIST:16,LEFT_PINKY:17,RIGHT_PINKY:18,LEFT_INDEX:19,RIGHT_INDEX:20,LEFT_THUMB:21,RIGHT_THUMB:22,LEFT_HIP:23,RIGHT_HIP:24,LEFT_KNEE:25,RIGHT_KNEE:26,LEFT_ANKLE:27,RIGHT_ANKLE:28,LEFT_HEEL:29,RIGHT_HEEL:30,LEFT_FOOT_INDEX:31,RIGHT_FOOT_INDEX:32}),_("POSE_LANDMARKS_LEFT",{LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,LEFT_EAR:7,LEFT_RIGHT:9,LEFT_SHOULDER:11,LEFT_ELBOW:13,LEFT_WRIST:15,LEFT_PINKY:17,LEFT_INDEX:19,LEFT_THUMB:21,LEFT_HIP:23,LEFT_KNEE:25,LEFT_ANKLE:27,LEFT_HEEL:29,LEFT_FOOT_INDEX:31}),_("POSE_LANDMARKS_RIGHT",{RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,RIGHT_EAR:8,RIGHT_LEFT:10,RIGHT_SHOULDER:12,RIGHT_ELBOW:14,RIGHT_WRIST:16,RIGHT_PINKY:18,RIGHT_INDEX:20,RIGHT_THUMB:22,RIGHT_HIP:24,RIGHT_KNEE:26,RIGHT_ANKLE:28,RIGHT_HEEL:30,RIGHT_FOOT_INDEX:32}),_("POSE_LANDMARKS_NEUTRAL",{NOSE:0}),_("VERSION","0.5.1675469404")}).call(Ma);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Je=he();Je.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE",()=>15);Je.registerFlag("WEBGPU_CPU_FORWARD",()=>!0);Je.registerFlag("WEBGPU_MATMUL_PROGRAM_TYPE",()=>-1);Je.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE",()=>!0);Je.registerFlag("WEBGPU_USE_LOW_POWER_GPU",()=>!1);Je.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e3);Je.registerFlag("WEBGPU_USE_PROFILE_TOOL",()=>!1);Je.registerFlag("WEBGPU_IMPORT_EXTERNAL_TEXTURE",()=>!0);Je.registerFlag("WEBGPU_USE_NAIVE_CONV2D_DEBUG",()=>!1);Je.registerFlag("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL",()=>-1);Je.registerFlag("WEBGPU_CONV_SEPARATE_IM2COL_SHADER",()=>!1);Je.registerFlag("WEBGPU_PRINT_SHADER",()=>"");Je.registerFlag("WEBGPU_ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sD{constructor(t){t&&(this.vendor=t.vendor,this.architecture=t.architecture,this.intelGPUGeneration=this.getIntelGPUGeneration())}getIntelGPUGeneration(){if(this.isIntel()){if(this.architecture.startsWith("gen"))return Number(this.architecture.match(/\d+/));if(this.architecture.startsWith("xe"))return 12}return 0}isIntel(){return this.vendor==="intel"}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iD{constructor(t){this.device=t,this.numUsedBuffers=0,this.numFreeBuffers=0,this.freeBuffers=new Map,this.usedBuffers=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireBuffer(t,e,s=!1,i=!0){let o;const r=Lh(t,e);return i?(this.freeBuffers.has(r)||this.freeBuffers.set(r,[]),this.freeBuffers.get(r).length>0?(o=this.freeBuffers.get(r).pop(),this.numFreeBuffers--):(o=this.device.createBuffer({size:t,usage:e,mappedAtCreation:s}),this.numBytesAllocated+=t)):(o=this.device.createBuffer({size:t,usage:e,mappedAtCreation:s}),this.numBytesAllocated+=t),this.usedBuffers.has(r)||this.usedBuffers.set(r,[]),this.usedBuffers.get(r).push(o),this.numUsedBuffers++,this.numBytesUsed+=t,o}releaseBuffer(t,e=!0){if(this.freeBuffers.size===0)return;const s=t.size,i=t.usage,o=Lh(s,i),r=this.usedBuffers.get(o),a=r.indexOf(t);if(a<0)throw new Error("Cannot find the buffer in buffer manager");r[a]=r[r.length-1],r.pop(),this.numUsedBuffers--,this.numBytesUsed-=s,e?(this.freeBuffers.get(o).push(t),this.numFreeBuffers++):(t.destroy(),this.numBytesAllocated-=s)}getNumUsedBuffers(){return this.numUsedBuffers}getNumFreeBuffers(){return this.numFreeBuffers}dispose(){this.freeBuffers.forEach((t,e)=>{t.forEach(s=>{s.destroy()})}),this.usedBuffers.forEach((t,e)=>{t.forEach(s=>{s.destroy()})}),this.freeBuffers=new Map,this.usedBuffers=new Map,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function Lh(n,t){return`${n}_${t}`}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oD{constructor(t){this.device=t,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures=new Map,this.usedTextures=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireTexture(t,e,s,i){const o=_h(s),r=t*e*o,a=Oh(t,e,s,i);if(this.freeTextures.has(a)||this.freeTextures.set(a,[]),this.usedTextures.has(a)||this.usedTextures.set(a,[]),this.numBytesUsed+=r,this.numUsedTextures++,this.freeTextures.get(a).length>0){this.numFreeTextures--;const u=this.freeTextures.get(a).shift();return this.usedTextures.get(a).push(u),u}this.numBytesAllocated+=r;const l=this.device.createTexture({size:[t,e],format:s,usage:i});return this.usedTextures.get(a).push(l),l}releaseTexture(t){if(this.freeTextures.size===0)return;const e=t.width,s=t.height,i=t.format,o=t.usage,r=Oh(e,s,i,o);this.freeTextures.has(r)||this.freeTextures.set(r,[]),this.freeTextures.get(r).push(t),this.numFreeTextures++,this.numUsedTextures--;const a=this.usedTextures.get(r),l=a.indexOf(t);if(l<0)throw new Error("Cannot release a texture that was never provided by this texture manager");a.splice(l,1);const u=_h(i),c=e*s*u;this.numBytesUsed-=c}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){this.freeTextures.forEach((t,e)=>{t.forEach(s=>{s.destroy()})}),this.usedTextures.forEach((t,e)=>{t.forEach(s=>{s.destroy()})}),this.freeTextures=new Map,this.usedTextures=new Map,this.numUsedTextures=0,this.numFreeTextures=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function Oh(n,t,e,s){return`${n}_${t}_${e}_${s}`}function _h(n){if(n==="rgba8unorm")return 16;throw new Error(`${n} is not supported!`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rD(n,t){if(Math.max(...n)>5)throw new Error("Cannot symbolically compute strides for rank > 6 tensor.");const e=n.length,s="xyzwuv",i=n.map(r=>`${t}.${s[r]}`),o=new Array(e-1);o[e-2]=i[e-1];for(let r=e-3;r>=0;--r)o[r]=`(${o[r+1]} * ${i[r+1]})`;return o}const Cs=(n,t,e)=>e==="int32"?`atomicAdd(${n}, bitcast<i32>(${t}));`:`
          {
            var oldValue = 0;
            loop {
              let newValueF32 = bitcast<f32>(oldValue) + (${t});
              let newValue = bitcast<i32>(newValueF32);
              let res = atomicCompareExchangeWeak(${n}, oldValue, newValue);
              if res.exchanged {
                break;
              }
              oldValue = res.old_value;
            }
          }`;/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var bi;(function(n){n[n.FROM_PIXELS=0]="FROM_PIXELS",n[n.DRAW=1]="DRAW"})(bi||(bi={}));const aD=(n,t,e,s,i)=>{const o={dtype:s.dtype,shape:s.shape},r=uD(e,o,t),a=n.createShaderModule({code:r,label:t.constructor.name});let l=he().get("WEBGPU_PRINT_SHADER");if(l!==""){l=l.toLowerCase();const u=l.split(",");(l==="all"||u.some(c=>t.shaderKey.toLowerCase().includes(c)))&&(console.group(t.shaderKey),console.debug(r),console.groupEnd())}return i?n.createComputePipelineAsync({compute:{module:a,entryPoint:"_start"},label:t.constructor.name,layout:"auto"}):n.createComputePipeline({compute:{module:a,entryPoint:"_start"},label:t.constructor.name,layout:"auto"})},Rt=(n,t="f32")=>{switch(n){case 1:return`${t}`;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw new Error(`${n}-component ${t} is not supported.`)}};function de(n){if(n<=1)return"i32";if(n===2)return"vec2<i32>";if(n===3)return"vec3<i32>";if(n===4)return"vec4<i32>";if(n===5)return"vec5";if(n===6)return"vec6";throw Error(`GPU for rank ${n} is not yet supported`)}function Yn(n){if(n===0)return"x";if(n===1)return"y";if(n===2)return"z";if(n===3)return"w";if(n===4)return"u";if(n===5)return"v";throw Error(`Index ${n} is not yet supported`)}function ot(...n){let t;switch(n.length){case 0:t=`
        fn main()
      `;break;case 1:t=`
        fn main(${n[0]} : i32)
      `;break;default:throw Error("Unreachable")}return t}function Bh(n,t){let e;return e=`
     ${lD(t)}
      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
                @builtin(global_invocation_id) GlobalId : vec3<u32>,
                @builtin(local_invocation_index) LocalIndex: u32,
                @builtin(workgroup_id) WorkgroupId : vec3<u32>,
                @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {
        localId = LocalId;
        localIndex = LocalIndex;
        globalId = GlobalId;
        numWorkgroups = NumWorkgroups;
        workgroupId = WorkgroupId;
        ${n?"main(getGlobalIndex());":"main();"};
      }
    `,e}function lD(n){return`
  @compute @workgroup_size(${n.workgroupSize[0]}, ${n.workgroupSize[1]}, ${n.workgroupSize[2]})
`}function uD(n,t,e){const s=[],i=e.workgroupSize[0]*e.workgroupSize[1]*e.workgroupSize[2];if(e.outputComponent=e.outputComponent?e.outputComponent:1,s.push(`

      var<private> localId: vec3<u32>;
      var<private> localIndex: u32;
      var<private> globalId: vec3<u32>;
      var<private> numWorkgroups: vec3<u32>;
      var<private> workgroupId: vec3<u32>;

      // Only used when the y/z dimension of workgroup size is 1.
      fn getGlobalIndex() -> i32 {
        ${Ly(e)?"  return i32(globalId.x);":`  return i32((workgroupId.z * numWorkgroups.x * numWorkgroups.y +
                workgroupId.y * numWorkgroups.x + workgroupId.x) * ${i}u +
                localIndex);
        `}
      }
    `),e.pixelsOpType!=null){const m=e.pixelsOpType===bi.FROM_PIXELS?`@group(0) @binding(0) var<storage, read_write> result: array<${Rs(t.dtype,e.outputComponent)}>;`:`@group(0) @binding(1) var<storage, read> inBuf : array<${Rs(n[0].dtype,e.outputComponent)}>;`,g=t.shape.length===3?"vec2<i32>":"i32";s.push(`
        struct Uniform {
          outShapeStrides : ${g},
          size            : i32,
          numChannels     : i32,
          alpha           : f32,
        };

        ${m}
        @group(0) @binding(2) var<uniform> uniforms: Uniform;
      `);const b=Vh(e);return[Wh,s.join(`
`),Wo(t.shape),e.getUserCode(),Bh(b,e)].join(`
`)}let o,r,a="struct Uniforms { NAN : f32, INFINITY : f32, ";e.variableNames.forEach((m,g)=>{const b=de(n[g].shape.length);a+=`${m.charAt(0).toLowerCase()+m.slice(1)}Shape : ${b}, `,o=n[g].shape.length-1,r=de(o),a+=`${m.charAt(0).toLowerCase()+m.slice(1)}ShapeStrides: ${r}, `});const l=de(t.shape.length);a+=`outShape : ${l}, `,o=t.shape.length-1,r=de(o),a+=`
         outShapeStrides: ${r}, `,e.size&&(a+="size : i32, "),e.uniforms&&(a+=e.uniforms),a+="};",a=bD(a),s.push(a),e.atomic?s.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;
    `):s.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<${Rs(t.dtype,e.outputComponent)}>;
    `),e.variableNames.forEach((m,g)=>{s.push(`
      @group(0) @binding(${1+g}) var<storage, read> ${m}: array<${e.variableComponents?Rs(n[g].dtype,e.variableComponents[g]):Rs(n[g].dtype,e.outputComponent)}>;
        `)}),a!==""&&s.push(`
      @group(0) @binding(${1+e.variableNames.length}) var<uniform> uniforms: Uniforms;
      `);const u=mD(t.shape,e.dispatchLayout),c=[Wh,s.join(`
`)+hD,Wo(t.shape),u,gD(t.shape.length)];e.atomic||c.push(yD(t.shape,t.dtype,e.outputComponent)),e.variableNames.forEach((m,g)=>{c.push(`${Wo(n[g].shape,m)}`)});const h=n.map((m,g)=>fD(m,t.shape,e.variableComponents?e.variableComponents[g]:e.outputComponent,e.dispatchLayout.x.length===t.shape.length)).join(`
`);c.push(h),c.push(e.getUserCode());const p=Vh(e);return c.push(Bh(p,e)),c.join(`
`)}function cD(n,t,e){let s=n.shaderKey;if(n.pixelsOpType!=null)return s;const i=[],o=[];t.forEach(c=>{i.push(c.shape),o.push(c.dtype)}),i.push(e.shape),o.push(e.dtype);const r=t.map(c=>nm(c.shape,e.shape)),a=t.map(c=>ke(c.shape,e.shape)).join("_"),l=r.map(c=>c.join("_")).join(";"),u=Ly(n)?"flatDispatch":"";return s+="_"+(n.workgroupSize?n.workgroupSize.join(","):"")+i.map(c=>c.length).join(",")+o.join(",")+n.variableNames.join(",")+l+a+u,s}const Wh=`
  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};
  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};

  // Checks whether coordinates lie within the bounds of the shape.
  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {
    return all(coord >= vec2<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {
    return all(coord >= vec3<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {
    return all(coord >= vec4<i32>(0)) && all(coord < shape);
  }

  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {
    return coord;
  }
  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {
    return dot(coords, vec2<i32>(shape.y, 1));
  }
  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {
    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));
  }
  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
    return dot(coords, vec4<i32>(
        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
  }
  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {
    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;
  }
  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {
    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;
  }

  // NaN defination in IEEE 754-1985 is :
  //   - sign = either 0 or 1.
  //   - biased exponent = all 1 bits.
  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).
  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers
  fn isnan(val: f32) -> bool {
    let floatToUint: u32 = bitcast<u32>(val);
    return (floatToUint & 0x7fffffffu) > 0x7f800000u;
  }
  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {
    let floatToUint: vec4<u32> = bitcast<vec4<u32>>(val);
    return (floatToUint & vec4<u32>(0x7fffffffu)) > vec4<u32>(0x7f800000u);
  }
`,hD=`
  fn isinf(val: f32) -> bool {
    return abs(val) == uniforms.INFINITY;
  }
`;function Wo(n,t=""){const e=n.length,s=t!==""?`get${t.charAt(0).toUpperCase()+t.slice(1)}CoordsFromIndex`:"getCoordsFromIndex",i=t!==""?`${t.charAt(0).toLowerCase()+t.slice(1)}ShapeStrides`:"outShapeStrides";if(e<=1)return`fn ${s}(index : i32) -> i32 { return index; }`;const o=Tt(n),r=de(e),a=[];for(let u=0;u<e;u++)a.push(`d${u}`);if(o.length===1)return`    fn ${s}(index : i32) -> vec2<i32> {
      let d0 = index / uniforms.${i}; let d1 = index - d0 * uniforms.${i};
      return vec2<i32>(d0, d1);
    }`;let l;return l="var index2 = index;"+o.map((u,c)=>{const h=`let ${a[c]} = index2 / uniforms.${i}.${Yn(c)}`,p=c===o.length-1?`let ${a[c+1]} = index2 - ${a[c]} * uniforms.${i}.${Yn(c)}`:`index2 = index2 - ${a[c]} * uniforms.${i}.${Yn(c)}`;return`${h}; ${p};`}).join(""),`
    fn ${s}(index : i32) -> ${r} {
      ${l}
      return ${r}(${a.join(",")});
    }
  `}function dD(n,t){const e=n.name,s=n.shape.length,i=de(s),o="get"+e.charAt(0).toUpperCase()+e.slice(1),r=["d0","d1","d2","d3","d4","d5"].slice(0,s),a=r.map(c=>`${c} : i32`).join(", ");if(s<1)return`
      fn ${o}() -> ${Rt(t)} {
        return ${Rt(t)}(${e}[0]);
      }
    `;const l=`uniforms.${e.charAt(0).toLowerCase()+e.slice(1)}Shape`;let u=`${s}D`;return s===0&&(u="1D"),`
    fn ${o}(${a}) -> ${Rt(t)} {
      return ${Rt(t)}(${e}[getIndexFromCoords${u}(${i}(${r.join(",")}),
        ${l})${t===1?"":` / ${t}`}]);
    }
   `}function pD(n,t,e,s){const i=n.name,o=i.charAt(0).toUpperCase()+i.slice(1),r="get"+o+"ByOutput",a=n.shape.length,l=t.length,u=de(l);if(ke(n.shape,t)&&s)return`
    fn ${r}Index(globalIndex : i32) -> ${Rt(e)} {
      return ${Rt(e)}(${i}[globalIndex]);
    }

    fn ${r}Coords(coords : ${u}) -> ${Rt(e)} {
      return ${Rt(e)}(${i}[${l>1?"getOutputIndexFromCoords(coords)":"coords"}${e===1?"":` / ${e}`}]);
    }
    `;const c=nm(n.shape,t),h=l-a;let p="";if(a===0)return`
    fn ${r}Index(globalIndex : i32) -> ${Rt(e)}{
      return get${o}();
    }

    fn ${r}Coords(coords : ${u}) -> ${Rt(e)}{
      return get${o}();
    }
  `;l<2&&c.length>=1?p="coords = 0;":p=c.map(b=>`coords.${Yn(b+h)} = 0;`).join(`
`);let f="";if(l<2&&a>0)f="coords";else if(l>1){const b=de(a),v=n.shape.map((w,k)=>`coords.${Yn(k+h)}`).join(", ");f=`${b}(${v})`}else f="coords";const m=`uniforms.${i.charAt(0).toLowerCase()+i.slice(1)}Shape`,g=`${a}D`;return`
  fn ${r}Index(globalIndex : i32) -> ${Rt(e)} {
    var coords = getCoordsFromIndex(globalIndex);
    ${p}
    return ${Rt(e)}(${i}[getIndexFromCoords${g}(${f}, ${m})${e===1?"":` / ${e}`}]);
  }

  fn ${r}Coords(coordsIn : ${u}) -> ${Rt(e)} {
    var coords = coordsIn;
    ${p}
    return ${Rt(e)}(${i}[getIndexFromCoords${g}(${f}, ${m})${e===1?"":` / ${e}`}]);
  }
`}function fD(n,t,e,s){let i=dD(n,e);return n.shape.length<=t.length&&(i+=pD(n,t,e,s)),i}function mD(n,t){const{x:e,y:s=[],z:i=[]}=t,o=n.length,r=e.length+s.length+i.length;if(r!==o)return"";if(e.length===o)return`fn getOutputCoords() -> ${de(o)}{
    let globalIndex = getGlobalIndex();
    return getCoordsFromIndex(globalIndex);
  }
  `;let a="";const l=[e,s,i];for(let p=0;p<l.length;p++){const f=l[p];if(f.length!==0)if(f.length===1)a+=`let d${f[0]} = i32(globalId[${p}]);`;else{const m=rD(f,"uniforms.outShape");a+=`var index${p} = i32(globalId[${p}]);`;for(let g=0;g<m.length;g++)a+=`let d${f[g]} = index${p} / ${m[g]};`,g===m.length-1?a+=`let d${f[g+1]} = index${p} - d${f[g]} * ${m[g]};`:a+=`index${p} = index${p} - d${f[g]} * ${m[g]};`}}const u=[];for(let p=0;p<r;p++)u.push(`d${p}`);const c=de(r);let h=`fn getOutputCoords() -> ${c} {
  ${a}
`;return u.length===0?h+=`return ${c}(0); }`:h+=`return ${c}(${u.join(",")}); }`,h}function gD(n){let t="";switch(n){case 0:case 1:t+=`
        fn getOutputIndexFromCoords(coords : i32) -> i32 {
          return coords;
        }
        `;break;case 2:t+=`
        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {
          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));
        }
        `;break;case 3:t+=`
        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {
          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));
        }
        `;break;case 4:t+=`
        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
          return dot(coords, vec4<i32>(
            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));
        }
        `;break;case 5:t+=`
        fn getOutputIndexFromCoords(coords : vec5) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u;
        }
        `;break;case 6:t+=`
        fn getOutputIndexFromCoords(coords : vec6) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u * uniforms.outShapeStrides.u +
              coords.v;
        }
        `;break;default:tt(!1,()=>`Unsupported ${n}D shape`);break}return t}function Ly(n){return n.dispatch[1]===1&&n.dispatch[2]===1}function Rs(n,t=1){if(n==="float32")return Rt(t,"f32");if(n==="int32"||n==="bool")return Rt(t,"i32");throw new Error(`type ${n} is not supported.`)}function yD(n,t,e){const s=n.length,i=Rs(t,e);let o=`fn setOutputAtIndex(flatIndex : i32, value : ${Rt(e)}) {
      result[flatIndex] = ${i}(value);
    }

    fn setOutputAtIndexI32(flatIndex : i32, value : ${Rt(e,"i32")}) {
      result[flatIndex] = ${i}(value);
    }
    `;if(s>=2){const r=["d0","d1","d2","d3","d4","d5"].slice(0,s),a=de(s);o+=`
      fn setOutputAtCoords(${r.map(l=>`${l} : i32`).join(", ")}, value : ${Rt(e)}) {
        let flatIndex = getOutputIndexFromCoords(${a}(${r.join(", ")}));
        setOutputAtIndex(flatIndex${e===1?"":` / ${e}`}, value);
      }
      fn setOutputAtCoordsI32(${r.map(l=>`${l} : i32`).join(", ")}, value : ${Rt(e,"i32")}) {
        let flatIndex = getOutputIndexFromCoords(${a}(${r.join(", ")}));
        setOutputAtIndexI32(flatIndex${e===1?"":` / ${e}`}, value);
      }
    `}return o}function bD(n){const t=/(\w+)\s*:\s*vec(5|6)/g;n=n.replace(t,s=>"@align(16) "+s);const e=/vec(5|6)\s*,\s*(\w+)/g;return n=n.replace(e,(s,i,o)=>`vec${i}, @align(16) ${o}`),n}function Vh(n){return!(n.dispatchLayout.hasOwnProperty("y")&&n.dispatchLayout.y.length!==0||n.dispatchLayout.hasOwnProperty("z")&&n.dispatchLayout.z.length!==0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ps=n=>{let t=1;for(let e=0;e<n.length;e++)t*=n[e];return t};function rt(n,t,e=[1,1,1],s=[1,1,1]){const[i,o,r]=[Math.ceil(Ps(n.x.map(a=>t[a]))/(e[0]*s[0])),n.y?Math.ceil(Ps(n.y.map(a=>t[a]))/(e[1]*s[1])):1,n.z?Math.ceil(Ps(n.z.map(a=>t[a]))/(e[2]*s[2])):1];return[i,o,r]}function xD(n,t,e,s=!1){const i=[8,8,1],o=[4,4,1];return s||(n<=8&&(o[1]=1),t<=16&&e<=16&&(i[0]=4)),{workgroupSize:i,elementsPerThread:o}}function Oy(n,t,e=!1){if(e)return[8,8,1];const s=Ps(n.x.map(o=>t[o])),i=Ps(n.y.map(o=>t[o]));return s<=4?[4,16,1]:i<=4?[16,4,1]:[16,16,1]}function _y(n,t,e=!1){if(e)return[4,4,1];const s=Ps(n.x.map(o=>t[o])),i=Ps(n.y.map(o=>t[o]));return s<=4?[1,2,1]:i<=4?[2,1,1]:[2,2,1]}function ht(n){return{x:n.map((t,e)=>e)}}function Uh(n){if(n==="float32"||n==="int32"||n==="bool"||n==="string")return 4;if(n==="complex64")return 8;throw new Error(`Unknown dtype ${n}`)}function By(){return!!(typeof globalThis<"u"&&globalThis.navigator&&globalThis.navigator.gpu)}function Wy(n,t){Array.isArray(n)||(n=[n]),n.forEach(e=>{e!=null&&tt(e.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the WebGPU backend.`)})}var Rn;(function(n){n[n.MatMulReduceProgram=0]="MatMulReduceProgram",n[n.MatMulSplitKProgram=1]="MatMulSplitKProgram",n[n.MatMulSmallOutputSizeProgram=2]="MatMulSmallOutputSizeProgram",n[n.MatMulPackedProgram=3]="MatMulPackedProgram",n[n.MatMulMax=4]="MatMulMax"})(Rn||(Rn={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wD=he().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD"),vD=(n,t)=>{const e=n.limits.maxComputeWorkgroupsPerDimension,s=t.dispatchLayout,i=t.dispatch;if(i.every(r=>r<=e))return i;tt(i[0]>e&&s.y===void 0&&s.z===void 0,()=>"Dispatch size exceeds WebGPU limits in Y or Z dimension.");let o=Math.ceil(Math.sqrt(i[0]));return o>e?(o=Math.ceil(Math.cbrt(i[0])),tt(o<=e,()=>"Total dispatch size exceeds WebGPU maximum."),[o,o,o]):[o,o,1]};class Ai extends Ap{nextDataId(){return Ai.nextDataId++}constructor(t,e){if(super(),this.commandQueueOwnedIds=new WeakSet,this.dispatchCountInPass=0,this.disposed=!1,this.downloadWaitMs=0,this.tensorDataPendingDisposal=[],this.queryResolveBuffer=null,this.querySet=null,this.querySetCount=2,this.stagingPendingDisposal=[],this.uniformPendingDisposal=[],this.uploadWaitMs=0,this.hasReadSyncWarned=!1,this.hasTimestampQueryWarned=!1,!By())throw new Error("WebGPU is not supported on this device");this.pipelineCache={},this.device=t,this.queue=t.queue,this.commandEncoder=null,this.computePassEncoder=null,this.adapterInfo=new sD(e),this.supportTimestampQuery=this.device.features.has("timestamp-query"),this.thresholdToIncreaseWorkgroups=this.adapterInfo.intelGPUGeneration>=12?16:8,this.bufferManager=new iD(this.device),this.textureManager=new oD(this.device),this.tensorMap=new Tp(this,us()),he().getBool("WEBGPU_USE_PROFILE_TOOL")&&(this.dummyCanvas=document.createElement("canvas"),this.dummyCanvas.width=1,this.dummyCanvas.height=1,this.dummyContext=this.dummyCanvas.getContext("webgpu"),this.dummyContext.configure({device:t,format:"bgra8unorm"}),document.body.appendChild(this.dummyCanvas))}floatPrecision(){return 32}disposeData(t,e=!1){if(!this.tensorMap.has(t))return!0;const s=this.tensorMap.get(t);return e?s.refCount=0:s.refCount--,s.refCount>0?!1:(s.complexTensorInfos!=null&&(this.disposeData(s.complexTensorInfos.real.dataId),this.disposeData(s.complexTensorInfos.imag.dataId)),this.commandQueueOwnedIds.has(t)?(this.tensorDataPendingDisposal.push(t),!0):(this.releaseResource(t),this.tensorMap.delete(t),!0))}memory(){return{numBytesInGPU:this.bufferManager.numBytesUsed,numBytesAllocatedInGPU:this.bufferManager.numBytesAllocated,unreliable:!1}}releaseResource(t){const e=this.tensorMap.get(t);if(!(!e||!e.resource)){if(e.external){e.resource=null;return}e.resource instanceof GPUBuffer?this.bufferManager.releaseBuffer(e.resource):e.resource instanceof GPUTexture&&this.textureManager.releaseTexture(e.resource),e.resource=null}}refCount(t){return this.tensorMap.has(t)?this.tensorMap.get(t).refCount:0}incRef(t){const e=this.tensorMap.get(t);e.refCount++}decRef(t){if(this.tensorMap.has(t)){const e=this.tensorMap.get(t);e.refCount--}}write(t,e,s){if(s==="complex64"&&t!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const i={id:this.nextDataId()};return this.tensorMap.set(i,{dtype:s,shape:e,values:t,refCount:1}),i}move(t,e,s,i,o){if(i==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.tensorMap.set(t,{dtype:i,shape:s,values:e,refCount:o})}submitQueue(){this.queue.submit([this.commandEncoder.finish()]),this.commandEncoder=null,this.dispatchCountInPass=0,this.commandQueueOwnedIds=new WeakSet,this.tensorDataPendingDisposal.forEach(t=>{this.releaseResource(t),this.tensorMap.delete(t)}),this.uniformPendingDisposal.forEach(t=>this.bufferManager.releaseBuffer(t)),this.stagingPendingDisposal.forEach(t=>this.bufferManager.releaseBuffer(t,!1)),this.tensorDataPendingDisposal=[],this.uniformPendingDisposal=[],this.stagingPendingDisposal=[]}ensureCommandEncoderReady(){this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder())}endComputePassEncoder(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}async checkCompileCompletionAsync(){let t;try{t=await Promise.all(Object.values(this.pipelineCache))}catch(e){throw new Error(e.message)}Object.keys(this.pipelineCache).map((e,s)=>{this.pipelineCache[e]=t[s]})}async getBufferData(t){if(he().getBool("WEBGPU_ENGINE_COMPILE_ONLY"))return console.warn("The data may be invalid since WEBGPU_ENGINE_COMPILE_ONLY is true, this can only be called when WEBGPU_ENGINE_COMPILE_ONLY is false"),null;const e=t.size,s=this.bufferManager.acquireBuffer(e,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(t,0,s,0,e),this.submitQueue(),await s.mapAsync(GPUMapMode.READ);const i=s.getMappedRange().slice(0);return s.unmap(),s!=null&&this.bufferManager.releaseBuffer(s),he().getBool("WEBGPU_USE_PROFILE_TOOL")&&(tt(this.dummyContext!==void 0,()=>"Fail to get context for profiling tool"),this.dummyContext.getCurrentTexture()),i}convertAndCacheOnCPU(t,e){const s=this.tensorMap.get(t);return s.values=e,s.values}readSync(t){const e=this.tensorMap.get(t),{values:s,complexTensorInfos:i}=e;if(s!=null||e.dtype==="string")return s;if(e.dtype==="complex64"){const g=this.readSync(i.real.dataId),b=this.readSync(i.imag.dataId),v=Bo(di(g,b).buffer,"float32");return this.convertAndCacheOnCPU(t,v),v}this.hasReadSyncWarned||(this.hasReadSyncWarned=!0,console.warn("The performance of synchronously reading data from GPU to CPU is poor on the webgpu backend, please use asynchronous APIs instead."));const o=["opaque","premultiplied"],r=e.resource,a=r.size;tt(a%4===0,()=>"Because there is 4 bytes for one pixel, buffer size must be multiple of 4.");const l=a/4,u=new ArrayBuffer(a),c=256,h=256,p=o.map(g=>new OffscreenCanvas(c,h)),f=new OffscreenCanvas(c,h);this.endComputePassEncoder(),p.map((g,b)=>{const v=g.getContext("webgpu");return v.configure({device:this.device,format:"bgra8unorm",usage:GPUTextureUsage.COPY_DST,alphaMode:o[b]}),v.getCurrentTexture()}).map((g,b)=>{const v=c*4,w=(A,z,F)=>{this.ensureCommandEncoderReady(),this.commandEncoder.copyBufferToTexture({buffer:r,bytesPerRow:v,offset:F},{texture:g},{width:A,height:z}),this.submitQueue();const E=f.getContext("2d",{willReadFrequently:!0});E.clearRect(0,0,A,z),E.drawImage(p[b],0,0);const U=E.getImageData(0,0,A,z).data,L=o[b],W=new Uint8ClampedArray(u,F,A*z*4);for(let _=0;_<W.length;_+=4)if(L==="premultiplied")W[_+3]=U[_+3];else{const V=U[_];W[_]=U[_+2],W[_+1]=U[_+1],W[_+2]=V}},k=Math.floor(l/(c*h));let C=c,I=h,N=0;for(let A=0;A<k;A++)w(C,I,N),N+=c*h*4;const $=l%(c*h);I=Math.floor($/c),I>0&&(w(C,I,N),N+=I*(c*4)),C=$%c,C>0&&w(C,1,N)});const m=Bo(u,e.dtype);return this.convertAndCacheOnCPU(t,m),m}async read(t){if(!this.tensorMap.has(t))throw new Error(`Tensor ${t} was not registered!`);const e=this.tensorMap.get(t),{values:s}=e;if(s!=null)return s;let i;if(e.dtype==="complex64"){const o=await Promise.all([this.read(e.complexTensorInfos.real.dataId),this.read(e.complexTensorInfos.imag.dataId)]),r=o[0],a=o[1];i=di(r,a)}else{const o=await this.getBufferData(e.resource);i=Bo(o,e.dtype)}return this.convertAndCacheOnCPU(t,i),i}copyBuffer(t){const e=t.size,s=t.usage,i=this.bufferManager.acquireBuffer(e,s);return this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(t,0,i,0,e),this.submitQueue(),i}createTensorFromGPUData(t,e,s){let i=t.buffer;if(s==="complex64")throw new Error("Cannot write to a complex64 dtype. ");const o={id:this.nextDataId()};this.tensorMap.set(o,{dtype:s,shape:e,values:null,refCount:1,external:t.zeroCopy});const r=this.tensorMap.get(o),a=Uh(r.dtype)*et(r.shape);if(t.buffer.size<a)throw new Error(`GPUBuffer size(${t.buffer.size}) is smaller than tensor size(${a})!`);if((t.buffer.usage&(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))!==(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))throw new Error("GPUBuffer.usage should include GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC!");return t.zeroCopy!==!0&&(i=this.copyBuffer(i)),r.resource=i,us().makeTensorFromDataId(o,e,s,this)}readToGPU(t){const e=this.tensorMap.get(t),{values:s,dtype:i,shape:o,resource:r}=e;if(i==="complex64")throw new Error("Does not support reading buffer for complex64 dtype.");if(r==null)throw s!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const a=r,l=a.size,u=a.usage,c=this.bufferManager.acquireBuffer(l,u);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(r,0,c,0,l),this.submitQueue();const h=this.makeTensorInfo(o,i),p=us().makeTensorFromTensorInfo(h),f=this.tensorMap.get(h.dataId);return f.resource=c,{tensorRef:p,buffer:c}}bufferSync(t){const e=this.readSync(t.dataId);if(t.dtype==="string")try{const s=e.map(i=>ho(i));return le(t.shape,t.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return le(t.shape,t.dtype,e)}async time(t){!this.supportTimestampQuery&&!this.hasTimestampQueryWarned&&(console.warn("This device doesn't support timestamp-query extension. Start Chrome browser with flag --enable-dawn-features=allow_unsafe_apis to try it again. Otherwise, zero will be shown for the kernel time when profiling mode is enabled."),this.hasTimestampQueryWarned=!0);const e=this.activeTimers,s=[];let i=!1;this.programTimersStack==null?(this.programTimersStack=s,i=!0):this.activeTimers.push(s),this.activeTimers=s,t();const o=eh(this.activeTimers.map(u=>u.query)).filter(u=>u!=null),r=eh(this.activeTimers.map(u=>u.name)).filter(u=>u!=null);this.activeTimers=e,i&&(this.programTimersStack=null);const a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},l=await Promise.all(o);return a.kernelMs=y1(l),a.getExtraProfileInfo=()=>l.map((u,c)=>({name:r[c],ms:u})).map(u=>`${u.name}: ${u.ms}`).join(", "),this.uploadWaitMs=0,this.downloadWaitMs=0,a}makeTensorInfo(t,e,s){return e==="string"&&s!=null&&s.length>0&&zp(s[0])&&(s=s.map(o=>Fp(o))),{dataId:this.write(s,t,e),shape:t,dtype:e}}tensorToBinding(t){if(!t)return null;const s=this.tensorMap.get(t.dataId).resource;return s instanceof GPUBuffer?{buffer:s}:s instanceof GPUTexture?s.createView():s}uploadToGPU(t){const e=this.tensorMap.get(t);if(e.resource!=null)return;const s=Uh(e.dtype)*et(e.shape);let i;const o=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST;if(e.values){if(i=this.bufferManager.acquireBuffer(s,o,!0),i.mapState==="unmapped"){const r=this.bufferManager.acquireBuffer(s,GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,!0,!1),a=r.getMappedRange();e.dtype==="int32"||e.dtype==="bool"?new Int32Array(a).set(e.values):new Float32Array(a).set(e.values),r.unmap(),this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(r,0,i,0,s),this.stagingPendingDisposal.push(r)}else{const r=i.getMappedRange();e.dtype==="int32"||e.dtype==="bool"?new Int32Array(r).set(e.values):new Float32Array(r).set(e.values),i.unmap()}e.values=null}else i=this.bufferManager.acquireBuffer(s,o);e.resource=i}makeUniforms(t){let e=0,s=0;const i=[];let o=1;t.forEach(l=>{l.data.length===0&&(l.data=[1]);let u;switch(l.data.length){case 1:u=4;break;case 2:u=8;break;case 3:u=16;break;case 4:u=16;break;case 5:u=16;break;case 6:u=16;break;default:tt(!1,()=>`Unsupported ${l.data.length}D shape`)}(s===5||s===6)&&(u=16),u>o&&(o=u),e=Math.ceil(e/u)*u,s=l.data.length,i.push(e),e+=l.data.length*4}),e=Math.ceil(e/o)*o;const r=new ArrayBuffer(e);t.forEach((l,u)=>{const c=i[u];l.type==="int32"?new Int32Array(r,c,l.data.length).set(l.data):l.type==="uint32"?new Uint32Array(r,c,l.data.length).set(l.data):new Float32Array(r,c,l.data.length).set(l.data)});const a=this.bufferManager.acquireBuffer(e,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);return this.queue.writeBuffer(a,0,r,0,e),this.uniformPendingDisposal.push(a),{offset:0,size:e,buffer:a}}runWebGPUProgram(t,e,s,i,o){if(o||(o=this.makeTensorInfo(t.outputShape,s)),et(o.shape)===0)return this.tensorMap.get(o.dataId).values=Ln(o.dtype,0),o;this.uploadToGPU(o.dataId),t.dispatch=vD(this.device,t);const r=e.map((l,u)=>{if(l.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");return this.uploadToGPU(l.dataId),{dtype:this.tensorMap.get(l.dataId).dtype,shape:l.shape,name:t.variableNames[u]}});t.shaderKey=cD(t,r,o);const a=he().getBool("WEBGPU_ENGINE_COMPILE_ONLY");return t.shaderKey in this.pipelineCache||(this.pipelineCache[t.shaderKey]=aD(this.device,t,r,o,a)),t.pipeline=this.pipelineCache[t.shaderKey],a||this.recordAndSubmit(t,o,e,i),o}recordAndSubmit(t,e,s,i){if(t.pipeline instanceof Promise)throw new Error("Please call checkCompileCompletionAsync to ensure parallel compilation is done!");let o=[],r=[];const a="int32";if(t.pixelsOpType==null){o.push({type:"float32",data:[NaN]},{type:"float32",data:[1/0]}),r=s.concat(e).map(f=>f.shape);const p="int32";r.map(f=>{o.push({type:p,data:f});const m=Tt(f);o.push({type:p,data:m})})}else{const p=Tt(e.shape);o.push({type:a,data:p})}if(t.size){const p=et(t.outputShape);o.push({type:a,data:[t.outputComponent?p/t.outputComponent:p]})}i&&(o=[...o,...i]);const l=[this.tensorToBinding(e),...s.map(p=>this.tensorToBinding(p)),this.makeUniforms(o)];s.forEach(p=>{this.commandQueueOwnedIds.add(p.dataId)}),this.commandQueueOwnedIds.add(e.dataId);const u=this.device.createBindGroup({layout:t.pipeline.getBindGroupLayout(0),entries:l.map((p,f)=>({binding:f,resource:p}))}),c=this.activeTimers!=null;this.ensureCommandEncoderReady();const h={};c&&this.supportTimestampQuery?(this.endComputePassEncoder(),this.querySet==null&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.querySetCount})),h.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:0,endOfPassWriteIndex:1},this.computePassEncoder=this.commandEncoder.beginComputePass(h)):this.computePassEncoder||(this.computePassEncoder=this.commandEncoder.beginComputePass(h)),this.computePassEncoder.setPipeline(t.pipeline),this.computePassEncoder.setBindGroup(0,u),this.computePassEncoder.dispatchWorkgroups(t.dispatch[0],t.dispatch[1],t.dispatch[2]),this.dispatchCountInPass++,(c||he().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE")<=this.dispatchCountInPass||t.pixelsOpType===bi.DRAW)&&(this.endComputePassEncoder(),c?this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime()}):this.submitQueue())}async getQueryTime(){if(!this.supportTimestampQuery)return 0;this.queryResolveBuffer==null&&(this.queryResolveBuffer=this.bufferManager.acquireBuffer(this.querySetCount*8,GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST|GPUBufferUsage.QUERY_RESOLVE)),this.commandEncoder.resolveQuerySet(this.querySet,0,this.querySetCount,this.queryResolveBuffer,0);const t=this.bufferManager.acquireBuffer(this.querySetCount*8,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,t,0,this.querySetCount*8),this.submitQueue(),await t.mapAsync(GPUMapMode.READ);const e=new BigUint64Array(t.getMappedRange()),s=Number(e[1]-e[0])/1e6;return t.unmap(),this.bufferManager.releaseBuffer(t),s}shouldExecuteOnCPU(t,e=wD){return he().getBool("WEBGPU_CPU_FORWARD")&&t.every(s=>this.tensorMap.get(s.dataId).resource==null&&et(s.shape)<e)}numDataIds(){return this.tensorMap.numDataIds()-this.tensorDataPendingDisposal.length}dispose(){this.disposed||(this.querySet!=null&&this.querySet.destroy(),this.bufferManager.dispose(),this.textureManager.dispose(),this.disposed=!0)}}Ai.nextDataId=0;/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */By()&&Mp("webgpu",async()=>{const n={powerPreference:he().get("WEBGPU_USE_LOW_POWER_GPU")?"low-power":"high-performance"},t=await navigator.gpu.requestAdapter(n),e={},s=[];t.features.has("timestamp-query")&&s.push("timestamp-query"),t.features.has("bgra8unorm-storage")&&s.push(["bgra8unorm-storage"]),e.requiredFeatures=s;const i=t.limits;e.requiredLimits={maxComputeWorkgroupStorageSize:i.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:i.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:i.maxStorageBufferBindingSize,maxBufferSize:i.maxBufferSize,maxComputeWorkgroupSizeX:i.maxComputeWorkgroupSizeX,maxComputeInvocationsPerWorkgroup:i.maxComputeInvocationsPerWorkgroup};const o=await t.requestDevice(e),r=await t.requestAdapterInfo();return new Ai(o,r)},3);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var vt;(function(n){n[n.ADD=0]="ADD",n[n.ATAN2=1]="ATAN2",n[n.COMPLEX_MULTIPLY_IMAG=2]="COMPLEX_MULTIPLY_IMAG",n[n.COMPLEX_MULTIPLY_REAL=3]="COMPLEX_MULTIPLY_REAL",n[n.DIV=4]="DIV",n[n.ELU_DER=5]="ELU_DER",n[n.EQUAL=6]="EQUAL",n[n.FLOOR_DIV=7]="FLOOR_DIV",n[n.GREATER=8]="GREATER",n[n.GREATER_EQUAL=9]="GREATER_EQUAL",n[n.LESS=10]="LESS",n[n.LESS_EQUAL=11]="LESS_EQUAL",n[n.LOGICAL_AND=12]="LOGICAL_AND",n[n.LOGICAL_OR=13]="LOGICAL_OR",n[n.MAX=14]="MAX",n[n.MIN=15]="MIN",n[n.MOD=16]="MOD",n[n.MUL=17]="MUL",n[n.NOT_EQUAL=18]="NOT_EQUAL",n[n.POW=19]="POW",n[n.PRELU=20]="PRELU",n[n.SQUARED_DIFFERENCE=21]="SQUARED_DIFFERENCE",n[n.SUB=22]="SUB"})(vt||(vt={}));const CD="let resultTemp = a + b;",kD="let resultTemp = atan2(a, b);",SD="let resultTemp = areal * breal - aimag * bimag;",ID="let resultTemp = areal * bimag + aimag * breal;",ND="let resultTemp = a / b;",$D="let resultTemp = select(a * (b + 1.0), a, b >= b - b);",DD=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a == b);
`,RD=`
  let remainder =
      select(a % b, round(a % b), (round(a) == a) & (round(b) == b));
  let quotient = (a - remainder) / b;
  let resultTemp =
      round(select(quotient, quotient - 1, sign(remainder) == -sign(b)));
`,AD=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a > b);
`,TD=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a >= b);
`,zD=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a < b);
`,FD=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a <= b);
`,MD="return f32(a >= 1.0 && b >= 1.0);",PD=`return (vec4<f32>(a >= vec4<f32>(1.0)) *
  vec4<f32>(b >= vec4<f32>(1.0)));`,ED="return f32(a >= 1.0 || b >= 1.0);",LD=`return min(vec4<f32>(a >= vec4<f32>(1.0)) +
  vec4<f32>(b >= vec4<f32>(1.0)), vec4<f32>(1.0));`,OD="let resultTemp = max(a, b);",_D="let resultTemp = min(a, b);",BD=`
  let isNaN = b == 0.;
  var resultTemp = a % b;
  resultTemp = select((resultTemp + b) % b, resultTemp,
      (a < 0. && b < 0.) || (a >= 0. && b > 0.));
`,WD=`
  let isNaN = !vec4<bool>(b);
  var resultTemp = vec4<f32>(a % b);
  if (!((a[0] < 0. && b[0] < 0.) || (a[0] >= 0. && b[0] > 0.))) {
    resultTemp[0] = (resultTemp[0] + b[0]) % b[0];
  }
  if (!((a[1] < 0. && b[1] < 0.) || (a[1] >= 0. && b[1] > 0.))) {
    resultTemp[1] = (resultTemp[1] + b[1]) % b[1];
  }
  if (!((a[2] < 0. && b[2] < 0.) || (a[2] >= 0. && b[2] > 0.))) {
    resultTemp[2] = (resultTemp[2] + b[2]) % b[2];
  }
  if (!((a[3] < 0. && b[3] < 0.) || (a[3] >= 0. && b[3] > 0.))) {
    resultTemp[3] = (resultTemp[3] + b[3]) % b[3];
  }
`,VD="let resultTemp = a * b;",UD=`
  var resultTemp = f32(a != b);
  let valueForNaN = 1.0;
`,GD=`
  var resultTemp = vec4<f32>(a != b);
  let valueForNaN = 1.0;
`,HD=`
  let isNaN = a < 0.0 && floor(b) < b;
  if (b == 0.0) {
    return 1.0;
  }
  var resultTemp = select(sign(a) * pow(abs(a), b), pow(abs(a), b),
      round(abs(b) % 2.0) != 1.0);
`,jD=`
  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);
  let isModRound1 = vec4<f32>(isModRound1Bool);
  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);
  var resultTemp = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  let isExpZero = b == vec4<f32>(0.0);
  if (isExpZero.r) {
    resultTemp.r = 1.0;
  }
  if (isExpZero.g) {
    resultTemp.g = 1.0;
  }
  if (isExpZero.b) {
    resultTemp.b = 1.0;
  }
  if (isExpZero.a) {
    resultTemp.a = 1.0;
  }
  let isNaN = (a < vec4<f32>(0.0)) & (floor(b) < b);
`,KD="if (a < 0.0) { return b * a; }  return a;",XD=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`,qD="let resultTemp = (a - b) * (a - b);",YD="let resultTemp = a - b;";function uc(n,t){let e;do{switch(n){case vt.ATAN2:e=kD;break;case vt.MAX:e=OD;break;case vt.MIN:e=_D;break;case vt.MOD:e=t?WD:BD;break;case vt.NOT_EQUAL:e=t?GD:UD;break;case vt.POW:e=t?jD:HD;break;default:continue}let s,i,o;return t?(s="isnanVec4",i="vec4<f32>",o="vec4<bool>"):(s="isnan",i="f32",o="bool"),`
      let aIsNaN = ${s}(a);
      let aPostLegalization = select(a, ${i}(42), aIsNaN);
      let bIsNaN = ${s}(b);
      let bPostLegalization = select(b, ${i}(42), bIsNaN);
      let isNaN = false;
      let valueForNaN = uniforms.NAN;
      {
        let a = aPostLegalization;
        let b = bPostLegalization;
        ${e}
        return select(
            resultTemp, ${i}(valueForNaN),
            ${o}(isNaN) | aIsNaN | bIsNaN);
      }
    `}while(!1);switch(n){case vt.ADD:e=CD;break;case vt.COMPLEX_MULTIPLY_IMAG:e=ID;break;case vt.COMPLEX_MULTIPLY_REAL:e=SD;break;case vt.DIV:e=ND;break;case vt.ELU_DER:e=$D;break;case vt.EQUAL:e=DD;break;case vt.FLOOR_DIV:e=RD;break;case vt.GREATER:e=AD;break;case vt.GREATER_EQUAL:e=TD;break;case vt.LESS:e=zD;break;case vt.LESS_EQUAL:e=FD;break;case vt.LOGICAL_AND:return t?PD:MD;case vt.LOGICAL_OR:return t?LD:ED;case vt.MUL:e=VD;break;case vt.PRELU:return t?XD:KD;case vt.SQUARED_DIFFERENCE:e=qD;break;case vt.SUB:e=YD;break}return`
    ${e}
    return resultTemp;
  `}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var st;(function(n){n[n.ABS=0]="ABS",n[n.ACOS=1]="ACOS",n[n.ACOSH=2]="ACOSH",n[n.ASIN=3]="ASIN",n[n.ASINH=4]="ASINH",n[n.ATAN=5]="ATAN",n[n.ATANH=6]="ATANH",n[n.CEIL=7]="CEIL",n[n.COS=8]="COS",n[n.COSH=9]="COSH",n[n.ELU=10]="ELU",n[n.ERF=11]="ERF",n[n.EXP=12]="EXP",n[n.EXPM1=13]="EXPM1",n[n.FLOOR=14]="FLOOR",n[n.IS_FINITE=15]="IS_FINITE",n[n.IS_INF=16]="IS_INF",n[n.IS_NAN=17]="IS_NAN",n[n.LINEAR=18]="LINEAR",n[n.LOG=19]="LOG",n[n.LOG1P=20]="LOG1P",n[n.LOGICAL_NOT=21]="LOGICAL_NOT",n[n.NEG=22]="NEG",n[n.RELU=23]="RELU",n[n.RELU6=24]="RELU6",n[n.LEAKYRELU=25]="LEAKYRELU",n[n.RECIPROCAL=26]="RECIPROCAL",n[n.ROUND=27]="ROUND",n[n.RSQRT=28]="RSQRT",n[n.SELU=29]="SELU",n[n.SIGMOID=30]="SIGMOID",n[n.SIGN=31]="SIGN",n[n.SIN=32]="SIN",n[n.SINH=33]="SINH",n[n.SOFTPLUS=34]="SOFTPLUS",n[n.SQRT=35]="SQRT",n[n.SQUARE=36]="SQUARE",n[n.STEP=37]="STEP",n[n.TAN=38]="TAN",n[n.TANH=39]="TANH",n[n.TO_INT=40]="TO_INT"})(st||(st={}));const ZD="return abs(a);",QD=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return acos(a);
`,JD=`
  if (a < 1.) {
    return uniforms.NAN;
  }
  return acosh(a);
`,tR=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return asin(a);
`,eR="return asinh(a);",nR=`
  if (isnan(a)) {
    return uniforms.NAN;
  }
  return atan(a);
`,sR=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  if (a == 1.) {
    return uniforms.INFINITY;
  }
  if (a == -1.) {
    return -uniforms.INFINITY;
  }
  return atanh(a);
`,iR="return ceil(a);",oR="return cos(a);",rR=`
  let e2x = exp(-a);
  return (e2x + 1.0 / e2x) / 2.0;
`,aR="return exp(a) - 1.0;",lR="if (a >= 0.0) { return a; }  return (exp(a) - 1.0);",uR=`
  var resFloat = exp(a) - vec4<f32>(1.0);
  if (a.r >= 0.0) {
    resFloat.r = a.r;
  }
  if (a.g >= 0.0) {
    resFloat.g = a.g;
  }
  if (a.b >= 0.0) {
    resFloat.b = a.b;
  }
  if (a.a >= 0.0) {
    resFloat.a = a.a;
  }
  return resFloat;
`,cR=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  let p = ${mf};
  let a1 = ${cf};
  let a2 = ${hf};
  let a3 = ${df};
  let a4 = ${pf};
  let a5 = ${ff};

  let sign = sign(a);
  let absA = abs(a);
  let t = 1.0 / (1.0 + p * absA);
  return sign * (1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-absA * absA));
`,hR="return exp(a);",dR="return floor(a);",pR="return f32(!isnan(a) && !isinf(a));",fR="return f32(isinf(a));",mR="return f32(isnan(a));",gR="return a;",yR=`if (a < 0.0) { return uniforms.NAN; }
  return log(a);`,bR=`
  if (isnan(a)) { return a; }
  return log(1.0 + a);
`,xR="return f32(!(a >= 1.0));",wR="return -a;",vR="if (a < 0.0) { return uniforms.alpha * a; } return a;",CR=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`,kR="return 1.0 / a;",SR="return select(a, 0.0, a < 0.0);",IR="return clamp(a, 0.0, 6.0);",NR="return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));",$R=`
  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));
`,DR="return round(a);",RR="return inverseSqrt(a);",AR=`
  if (a >= 0.0) {
    return ${pu} * a;
  } else {
    return ${du} * (exp(a) - 1.0);
  }
`,TR="return 1.0 / (1.0 + exp(-1.0 * a));",zR="return sign(a);",FR="return sin(a);",MR=`
  let e2x = exp(a);
  return (e2x - 1.0 / e2x) / 2.0;
`,PR=`
  let epsilon = 1.1920928955078125e-7;
  let threshold = log(epsilon) + 2.0;

  let too_large = a > -threshold;
  let too_small = a < threshold;
  let exp_a = exp(a);

  if (too_large) {
    return a;
  } else if (too_small) {
    return exp_a;
  } else {
    return log(exp_a + 1.0);
  }
`,ER="return sqrt(a);",LR="return a * a;",OR=`
  if (isnan(a)) {
    return a;
  }

  return select(uniforms.stepAlpha, 1.0, a > 0.0);
`,_R="return tan(a);",BR=`
  let e2x = exp(-2.0 * abs(a));
  return sign(a) * (1.0 - e2x) / (1.0 + e2x);
`,WR="return f32(i32((a)));";function $s(n,t){switch(n){case st.ABS:return ZD;case st.ACOS:return QD;case st.ACOSH:return JD;case st.ASIN:return tR;case st.ASINH:return eR;case st.ATAN:return nR;case st.ATANH:return sR;case st.COS:return oR;case st.COSH:return rR;case st.CEIL:return iR;case st.ELU:return t?uR:lR;case st.ERF:return cR;case st.EXP:return hR;case st.EXPM1:return aR;case st.FLOOR:return dR;case st.IS_FINITE:return pR;case st.IS_INF:return fR;case st.IS_NAN:return mR;case st.LINEAR:return gR;case st.LOG:return yR;case st.LOG1P:return bR;case st.LOGICAL_NOT:return xR;case st.NEG:return wR;case st.LEAKYRELU:return t?CR:vR;case st.RECIPROCAL:return kR;case st.RELU:return t?$R:SR;case st.RELU6:return t?NR:IR;case st.ROUND:return DR;case st.RSQRT:return RR;case st.SELU:return AR;case st.SIGMOID:return TR;case st.SIGN:return zR;case st.SIN:return FR;case st.SINH:return MR;case st.SOFTPLUS:return PR;case st.SQRT:return ER;case st.SQUARE:return LR;case st.STEP:return OR;case st.TAN:return _R;case st.TANH:return BR;case st.TO_INT:return WR;default:throw new Error(`BinaryType ${n} is not implemented!`)}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function is(n,t=!1,e=!1,s=3){if(n===null)return"";let i="";if(n==="linear")i=$s(st.LINEAR);else if(n==="relu")i=$s(st.RELU,e);else if(n==="elu")i=$s(st.ELU,e);else if(n==="relu6")i=$s(st.RELU6,e);else if(n==="prelu")i=uc(vt.PRELU,e);else if(n==="sigmoid")i=$s(st.SIGMOID,e);else if(n==="leakyrelu")i=$s(st.LEAKYRELU,e);else throw new Error(`Activation ${n} has not been implemented for the WebGPU backend.`);const r=Rt(e?4:1);let a="";return t?a=`
      fn activation(a : ${r}, coords : vec${s}<i32>) -> ${r} {
        let b = getPreluActivationWeightsByOutputCoords(coords);
        ${i}
      }`:a=`
      fn activation(a : ${r}, coords : vec${s}<i32>) -> ${r} {
        ${i}
      }`,a}function Ks(n,t){return`
      ${n?"value = value + getBiasByOutputCoords(coords);":""}
      ${t?"value = activation(value, coords);":""}
      `}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vy(n,t,e=!1,s=!1,i=!1,o=1){tt(n&&o===1||!n,()=>`transposeA ${n} is not compatible with component size ${o}`);const r=`
      ${n?"value = getA(batch, col, row);":"value = getA(batch, row, col);"}

    `,a=t?"value = getB(batch, col, row);":"value = getB(batch, row, col);";return`
  fn mm_readA(batch: i32, row: i32, col: i32) -> ${Rt(o)} {
    var value = ${Rt(o)}(0.0);
    ${e&&i?r:`
    ${n?"if(row < uniforms.dimAOuter && col < uniforms.dimInner)":"if(row < uniforms.aShape[1] && col < uniforms.aShape[2])"}
    {
      ${r}
    }
    `}
    return value;
  }

  fn mm_readB(batch: i32, row: i32, col: i32) -> ${Rt(o)} {
    var value = ${Rt(o)}(0.0);
    ${a}
    return value;
  }
  `}function cc(n,t,e,s,i=!1,o=!1,r=!1,a=1){return`
  ${Vy(e,s,i,o,r,a)}
  fn mm_write(batch: i32, row: i32, col: i32, valueIn: ${Rt(a)}) {
    ${i&&o?"":"if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)"}
    {
      var value = valueIn;
      let coords = vec3<i32>(batch, row, col);
      ${Ks(n,t)}
      setOutputAtCoords(coords[0], coords[1], coords[2], value);
    }
  }
  `}const VR=(n,t)=>n?`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol * ${t});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRow + innerRow,
          kStart + inputCol * ${t});
        `,UR=(n,t,e,s)=>{if(n)return`
      for (var k = 0; k < ${s}; k++) {
        let BCached0 = mm_Bsub[k][tileCol];
        let ACached0 = mm_Asub[k][localRow];
        for (var i = 0; i < ${e}; i++) {
          acc[i] = fma(BCached0, vec4<f32>(ACached0[i]), acc[i]);
        }
      }`;{let i="",o="";for(let r=0;r<t;r++)i+=`let BCached${r} = mm_Bsub[k * ${t} + ${r}][tileCol];`,o+=`acc[i] = fma(BCached${r}, vec4<f32>(ACached[${r}]), acc[i]);`;return`
      for (var k = 0; k < ${s/t}; k++) {
        ${i}
        for (var i = 0; i < ${e}; i++) {
          let ACached = mm_Asub[tileRow + i][k];
          ${o}
        }
      }`}};function ha(n,t,e=!1,s=32,i=!1,o=32,r=!1){const a=t[1]*n[1],l=t[0]*n[0],u=e?a:s,c=e?s:a,h=u/t[0],p=s/t[1],f=n[1],m=n[0];return tt((e&&h===4&&n[1]===4||!e&&(h===3||h===4))&&u%t[0]===0&&s%t[1]===0&&n[0]===4,()=>`If transposeA ${e} is true, innerElementSize ${h} and workPerThread[1] ${n[1]} must be 4.
          Otherwise, innerElementSize ${h} must be 3 or 4.
      tileAWidth ${u} must be divisible by workgroupSize[0]${t[0]}. tileInner ${s} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${n[0]} must be 4.`),`
  var<workgroup> mm_Asub : array<array<vec${h}<f32>, ${u/h}>, ${c}>;
  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${l/n[0]}>, ${s}>;

  ${ot()} {
    let localRow = i32(localId.y);
    let tileRow = localRow * ${f};
    let tileCol = i32(localId.x);

    let globalRow = i32(globalId.y) * ${f};
    let globalCol = i32(globalId.x) * ${m};
    let batch = ${i?"0":"i32(globalId.z)"};
    let batchA = ${i||!r?"batch":"batch % uniforms.aShape[0]"};
    let batchB = ${i||!r?"batch":"batch % uniforms.bShape[0]"};
    let globalRowStart = i32(workgroupId.y) * ${a};

    let numTiles = ${i?`${Math.ceil(o/s)}`:`(uniforms.dimInner - 1) / ${s} + 1`};
    var kStart = ${i?`i32(globalId.z) * ${o}`:"0"};

    var acc: array<vec4<f32>, ${f}>;

    // Loop over shared dimension.
    let tileRowB = localRow * ${p};
    for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var innerRow = 0; innerRow < ${f}; innerRow++) {
            let inputRow = tileRow + innerRow;
            let inputCol = tileCol;
            ${VR(e,h)}
        }

        // Load one tile of B into local memory.
        for (var innerRow = 0; innerRow < ${p}; innerRow++) {
            let inputRow = tileRowB + innerRow;
            let inputCol = tileCol;
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB, kStart + inputRow, globalCol);
        }
        kStart = kStart + ${s};
        workgroupBarrier();

        // Compute acc values for a single thread.
        ${UR(e,h,f,s)}
        workgroupBarrier();
    }

    for (var innerRow = 0; innerRow < ${f}; innerRow++) {
        mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
    }
  }`}const Gh=n=>n?`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol);
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRowStart + inputRow,
          kStart + inputCol);
        `,GR=n=>n?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];";function da(n,t,e=!1,s=32,i=!1,o=32,r=!1,a=!1){const l=n[1]*t[1],u=n[0]*t[0],c=e?l:s,h=e?s:l;tt(h%t[1]===0&&c%t[0]===0&&s%t[1]===0,()=>`tileAHight ${h} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${c} must be divisible by workgroupSize[0]${t[0]}, tileInner ${s} must be divisible by workgroupSize[1]${t[1]}`);const p=h/t[1],f=c/t[0],m=s/t[1],g=n[1],b=n[0],v=r?`
      let localRow = i32(localId.y);
      let localCol = i32(localId.x);
      let globalRowStart = i32(workgroupId.y) * ${l};
      let globalColStart = i32(workgroupId.x) * ${u};

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var inputRow = localRow; inputRow < ${h}; inputRow = inputRow + ${t[1]}) {
          for (var inputCol = localCol; inputCol < ${c}; inputCol = inputCol + ${t[0]}) {
            ${Gh(e)}
          }
        }
        // Load one tile of B into local memory.
        for (var inputRow = localRow; inputRow < ${s}; inputRow = inputRow + ${t[1]}) {
              for (var inputCol = localCol; inputCol < ${u}; inputCol = inputCol + ${t[0]}) {
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
              kStart + inputRow,
              globalColStart + inputCol);
          }
        }
        kStart = kStart + ${s};
        workgroupBarrier();

        // Compute acc values for a single thread.
        var BCached : array<f32, ${b}>;
        for (var k = 0; k < ${s}; k++) {
          for (var inner = 0; inner < ${b}; inner++) {
            BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];
          }
          for (var innerRow = 0; innerRow < ${g}; innerRow++) {
            let ACached = ${e?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}
            for (var innerCol = 0; innerCol < ${b}; innerCol++) {
              acc[innerRow][innerCol] =
                  fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
            }
          }
        }
        workgroupBarrier();
      }
      for (var innerRow = 0; innerRow < ${g}; innerRow++) {
        let gRow = globalRowStart + localRow + innerRow * ${t[1]};
        for (var innerCol = 0; innerCol < ${b}; innerCol++) {
          let gCol = globalColStart + localCol + innerCol * ${t[0]};
          mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
        }
      }
      `:`
  let tileRow = i32(localId.y) * ${g};
  let tileCol = i32(localId.x) * ${b};

  let globalRow = i32(globalId.y) * ${g};
  let globalCol = i32(globalId.x) * ${b};
  let globalRowStart = i32(workgroupId.y) * ${l};

  let tileRowA = i32(localId.y) * ${p};
  let tileColA = i32(localId.x) * ${f};
  let tileRowB = i32(localId.y) * ${m};
  // Loop over shared dimension.
  for (var t = 0; t < numTiles; t++) {
    // Load one tile of A into local memory.
    for (var innerRow = 0; innerRow < ${p}; innerRow++) {
      for (var innerCol = 0; innerCol < ${f}; innerCol++) {
        let inputRow = tileRowA + innerRow;
        let inputCol = tileColA + innerCol;
        ${Gh(e)}
      }
    }

    // Load one tile of B into local memory.
    for (var innerRow = 0; innerRow < ${m}; innerRow++) {
      for (var innerCol = 0; innerCol < ${b}; innerCol++) {
        let inputRow = tileRowB + innerRow;
        let inputCol = tileCol + innerCol;
        mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
          kStart + inputRow,
          globalCol + innerCol);
      }
    }
    kStart = kStart + ${s};
    workgroupBarrier();

    // Compute acc values for a single thread.
    var BCached : array<f32, ${b}>;
    for (var k = 0; k < ${s}; k++) {
      for (var inner = 0; inner < ${b}; inner++) {
        BCached[inner] = mm_Bsub[k][tileCol + inner];
      }

      for (var innerRow = 0; innerRow < ${g}; innerRow++) {
        ${GR(e)}
        for (var innerCol = 0; innerCol < ${b}; innerCol++) {
          acc[innerRow][innerCol] =
              fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
        }
      }
    }

    workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < ${g}; innerRow++) {
    for (var innerCol = 0; innerCol < ${b}; innerCol++) {
      mm_write(batch, globalRow + innerRow, globalCol + innerCol,
          acc[innerRow][innerCol]);
    }
  }
  `;return`
    var<workgroup> mm_Asub : array<array<f32, ${c}>, ${h}>;
    var<workgroup> mm_Bsub : array<array<f32, ${u}>, ${s}>;

    ${ot()} {
      let batch = ${i?"0":"i32(globalId.z)"};
      let batchA = ${i||!a?"batch":"batch % uniforms.aShape[0]"};
      let batchB = ${i||!a?"batch":"batch % uniforms.bShape[0]"};
      let numTiles = ${i?`${Math.ceil(o/s)}`:`(uniforms.dimInner - 1) / ${s} + 1`};
      var kStart = ${i?`i32(globalId.z) * ${o}`:"0"};

      var acc : array<array<f32, ${b}>, ${g}>;

      // Without this initialization strange values show up in acc.
      for (var innerRow = 0; innerRow < ${g}; innerRow++) {
        for (var innerCol = 0; innerCol < ${b}; innerCol++) {
          acc[innerRow][innerCol] = 0.0;
        }
      }
      ${v}
    }
  `}const HR=n=>n?`
      mm_readA(batchA, colA, globalRow),
      mm_readA(batchA, colA + 1, globalRow),
      mm_readA(batchA, colA + 2, globalRow),
      mm_readA(batchA, colA + 3, globalRow)
  `:`
      mm_readA(batchA, globalRow, colA),
      mm_readA(batchA, globalRow, colA + 1),
      mm_readA(batchA, globalRow, colA + 2),
      mm_readA(batchA, globalRow, colA + 3)
  `;function jR(n,t=!1){tt(n[1]===1&&n[2]===1,()=>`A linear work group size is required. But got ${n}.`);const e=n[0]*4;return`
    var<workgroup> mm_Asub : array<vec4<f32>, ${n[0]}>;

    ${ot()} {
      let tileCol = i32(localId.x);
      let globalCol = i32(globalId.x);
      let globalRow = i32(globalId.y);

      let numTiles = (uniforms.dimInner - 1) / ${e} + 1;
      let batch = i32(globalId.z);
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      // Without this initialization strange values show up in acc.
      var acc = 0.0;

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        let colA = t * ${e} + tileCol * 4;
        mm_Asub[tileCol] = vec4<f32>(${HR(t)});
        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < ${e/4}; k++) {
          let rowB = t * ${e} + k * 4;
          let BCached = vec4<f32>(mm_readB(batchB, rowB, globalCol),
                              mm_readB(batchB, rowB + 1, globalCol),
                              mm_readB(batchB, rowB + 2, globalCol),
                              mm_readB(batchB, rowB + 3, globalCol));

          let ACached = mm_Asub[k];
          acc = acc + dot(ACached, BCached);
        }

        workgroupBarrier();
      }

      mm_write(batch, globalRow, globalCol, acc);
    }
  `}class KR{constructor(t,e,s=!1,i=!1,o=null,r=null,a=null,l=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e,this.dispatchLayout={x:[2],y:[1],z:[0]};const u=s?t[1]:t[2];if(this.isVec4=(u%4===0&&!s||e[1]%4===0&&s)&&e[2]%4===0&&!i,this.outputComponent=this.isVec4?4:1,this.isVectorA=e[1]===1&&!s,!this.isVec4&&this.isVectorA)this.elementsPerThread=[1,1,1],this.workgroupSize=[32,1,1];else{const p=xD(e[1],u,e[2],s);this.workgroupSize=p.workgroupSize,this.elementsPerThread=p.elementsPerThread}this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread);const c=o!=null,h=a!=null;c&&this.variableNames.push("bias"),h&&this.variableNames.push("preluActivationWeights"),this.sequentialAccessByThreads=l,this.transposeA=s,this.transposeB=i,this.addBias=c,this.activation=r,this.hasPreluActivationWeights=h,[this.fitAOuter,this.fitBOuter,this.fitInner]=this.getShapeFit(e[1],e[2],u),this.shaderKey=`matMulPacked_${this.elementsPerThread}_${s}_${i}_${this.activation}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.isVectorA}_${this.sequentialAccessByThreads}`}getShapeFit(t,e,s){const i=this.workgroupSize[1]*this.elementsPerThread[1],o=this.workgroupSize[0]*this.elementsPerThread[0];!this.isVec4&&this.isVectorA?this.tileInner=this.workgroupSize[0]*4:this.tileInner=o;const r=t%i===0,a=e%o===0,l=s%this.tileInner===0;return[r,a,l]}getUserCode(){return`
      ${is(this.activation,this.hasPreluActivationWeights,this.isVec4)}
      ${cc(this.addBias,this.activation,!1,this.transposeB,this.fitAOuter,this.fitBOuter,this.fitInner,this.isVec4?4:1)}
      ${this.isVec4?ha(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,!0):this.isVectorA?jR(this.workgroupSize,this.transposeA):da(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,this.sequentialAccessByThreads,!0)}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XR(n){return`
    var<workgroup> sumValues : array<f32, ${n}>;
    ${ot()} {
      let coords = getOutputCoords();
      let batch = coords[0];
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      let row = coords[1];
      let col = coords[2];
      var sum = 0.0;
      let Length = uniforms.dimInner;
      for (var k = i32(localId.x); k < Length; k = k + ${n}) {
        let dataA = mm_readA(batchA, row, k);
        let dataB = mm_readB(batchB, k, col);
        sum = sum + dataA * dataB;
      }
      sumValues[localId.x] = sum;
      workgroupBarrier();

      for(var currentSize = ${n/2}u; currentSize > 1u;
          currentSize = currentSize / 2u) {
        if (localId.x < currentSize)
        {
          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];
        }
        workgroupBarrier();
      }

      if (localId.x == 0u) {
        sum = sumValues[0] + sumValues[1];
        mm_write(batch, row, col, sum);
      }
    }
  `}class qR{constructor(t,e=!1,s=!1,i=null,o=null,r=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[256,1,1],this.outputShape=t,this.dispatchLayout={x:[],y:[1,2],z:[0]},this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize);const a=i!=null,l=r!=null;a&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),this.transposeA=e,this.transposeB=s,this.addBias=a,this.activation=o,this.hasPreluActivationWeights=l,this.shaderKey=`matMulReduce_${this.activation}_${e}_${s}`}getUserCode(){return`
      ${is(this.activation,this.hasPreluActivationWeights)}
      ${cc(this.addBias,this.activation,this.transposeA,this.transposeB)}
      ${XR(this.workgroupSize[0])}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YR(n){const t=n[1],e=n[0],s=t>e?t:e;return`
  var<workgroup> mm_Asub : array<array<f32, ${s}>, ${t}>;
  var<workgroup> mm_Bsub : array<array<f32, ${e}>, ${s}>;

  // If the output size is small for matrix multiplication, avoid to use vec4
  // and handle some elements per thread to optimally utilize the ALU.
  // Read data from global memory to registers firstly, then store them into
  // shared memory, so it is instruction-Level parallelism for arithmetic
  // operations and others handle IO operations between barrier api, makes ALU
  // and load/store units work simultaneously, could improves the performance.
  ${ot()} {
    let tileRow = i32(localId.y);
    let tileCol = i32(localId.x);
    let globalRow = i32(globalId.y);
    let globalCol = i32(globalId.x);
    let batch = i32(globalId.z);
    let batchA = batch % uniforms.aShape[0];
    let batchB = batch % uniforms.bShape[0];

    // uniforms.dimInner should be greater than 0.
    let numTiles = (uniforms.dimInner - 1) / ${s} + 1;
    var acc = 0.0;

    var globalColA = tileCol;
    var globalRowB = 0;
    var regA = mm_readA(batchA, globalRow, globalColA);
    var regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
    var regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
    globalColA = globalColA + ${s};
    globalRowB = globalRowB + ${s};

    for (var t = 0; t < numTiles; t = t + 1) {
      mm_Asub[tileRow][tileCol] = regA;
      mm_Bsub[2 * tileRow][tileCol] = regB0;
      mm_Bsub[2 * tileRow + 1][tileCol] = regB1;

      workgroupBarrier();

      regA = mm_readA(batchA, globalRow, globalColA);
      regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
      regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
      globalColA = globalColA + ${s};
      globalRowB = globalRowB + ${s};

      for (var k = 0; k < ${s}; k = k + 1) {
        acc = acc + mm_Asub[tileRow][k] * mm_Bsub[k][tileCol];
      }
      workgroupBarrier();
    }

    mm_write(batch, globalRow, globalCol, acc);
  }
  `}class ZR{constructor(t,e,s,i=!1,o=!1,r=null,a=null,l=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[16,8,1],this.outputShape=s,this.dispatchLayout={x:[2],y:[1],z:[0]},this.dispatch=[Math.ceil(s[2]/this.workgroupSize[0]),Math.ceil(s[1]/this.workgroupSize[1]),s[0]];const u=r!=null;u&&this.variableNames.push("bias");const c=l!=null;c&&this.variableNames.push("preluActivationWeights"),this.transposeA=i,this.transposeB=o,this.addBias=u,this.activation=a,this.hasPreluActivationWeights=c,this.shaderKey=`matMulSmallOutputSize_${this.activation}_${i}_${o}`}getUserCode(){return`
      ${is(this.activation,this.hasPreluActivationWeights)}
      ${cc(this.addBias,this.activation,this.transposeA,this.transposeB)}
      ${YR(this.workgroupSize)}
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class QR{constructor(t,e,s=!1,i=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[8,8,1],this.atomic=!0,this.splitedDimInner=128,tt(t[0]===1,()=>"MatMulSplitKProgram only supports batch = 1."),this.outputShape=t,this.dispatchLayout={x:[2],y:[1],z:[0,3]};const o=(s&&this.outputShape[1]%4===0||!s&&e%4===0)&&this.outputShape[2]%4===0;this.elementsPerThread=[4,4,this.splitedDimInner],this.outputComponent=o?4:1,o||(this.outputShape[1]<16&&(this.elementsPerThread[1]=1),this.outputShape[2]<16&&(this.elementsPerThread[0]=1)),this.dispatch=rt(this.dispatchLayout,[this.outputShape[0],this.outputShape[1],this.outputShape[2],e],this.workgroupSize,this.elementsPerThread),this.transposeA=s,this.transposeB=i,this.shaderKey=`matMulSplitK_${s}_${i}_${this.elementsPerThread}_${this.outputComponent}`}getUserCode(){const t=this.outputComponent;return`
      ${Vy(!1,this.transposeB,!1,!1,!1,t)}
      fn mm_write(batch: i32, row : i32, col : i32, value : ${Rt(t)}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
          let coords = vec3<i32>(batch, row, col);
          let flatIndex = getOutputIndexFromCoords(coords);
          // The problem is that we should initialize output to zero before using.
          // Otherwise, the original value will be added to the result.
          for (var i = 0; i < ${t}; i = i + 1) {
            ${Cs("&result[flatIndex + i]",`${t>1?"value[i]":"value"}`,"float32")}
          }
        }
      }
      ${t===4?ha(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner):da(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner)}
    `}}class JR{constructor(t,e=null,s=null,i=null){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=e!=null,this.hasPreluActivationWeights=i!=null,this.activation=s,this.addBias&&this.variableNames.push("bias"),this.hasPreluActivationWeights&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`biasActivation_${s}`}getUserCode(){return`
    ${is(this.activation,this.hasPreluActivationWeights)}
    ${ot("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        var value = getXByOutputIndex(index);
        ${Ks(this.addBias,this.activation)}
        setOutputAtIndex(index, value);
      }
    }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tA{constructor(t){this.variableNames=[],this.outputShape=[],this.uniforms="value : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="fill"}getUserCode(){return`
    ${ot("index")} {
      if (index < uniforms.size) {
        setOutputAtIndex(index, uniforms.value);
      }
    }
  `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _e(n){const{backend:t,attrs:e}=n,{shape:s,value:i}=e;let{dtype:o}=e;if(o=o||vf(i),o==="string"){const r=Jr(o,et(s));return r.fill(i),t.makeTensorInfo(s,o,r)}else{const r=new tA(s),a=[{type:"float32",data:[i]}];return t.runWebGPUProgram(r,[],o,a)}}const eA={kernelName:wf,backendName:"webgpu",kernelFunc:_e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ft(n){const{inputs:t,attrs:e}=n,{x:s}=t,{shape:i}=e,o=et(s.shape),r=Pp(i,o),a=et(r);return tt(o===a,()=>`The new shape (${r}) has ${a} elements and the old shape (${s.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`),n.backend.incRef(s.dataId),{dataId:s.dataId,shape:r,dtype:s.dtype}}const nA={kernelName:ou,backendName:"webgpu",kernelFunc:ft};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pa({a:n,b:t,transposeA:e,transposeB:s,backend:i,bias:o=null,preluActivationWeights:r=null,leakyreluAlpha:a=0,activation:l=null}){const u=n.shape.length,c=t.shape.length,h=e?n.shape[u-2]:n.shape[u-1],p=s?t.shape[c-1]:t.shape[c-2],f=e?n.shape[u-1]:n.shape[u-2],m=s?t.shape[c-2]:t.shape[c-1],g=n.shape.slice(0,-2),b=t.shape.slice(0,-2),v=et(g),w=et(b),C=Ne(n.shape.slice(0,-2),t.shape.slice(0,-2)).concat([f,m]);tt(h===p,()=>`Error in matMul: inner shapes (${h}) and (${p}) of Tensors with shapes ${n.shape} and ${t.shape} and transposeA=${e} and transposeB=${s} must match.`);const I=e?[v,h,f]:[v,f,h],N=s?[w,m,p]:[w,p,m],$=ft({inputs:{x:n},backend:i,attrs:{shape:I}}),A=ft({inputs:{x:t},backend:i,attrs:{shape:N}}),z=[$,A],F=Math.max(v,w),E=[$,A],U=[{type:"int32",data:[f]},{type:"int32",data:[m]},{type:"int32",data:[h]}];let L,W;const _=[F,f,m];let V=he().get("WEBGPU_MATMUL_PROGRAM_TYPE");if(V<0){const j=he().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),K=j>0?j:i.thresholdToIncreaseWorkgroups,Z=F*Math.ceil(f/32)*Math.ceil(m/32);Z<=K||f<=8&&Z<=K*2?F*f*m<=128?V=Rn.MatMulReduceProgram:F===1&&p>=2e3?V=Rn.MatMulSplitKProgram:V=Rn.MatMulSmallOutputSizeProgram:V=Rn.MatMulPackedProgram}switch(V){case Rn.MatMulReduceProgram:L=new qR(_,e,s,o,l,r);break;case Rn.MatMulSplitKProgram:{if(W=_e({backend:i,attrs:{shape:_,value:0,dtype:n.dtype}}),L=new QR(_,p,e,s),o||l){W=i.runWebGPUProgram(L,E,n.dtype,U,W);const K=new JR(W.shape,o,l,r);let Z=null;const Y=[W];o&&Y.push(o),r&&Y.push(r),l==="leakyrelu"&&(Z=[{type:"float32",data:[a]}],K.uniforms+=" alpha : f32,");const it=i.runWebGPUProgram(K,Y,W.dtype,Z);z.push(W);const nt=ft({inputs:{x:it},backend:i,attrs:{shape:C}});z.push(it);for(const lt of z)i.disposeData(lt.dataId);return nt}break}case Rn.MatMulSmallOutputSizeProgram:L=new ZR(I,N,_,e,s,o,l,r);break;case Rn.MatMulPackedProgram:const j=i.adapterInfo.isIntel();L=new KR(I,_,e,s,o,l,r,j);break;default:throw new Error(`Unsupported MatMulProgramType ${V}.`)}o&&E.push(o),r&&E.push(r),l==="leakyrelu"&&(U.push({type:"float32",data:[a]}),L.uniforms+=" alpha : f32,"),W=i.runWebGPUProgram(L,E,n.dtype,U,W);const X=ft({inputs:{x:W},backend:i,attrs:{shape:C}});z.push(W);for(const j of z)i.disposeData(j.dataId);return X}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sA(n){const{inputs:t,backend:e,attrs:s}=n,{a:i,b:o,bias:r,preluActivationWeights:a}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:h}=s;return pa({a:i,b:o,transposeA:l,transposeB:u,backend:e,bias:r,preluActivationWeights:a,leakyreluAlpha:h,activation:c})}const iA={kernelName:Ep,backendName:"webgpu",kernelFunc:sA};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Hh{constructor(t,e,s){this.variableNames=["AReal","AImag","BReal","BImag"],this.workgroupSize=[128,1,1],this.size=!0,this.outputShape=Ne(e,s),this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`binaryOpComplex_${t}`,this.op=t}getUserCode(){return`
      fn binaryOpComplex(
          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {
        ${uc(this.op,!1)}
      }

      ${ot("index")} {
        if(index < uniforms.size) {
          let areal = getARealByOutputIndex(index);
          let aimag = getAImagByOutputIndex(index);
          let breal = getBRealByOutputIndex(index);
          let bimag = getBImagByOutputIndex(index);
          setOutputAtIndex(index, binaryOpComplex(areal, aimag, breal, bimag));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ar{constructor(t,e,s){if(this.size=!0,this.variableNames=["A","B"],this.outputShape=Ne(e,s),this.dispatchLayout=ht(this.outputShape),this.op=t,this.useSharedMemoryWithA=e.length<=1&&s.length>1&&e[0]<128,this.useSharedMemoryWithB=s.length<=1&&e.length>1&&s[0]<128,this.useSharedMemoryWithA||this.useSharedMemoryWithB)this.outputComponent=1,this.variableComponents=[1,1],this.lastDimensionSize=this.useSharedMemoryWithB?s[0]:e[0],this.shaderKey=`binary_${t}_${this.lastDimensionSize}`,this.type="shared",this.workgroupSize=[256,1,1];else{const i=e.length>0&&e[e.length-1]%4===0,o=s.length>0&&s[s.length-1]%4===0;i&&o?(this.outputComponent=4,this.variableComponents=[4,4]):i&&(nh(s)||s[s.length-1]===1)||o&&(nh(e)||e[e.length-1]===1)?(this.outputComponent=4,this.variableComponents=i?[4,1]:[1,4]):(this.outputComponent=1,this.variableComponents=[1,1]),this.type="nonshared",this.shaderKey=`binary_${t}_${this.variableComponents}`,this.workgroupSize=[128,1,1]}this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.outputComponent,1,1])}getUserCode(){let t;const e=this.outputComponent===4?"vec4<f32>":"f32",s=`
    fn binaryOperation(a : ${e}, b : ${e}) -> ${e} {
      ${uc(this.op,this.outputComponent===4)}
    };
    `;if(this.type==="shared"){const i=this.lastDimensionSize>1?`coords[${this.outputShape.length-1}]`:"0",o=this.useSharedMemoryWithB?`let a = getAByOutputIndex(index);
          let b = sharedBuf[${i}];`:`let a = sharedBuf[${i}];
          let b = getBByOutputIndex(index);`;t=`
        ${s}
        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;
        ${ot("index")} {
          // Fill in the shared memory buffer.
          let localIndex = i32(localId.x);
          if(localIndex < ${this.lastDimensionSize}) {
            sharedBuf[localIndex] = f32(${this.useSharedMemoryWithB?"B":"A"}[localIndex]);
          }
          workgroupBarrier();

          if(index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            ${o}
            setOutputAtIndex(index, binaryOperation(a, b));
          }
        }
        `}else t=`
       ${s}
       ${ot("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index * ${this.outputComponent});
           let a = ${e}(getAByOutputCoords(coords));
           let b = ${e}(getBByOutputCoords(coords));
           setOutputAtIndex(index, binaryOperation(a, b));
         }
       }
       `;return t}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function je(n){const{inputs:t}=n,{x:e}=t;return n.backend.incRef(e.dataId),{dataId:e.dataId,shape:e.shape,dtype:e.dtype}}const oA={kernelName:jd,backendName:"webgpu",kernelFunc:je};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xs(n){const{inputs:t,backend:e}=n,{real:s,imag:i}=t,o=e.makeTensorInfo(s.shape,"complex64"),r=e.tensorMap.get(o.dataId),a=je({inputs:{x:s},backend:e}),l=je({inputs:{x:i},backend:e});return r.complexTensorInfos={real:a,imag:l},o}const rA={kernelName:b1,backendName:"webgpu",kernelFunc:Xs};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ti{constructor(t,e,s=""){this.variableNames=["A"],this.size=!0;const i=128;this.workgroupSize=[i,1,1],this.outputShape=t,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.op=e,s!==""&&(this.uniforms=s),this.shaderKey=`unary_${e}`}getUserCode(){return`
      fn unaryOperation(a : f32) -> f32 {
        ${$s(this.op,!1)}
      }
      ${ot("index")} {
        if (index < uniforms.size) {
          let a = getAByOutputIndex(index);
          setOutputAtIndex(index, unaryOperation(a));
        }
      }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bt({opType:n,cpuKernelImpl:t,dtype:e}){return({inputs:s,backend:i})=>{const{x:o}=s,r=i,a=e||o.dtype;if(r.shouldExecuteOnCPU([o])&&t!=null){const u=r.tensorMap.get(o.dataId),c=t(u.values,a);return r.makeTensorInfo(o.shape,a,c)}const l=new Ti(o.shape,n);return r.runWebGPUProgram(l,[o],a)}}function Se({opType:n,cpuKernelImpl:t,supportsComplex:e=!1,dtype:s}){return({inputs:i,backend:o})=>{const{a:r,b:a}=i,l=o;if(e&&r.dtype==="complex64"){const h=l.tensorMap.get(r.dataId),p=l.tensorMap.get(a.dataId);let f,m;if(n!==vt.MUL)[f,m]=[[h.complexTensorInfos.real,p.complexTensorInfos.real],[h.complexTensorInfos.imag,p.complexTensorInfos.imag]].map(b=>{const[v,w]=b,k={dataId:v.dataId,dtype:v.dtype,shape:r.shape},C={dataId:w.dataId,dtype:w.dtype,shape:a.shape},I=new ar(n,r.shape,a.shape);return l.runWebGPUProgram(I,[k,C],es(v.dtype,w.dtype))});else{const b=new Hh(vt.COMPLEX_MULTIPLY_REAL,r.shape,a.shape),v=new Hh(vt.COMPLEX_MULTIPLY_IMAG,r.shape,a.shape),w=[{dataId:h.complexTensorInfos.real.dataId,dtype:h.complexTensorInfos.real.dtype,shape:r.shape},{dataId:h.complexTensorInfos.imag.dataId,dtype:h.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:p.complexTensorInfos.real.dataId,dtype:p.complexTensorInfos.real.dtype,shape:a.shape},{dataId:p.complexTensorInfos.imag.dataId,dtype:p.complexTensorInfos.imag.dtype,shape:a.shape}];f=l.runWebGPUProgram(b,w,"float32"),m=l.runWebGPUProgram(v,w,"float32")}const g=Xs({inputs:{real:f,imag:m},backend:l});return l.disposeData(f.dataId),l.disposeData(m.dataId),g}const u=s||es(r.dtype,a.dtype);if((r.dtype==="string"||a.dtype==="string"||l.shouldExecuteOnCPU([r,a]))&&t!=null){const h=l.tensorMap.get(r.dataId).values,p=l.tensorMap.get(a.dataId).values,f=r.dtype==="string"?sh(h):h,m=r.dtype==="string"?sh(p):p,[g,b]=t(r.shape,a.shape,f,m,u);return l.makeTensorInfo(b,u,g)}const c=new ar(n,r.shape,a.shape);return l.runWebGPUProgram(c,[r,a],u)}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:aA,castImpl:lA,ceilImpl:uA,concatImpl:cA,equalImpl:hA,expImpl:dA,expm1Impl:pA,floorImpl:fA,floorDivImpl:mA,gatherNdImpl:gA,gatherV2Impl:yA,greaterEqualImpl:bA,greaterImpl:xA,lessEqualImpl:wA,lessImpl:vA,logImpl:CA,maxImpl:kA,maximumImpl:SA,minimumImpl:IA,multiplyImpl:NA,negImpl:$A,notEqualImpl:DA,prodImpl:RA,rangeImpl:AA,rsqrtImpl:TA,scatterImpl:zA,simpleAbsImpl:FA,sliceImpl:MA,stridedSliceImpl:PA,stringNGramsImpl:EA,subImpl:LA,tileImpl:OA,topKImpl:_A,transposeImpl:BA,uniqueImpl:QO}=x1;/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WA=Bt({opType:st.ABS,cpuKernelImpl:FA}),VA={kernelName:Ad,backendName:"webgpu",kernelFunc:WA};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UA=Bt({opType:st.ACOS}),GA={kernelName:dr,backendName:"webgpu",kernelFunc:UA};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HA=Bt({opType:st.ACOSH}),jA={kernelName:pr,backendName:"webgpu",kernelFunc:HA};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KA=Se({opType:vt.ADD,cpuKernelImpl:aA,supportsComplex:!0}),XA={kernelName:Td,backendName:"webgpu",kernelFunc:KA};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qA{constructor(t){this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t[0],this.variableNames=t.map((e,s)=>`T${s}`),this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="addN"}getUserCode(){const t=[];this.variableNames.forEach(i=>{t.push(`let v${i} = get${i}ByOutputCoords(coords);`)});const e=this.variableNames.map(i=>`v${i}`).join(" + ");return`
      ${ot("index")} {
        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if (flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            ${t.join(`
        `)}
            setOutputAtIndex(flatIndex, ${e});
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YA(n){const{inputs:t,backend:e}=n,s=t;if(s.length===1)return je({inputs:{x:s[0]},backend:e});const i=s.map(a=>a.dtype).reduce((a,l)=>es(a,l)),o=s.map(a=>a.shape),r=new qA(o);return e.runWebGPUProgram(r,s,i)}const ZA={kernelName:xl,backendName:"webgpu",kernelFunc:YA};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class QA{constructor(t,e){this.variableNames=["A"],this.workgroupSize=[16,16,1];const s=new Array(t.length);for(let i=0;i<s.length;i++)s[i]=t[e[i]];this.outputShape=s,this.dispatchLayout={x:[0],y:[1]},this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize,[1,1,1]),this.shaderKey="transposeShared"}getUserCode(){tt(this.workgroupSize[0]===this.workgroupSize[1],()=>`Must be a square tile, current tile shape is ${this.workgroupSize[0]} x ${this.workgroupSize[1]}`);const t=this.workgroupSize[0];return`
      var<workgroup> tile : array<array<f32, ${this.workgroupSize[0]+1}>, ${this.workgroupSize[0]}>;
      ${ot()} {
        var x = i32(workgroupId.x) * ${t} + i32(localId.x);
        var y = i32(workgroupId.y) * ${t} + i32(localId.y);
        let width = uniforms.outShape[0];
        let height = uniforms.outShape[1];
        if (x < width && y < height) {
          tile[localId.y][localId.x] = f32(A[y * width + x]);
        }
        workgroupBarrier();

        x = i32(workgroupId.y) * ${t} + i32(localId.x);
        y = i32(workgroupId.x) * ${t} + i32(localId.y);
        if (x < height && y < width) {
          setOutputAtIndex((y * height + x), tile[localId.x]
            [localId.y]);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JA{constructor(t,e){this.variableNames=["A"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0;const s=new Array(t.length);for(let i=0;i<s.length;i++)s[i]=t[e[i]];this.outputShape=s,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.newDim=e,this.shaderKey=`transpose_${e}`}getUserCode(){const t=de(this.outputShape.length),e=Uy(this.newDim);return`
      ${ot("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            setOutputAtIndex(flatIndex, A[getIndexFromCoords${this.outputShape.length}D(
              ${t}(${e}), uniforms.aShape)]);
          }
        }
      }
    `}}function Uy(n){const t=n.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const e=new Array(t);for(let s=0;s<n.length;s++)e[n[s]]=`coords.${Yn(s)}`;return e.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _n(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{perm:o}=s,r=e,a=i.shape.length,l=new Array(a);for(let c=0;c<l.length;c++)l[c]=i.shape[o[c]];if(e.shouldExecuteOnCPU([i])){const h=r.tensorMap.get(i.dataId).values,p=BA(h,i.shape,i.dtype,o,l);return e.makeTensorInfo(l,i.dtype,p)}if(i.shape.length===2&&ke(o,[1,0])){const c=new QA(i.shape,o);return r.runWebGPUProgram(c,[i],i.dtype)}const u=new JA(i.shape,o);return r.runWebGPUProgram(u,[i],i.dtype)}const tT={kernelName:cp,backendName:"webgpu",kernelFunc:_n};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eT{constructor(t,e,s){this.variableNames=["x"],this.uniforms="reduceSize : i32,",this.size=!0,this.inputShape=[t.batchSize,t.inSize];const[i]=un(this.inputShape,[1]);this.outputShape=i.length===0?[1]:i,t.inSize>=32768&&s>=512?this.workgroupSize=[512,1,1]:t.inSize>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,[1,1,1]),this.reduceType=e,this.shaderKey=`reduce_${e}`}getUserCode(){let t="",e="0.0";const s=this.workgroupSize[0];this.reduceType==="min"||this.reduceType==="max"?(t=`
         if (isnan(candidate)) {
          bestValue = uniforms.NAN;
         } else if (!isnan(bestValue) && candidate ${this.reduceType==="min"?"<":">"} bestValue)
           {  bestValue = candidate; }`,e="f32(x[offset])"):this.reduceType==="sum"||this.reduceType==="mean"?t=" bestValue = bestValue + candidate; ":this.reduceType==="prod"?(t=" bestValue = bestValue * candidate; ",e="1.0"):this.reduceType==="all"?(t=" bestValue = f32(bestValue >= 1.0 && candidate >= 1.0); ",e="1.0"):this.reduceType==="any"&&(t=" bestValue = f32(bestValue >= 1.0 || candidate >= 1.0); ",e="0.0");const i=this.reduceType==="mean"?"setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));":"setOutputAtIndex(outputIndex, bestValue);";return`
       fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
       }

       ${`
         var<workgroup> xBestValues : array<f32, ${s}>;
       `}
       fn getOffset(outputIndex : i32) -> i32 {
         let outputCoords = getCoordsFromIndex(outputIndex);
         let offset = ${this.outputShape.length===1?"outputCoords":"outputCoords[0]"} * uniforms.reduceSize;
          return offset;
       }
       ${ot("index")} {
         let outputIndex = index / ${s};
         let offset = getOffset(outputIndex);
         var bestValue = ${e};
         let Length = uniforms.reduceSize;
         let WorkPerThread = DIV_CEIL(u32(Length), ${s}u);
         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;
             k = k + ${s}) {
           let candidate = f32(x[offset + k]);
           ${t}
         }
         xBestValues[localId.x] = bestValue;
         workgroupBarrier();

         var reduceSize = min(u32(Length), ${s}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            ${t}
            xBestValues[localId.x] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (localId.x == 0u && outputIndex < uniforms.size) {
          ${i}
        }
       }
     `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nT={mean:"float32",all:"bool",any:"bool"};function qs(n,t,e,s,i){const o=n.shape.length,r=[],a=ee(t,n.shape);let l=a;const u=Pe(l,o);let c=n;u!=null&&(c=_n({inputs:{x:n},attrs:{perm:u},backend:i}),l=Ke(l.length,o),r.push(c)),Vn(s,l,o);const[h,p]=un(c.shape,l);let f=h;e&&(f=Jn(h,a));let m;if((s==="max"||s==="prod")&&i.shouldExecuteOnCPU([c])){const g=i.tensorMap.get(c.dataId).values;switch(s){case"max":const b=kA(g,et(p),f,n.dtype);m=i.makeTensorInfo(f,n.dtype,b);break;case"prod":const{outVals:v,outShape:w,outDtype:k}=RA(c.shape,c.dtype,g,l);m=i.makeTensorInfo(w,k,v);break;default:throw new Error(`${s} CPU implementation is not yet supported.`)}}else{const g=et(p),v=et(c.shape)/g,w={windowSize:g,inSize:g,batchSize:v,outSize:1},k=nT[s]||w1(n.dtype),C=[{type:"int32",data:[g]}],I=new eT(w,s,i.device.limits.maxComputeWorkgroupSizeX),N=i.runWebGPUProgram(I,[c],k,C);r.push(N),m=ft({inputs:{x:N},attrs:{shape:f},backend:i})}return r.forEach(g=>i.disposeData(g.dataId)),m}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sT(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{keepDims:o,axis:r}=s;return qs(i,r,o,"all",e)}const iT={kernelName:Lp,backendName:"webgpu",kernelFunc:sT};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oT(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{keepDims:o,axis:r}=s;return qs(i,r,o,"any",e)}const rT={kernelName:Op,backendName:"webgpu",kernelFunc:oT};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Gy{constructor(t,e,s){this.workgroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="infinityValue : f32,",this.size=!0;const i=[e];this.op=s==="min"?"<":">";const[o,r]=un(t,i);this.outputShape=o.length===0?[1]:o,this.dispatchLayout=ht(this.outputShape),et(r)<32?(this.type="plain",this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize)):(this.type="shared",this.dispatch=rt(this.dispatchLayout,this.outputShape,[1,1,1])),this.inputShape=t,this.shaderKey=`argMinMax_${this.op}_${this.type}`}getUserCode(){const t=this.workgroupSize[0],e=()=>this.inputShape.length===1?"uniforms.xShape":`uniforms.xShape.${Yn(this.inputShape.length-1)}`,s=()=>{let i="";if(this.outputShape.length===1)this.inputShape.length!==1&&(i+="outputCoords,");else for(let o=0;o<this.outputShape.length;o++)i+=`outputCoords.${Yn(o)},`;return i};return this.type==="shared"?`
      fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
      }

      ${`
      var<workgroup> xBestIndices : array<i32, ${t}>;
      var<workgroup> xBestValues : array<f32, ${t}>;
    `}

      ${ot("index")} {
        let outputIndex = index / ${t};
        let reduceLength = ${e()};

        var bestIndex = i32(localId.x);
        var bestValue = uniforms.infinityValue;
        let outputCoords = getCoordsFromIndex(outputIndex);
        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;
            k = k + ${t}) {
          let candidate = getX(${s()} k);
          if (!isnan(candidate) && candidate ${this.op} bestValue) {
            bestValue = candidate;
            bestIndex = k;
          }
        }
        xBestValues[localId.x] = bestValue;
        xBestIndices[localId.x] = bestIndex;
        workgroupBarrier();

        var reduceSize = min(u32(reduceLength), ${t}u);
        for (var currentSize = reduceSize / 2u; reduceSize > 1u;
            currentSize = reduceSize / 2u) {
          let interval = DIV_CEIL(reduceSize, 2u);
          if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              xBestValues[localId.x] = bestValue;
              xBestIndices[localId.x] = xBestIndices[localId.x + interval];
            }
          }
          reduceSize = interval;
          workgroupBarrier();
        }

        if (localId.x == 0u && outputIndex < uniforms.size) {
          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);
        }
      }
    `:`
      ${ot("index")} {
        if (index < uniforms.size) {
          let outputCoords = getCoordsFromIndex(index);
          var bestIndex = 0;
          var bestValue = getX(${s()} 0);
          let reduceLength = ${e()};
          for (var i = 1; i < reduceLength; i++) {
            let candidate = getX(${s()} i);
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              bestIndex = i;
            }
          }
          setOutputAtIndexI32(index, bestIndex);
        }
      }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aT(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:o}=s;let r=ee(o,i.shape);const a=Pe(r,i.shape.length);let l=i;const u=[];a!=null&&(l=_n({inputs:{x:i},backend:e,attrs:{perm:a}}),u.push(l),r=Ke(r.length,l.shape.length)),Vn("argMax",[r[0]],l.shape.length);const c=new Gy(l.shape,r[0],"max"),h=[{type:"float32",data:[Number.NEGATIVE_INFINITY]}],p=e.runWebGPUProgram(c,[l],"int32",h);return u.forEach(f=>e.disposeData(f.dataId)),p}const lT={kernelName:wl,backendName:"webgpu",kernelFunc:aT};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uT(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:o}=s;let r=ee(o,i.shape);const a=Pe(r,i.shape.length);let l=i;const u=[];a!=null&&(l=_n({inputs:{x:i},backend:e,attrs:{perm:a}}),u.push(l),r=Ke(r.length,l.shape.length)),Vn("argMin",[r[0]],l.shape.length);const c=new Gy(l.shape,r[0],"min"),h=[{type:"float32",data:[Number.POSITIVE_INFINITY]}],p=e.runWebGPUProgram(c,[l],"int32",h);return u.forEach(f=>e.disposeData(f.dataId)),p}const cT={kernelName:vl,backendName:"webgpu",kernelFunc:uT};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hT=Bt({opType:st.ASIN}),dT={kernelName:fr,backendName:"webgpu",kernelFunc:hT};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pT=Bt({opType:st.ASINH}),fT={kernelName:mr,backendName:"webgpu",kernelFunc:pT};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mT=Bt({opType:st.ATAN}),gT={kernelName:yr,backendName:"webgpu",kernelFunc:mT};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yT=Se({opType:vt.ATAN2}),bT={kernelName:gr,backendName:"webgpu",kernelFunc:yT};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xT=Bt({opType:st.ATANH}),wT={kernelName:br,backendName:"webgpu",kernelFunc:xT};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vT{constructor(t){this.variableNames=["x"],this.uniforms="strides : vec2<i32>,",this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=t.outShape,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="poolWithFilterSizeEqualsOne"}getUserCode(){return`
      ${ot("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];

          let xRCCorner = coords.yz * uniforms.strides;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          let value = getX(batch, xRCorner, xCCorner, d);
          setOutputAtIndex(index, value);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oo{constructor(t,e,s=!1,i=!1,o=!1){if(this.variableNames=["x"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,",this.workgroupSize=[128,1,1],this.size=!0,e==="avg"&&s)throw new Error("Cannot compute positions for average pool.");this.outputShape=t.outShape,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=e,this.computePositions=s,this.flattenPositions=i,this.includeBatchIndex=o,this.shaderKey=`pool2D_${e}_${s}_${i}_${o}`}getUserCode(){let t;this.poolType==="avg"?t="resultValue = resultValue + value; count = count + 1.0;":this.computePositions?t=`let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"((batch * uniforms.xShape[1] + xR) * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"(xR * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"wR * uniforms.filterDims.y + wC"};
      }`:t="resultValue = max(value, resultValue);";let e="resultValue";return this.poolType==="avg"&&(e="resultValue / max(count, 1.0)"),`
      ${ot("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];
          let xRCCorner = vec2<i32>(coords.yz) * uniforms.strides - uniforms.pads;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          ${this.computePositions?`var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;`:`var resultValue = ${this.poolType==="avg"?"0.0":"-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilations.x) {
            let xR = xRCorner + wR;

            if (xR < 0 || xR >= uniforms.convDims.x) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilations.y) {
              let xC = xCCorner + wC;
              if (xC < 0 || xC >= uniforms.convDims.y) {
                continue;
              }

              let value = getX(batch, xR, xC, d);
              ${t}
            }
          }

          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${e});`}
        }
      }
    `}}class hc{constructor(t,e,s=!1,i=!1,o=!1){if(this.variableNames=["x"],this.uniforms="strides : vec3<i32>, pads : vec3<i32>, convDims : vec3<i32>, filterDims : vec3<i32>,",this.workgroupSize=[128,1,1],this.size=!0,e==="avg"&&s)throw new Error("Cannot compute positions for average pool.");this.outputShape=t.outShape,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=e,this.computePositions=s,this.flattenPositions=i,this.includeBatchIndex=o,this.shaderKey=`pool3D_${e}_${s}_${i}_${o}`}getUserCode(){let t;this.poolType==="avg"?t="resultValue += value; count += 1.0;":this.computePositions?t=`let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"(((batch * uniforms.xShape.y + xD) * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"((xD * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"wD * uniforms.filterDims.y * uniforms.filterDims.y + wR * uniforms.filterDims.z + wC"};
      }`:t="resultValue = max(value, resultValue);";let e="resultValue";return this.poolType==="avg"&&(e="resultValue / max(count, 1.0)"),`
      ${ot("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords.x;
          let ch = coords.u;

          let xCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
          let xDCorner = xCorner.x;
          let xRCorner = xCorner.y;
          let xCCorner = xCorner.z;

          ${this.computePositions?`var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;`:`var resultValue = ${this.poolType==="avg"?"0.0":"-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wD = 0; wD < uniforms.filterDims.x; wD++) {
            let xD = xDCorner + wD;
            if (xD < 0 || xD >= uniforms.convDims.x) {
              continue;
            }

            for (var wR = 0; wR < uniforms.filterDims.y; wR++) {
              let xR = xRCorner + wR;
              if (xR < 0 || xR >= uniforms.convDims.y) {
                continue;
              }

              for (var wC = 0; wC < uniforms.filterDims.z; wC++) {
                let xC = xCCorner + wC;
                if (xC < 0 || xC >= uniforms.convDims.z) {
                  continue;
                }

                let value = getX(batch, xD, xR, xC, ch);
                ${t}
              }
            }
          }

          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${e});`}
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hy(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{reductionIndices:o,keepDims:r}=s;return qs(i,o,r,"max",e)}const CT={kernelName:Hl,backendName:"webgpu",kernelFunc:Hy};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jy(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{keepDims:o,axis:r}=s;return qs(i,r,o,"mean",e)}const kT={kernelName:Yl,backendName:"webgpu",kernelFunc:jy};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ky(n,t,e,s){if(t.filterWidth===1&&t.filterHeight===1&&ke(t.inShape,t.outShape))return je({inputs:{x:n},backend:s});if(t.filterWidth===t.inWidth&&t.filterHeight===t.inHeight&&t.batchSize===1&&t.padInfo.type==="VALID"){const r=n.shape.length,a=ft({inputs:{x:n},backend:s,attrs:{shape:[n.shape[r-3]*n.shape[r-2],n.shape[r-1]]}});let l;e==="avg"?l=jy({inputs:{x:a},backend:s,attrs:{axis:0,keepDims:!1}}):(tt(e==="max",()=>`Invalid pool type ${e}`),l=Hy({inputs:{x:a},backend:s,attrs:{reductionIndices:0,keepDims:!1}}));const u=ft({inputs:{x:l},backend:s,attrs:{shape:t.outShape}});return s.disposeData(a.dataId),s.disposeData(l.dataId),u}let i;const o=[{type:"int32",data:[t.strideHeight,t.strideWidth]}];return t.filterHeight===1&&t.filterWidth===1?i=new vT(t):(e==="avg"?i=new oo(t,"avg"):(tt(e==="max",()=>`Invalid pool type ${e}`),i=new oo(t,"max")),o.push({type:"int32",data:[t.padInfo.top,t.padInfo.left]},{type:"int32",data:[t.dilationHeight,t.dilationWidth]},{type:"int32",data:[t.inHeight,t.inWidth]},{type:"int32",data:[t.effectiveFilterHeight,t.effectiveFilterWidth]})),s.runWebGPUProgram(i,[n],n.dtype,o)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ST(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{filterSize:o,strides:r,pad:a,dimRoundingMode:l}=s,c=Un(i.shape,o,r,1,a,l);return Ky(i,c,"avg",e)}const IT={kernelName:Il,backendName:"webgpu",kernelFunc:ST};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NT(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{filterSize:o,strides:r,pad:a,dataFormat:l,dimRoundingMode:u}=s,c=[1,1,1],h=xs(i.shape,o,r,c,a,u,l),p=new hc(h,"avg"),f=[{type:"int32",data:[h.strideDepth,h.strideHeight,h.strideWidth]},{type:"int32",data:[h.padInfo.front,h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.inDepth,h.inHeight,h.inWidth]},{type:"int32",data:[h.effectiveFilterDepth,h.effectiveFilterHeight,h.effectiveFilterWidth]}];return e.runWebGPUProgram(p,[i],i.dtype,f)}const $T={kernelName:kl,backendName:"webgpu",kernelFunc:NT};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class DT{constructor(t){this.variableNames=["dy"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, avgMultiplier : f32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.inShape,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool2DBackprop"}getUserCode(){return`
      ${ot("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR = wR + uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC = wC + uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);

            dotProd = dotProd + dyValue * uniforms.avgMultiplier;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}class RT{constructor(t){this.variableNames=["dy"],this.uniforms=`strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
       outDepth : i32, outHeight : i32, outWidth : i32, avgMultiplier : f32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.inShape,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool3DBackprop"}getUserCode(){return`
      ${ot("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              dotProd += dyValue * uniforms.avgMultiplier;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AT(n){const{inputs:t,backend:e,attrs:s}=n,{dy:i,input:o}=t,r=o,{filterSize:a,strides:l,pad:u,dimRoundingMode:c}=s,h=xs(r.shape,a,l,1,u,c),p=new RT(h),f=1/(h.filterDepth*h.filterHeight*h.filterWidth),m=[{type:"int32",data:[h.strideDepth,h.strideHeight,h.strideWidth]},{type:"int32",data:[h.effectiveFilterDepth-1-h.padInfo.front,h.effectiveFilterHeight-1-h.padInfo.top,h.effectiveFilterWidth-1-h.padInfo.left]},{type:"int32",data:[h.effectiveFilterDepth,h.effectiveFilterHeight,h.effectiveFilterWidth]},{type:"int32",data:[h.outDepth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]},{type:"float32",data:[f]}];return e.runWebGPUProgram(p,[i],r.dtype,m)}const TT={kernelName:Cl,backendName:"webgpu",kernelFunc:AT};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zT(n){const{inputs:t,backend:e,attrs:s}=n,{dy:i,input:o}=t,r=o;Wy([i,o],"avgPoolGrad");const{filterSize:a,strides:l,pad:u}=s,c=Un(r.shape,a,l,1,u),h=new DT(c),p=1/(c.filterHeight*c.filterWidth),f=[{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.effectiveFilterHeight-1-c.padInfo.top,c.effectiveFilterWidth-1-c.padInfo.left]},{type:"int32",data:[c.dilationHeight,c.dilationWidth]},{type:"int32",data:[c.effectiveFilterHeight,c.effectiveFilterWidth]},{type:"int32",data:[c.outHeight]},{type:"int32",data:[c.outWidth]},{type:"float32",data:[p]}];return e.runWebGPUProgram(h,[i],r.dtype,f)}const FT={kernelName:Sl,backendName:"webgpu",kernelFunc:zT};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MT(n){const{inputs:t,backend:e,attrs:s}=n,{a:i,b:o}=t,{transposeA:r,transposeB:a}=s;return pa({a:i,b:o,transposeA:r,transposeB:a,backend:e})}const PT={kernelName:Nl,backendName:"webgpu",kernelFunc:MT};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ET{constructor(t,e){this.variableNames=["source"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.rank=e.length,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.start=t,this.uniforms=`start : ${de(t.length)}, `,this.shaderKey="slice"}getUserCode(){const t=de(this.rank),e=LT(this.rank);let s;return this.start.length===1?s=this.outputShape.map((o,r)=>"sourceLoc = uniforms.start + coords;"):s=this.outputShape.map((o,r)=>`sourceLoc.${dl[r]} = uniforms.start.${Yn(r)} + coords.${dl[r]};`),`
      ${ot("index")} {
        if (index < uniforms.size) {
          var sourceLoc : ${t};
          let coords = getCoordsFromIndex(index);
          ${s.join(`
`)}
          setOutputAtIndex(index, getSource(${e}));
        }
      }
    `}}const dl=["x","y","z","w","u","v"];function LT(n){if(n===1)return"sourceLoc";if(n<=6)return dl.slice(0,n).map(t=>`sourceLoc.${t}`).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zi(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{begin:o,size:r}=s,[a,l]=op(i,o,r);if(v1(i,a,l),e.shouldExecuteOnCPU([i])||i.dtype==="string"){const h=e.tensorMap.get(i.dataId),p=MA(h.values,a,l,i.shape,i.dtype);return e.makeTensorInfo(l,i.dtype,p)}if(et(l)===0)return e.makeTensorInfo(l,i.dtype,[]);const u=new ET(a,l),c=[{type:"int32",data:a}];return e.runWebGPUProgram(u,[i],i.dtype,c)}const OT={kernelName:ip,backendName:"webgpu",kernelFunc:zi};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _T=n=>{const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{blockShape:o,crops:r}=s;tt(i.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet");const a=o.reduce((w,k)=>w*k),l=Yr(i.shape,o,a),u=Zr(l.length,o.length),c=Qr(i.shape,o,a),h=_p(r,o.length),p=Bp(c,r,o.length),f=[],m=ft({inputs:{x:i},backend:e,attrs:{shape:l}}),g=_n({inputs:{x:m},backend:e,attrs:{perm:u}}),b=ft({inputs:{x:g},backend:e,attrs:{shape:c}}),v=zi({inputs:{x:b},backend:e,attrs:{begin:h,size:p}});return f.push(m),f.push(g),f.push(b),f.forEach(w=>e.disposeData(w.dataId)),v},BT={kernelName:$l,backendName:"webgpu",kernelFunc:_T};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WT=`
  fn bincount_write(index: i32, value: f32) {
    ${Cs("&result[index]","value","float32")}
  }
`,VT=`
  fn bincount_write(index: i32, value: f32) {
    atomicStore(&result[index], bitcast<i32>(value));
  }
`;class Xy{constructor(t,e,s=!1){this.outputShape=[],this.variableNames=["x"],this.uniforms="binCountSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.hasWeights=!0,this.binaryOutput=!1,this.outputShape=t,this.rank=t.length,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.binaryOutput=s,s&&(this.atomic=!1),this.hasWeights=e,this.hasWeights&&this.variableNames.push("w"),this.shaderKey=`bincount_${this.hasWeights}_${this.binaryOutput}_${this.rank}`}getUserCode(){return`
    ${this.binaryOutput?VT:WT}
  ${ot("index")} {
    ${this.rank===1?`if (index < uniforms.xShape) {
      let indexVal = i32(getX(index));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput?1:this.hasWeights?"getW(index)":"1."};
        bincount_write(indexVal, value);
      }
    }`:`let coord = getCoordsFromIndex(index);
    if (coordsInBounds2D(coord, uniforms.xShape)) {
      let indexVal = i32(getX(coord[0], coord[1]));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput?1:this.hasWeights?"getW(coord[0], coord[1])":"1."};
        bincount_write(coord.x * uniforms.binCountSize + indexVal, value);
      }
    }`}
  }
  `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UT(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,weights:o}=t,{size:r}=s,a=et(i.shape),u=et(o.shape)>0,c=[r],h=o.dtype,p=_e({backend:e,attrs:{shape:c,value:0,dtype:h}}),f=new Xy([a],u),m=[{type:"int32",data:[r]}],g=u?[i,o]:[i];return e.runWebGPUProgram(f,g,h,m,p)}const GT={kernelName:Wp,backendName:"webgpu",kernelFunc:UT};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class HT{constructor(t){this.outputShape=[],this.variableNames=["s0","s1"],this.uniforms="s0Size : i32, s1Size : i32, ",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[t],this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="broadcastArgs"}getUserCode(){return`
  ${ot("index")} {
    if (index < uniforms.size) {
      var s0 = 1.0;
      var s1 = 1.0;
      let indexS0 = index - uniforms.size + uniforms.s0Size;
      let indexS1 = index - uniforms.size + uniforms.s1Size;
      if (indexS0 >= 0) {
        s0 = getS0(indexS0);
      }
      if (indexS1 >= 0) {
        s1 = getS1(indexS1);
      }

      if (s0 == 1.0) {
        setOutputAtIndex(index, s1);
      } else if (s1 == 1.0) {
        setOutputAtIndex(index, s0);
      } else if (s0 != s1) {
        setOutputAtIndex(index, uniforms.NAN);
      } else {
        setOutputAtIndex(index, s0);
      }
    }
  }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jT(n){const{inputs:t,backend:e}=n,{s0:s,s1:i}=t;if(e.shouldExecuteOnCPU([s,i])){const c=e.tensorMap.get(s.dataId),h=e.tensorMap.get(i.dataId),p=c.values,f=h.values,m=Ne(Array.from(p),Array.from(f));return e.makeTensorInfo([m.length],"int32",Int32Array.from(m))}const o=et(s.shape),r=et(i.shape),a=Math.max(o,r),l=new HT(a),u=[{type:"int32",data:[o]},{type:"int32",data:[r]}];return e.runWebGPUProgram(l,[s,i],"int32",u)}const KT={kernelName:Up,backendName:"webgpu",kernelFunc:jT};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qy=Se({opType:vt.NOT_EQUAL,dtype:"bool",cpuKernelImpl:DA}),XT={kernelName:C1,backendName:"webgpu",kernelFunc:qy};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Co(n){const{inputs:t,backend:e}=n,{input:s}=t,i=e.tensorMap.get(s.dataId);return je({inputs:{x:i.complexTensorInfos.real},backend:e})}const qT={kernelName:k1,backendName:"webgpu",kernelFunc:Co};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YT(n,t){const e=new Ti(n.shape,st.TO_INT),s=t.runWebGPUProgram(e,[n],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pl(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{dtype:o}=s;if(o==="complex64"){if(i.dtype==="complex64")return je({inputs:{x:i},backend:e});const r=Le(i.shape),a=pl({inputs:{x:i},backend:e,attrs:{dtype:"float32"}}),l=Xs({inputs:{real:a,imag:r},backend:e});return r.dispose(),e.disposeData(a.dataId),l}if(i.dtype==="complex64"){const r=Co({inputs:{input:i},backend:e}),a=pl({inputs:{x:r},backend:e,attrs:{dtype:o}});return e.disposeData(r.dataId),a}if(!S1(i.dtype,o)){const r=je({inputs:{x:i},backend:e});return{dataId:r.dataId,shape:r.shape,dtype:o}}if(e.shouldExecuteOnCPU([i])){const r=e.tensorMap.get(i.dataId).values,[a,l,u]=lA(r,i.shape,i.dtype,o);return e.makeTensorInfo(a,l,u)}if(o==="int32")return YT(i,e);if(o==="bool"){const r=e.makeTensorInfo([],"bool",Ln("bool",1)),l=qy({inputs:{a:i,b:r},backend:e});return e.disposeData(r.dataId),l}throw new Error(`Error in Cast: failed to cast ${i.dtype} to ${o}`)}const ZT={kernelName:Fd,backendName:"webgpu",kernelFunc:pl};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QT=Bt({opType:st.CEIL,cpuKernelImpl:uA}),JT={kernelName:Md,backendName:"webgpu",kernelFunc:QT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tz{constructor(t){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workPerThread=4,this.workgroupSize=[64,1,1],this.outputComponent=4,this.size=!0,this.outputShape=t,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="clipVec4"}getUserCode(){return`
      ${ot("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          var clampedValue = clamp(
              value, vec4<f32>(uniforms.minVal), vec4<f32>(uniforms.maxVal));
          clampedValue = select(clampedValue, value, isnanVec4(value));
          setOutputAtIndex(index, clampedValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ez{constructor(t){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="clip"}getUserCode(){return`
      ${ot("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          if (isnan(value)) {
            setOutputAtIndex(index, value);
            return;
          }
          setOutputAtIndex(index, clamp(value, uniforms.minVal, uniforms.maxVal));
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nz(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{clipValueMin:o,clipValueMax:r}=s;let a;const l=[{type:"float32",data:[o]},{type:"float32",data:[r]}];return et(i.shape)%4===0?a=new tz(i.shape):a=new ez(i.shape),e.runWebGPUProgram(a,[i],i.dtype,l)}const sz={kernelName:wr,backendName:"webgpu",kernelFunc:nz};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iz{constructor(t){this.outputShape=[],this.variableNames=["real","imag"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="complexAbs"}getUserCode(){return`
    ${ot("index")} {
      if (index < uniforms.size) {
        let re = abs(getRealByOutputIndex(index));
        let im = abs(getImagByOutputIndex(index));
        let mx = max(re, im);

        // The length function in wgsl may be not underflow-safe on some GPUs.
        // So the safe solution is to ensure underflow-safety in all cases.
        setOutputAtIndex(index, select(mx * length(vec2<f32>(1, min(re, im)/mx)), 0.0, mx == 0.0));
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jh(n,t){return{dataId:t.dataId,dtype:t.dtype,shape:n.shape}}function oz(n){const{inputs:t,backend:e}=n,{x:s}=t,i=e.tensorMap.get(s.dataId),o=new iz(s.shape),r=[jh(s,i.complexTensorInfos.real),jh(s,i.complexTensorInfos.imag)];return e.runWebGPUProgram(o,r,r[0].dtype)}const rz={kernelName:Dl,backendName:"webgpu",kernelFunc:oz};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class az{constructor(t){this.uniforms="",this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=cs(t,1),this.variableNames=t.map((e,s)=>`T${s}`),this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.offsetLength=t.length-1;for(let e=0;e<this.offsetLength;e++)this.uniforms+=`offset${e} : i32,`;this.shaderKey="concat"}getUserCode(){const t=[];if(this.offsetLength>0){t.push("if (yC < uniforms.offset0){ setOutputAtCoords(coords.x, coords.y, getT0(yR, yC)); }");for(let o=1;o<this.offsetLength;o++)t.push(`else if (yC < uniforms.offset${[o]}){ setOutputAtCoords(coords.x, coords.y, getT${o}(yR, yC - uniforms.offset${o-1})); }`);const s=this.offsetLength,i=this.offsetLength-1;t.push(`else { setOutputAtCoords(coords.x, coords.y, getT${s}(yR, yC - uniforms.offset${i})); }`)}else t.push("setOutputAtCoords(coords.x, coords.y, getT0(yR, yC));");return`
      ${ot("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            let yR = coords.x;
            let yC = coords.y;

            ${t.join(`
        `)}
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fa(n){const{inputs:t,backend:e}=n,{input:s}=t,i=e.tensorMap.get(s.dataId);return je({inputs:{x:i.complexTensorInfos.imag},backend:e})}const lz={kernelName:Gp,backendName:"webgpu",kernelFunc:fa};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ki(n,t,e){const s=n[0].dtype;if(s==="complex64"){const m=n.map(k=>Co({inputs:{input:k},backend:e})),g=n.map(k=>fa({inputs:{input:k},backend:e})),b=Ki(m,t,e),v=Ki(g,t,e),w=Xs({inputs:{real:b,imag:v},backend:e});return m.forEach(k=>e.disposeData(k.dataId)),g.forEach(k=>e.disposeData(k.dataId)),e.disposeData(b.dataId),e.disposeData(v.dataId),w}let i=e.shouldExecuteOnCPU(n);if(s==="string"&&(i=!0),i){const m=n.map(I=>{const $=[-1,et(I.shape.slice(t))];return ft({inputs:{x:I},backend:e,attrs:{shape:$}})}),g=m.map(I=>({vals:e.readSync(I.dataId),shape:I.shape})),b=cs(m.map(I=>I.shape),1),v=m[0].shape[0]===1,w=cA(g,b,s,v),k=cs(n.map(I=>I.shape),t),C=e.makeTensorInfo(k,s,w);return m.forEach(I=>e.disposeData(I.dataId)),C}const o=e.device.limits.maxStorageBuffersPerShaderStage-1;if(n.length>o){const m=[];for(let b=0;b<n.length;b+=o){const v=n.slice(b,b+o);m.push(Ki(v,t,e))}const g=Ki(m,t,e);for(const b of m)e.disposeData(b.dataId);return g}const{tensors2D:r,outShape:a}=uz(n,t,e),l=r.map(m=>m.shape),u=new az(l),c=[],h=new Array(l.length-1);if(h.length>0){h[0]=l[0][1],c.push({type:"int32",data:[h[0]]});for(let m=1;m<h.length;m++)h[m]=h[m-1]+l[m][1],c.push({type:"int32",data:[h[m]]})}const p=e.runWebGPUProgram(u,r,r[0].dtype,c);r.forEach(m=>e.disposeData(m.dataId));const f=ft({inputs:{x:p},backend:e,attrs:{shape:a}});return e.disposeData(p.dataId),f}function uz(n,t,e){const s=cs(n.map(o=>o.shape),t);return{tensors2D:n.map(o=>ft({inputs:{x:o},backend:e,attrs:{shape:[et(o.shape.slice(0,t)),et(o.shape.slice(t))]}})),outShape:s}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yy(n){const{inputs:t,backend:e,attrs:s}=n,{axis:i}=s,o=ee(i,t[0].shape)[0],r=t.map(u=>u.shape);Hp(r,o);const a=cs(t.map(u=>u.shape),o);if(et(a)===0)return e.makeTensorInfo(a,t[0].dtype,[]);const l=t.filter(u=>et(u.shape)>0);return l.length===1?je({inputs:{x:l[0]},backend:e}):Ki(l,o,e)}const cz={kernelName:Rl,backendName:"webgpu",kernelFunc:Yy};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hz(n,t,e,s,i=!1,o=null,r=!1,a=4,l=4,u=4){const c=z=>{switch(z){case 1:return"resData = f32(x[xIndex]);";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = vec4<f32>(x[xIndex / 4]);";default:throw new Error(`innerElementSize ${z} is not supported.`)}},h=z=>{switch(z){case 1:return"return f32(W[row * uniforms.wShape[3] + col]);";case 4:return"return vec4<f32>(W[(row * uniforms.wShape[3] + col) / 4]);";default:throw new Error(`innerElementSize ${z} is not supported.`)}},p=n?`
      let coord = vec4<i32>(batch, xRow, xCol, xCh);
      `:`
      let coord = vec4<i32>(batch, xCh, xRow, xCol);
      `,f=n?`
      let coords = vec4<i32>(
        batch,
        row / outWidth,
        row % outWidth,
        col);
      `:`
      let coords = vec4<i32>(
        batch,
        row,
        col / outWidth,
        col % outWidth);
      `,m=n?"uniforms.xShape[1]":"uniforms.xShape[2]",g=n?"uniforms.xShape[2]":"uniforms.xShape[3]",b=n?"row":"col",v=n?"col":"row",w=`
      let inChannels = uniforms.wShape[2];
      let outWidth = ${n?"uniforms.outShape[2]":"uniforms.outShape[3]"};
      let outRow = ${b} / outWidth;
      let outCol = ${b} % outWidth;

      let WRow = ${v} / (uniforms.filterDims[1] * inChannels);
      let WCol = ${v} / inChannels % uniforms.filterDims[1];
      let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * WRow - uniforms.pads[0];
      let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * WCol - uniforms.pads[1];
      let xCh = ${v} % inChannels;
      var resData = ${Rt(a)}(0.0);
      // The bounds checking is always needed since we use it to pad zero for
      // the 'same' padding type.
      if (xRow >= 0 && xRow < ${m} && xCol >= 0 && xCol < ${g}) {
        ${p}
        let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);
        ${c(a)}
      }
      return resData;`,k=n?t&&s?`
      ${w}`:`
      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${w}
      }
      return ${Rt(a)}(0.0);`:s&&e?`
      ${w}`:`
      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {
        ${w}
      }
      return ${Rt(a)}(0.0);`,C=`${h(l)}`,I=Rt(u),N=Rt(n?a:l),$=Rt(n?l:a);return`
      ${is(o,r,u===4,4)}
      fn mm_readA(batch: i32, row : i32, col : i32) -> ${N} {
        ${n?k:C}
      }

      fn mm_readB(batch: i32, row : i32, col : i32) -> ${$} {
        ${n?C:k}
      }

      fn mm_write(batch: i32, row : i32, col : i32, valueIn : ${I}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)
        {
        var value = valueIn;
        let outWidth = ${n?"uniforms.outShape[2]":"uniforms.outShape[3]"};
        ${f}
        ${Ks(i,o)}
        setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }`}class dz{constructor(t,e,s,i,o=!1,r=null,a=!1,l=!1){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=t.outShape,this.isChannelsLast=t.dataFormat==="channelsLast",this.isVec4=((t.inChannels%4===0||t.inChannels%3===0)&&this.isChannelsLast||t.outWidth%4===0&&!this.isChannelsLast)&&t.outChannels%4===0,this.dispatchLayout=this.isChannelsLast?{x:[3],y:[1,2],z:[0]}:{x:[2,3],y:[1],z:[0]},this.workgroupSize=Oy(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=_y(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4?(this.outputComponent=4,this.isChannelsLast&&t.inChannels%4!==0?(this.innerElementSize=3,this.variableComponents=[1,4]):(this.innerElementSize=4,this.variableComponents=[4,4]),o&&(this.variableNames.push("bias"),this.variableComponents.push(4)),a&&(this.variableNames.push("preluActivationWeights"),this.variableComponents.push(4))):(this.innerElementSize=this.elementsPerThread[0],o&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights")),this.sequentialAccessByThreads=l,this.addBias=o,this.activation=r,this.hasPreluActivationWeights=a,this.tileAOuter=this.workgroupSize[1]*this.elementsPerThread[1],this.tileBOuter=this.workgroupSize[0]*this.elementsPerThread[0],this.tileInner=Math.max(this.workgroupSize[0]*this.innerElementSize,this.workgroupSize[1]),this.fitAOuter=e%this.tileAOuter===0,this.fitBOuter=s%this.tileBOuter===0,this.fitInner=i%this.tileInner===0,this.shaderKey=`conv2DMM_${this.elementsPerThread}_${this.activation}}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.innerElementSize}_${this.isChannelsLast}_${this.sequentialAccessByThreads}`}getUserCode(){const t=this.isVec4?ha(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner):da(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner,!1,null,this.sequentialAccessByThreads),e=this.isVec4?[this.innerElementSize,4,4]:[1,1,1];return`
    ${hz(this.isChannelsLast,this.fitAOuter,this.fitBOuter,this.fitInner,this.addBias,this.activation,this.hasPreluActivationWeights,e[0],e[1],e[2])}
    ${t}
  `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pz{constructor(t,e=!1,s=null,i=!1){this.variableNames=["x","W"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>,",this.workgroupSize=[4,4,8],this.outputShape=t.outShape,this.isChannelsLast=t.dataFormat==="channelsLast",this.dispatchLayout=this.isChannelsLast?{x:[2],y:[1],z:[0,3]}:{x:[3],y:[2],z:[0,1]},this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=e,this.activation=s,this.hasPreluActivationWeights=i,e&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`conv2dnaive_${this.activation}_${this.isChannelsLast}`}getUserCode(){return`
       ${is(this.activation,this.hasPreluActivationWeights,!1,4)}
       fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32{
         let coords = vec4<i32>(batch, row, col, chan);
         if (coordsInBounds4D(coords, uniforms.xShape)) {
           return  getX(batch, row, col, chan);
         } else {
          return 0.0;
         }
       }
       fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{
         let coords = vec4<i32>(row, col, xChannel, outChannel);
         if(coordsInBounds4D(coords, uniforms.wShape)) {
           return getW(row, col, xChannel, outChannel);
          } else {
            return 0.0;
          }
       }
       fn writeResult(batch : i32, row : i32, col : i32, chan : i32, valueIn : f32) {
         let coords = ${this.isChannelsLast?"vec4<i32>(batch, row, col, chan);":"vec4<i32>(batch, chan, row, col);"}
         if (coordsInBounds4D(coords, uniforms.outShape)) {
           var value = valueIn;
           ${Ks(this.addBias,this.activation)}
           setOutputAtCoords(coords.x, coords.y, coords.z, coords.w, value);
         }
       }
       ${ot("index")} {
         let coords = getOutputCoords();
         let batch = coords[0];
         let outChannel = ${this.isChannelsLast?"coords[3];":"coords[1];"}
         let outRow = ${this.isChannelsLast?"coords[1];":"coords[2];"}
         let outCol = ${this.isChannelsLast?"coords[2];":"coords[3];"}
         var acc : f32 = 0.0;
         for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {
           for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {
             let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * row - uniforms.pads[0];
             let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * col - uniforms.pads[1];
             for (var xChannel = 0; xChannel < ${this.isChannelsLast?"uniforms.xShape[3];":"uniforms.xShape[1];"} xChannel = xChannel + 1) {
               ${this.isChannelsLast?"let v = readInp(batch, xRow, xCol, xChannel);":"let v = readInp(batch, xChannel, xRow, xCol);"}
               let f = readFilt(row, col, xChannel, outChannel);
               acc = acc + v * f;
             }
           }
         }
         writeResult(batch, outRow, outCol, outChannel, acc);
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fz{constructor(t,e){this.variableNames=["x"],this.uniforms=`pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, outWidth : i32, itemsPerBlockRow : i32,
       inChannels : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=e,this.shaderKey=`im2col_${this.isChannelsLast}`}getUserCode(){const t=this.isChannelsLast?1:2,e=this.isChannelsLast?2:3,s=this.isChannelsLast?"coords[1]":"coords[2]",i=this.isChannelsLast?"coords[2]":"coords[1]",o=this.isChannelsLast?"getX(batch, xRow, xCol, ch)":"getX(batch, ch, xRow, xCol)";return`
    ${ot("index")} {
      let coords = getCoordsFromIndex(index);
      if(index < uniforms.size) {
        let batch = coords[0];
        let row = ${s};
        let col = ${i};
        let offsetY = (row / uniforms.outWidth) * uniforms.strides[0] - uniforms.pads[0];
        let xRow = offsetY + uniforms.dilations[0] * (col / uniforms.itemsPerBlockRow);
        var value = 0.0;
        if(xRow < uniforms.xShape[${t}] && xRow >= 0) {
          let offsetX = (row % uniforms.outWidth) * uniforms.strides[1] -
              uniforms.pads[1];
          let xCol = offsetX + uniforms.dilations[1] * ((col %
              uniforms.itemsPerBlockRow) / uniforms.inChannels);
          let ch = col % uniforms.inChannels;
          if(xCol < uniforms.xShape[${e}] && xCol >= 0) {
            value = ${o};
          }
        }
        setOutputAtIndex(index, value);
      }
    }
   `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lr(n,t){const e=n.length;return e>=3?t?[...n.slice(0,-3),n[e-3]*n[e-2],n[e-1]]:[...n.slice(0,-3),n[e-3],n[e-2]*n[e-1]]:!t&&e===1&&n[0]>1?[n[0],1]:null}function mz({x:n,filter:t,convInfo:e,backend:s,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:r=0,activation:a=null}){const l=e.dataFormat==="channelsLast",u=!l,c=!1,h=l&&e.filterHeight===e.inHeight&&e.filterWidth===e.inWidth&&e.padInfo.type==="VALID",p=[];let f,m;if(h){const v=e.inHeight*e.inWidth*e.inChannels;f=ft({inputs:{x:n},backend:s,attrs:{shape:[1,e.batchSize,v]}}),m=ft({inputs:{x:t},backend:s,attrs:{shape:[1,v,e.outChannels]}})}else f=ft({inputs:{x:n},backend:s,attrs:{shape:l?[e.batchSize,e.inHeight*e.inWidth,e.inChannels]:[e.batchSize,e.inChannels,e.inHeight*e.inWidth]}}),m=ft({inputs:{x:t},backend:s,attrs:{shape:[1,e.inChannels,e.outChannels]}});if(p.push(f),p.push(m),o!=null){const v=lr(o.shape,l);v!=null&&(o=ft({inputs:{x:o},backend:s,attrs:{shape:v}}),p.push(o))}if(i!=null){const v=lr(i.shape,l);v!=null&&(i=ft({inputs:{x:i},backend:s,attrs:{shape:v}}),p.push(i))}const g=pa({a:l?f:m,b:l?m:f,transposeA:u,transposeB:c,backend:s,bias:i,activation:a,preluActivationWeights:o,leakyreluAlpha:r}),b=ft({inputs:{x:g},backend:s,attrs:{shape:e.outShape}});p.push(g);for(const v of p)s.disposeData(v.dataId);return b}function gz({x:n,filter:t,convInfo:e,backend:s,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:r=0,activation:a=null}){const{filterWidth:l,filterHeight:u,inChannels:c,strideWidth:h,strideHeight:p,padInfo:f,outWidth:m,outHeight:g,dilationWidth:b,dilationHeight:v,dataFormat:w}=e,k=w==="channelsLast",C=l*u*c,I=g*m,N=k?[e.batchSize,I,C]:[e.batchSize,C,I],$=new fz(N,k),A=[{type:"int32",data:[f.top,f.left]},{type:"int32",data:[p,h]},{type:"int32",data:[v,b]},{type:"int32",data:[m]},{type:"int32",data:[c*l]},{type:"int32",data:[c]}],z=s.runWebGPUProgram($,[n],n.dtype,A),F=[];F.push(z);const E=ft({inputs:{x:t},backend:s,attrs:{shape:[1,C,-1]}});if(F.push(E),o!=null){const V=lr(o.shape,k);V!=null&&(o=ft({inputs:{x:o},backend:s,attrs:{shape:V}}),F.push(o))}if(i!=null){const V=lr(i.shape,k);V!=null&&(i=ft({inputs:{x:i},backend:s,attrs:{shape:V}}),F.push(i))}const W=pa({a:k?z:E,b:k?E:z,transposeA:!k,transposeB:!1,backend:s,bias:i,activation:a,preluActivationWeights:o,leakyreluAlpha:r}),_=ft({inputs:{x:W},backend:s,attrs:{shape:e.outShape}});F.push(W);for(const V of F)s.disposeData(V.dataId);return _}function Zy({x:n,filter:t,convInfo:e,backend:s,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:r=0,activation:a=null}){const l=i!=null,u=o!=null,c=e.dataFormat==="channelsLast",h=c&&e.filterHeight===e.inHeight&&e.filterWidth===e.inWidth&&e.padInfo.type==="VALID",p=he().getBool("WEBGPU_USE_NAIVE_CONV2D_DEBUG");if(!p&&(h||e.filterHeight===1&&e.filterWidth===1&&e.dilationHeight===1&&e.dilationWidth===1&&e.strideHeight===1&&e.strideWidth===1&&(e.padInfo.type==="SAME"||e.padInfo.type==="VALID")))return mz({x:n,filter:t,convInfo:e,backend:s,bias:i,activation:a,preluActivationWeights:o,leakyreluAlpha:r});const f=he().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),m=f>-1?f:s.thresholdToIncreaseWorkgroups,g=e.batchSize*Math.ceil(e.outHeight*e.outWidth/32)*Math.ceil(e.outChannels/32);if(he().getBool("WEBGPU_CONV_SEPARATE_IM2COL_SHADER")||g<=m)return gz({x:n,filter:t,convInfo:e,backend:s,bias:i,preluActivationWeights:o,leakyreluAlpha:r,activation:a});let b;const v=[e.padInfo.top,e.padInfo.left],w=[{type:"int32",data:[e.filterHeight,e.filterWidth]},{type:"int32",data:[...v]},{type:"int32",data:[e.strideHeight,e.strideWidth]},{type:"int32",data:[e.dilationHeight,e.dilationWidth]}];if(p)b=new pz(e,l,a,u);else{const N=c?e.outHeight*e.outWidth:e.outChannels,$=c?e.outChannels:e.outHeight*e.outWidth,A=e.filterHeight*e.filterWidth*e.inChannels;w.push({type:"int32",data:[N]},{type:"int32",data:[$]},{type:"int32",data:[A]});const z=s.adapterInfo.isIntel();b=new dz(e,N,$,A,l,a,u,z)}const k=[],C=[n,t];l&&(!c&&i.shape.length===1&&(i=ft({inputs:{x:i},backend:s,attrs:{shape:[i.shape[0],1,1]}}),k.push(i)),C.push(i)),u&&(!c&&o.shape.length===1&&(o=ft({inputs:{x:o},backend:s,attrs:{shape:[o.shape[0],1,1]}}),k.push(o)),C.push(o)),a==="leakyrelu"&&(w.push({type:"float32",data:[r]}),b.uniforms+=" alpha : f32,");const I=s.runWebGPUProgram(b,C,n.dtype,w);for(const N of k)s.disposeData(N.dataId);return I}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yz(n){const{inputs:t,attrs:e,backend:s}=n,{x:i,filter:o}=t,{strides:r,pad:a,dataFormat:l,dilations:u,dimRoundingMode:c}=e,h=ws(l),p=Xe(i.shape,o.shape,r,u,a,c,!1,h);return Zy({x:i,filter:o,convInfo:p,backend:s})}const bz={kernelName:Al,backendName:"webgpu",kernelFunc:yz};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xz{constructor(t){this.variableNames=["dy","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>,",this.workgroupSize=[64,1,1],this.size=!1,this.isVec4=!1,this.workPerThread=1,this.outputShape=t.inShape,this.isChannelsLast=t.dataFormat==="channelsLast",this.isVec4=this.isChannelsLast&&t.outChannels%4===0&&t.inChannels%4===0,this.isVec4?(this.workPerThread=2,this.outputComponent=4,this.workgroupSize=[4,4,4],this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize,[4,this.workPerThread,1])):(this.size=!0,this.workPerThread=1,this.workgroupSize=[64,1,1],this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize)),this.shaderKey=`conv2DDerInput_${this.isChannelsLast}_${this.isVec4}_${this.workPerThread}`}getUserCode(){const t=this.isChannelsLast?1:2,e=this.isChannelsLast?2:3,s=this.isChannelsLast?3:1,i=`
    ${ot()} {
      let batch = i32(globalId.z) / uniforms.outShape[1];
      let r = i32(globalId.z) % uniforms.outShape[1];
      let c = i32(globalId.y) * ${this.workPerThread};
      let d1 = i32(globalId.x) * 4;

      let dyCorner = vec2<i32>(r, c) - uniforms.pads;

      // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
      // ? = to be determined. : = across all values in that axis.
      var dotProd: array<vec4<f32>, ${this.workPerThread}>;
      for (var i = 0; i < ${this.workPerThread}; i++) {
        dotProd[i] = vec4<f32>(0.0);
      }
      for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
        let dyR = f32(dyCorner.x + wR) / f32(uniforms.strides.x);
        let wRPerm = uniforms.filterDims.x - 1 - wR;
        if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) ||
            fract(dyR) > 0.0) {
          continue;
        }
        let idyR = i32(dyR);

        for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
          let dyC = f32(dyCorner.y + wC) / f32(uniforms.strides.y);
          let dyC2 = f32(dyCorner.y + 1 + wC) / f32(uniforms.strides.y);
          let wCPerm = uniforms.filterDims.y - 1 - wC;
          var bDyCVal = true;
          var bDyCVal2 = true;
          if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
              fract(dyC) > 0.0) {
            bDyCVal = false;
          }
          if (dyC2 < 0.0 || dyC2 >= f32(uniforms.outBackprop[2]) ||
              fract(dyC2) > 0.0) {
            bDyCVal2 = false;
          }

          let idyC = i32(dyC);
          let idyC2 = i32(dyC2);
          if (bDyCVal && bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
              xValue = getDy(batch, idyR, idyC2, d2);
              dotProd[1] = dotProd[1] + vec4<f32>(dot(xValue, wValue0),
                                                  dot(xValue, wValue1),
                                                  dot(xValue, wValue2),
                                                  dot(xValue, wValue3));
            }
          } else if (bDyCVal) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
            }
          } else if (bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC2, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[1] = dotProd[1] + tmpval;
            }
          }
        }
      }

      for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
        let coords = vec4<i32>(batch, r, c + i, d1);
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], dotProd[i]);
        }
      }
    }
    `;return this.isVec4?`
    ${i}
    `:`
    ${ot("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[${s}];

        let dyCorner = vec2<i32>(coords[${t}], coords[${e}]) - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.strides.x);
          let wRPerm = uniforms.filterDims.x - 1 - wR;
          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||
              wRPerm < 0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.strides.y);
            let wCPerm = uniforms.filterDims.y - 1 - wC;
            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
                fract(dyC) > 0.0 || wCPerm < 0) {
              continue;
            }
            let idyC = i32(dyC);

            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {
              let xValue = ${this.isChannelsLast?"getDy(batch, idyR, idyC, d2)":"getDy(batch, d2, idyR, idyC)"};
              let wValue = getW(wRPerm, wCPerm, d1, d2);
              dotProd = dotProd + xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}class wz{constructor(t){this.variableNames=["x","dy"],this.uniforms="pads : vec2<i32>, strides : vec2<i32>, batchSize : i32, outHeight : i32, outWidth : i32, inHeight : i32, inWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.filterShape,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=t.dataFormat==="channelsLast",this.shaderKey=`conv2DDerFilter_${this.isChannelsLast}`}getUserCode(){return`
    ${ot("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let d2 = coords[3];

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b = b + 1) {
          for (var yR = 0; yR < uniforms.outHeight; yR = yR + 1) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];
            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC = yC + 1) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              if (${this.isChannelsLast}) {
                let dyValue = getDy(b, yR, yC, d2);
                let xValue = getX(b, xR, xC, d1);
                dotProd = dotProd + xValue * dyValue;
              } else {
                let dyValue = getDy(b, d2, yR, yC);
                let xValue = getX(b, d1, xR, xC);
                dotProd = dotProd + xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}class vz{constructor(t){this.variableNames=["x","dy"],this.uniforms=`pads : vec3<i32>, strides : vec3<i32>, batchSize : i32, outDepth : i32,
       outHeight : i32, outWidth : i32, inDepth : i32, inHeight : i32, inWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.filterShape,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerFilter"}getUserCode(){return`
    ${ot("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wF = coords.x;
        let wR = coords.y;
        let wC = coords.z;
        let d1 = coords.w;
        let d2 = coords.u;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yF = 0; yF < uniforms.outDepth; yF++) {
            let xF = wF + yF * uniforms.strides[0] - uniforms.pads[0];
            if (xF < 0 || xF >= uniforms.inDepth) {
              continue;
            }

            for (var yR = 0; yR < uniforms.outHeight; yR++) {
              let xR = wR + yR * uniforms.strides[1] - uniforms.pads[1];
              if (xR < 0 || xR >= uniforms.inHeight) {
                continue;
              }

              for (var yC = 0; yC < uniforms.outWidth; yC++) {
                let xC = wC + yC * uniforms.strides[2] - uniforms.pads[2];
                if (xC < 0 || xC >= uniforms.inWidth) {
                  continue;
                }

                let dyValue = getDy(b, yF, yR, yC, d2);
                let xValue = getX(b, xF, xR, xC, d1);
                dotProd += xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}class Cz{constructor(t){this.variableNames=["dy","W"],this.uniforms=`filterDims : vec3<i32>, pads : vec3<i32>, strides : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32, outChannels : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.inShape,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerInput"}getUserCode(){return`
    ${ot("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let d1 = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyFCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let dyF = f32(dyFCorner + wF) / f32(uniforms.strides[0]);
          if (dyF < 0.0 || dyF >= f32(uniforms.outDepth) || fract(dyF) > 0.0) {
            continue;
          }
          let idyF = i32(dyF);

          let wFPerm = uniforms.filterDims[0] - 1 - wF;

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            let wRPerm = uniforms.filterDims[1] - 1 - wR;

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let wCPerm = uniforms.filterDims[2] - 1 - wC;

              for (var d2 = 0; d2 < uniforms.outChannels; d2++) {
                let xValue = getDy(batch, idyF, idyR, idyC, d2);
                let wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kz(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,dy:o}=t,{strides:r,pad:a,dataFormat:l,dimRoundingMode:u,filterShape:c}=s,h=ws(l),p=Xe(i.shape,c,r,1,a,u,!1,h),f=new wz(p),m=[{type:"int32",data:[p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.batchSize]},{type:"int32",data:[p.outHeight]},{type:"int32",data:[p.outWidth]},{type:"int32",data:[p.inHeight]},{type:"int32",data:[p.inWidth]}];return e.runWebGPUProgram(f,[i,o],i.dtype,m)}const Sz={kernelName:jp,backendName:"webgpu",kernelFunc:kz};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iz(n=4){const t=o=>{switch(o){case 1:return"return W[getIndexFromCoords4D(coord, uniforms.wShape)];";case 4:return`
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];
            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];
            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];
            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];
            return vec4<f32>(v0, v1, v2, v3);
            `;default:throw new Error(`innerElementSize ${o} is not supported.`)}},s=`if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${`
      let outRow = row / uniforms.outShape[2];
      let outCol = row % uniforms.outShape[2];

      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];
      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.strides[0]);
      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.strides[1]);
      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {
        return ${Rt(n)}(0.0);
      }
      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {
        return ${Rt(n)}(0.0);
      }
      let coord = vec4<i32>(
          batch,
          i32(xR),
          i32(xC),
          col % uniforms.outBackprop[3]);
      return x[getIndexFromCoords4D(coord, uniforms.xShape)/${n}];`}
      }
      return ${Rt(n)}(0.0);`;return`
  fn mm_readA(batch: i32, row : i32, col : i32) -> ${Rt(n)} {
    ${s}
  }

  fn mm_readB(batch: i32, row : i32, col : i32) -> ${Rt(n)} {
    let coordX = uniforms.filterDims.x - 1 -
        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
    let coordY = uniforms.filterDims.y - 1 -
        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];
    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&
        coordX >= 0 && coordY >= 0) {
      let rowInner = row % uniforms.outBackprop[3];
      let coord = vec4<i32>(coordX, coordY, col, rowInner);
      ${t(n)}
    }
    return ${Rt(n)}(0.0);
  }

  fn mm_write(batch: i32, row : i32, col : i32, valueInput : ${Rt(n)}) {
    if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
      var value = valueInput;
      let outCoord = vec4<i32>(
          batch,
          row / uniforms.outShape[2],
          row % uniforms.outShape[2],
          col);
      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/${n}] = value;
    }
  }`}class Nz{constructor(t){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=t.inShape,tt(t.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),this.isVec4=t.inChannels%4===0&&t.outChannels%4===0,this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workgroupSize=Oy(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=_y(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4&&(this.outputComponent=4,this.variableComponents=[4,1]),this.shaderKey=`conv2DDerInputMM_${this.isVec4}_${this.elementsPerThread}`}getUserCode(){const t=this.isVec4?ha(this.elementsPerThread,this.workgroupSize):da(this.elementsPerThread,this.workgroupSize);return`
    ${Iz(this.isVec4?4:1)}
    ${t}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $z(n){const{inputs:t,backend:e,attrs:s}=n,{dy:i,filter:o}=t,{inputShape:r,strides:a,pad:l,dataFormat:u,dimRoundingMode:c}=s,h=ws(u),p=Xe(r,o.shape,a,1,l,c,!1,h),f=[{type:"int32",data:[p.filterHeight,p.filterWidth]},{type:"int32",data:[p.filterHeight-1-p.padInfo.top,p.filterWidth-1-p.padInfo.left]},{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.batchSize,p.outHeight,p.outWidth,p.outChannels]}];let m;if(he().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE")||p.dataFormat!=="channelsLast")m=new xz(p);else{m=new Nz(p);const g=p.inHeight*p.inWidth,b=p.inChannels,v=p.filterHeight*p.filterWidth*p.outChannels;f.push({type:"uint32",data:[g]},{type:"uint32",data:[b]},{type:"uint32",data:[v]})}return e.runWebGPUProgram(m,[i,o],"float32",f)}const Dz={kernelName:zl,backendName:"webgpu",kernelFunc:$z};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Rz{constructor(t){this.variableNames=["x","W"],this.uniforms="filterDims: vec3<i32>, pads: vec3<i32>, strides: vec3<i32>, dilations: vec3<i32>,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.outShape,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3dnaive"}getUserCode(){return`
    ${ot("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords.x;
        let d2 = coords.u;

        let xFRCCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
        let xFCorner = xFRCCorner.x;
        let xRCorner = xFRCCorner.y;
        let xCCorner = xFRCCorner.z;

        let inputDepthNearestVec4 = (uniforms.xShape.u / 4) * 4;
        let inputDepthVec4Remainder = uniforms.xShape.u % 4;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let xF = xFCorner + wF * uniforms.dilations[0];
          if (xF < 0 || xF >= uniforms.xShape.y) {
            continue;
          }

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let xR = xRCorner + wR * uniforms.dilations[1];
            if (xR < 0 || xR >= uniforms.xShape.z) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let xC = xCCorner + wC * uniforms.dilations[2];
              if (xC < 0 || xC >= uniforms.xShape.w) {
                continue;
              }

              for (var d1 = 0; d1 < inputDepthNearestVec4; d1 += 4) {
                let xValues = vec4<f32>(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                let wValues = vec4<f32>(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (inputDepthVec4Remainder == 1) {
                dotProd += getX(batch, xF, xR, xC, inputDepthNearestVec4) *
                  getW(wF, wR, wC, inputDepthNearestVec4, d2);
              } else if (inputDepthVec4Remainder == 2) {
                let xValues = vec2<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1)
                );
                let wValues = vec2<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (inputDepthVec4Remainder == 3) {
                let xValues = vec3<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2)
                );
                let wValues = vec3<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }`}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Az(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,filter:o}=t,{strides:r,pad:a,dilations:l}=s,u=Ni(i.shape,o.shape,r,l,a),c=[u.padInfo.front,u.padInfo.top,u.padInfo.left],h=[{type:"int32",data:[u.filterDepth,u.filterHeight,u.filterWidth]},{type:"int32",data:[...c]},{type:"int32",data:[u.strideDepth,u.strideHeight,u.strideWidth]},{type:"int32",data:[u.dilationDepth,u.dilationHeight,u.dilationWidth]}],p=new Rz(u),f=es(i.dtype,o.dtype);return e.runWebGPUProgram(p,[i,o],f,h)}const Tz={kernelName:Ml,backendName:"webgpu",kernelFunc:Az};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zz(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,dy:o}=t,{strides:r,pad:a,filterShape:l}=s,u=Ni(i.shape,l,r,1,a),c=new vz(u),h=[{type:"int32",data:[u.padInfo.front,u.padInfo.top,u.padInfo.left]},{type:"int32",data:[u.strideDepth,u.strideHeight,u.strideWidth]},{type:"int32",data:[u.batchSize]},{type:"int32",data:[u.outDepth]},{type:"int32",data:[u.outHeight]},{type:"int32",data:[u.outWidth]},{type:"int32",data:[u.inDepth]},{type:"int32",data:[u.inHeight]},{type:"int32",data:[u.inWidth]}];return e.runWebGPUProgram(c,[i,o],o.dtype,h)}const Fz={kernelName:Fl,backendName:"webgpu",kernelFunc:zz};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mz(n){const{inputs:t,backend:e,attrs:s}=n,{dy:i,filter:o}=t,{strides:r,pad:a,inputShape:l}=s,u=Ni(l,o.shape,r,1,a),c=new Cz(u),h=[{type:"int32",data:[u.filterDepth,u.filterHeight,u.filterWidth]},{type:"int32",data:[u.filterDepth-1-u.padInfo.front,u.filterHeight-1-u.padInfo.top,u.filterWidth-1-u.padInfo.left]},{type:"int32",data:[u.strideDepth,u.strideHeight,u.strideWidth]},{type:"int32",data:[u.outDepth]},{type:"int32",data:[u.outHeight]},{type:"int32",data:[u.outWidth]},{type:"int32",data:[u.outChannels]}];return e.runWebGPUProgram(c,[i,o],i.dtype,h)}const Pz={kernelName:Kp,backendName:"webgpu",kernelFunc:Mz};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ez=Bt({opType:st.COS}),Lz={kernelName:Cr,backendName:"webgpu",kernelFunc:Ez};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oz=Bt({opType:st.COSH}),_z={kernelName:kr,backendName:"webgpu",kernelFunc:Oz};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Bz{constructor(t,e,s,i){this.variableNames=["Image","Boxes","BoxInd"],this.uniforms="extrapolationValue : f32,",this.workgroupSize=[64,1,1],this.size=!0;const[o]=e;this.outputShape=[o,s[0],s[1],t],this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.methodId=i==="bilinear"?1:0,this.cropHeightBiggerThan1=this.outputShape[1]>1,this.cropWidthBiggerThan1=this.outputShape[2]>1,this.shaderKey=`cropAndResize_${this.methodId}_${this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`}getUserCode(){const[t,e]=["f32(uniforms.imageShape[1] - 1)","f32(uniforms.imageShape[2] - 1)"],[s,i,o]=this.cropHeightBiggerThan1?[`(${t} / f32(uniforms.outShape[1] - 1))`,"(y2-y1) * height_ratio",`y1*${t} + f32(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${t}`],[r,a,l]=this.cropWidthBiggerThan1?[`(${e} / f32(uniforms.outShape[2] - 1))`,"(x2-x1) * width_ratio",`x1*${e} + f32(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${e}`];return`
    ${ot("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let height_ratio = f32(${s});
        let width_ratio = f32(${r});
        let b = coords[0];
        let y = coords[1];
        let x = coords[2];
        let d = coords[3];
        // get box vals
        let y1 = getBoxes(b, 0);
        let x1 = getBoxes(b, 1);
        let y2 = getBoxes(b, 2);
        let x2 = getBoxes(b, 3);
        // get image in batch index
        let bInd = i32(round(getBoxInd(b)));
        if(bInd < 0 || bInd >= uniforms.outShape[0]) {
          return;
        }
        let height_scale = ${i};
        let width_scale = ${a};
        let in_y = ${o};
        if( in_y < 0.0 || in_y > ${t} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let in_x = ${l};
        if( in_x < 0.0 || in_x > ${e} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let sourceFracIndexCR = vec2<f32>(in_x,in_y);
        if(${this.methodId} == 1) {
          // Compute the four integer indices.
          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);
          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));
          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);
          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);
          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);
          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);
          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);
          let top = topLeft + (topRight - topLeft) * fracCR.x;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          let newValue = top + (bottom - top) * fracCR.y;
          setOutputAtIndex(index, newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          let sourceNearestCR = vec2<i32>(floor(
            sourceFracIndexCR + vec2<f32>(0.5,0.5)));
          let newValue = getImage(
            bInd, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutputAtIndex(index, newValue);
        }
      }
    }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wz=n=>{const{inputs:t,backend:e,attrs:s}=n,{image:i,boxes:o,boxInd:r}=t,{cropSize:a,method:l,extrapolationValue:u}=s,c=new Bz(i.shape[3],o.shape,a,l),h=[{type:"float32",data:[u]}];return e.runWebGPUProgram(c,[i,o,r],"float32",h)},Vz={kernelName:Xp,backendName:"webgpu",kernelFunc:Wz};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var ro;(function(n){n.Prod="*",n.Sum="+"})(ro||(ro={}));class Kh{constructor(t,e,s,i){this.variableNames=["x"],this.uniforms="index : f32,",this.size=!0,this.workgroupSize=[128,1,1],this.outputShape=e,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.exclusive=s,this.reverse=i,this.op=t,this.shaderKey=`cum_${this.op}_${this.exclusive}_${this.reverse}`}getUserCode(){const t=this.outputShape.length,e=this.op===ro.Prod?"1.0":"0.0",s=this.exclusive?e:`getX(${Xh(t,"coords",this.op)})`,i=this.outputShape[this.outputShape.length-1];let o="",r="";return this.exclusive?(o=this.reverse?`end != ${i-1}`:"end != 0",r=this.reverse?"end + 1":"end - 1"):(o=this.reverse?`end + pow2 < ${i}`:"end >= pow2",r=this.reverse?"end + pow2":"end - pow2"),`
      ${ot("index")} {
       if (index < uniforms.size) {
         var coords = getCoordsFromIndex(index);

         let end = ${qh(t,"coords",this.op)};
         var val = ${s};
         let pow2 = i32(pow(2.0, uniforms.index));
         if (${o}) {
           let idx = ${r};
           ${qh(t,"coords",this.op)} = idx;
           val ${this.op}= getX(${Xh(t,"coords",this.op)});
         }
         setOutputAtIndex(index, val);
       }
      }
    `}}function Xh(n,t,e){if(n===1)return`${t}`;if(n===2)return`${t}.x, ${t}.y`;if(n===3)return`${t}.x, ${t}.y, ${t}.z`;if(n===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw Error(`Cumulative ${e} for rank ${n} is not yet supported`)}function qh(n,t,e){if(n===1)return`${t}`;if(n===2)return`${t}.y`;if(n===3)return`${t}.z`;if(n===4)return`${t}.w`;throw Error(`Cumulative ${e} for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qy(n,t,e,s,i,o){const r=t.shape.length,a=Pe([s],r);let l=t;a!=null&&(l=_n({inputs:{x:t},backend:e,attrs:{perm:a}}));const u=Ke(1,r)[0];if(u!==r-1)throw new Error(`WebGPU cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${s}`);const c=l.shape[u];let h=je({inputs:{x:l},backend:e});for(let p=0;p<=Math.ceil(Math.log2(c))-1;p++){const f=new Kh(n,l.shape,!1,o),m=h,g=[{type:"float32",data:[p]}];h=e.runWebGPUProgram(f,[h],h.dtype,g),e.disposeData(m.dataId)}if(i){const p=new Kh(n,l.shape,i,o),f=h,m=[{type:"float32",data:[0]}];h=e.runWebGPUProgram(p,[h],h.dtype,m),e.disposeData(f.dataId)}if(a!=null){const p=_s(a),f=_n({inputs:{x:h},backend:e,attrs:{perm:p}});return e.disposeData(h.dataId),e.disposeData(l.dataId),f}return h}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uz(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:o,exclusive:r,reverse:a}=s;return Qy(ro.Prod,i,e,o,r,a)}const Gz={kernelName:qp,backendName:"webgpu",kernelFunc:Uz};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hz(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:o,exclusive:r,reverse:a}=s;return Qy(ro.Sum,i,e,o,r,a)}const jz={kernelName:Pl,backendName:"webgpu",kernelFunc:Hz};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kz(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,weights:o}=t,{size:r,binaryOutput:a}=s,l=i.shape.length===1,c=et(o.shape)>0,h=o.dtype,p=l?[i.shape[0]]:[i.shape[0],i.shape[1]],f=l?[r]:[i.shape[0],r],m=_e({backend:e,attrs:{shape:f,value:0,dtype:h}}),g=new Xy(p,c,a),b=[{type:"int32",data:[r]}],v=c?[i,o]:[i];return e.runWebGPUProgram(g,v,h,b,m)}const Xz={kernelName:Yp,backendName:"webgpu",kernelFunc:Kz};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qz{constructor(t,e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.uniforms="blockSize : i32,",this.outputShape=t,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`depthToSpace_${e}`,this.dataFormat=e}getUserCode(){return`
      ${ot("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let h = ${this.getHeightCoordString()};
          let w = ${this.getWidthCoordString()};
          let d = ${this.getDepthCoordString()};

          let in_h = h / uniforms.blockSize;
          let offset_h = h % uniforms.blockSize;
          let in_w = w / uniforms.blockSize;
          let offset_w = w % uniforms.blockSize;
          let offset_d = (offset_h * uniforms.blockSize + offset_w) *
            ${this.getOutputDepthSize()};
          let in_d = d + offset_d;

          let rlt = ${this.getInputSamplingString()};
          setOutputAtIndex(index, rlt);
        }
      }`}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?"uniforms.outShape[3]":"uniforms.outShape[1]"}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yz(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{blockSize:o,dataFormat:r}=s,a=i.shape[0],l=r==="NHWC"?i.shape[1]:i.shape[2],u=r==="NHWC"?i.shape[2]:i.shape[3],c=r==="NHWC"?i.shape[3]:i.shape[1],h=l*o,p=u*o,f=c/(o*o),m=r==="NHWC"?[a,h,p,f]:[a,f,h,p],g=[{type:"int32",data:[o]}],b=new qz(m,r);return e.runWebGPUProgram(b,[i],i.dtype,g)}const Zz={kernelName:Zp,backendName:"webgpu",kernelFunc:Yz};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Qz{constructor(t,e,s,i=!1,o=null,r=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>,",this.workgroupSize=[16,16,1],this.outputShape=t,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),i&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.addBias=i,this.activation=o,this.hasPreluActivation=r,this.filterHeight=e,this.filterWidth=s,this.shaderKey=`depthwiseNCHW_${this.activation}_${this.filterHeight}_${this.filterWidth}`}getUserCode(){const t=this.filterWidth*this.filterHeight,e=this.workgroupSize[0]*this.workgroupSize[1]*this.workgroupSize[2],s=this.workgroupSize[1]+this.filterHeight-1,i=this.workgroupSize[0]+this.filterWidth-1;return`
      ${is(this.activation,this.hasPreluActivation,!1,4)}

      var<workgroup> mm_Asub : array<array<f32, ${i}>, ${s}>;
      var<workgroup> mm_Bsub : array<array<f32, ${this.filterWidth}>, ${this.filterHeight}>;
      fn readX(batch : i32, channel : i32, row : i32, col : i32) -> f32 {
        var value = 0.0;
        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])
        {
          value = getX(batch, channel, row, col);
        }
        return value;
      }

      ${ot()} {
        let coords = getOutputCoords();
        let batch = coords[0];
        let xRCCorner = vec2<i32>(coords.zw) - uniforms.pads;
        let channelMul = uniforms.wShape[3];
        let d1 = coords[1] / channelMul;
        let q = coords[1] % channelMul;

        let inputRowStart = xRCCorner.x;
        let inputColStart = xRCCorner.y;

        let localRow = i32(localId.y);
        let localCol = i32(localId.x);

        // Load one tile of X into local memory.
        for (var inputRow = localRow; inputRow < ${s}; inputRow = inputRow + ${this.workgroupSize[1]}) {
          for (var inputCol = localCol; inputCol < ${i}; inputCol = inputCol + ${this.workgroupSize[0]}) {
            let rowOffset = inputRow - localRow;
            let colOffset = inputCol - localCol;
            mm_Asub[inputRow][inputCol] = readX(batch, d1, inputRowStart + rowOffset, inputColStart + colOffset);
          }
        }

        // Load one tile of W into local memory.
        var wIndex = i32(localIndex);
        ${t<e?`if (wIndex < ${t})`:`for(; wIndex < ${t}; wIndex = wIndex + ${e})`}

        {
          let wRow = wIndex / ${this.filterWidth};
          let wCol = wIndex % ${this.filterWidth};
          mm_Bsub[wRow][wCol] = getW(wRow, wCol, d1, q);
        }

        workgroupBarrier();

        var value = 0.0;
        for (var wR = 0; wR < ${this.filterHeight}; wR = wR + 1) {
          for (var wC = 0; wC < ${this.filterWidth}; wC = wC + 1) {
            let xVal = mm_Asub[localRow + wR][localCol + wC];
            let wVal = mm_Bsub[wR][wC];
            value = fma(xVal, wVal, value);
          }
        }
        ${Ks(this.addBias,this.activation)}
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Jy{constructor(t,e=!1,s=null,i=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>, virtualWidth : i32,",this.workgroupSize=[64,1,1],this.workPerThread=4,this.outputComponent=4,this.outputShape=t.outShape,this.virtualWidth=Math.ceil(this.outputShape[2]/this.workPerThread)*this.workPerThread;const o=[this.outputShape[0],this.outputShape[1],this.virtualWidth,this.outputShape[3]];this.dispatchLayout=ht(o),this.dispatch=rt(this.dispatchLayout,o,this.workgroupSize,[this.outputComponent*this.workPerThread,1,1]),tt(t.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),e&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),this.convInfo=t,this.addBias=e,this.activation=s,this.hasPreluActivation=i,this.shaderKey=`depthwiseVec4_${s}_${this.convInfo.filterHeight}_${this.convInfo.filterWidth}_${this.convInfo.strideHeight}_${this.convInfo.strideWidth}_${this.workPerThread}`}getUserCode(){const t=(this.workPerThread-1)*this.convInfo.strideWidth+this.convInfo.filterWidth,e=this.convInfo.strideHeight,s=this.convInfo.strideWidth;return`
      ${is(this.activation,this.hasPreluActivation,!0,4)}
      fn readX(batch : i32, row : i32, col : i32, channel : i32) -> vec4<f32> {
        var value = vec4<f32>(0.0);
        if (col >=0 && col < uniforms.inDims[1]) {
          value = getX(batch, row, col, channel);
        }
        return value;
      }

      ${ot("index")} {
        let width0 = uniforms.outShape[3] / ${this.outputComponent};
        let d1 = (index % width0) * ${this.outputComponent};
        var index1 = index / width0;
        let width1 = uniforms.virtualWidth / ${this.workPerThread};
        let c = (index1 % width1) * ${this.workPerThread};
        index1 = index1 / width1;
        let r = index1 % uniforms.outShape[1];
        let batch = index1 / uniforms.outShape[1];

        let xRCCorner = vec2<i32>(r, c) * vec2<i32>(${e}, ${s}) - uniforms.pads;

        let xRCorner = xRCCorner.x;
        let xCCorner = xRCCorner.y;
        var xVals : array<vec4<f32>, ${t}>;
        var dotProd : array<vec4<f32>, ${this.workPerThread}>;
        for (var i = 0; i < ${this.workPerThread}; i++) {
          dotProd[i] = vec4<f32>(0.0);
        }

        // Use constant instead of uniform can give better performance.
        for (var wR = 0; wR < ${this.convInfo.filterHeight}; wR = wR + 1) {
          let xR = xRCorner + wR;
          if (xR >=0 && xR < uniforms.inDims[0]) {
            for (var i = 0; i < ${t}; i++) {
              xVals[i] = readX(batch, xR, xCCorner + i, d1);
            }
            for (var wC = 0; wC < ${this.convInfo.filterWidth}; wC = wC + 1) {
              let wValue = getW(wR, wC, d1, 0);
              for (var i = 0; i < ${this.workPerThread}; i++) {
                dotProd[i] = fma(xVals[i * ${s} + wC], wValue, dotProd[i]);
              }
            }
          }
        }

        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let coords = vec4<i32>(batch, r, c + i, d1);
          if (coordsInBounds4D(coords, uniforms.outShape)) {
            var value = dotProd[i];
            ${Ks(this.addBias,this.activation)}
            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tb{constructor(t,e=!1,s=null,i=!1){this.variableNames=["x","W"],this.uniforms=`pads : vec2<i32>, inDims : vec2<i32>, filterHeight : i32,
      filterWidth : i32, strides : vec2<i32>, dilations : vec2<i32>,`,this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=t.outShape,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=t.dataFormat==="channelsLast",e&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),this.convInfo=t,this.addBias=e,this.activation=s,this.hasPreluActivation=i,this.shaderKey=`depthwise_${this.activation}_${this.isChannelsLast}`}getUserCode(){const t=this.isChannelsLast?"getX(batch, xR, xC, d1);":"getX(batch, d1, xR, xC);";return`
      ${is(this.activation,this.hasPreluActivation,!1,4)}

      ${ot("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let batch = coords[0];
          let xRCCorner = vec2<i32>(coords.${this.isChannelsLast?"yz":"zw"}) * uniforms.strides - uniforms.pads;
          let d2 = coords[${this.isChannelsLast?3:1}];
          let channelMul = uniforms.wShape[3];
          let d1 = d2 / channelMul;
          let q = d2 % channelMul;

          let inputRowStart = xRCCorner.x;
          let inputColStart = xRCCorner.y;
          let inputRowEnd = inputRowStart + uniforms.filterHeight *
              uniforms.dilations[0];
          let inputColEnd = inputColStart + uniforms.filterWidth *
              uniforms.dilations[1];

          // Convolve x(?, ?, d1)|x(d1, ?, ?) with w(:, :, d1, q) to get
          // y(yR, yC, d2)|y(d2, yR, yC). ? = to be determined. : = across all
          // values in that axis. x(?, ?, d1) and y(yR, yC, d2) is for NHWC.
          // x(d1, ?, ?) and y(d2, yR, yC) is for NCHW.
          var value = 0.0;

          // Extract if checking out of for loop for performance.
          if (inputRowStart >= 0 && inputColStart >= 0 &&
            inputRowEnd < uniforms.inDims[0] &&
                inputColEnd < uniforms.inDims[1]) {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  let xVal = ${t};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            } else {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                if (xR < 0 || xR >= uniforms.inDims[0]) {
                  continue;
                }

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  if (xC < 0 || xC >= uniforms.inDims[1]) {
                    continue;
                  }

                  let xVal = ${t};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            }
            ${Ks(this.addBias,this.activation)}
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jz(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,filter:o}=t,{strides:r,pad:a,dataFormat:l,dilations:u,dimRoundingMode:c}=s,h=ws(l);let p=u;p==null&&(p=[1,1]);const f=Xe(i.shape,o.shape,r,p,a,c,!0,h),m=[{type:"int32",data:[f.padInfo.top,f.padInfo.left]},{type:"int32",data:[f.inHeight,f.inWidth]}],g=f.dataFormat==="channelsLast";let b;return!g&&f.inHeight>16&&f.inWidth>16&&f.strideHeight===1&&f.strideWidth===1&&f.dilationWidth===1&&f.dilationHeight===1&&f.inChannels===f.outChannels?b=new Qz(f.outShape,f.filterHeight,f.filterWidth):g&&f.outHeight>4&&f.outWidth>4&&f.strideWidth<=2&&f.inChannels===f.outChannels&&f.dilationHeight===1&&f.dilationWidth===1&&f.inChannels%4===0?(b=new Jy(f),m.push({type:"int32",data:[b.virtualWidth]})):(b=new tb(f),m.push({type:"int32",data:[f.filterHeight]},{type:"int32",data:[f.filterWidth]},{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.dilationHeight,f.dilationWidth]})),e.runWebGPUProgram(b,[i,o],i.dtype,m)}const tF={kernelName:El,backendName:"webgpu",kernelFunc:Jz};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eF{constructor(t){this.variableNames=["x","dy"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>, outHeight : i32,
      outWidth : i32, inHeight : i32, inWidth : i32, batchSize : i32, channelMul : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.filterShape,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_filter"}getUserCode(){return`
      ${ot("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let dm = coords[3];
        let d2 = d1 * uniforms.channelMul + dm;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yR = 0; yR < uniforms.outHeight; yR++) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];

            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC++) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              let dyValue = getDy(b, yR, yC, d2);
              let xValue = getX(b, xR, xC, d1);
              dotProd += xValue * dyValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}class nF{constructor(t){this.variableNames=["dy","W"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, channelMul : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.inShape,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_input"}getUserCode(){return`
      ${ot("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[3];
        let dyCorner = coords.yz - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }

          let idyR = i32(dyR);
          let wRPerm = uniforms.filterDims[0] - 1 - wR;

          for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }

            let idyC = i32(dyC);
            let wCPerm = uniforms.filterDims[1] - 1 - wC;

            for (var dm = 0; dm < uniforms.channelMul; dm++) {
              let d2 = d1 * uniforms.channelMul + dm;
              let xValue = getDy(batch, idyR, idyC, d2);
              let wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sF(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,dy:o}=t,{strides:r,dilations:a,pad:l,dimRoundingMode:u,filterShape:c}=s,h=Xe(i.shape,c,r,a,l,u,!0),p=new eF(h),f=[{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.filterHeight,h.filterWidth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]},{type:"int32",data:[h.inHeight]},{type:"int32",data:[h.inWidth]},{type:"int32",data:[h.batchSize]},{type:"int32",data:[h.outChannels/h.inChannels]}];return e.runWebGPUProgram(p,[i,o],"float32",f)}const iF={kernelName:Qp,backendName:"webgpu",kernelFunc:sF};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oF(n){const{inputs:t,backend:e,attrs:s}=n,{dy:i,filter:o}=t,{strides:r,dilations:a,pad:l,dimRoundingMode:u,inputShape:c}=s,h=Xe(c,o.shape,r,a,l,u,!0),p=new nF(h),f=[{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.filterHeight-1-h.padInfo.top,h.filterWidth-1-h.padInfo.left]},{type:"int32",data:[h.filterHeight,h.filterWidth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]},{type:"int32",data:[h.outChannels/h.inChannels]}];return e.runWebGPUProgram(p,[i,o],i.dtype,f)}const rF={kernelName:Jp,backendName:"webgpu",kernelFunc:oF};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aF{constructor(t){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[t,t],this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="diag"}getUserCode(){return`
      ${ot("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let value = select(0.0, getX(coords[0]), coords[0] == coords[1]);
          setOutputAtIndex(index, value);
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lF(n){const{inputs:t,backend:e}=n,{x:s}=t,i=[...s.shape,...s.shape],o=et(s.shape),r=ft({inputs:{x:s},backend:e,attrs:{shape:[o]}}),a=new aF(o),l=e.runWebGPUProgram(a,[r],r.dtype),u=ft({inputs:{x:l},backend:e,attrs:{shape:i}});return e.disposeData(r.dataId),e.disposeData(l.dataId),u}const uF={kernelName:tf,backendName:"webgpu",kernelFunc:lF};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cF{constructor(t){this.variableNames=["x","w"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.outShape,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="dilation2d"}getUserCode(){return`
       ${ot("index")} {
         if (index < uniforms.size) {
           let neg_infinity = -3.4e38;
           let coords = getOutputCoords();
           let batch = coords.x;
           let d1 = coords.w;
           let outTopLeftCorner = coords.yz * uniforms.strides - uniforms.pads;
           let hBeg = outTopLeftCorner.x;
           let wBeg = outTopLeftCorner.y;

           var curVal = neg_infinity;
           for (var h = 0; h < uniforms.filterDims[0]; h = h + 1) {
             let hIn = hBeg + h * uniforms.dilations[0];

             if (hIn >= 0 && hIn < uniforms.xShape[1]) {
               for (var w = 0; w < uniforms.filterDims[1]; w = w + 1) {
                 let wIn = wBeg + w * uniforms.dilations[1];

                 if (wIn >= 0 && wIn < uniforms.xShape[2]) {
                   let val = getX(batch, hIn, wIn, d1) + getW(h, w, d1);
                   if (val > curVal) {
                     curVal = val;
                   }
                 }
               }
             }
           }

           setOutputAtIndex(index, curVal);
         }
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hF(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,filter:o}=t,{strides:r,pad:a,dilations:l}=s,u=$i(i.shape,o.shape,r,a,"NHWC",l),c=[u.padInfo.top,u.padInfo.left],h=[{type:"int32",data:[u.filterHeight,u.filterWidth]},{type:"int32",data:[...c]},{type:"int32",data:[u.strideHeight,u.strideWidth]},{type:"int32",data:[u.dilationHeight,u.dilationWidth]}],p=new cF(u);return e.runWebGPUProgram(p,[i,o],i.dtype,h)}const dF={kernelName:Ll,backendName:"webgpu",kernelFunc:hF};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pF{constructor(t,e){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=t.inShape,this.dispatchLayout=ht(t.outShape),this.dispatch=rt(this.dispatchLayout,t.outShape,this.workgroupSize),e!=="float32"&&e!=="int32")throw new Error(`Dilation2DBackpropInput only supports float32 and int32
          types, does not support ${e} type.`);this.type=e,this.shaderKey="dilation2DBackpropInput"}getUserCode(){return`
       ${ot("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var xRMax = 0;
           var xCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     xRMax = xR;
                     xCMax = xC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.xShape[3] *
               (xCMax + uniforms.xShape[2] * (xRMax + uniforms.xShape[1] * b));
           let value = getDy(b, r, c, d);
           ${Cs("&result[flatIndexIn]","value",this.type)}
         }
       }
     `}}class fF{constructor(t,e,s){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=t.filterShape,this.dispatchLayout=ht(t.outShape),this.dispatch=rt(this.dispatchLayout,t.outShape,this.workgroupSize),s!=="float32"&&s!=="int32")throw new Error(`Dilation2DBackpropFilter only supports float32 and int32
          types, does not support ${s} type.`);this.type=s,this.shaderKey="dilation2DBackpropFilter"}getUserCode(){return`
       ${ot("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var wRMax = 0;
           var wCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     wRMax = wR;
                     wCMax = wC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.wShape[2] * (wCMax + wRMax * uniforms.wShape[1]);
           let value = getDy(b, r, c, d);
           ${Cs("&result[flatIndexIn]","value",this.type)}
         }
       }
     `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mF(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,filter:o,dy:r}=t,{strides:a,pad:l,dilations:u}=s,c=$i(i.shape,o.shape,a,l,"NHWC",u),h=o.dtype,p=new fF(c,o.shape,h),f=[{type:"int32",data:[c.filterHeight,c.filterWidth]},{type:"int32",data:[c.padInfo.top,c.padInfo.left]},{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.dilationHeight,c.dilationWidth]},{type:"int32",data:[et(c.outShape)]}],m=_e({backend:e,attrs:{shape:o.shape,value:0,dtype:h}});return e.runWebGPUProgram(p,[i,o,r],h,f,m)}const gF={kernelName:Go,backendName:"webgpu",kernelFunc:mF};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yF(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,filter:o,dy:r}=t,{strides:a,pad:l,dilations:u}=s,c=$i(i.shape,o.shape,a,l,"NHWC",u),h=i.dtype,p=new pF(c,h),f=[{type:"int32",data:[c.filterHeight,c.filterWidth]},{type:"int32",data:[c.padInfo.top,c.padInfo.left]},{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.dilationHeight,c.dilationWidth]},{type:"int32",data:[et(c.outShape)]}],m=_e({backend:e,attrs:{shape:c.inShape,value:0,dtype:h}});return e.runWebGPUProgram(p,[i,o,r],h,f,m)}const bF={kernelName:Uo,backendName:"webgpu",kernelFunc:yF};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xF{constructor(t,e,s){this.variableNames=["Image"],this.uniforms="alpha: f32,",this.workgroupSize=[64,1,1],this.pixelsOpType=bi.DRAW,this.size=!0,this.outputShape=t,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.type=e,this.textureFormat=s,this.shaderKey=`draw_${e}_${s}`}getUserCode(){let t;const e=this.type==="float32"?"value":"value / 255.0";return t=`
      if (uniforms.numChannels == 1) {
        rgba[0] = ${e};
        rgba[1] = ${e};
        rgba[2] = ${e};
      } else {
        rgba[d] = ${e};
      }`,`
       @group(0) @binding(0) var outImage : texture_storage_2d<${this.textureFormat}, write>;
       ${ot("index")} {
         if (index < uniforms.size) {
           var rgba = vec4<f32>(0.0, 0.0, 0.0, uniforms.alpha);
           for (var d = 0; d < uniforms.numChannels; d = d + 1) {
             let value = f32(inBuf[index * uniforms.numChannels + d]);
             ${t}
           }
           rgba.x = rgba.x * rgba.w;
           rgba.y = rgba.y * rgba.w;
           rgba.z = rgba.z * rgba.w;
           let coords = getCoordsFromIndex(index);
           textureStore(outImage, vec2<i32>(coords.yx), rgba);
         }
       }
      `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use backend file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wF(n){const{inputs:t,backend:e,attrs:s}=n,{image:i}=t,{canvas:o,options:r}=s,[a,l]=i.shape.slice(0,2),{imageOptions:u}=r||{},c=(u==null?void 0:u.alpha)||1,h=e.device.features.has("bgra8unorm-storage")?"bgra8unorm":"rgba8unorm",p=[a,l],f=new xF(p,i.dtype,h);o.width=l,o.height=a;const m="webgpu";let g=o.getContext(m),b;g||(b=new OffscreenCanvas(l,a),g=b.getContext(m));const v=i.shape.length===3?i.shape[2]:1;g.configure({device:e.device,format:h,usage:GPUTextureUsage.STORAGE_BINDING,alphaMode:"premultiplied"});const w="int32",k=e.makeTensorInfo(p,w),C=e.tensorMap.get(k.dataId);C.resource=g.getCurrentTexture(),C.external=!0;const I=[{type:"uint32",data:[v]},{type:"float32",data:[c]}];if(e.runWebGPUProgram(f,[i],w,I,k),b){const N=o.getContext("2d");if(!N)throw new Error("Please make sure this canvas has only been used for 2d or webgpu context!");N.drawImage(b,0,0)}return e.disposeData(k.dataId),i}const vF={kernelName:nf,backendName:"webgpu",kernelFunc:wF};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eb=Se({opType:vt.MUL,cpuKernelImpl:NA,supportsComplex:!0}),CF={kernelName:Zd,backendName:"webgpu",kernelFunc:eb};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nb(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:o,keepDims:r}=s;return qs(i,o,r,"sum",e)}const kF={kernelName:xu,backendName:"webgpu",kernelFunc:nb};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SF(n){const{inputs:t,backend:e,attrs:s}=n,{equation:i}=s,o=t,{allDims:r,summedDims:a,idDims:l}=of(i,o.length);rf(r.length,l,o);const{path:u,steps:c}=af(a,l),h=c.length;let p=null,f=r.length;const m=[];for(let g=0;g<h;++g){for(const b of c[g]){const{permutationIndices:v,expandDims:w}=lf(f,l[b]);let k;uf(v)?k=o[b]:(k=_n({inputs:{x:o[b]},backend:e,attrs:{perm:v}}),m.push(k));const C=k.shape.slice();for(let I=0;I<w.length;++I)C.splice(w[I],0,1);ke(k.shape,C)||(k=ft({inputs:{x:k},backend:e,attrs:{shape:C}}),m.push(k)),p===null?p=k:(p=eb({inputs:{a:k,b:p},backend:e}),m.push(p))}g<h-1&&(u[g]>=0&&(p=nb({inputs:{x:p},backend:e,attrs:{axis:u[g]-(r.length-f),keepDims:!1}}),m.push(p)),f--)}for(const g of m)g!==p&&e.disposeData(g.dataId);return p}const IF={kernelName:sf,backendName:"webgpu",kernelFunc:SF};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NF=Bt({opType:st.ELU}),$F={kernelName:Sr,backendName:"webgpu",kernelFunc:NF};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DF=n=>{const{inputs:t,backend:e}=n,{dy:s,y:i}=t,o=new ar(vt.ELU_DER,s.shape,i.shape);return e.runWebGPUProgram(o,[s,i],s.dtype)},RF={kernelName:Ol,backendName:"webgpu",kernelFunc:DF};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AF=Se({opType:vt.EQUAL,dtype:"bool",cpuKernelImpl:hA}),TF={kernelName:I1,backendName:"webgpu",kernelFunc:AF};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zF=Bt({opType:st.ERF}),FF={kernelName:Ir,backendName:"webgpu",kernelFunc:zF};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MF=Bt({opType:st.EXP,cpuKernelImpl:dA,dtype:"float32"}),PF={kernelName:_d,backendName:"webgpu",kernelFunc:MF};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fl(n){const{inputs:t,attrs:e,backend:s}=n,{dim:i}=e,{input:o}=t,r=o.shape.length,a=o.shape.slice();let l=i;return i<0&&(tt(-(r+1)<=i,()=>`Axis must be in the interval [${-(r+1)}, ${r}]`),l=r+i+1),a.splice(l,0,1),ft({inputs:{x:o},backend:s,attrs:{shape:a}})}const EF={kernelName:_l,backendName:"webgpu",kernelFunc:fl};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LF=Bt({opType:st.EXPM1,cpuKernelImpl:pA}),OF={kernelName:Bd,backendName:"webgpu",kernelFunc:LF};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Yh{constructor(t,e){this.variableNames=["real","imag"],this.outputShape=[],this.uniforms="exponentMultiplier : f32, denominator: f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.component=t,this.shaderKey=`fft_${t}`}getUserCode(){return`
    fn unaryOpComplex(real: f32, expR: f32, imag: f32, expI: f32) -> f32 {
      ${this.component==="real"?"return real * expR - imag * expI;":"return real * expI + imag * expR;"}
    }

    fn mulMatDFT(batch: i32, index: i32) -> f32 {
      let indexRatio = f32(index) / f32(uniforms.realShape[1]);
      let exponentMultiplierTimesIndexRatio =
          uniforms.exponentMultiplier * indexRatio;

      var result = 0.0;

      for (var i = 0; i < uniforms.realShape[1]; i = i + 1) {
        // x = (-2|2 * PI / N) * index * i;
        let x = exponentMultiplierTimesIndexRatio * f32(i);
        let expR = cos(x);
        let expI = sin(x);
        let real = getReal(batch, i);
        let imag = getImag(batch, i);

        result = result +
            unaryOpComplex(real, expR, imag, expI) / uniforms.denominator;
      }

      return result;
    }

    ${ot("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        setOutputAtIndex(index, mulMatDFT(coords[0], coords[1]));
      }
    }
  `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sb(n,t,e){const s=e.tensorMap.get(n.dataId),i=et(n.shape),o=n.shape[n.shape.length-1],r=i/o,a=[],l=ft({inputs:{x:n},backend:e,attrs:{shape:[r,o]}});a.push(l);const u=l.shape,c=new Yh("real",u),h=new Yh("imag",u),p=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:u},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:u}],f=t?2*Math.PI:-2*Math.PI,m=t?u[1]:1,g=[{type:"float32",data:[f]},{type:"float32",data:[m]}],b=e.runWebGPUProgram(c,p,"float32",g);a.push(b);const v=e.runWebGPUProgram(h,p,"float32",g);a.push(v);const w=Xs({inputs:{real:b,imag:v},backend:e});a.push(w);const k=ft({inputs:{x:w},backend:e,attrs:{shape:n.shape}});return a.forEach(C=>e.disposeData(C.dataId)),k}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _F(n){const{inputs:t,backend:e}=n,{input:s}=t;return sb(s,!1,e)}const BF={kernelName:xf,backendName:"webgpu",kernelFunc:_F};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class WF{constructor(t){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="flipLeftRight"}getUserCode(){return`
      ${ot("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let coordX = uniforms.xShape[2] - coords[2] - 1;
          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);
          setOutputAtIndex(index, outputValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VF={kernelName:Cf,backendName:"webgpu",kernelFunc:({inputs:n,backend:t})=>{const{image:e}=n,s=t,i=new WF(e.shape);return s.runWebGPUProgram(i,[e],e.dtype)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UF=Bt({opType:st.FLOOR,cpuKernelImpl:fA}),GF={kernelName:Wd,backendName:"webgpu",kernelFunc:UF};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HF=Se({opType:vt.FLOOR_DIV,cpuKernelImpl:mA,dtype:"int32"}),jF={kernelName:Vd,backendName:"webgpu",kernelFunc:HF};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class KF{constructor(t,e,s=!1){this.pixelsOpType=bi.FROM_PIXELS,this.outputShape=[0],this.variableNames=[],this.workgroupSize=[256,1,1],this.outputShape=t,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize,[e,1,1]),this.importVideo=s,this.shaderKey=`fromPixels_${this.importVideo}`}getUserCode(){const t=this.importVideo?"textureLoad(src, vec2<i32>(coords.yx));":"textureLoad(src, vec2<i32>(coords.yx), 0)";return`
      @binding(1) @group(0) var src: ${this.importVideo?"texture_external":"texture_2d<f32>"};
      ${ot("index")} {
        let flatIndex = index * uniforms.numChannels;
        if (flatIndex < uniforms.size) {
          let coords = getCoordsFromIndex(flatIndex);
          let values = ${t};
          for (var i = 0; i < uniforms.numChannels; i = i + 1) {
            result[flatIndex + i] = i32(floor(255.0 * values[i]));
          }
        }
      }
  `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use backend file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XF={kernelName:N1,backendName:"webgpu",kernelFunc:qF};let ei,Wa=he().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function qF(n){const{inputs:t,backend:e,attrs:s}=n;let{pixels:i}=t;const{numChannels:o}=s;if(i==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");const r=typeof HTMLVideoElement<"u"&&i instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&i instanceof HTMLImageElement,l=typeof HTMLCanvasElement<"u"&&i instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&i instanceof OffscreenCanvas,u=typeof ImageBitmap<"u"&&i instanceof ImageBitmap,[c,h]=r?[i.videoWidth,i.videoHeight]:[i.width,i.height],p=[h,c,o],f=he().getBool("WEBGPU_IMPORT_EXTERNAL_TEXTURE")&&r,m=r||a;if(u||l||m){let w;if(f)w=e.device.importExternalTexture({source:i});else{if(m){const L=he().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(ei==null||L!==Wa)&&(Wa=L,ei=document.createElement("canvas").getContext("2d",{willReadFrequently:Wa})),ei.canvas.width=c,ei.canvas.height=h,ei.drawImage(i,0,0,c,h),i=ei.canvas}const F=GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,U=e.textureManager.acquireTexture(p[1],p[0],"rgba8unorm",F);e.queue.copyExternalImageToTexture({source:i},{texture:U},[p[1],p[0]]),w=U}const k=et(p),C=Tt(p),I=new KF(p,o,f),N=[{type:"uint32",data:[k]},{type:"uint32",data:[o]},{type:"uint32",data:[...C]}],$=e.makeTensorInfo([h,c],"int32"),A=e.tensorMap.get($.dataId);A.resource=w;const z=e.runWebGPUProgram(I,[$],"int32",N);return e.disposeData($.dataId),z}const g=i.data;let b=g;if(o!=null&&o!==4){b=new Uint8Array(i.width*i.height*o);const w=g.length;let k=0;for(let C=0;C<w;C++)C%4<o&&(b[k++]=g[C])}const v=e.makeTensorInfo(p,"int32",new Int32Array(b));return e.uploadToGPU(v.dataId),v}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class YF{constructor(t,e,s,i,o){this.uniforms="varianceEpsilon : f32,",this.workgroupSize=[128,1,1],this.size=!0,this.variableNames=["x","mean","variance"],Ne(t,e),Ne(t,s),this.outputShape=t,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),i!=null&&(Ne(t,i),this.variableNames.push("offset")),o!=null&&(Ne(t,o),this.variableNames.push("scale")),this.offsetShape=i,this.scaleShape=o,this.shaderKey="batchNorm"}getUserCode(){let t="0.0";this.offsetShape!=null&&(t="getOffsetByOutputIndex(index)");let e="1.0";return this.scaleShape!=null&&(e="getScaleByOutputIndex(index)"),`
      ${ot("index")} {
        if (index < uniforms.size)
        {
          let xValue = getXByOutputIndex(index);
          let meanValue = getMeanByOutputIndex(index);
          let varianValue = getVarianceByOutputIndex(index);
          let offsetValue = ${t};
          let scaleValue = ${e};
          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));
          setOutputAtIndex(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));
        }
      }
  `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZF={kernelName:Bl,backendName:"webgpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:s,scale:i,offset:o,mean:r,variance:a}=n,{varianceEpsilon:l}=t,u=e,c=[s,r,a];let h=null;o!=null&&(h=o.shape,c.push(o));let p=null;i!=null&&(p=i.shape,c.push(i));const f=new YF(s.shape,r.shape,a.shape,h,p),m=[{type:"float32",data:[l]}];return u.runWebGPUProgram(f,c,s.dtype,m)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QF(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,filter:o,bias:r,preluActivationWeights:a}=t,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:p,activation:f,leakyreluAlpha:m}=s,g=ws(c),b=Xe(i.shape,o.shape,l,h,u,p,!1,g);return Zy({x:i,filter:o,convInfo:b,backend:e,bias:r,preluActivationWeights:a,leakyreluAlpha:m,activation:f})}const JF={kernelName:kf,backendName:"webgpu",kernelFunc:QF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tM(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,filter:o,bias:r,preluActivationWeights:a}=t,{strides:l,pad:u,dilations:c,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=s;let m=c;m==null&&(m=[1,1]),tt(ki(l,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`);const g=Xe(i.shape,o.shape,l,m,u,h,!0),b=[i,o],v=r!=null,w=a!=null;v&&b.push(r),w&&b.push(a);const k=[{type:"int32",data:[g.padInfo.top,g.padInfo.left]},{type:"int32",data:[g.inHeight,g.inWidth]}];let C;return g.outHeight>4&&g.outWidth>4&&g.strideWidth<=2&&g.inChannels===g.outChannels&&g.dilationHeight===1&&g.dilationWidth===1&&g.inChannels%4===0?(C=new Jy(g,v,p,w),k.push({type:"int32",data:[C.virtualWidth]})):(C=new tb(g,v,p,w),k.push({type:"int32",data:[g.filterHeight]},{type:"int32",data:[g.filterWidth]},{type:"int32",data:[g.strideHeight,g.strideWidth]},{type:"int32",data:[g.dilationHeight,g.dilationWidth]})),p==="leakyrelu"&&(k.push({type:"float32",data:[f]}),C.uniforms+=" alpha : f32,"),e.runWebGPUProgram(C,b,"float32",k)}const eM={kernelName:Sf,backendName:"webgpu",kernelFunc:tM};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nM{constructor(t,e){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`gathernd_${t}`,this.sliceDim=t,this.uniforms=`sliceDim : i32, strides : ${de(t)},`}getUserCode(){let t;return this.sliceDim>1?t="uniforms.strides[j]":t="uniforms.strides",`
      ${ot("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          var flattenIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexTemp = i32(round(getIndices(coords[0], j)));
            let strideNum = ${t};
            flattenIndex = flattenIndex + indexTemp * strideNum;
          }

          setOutputAtIndex(index, getA(flattenIndex, coords[1]));
        }
      }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sM(n){const{inputs:t,backend:e}=n,{params:s,indices:i}=t,o=i.shape,r=o[o.length-1],a=et(s.shape),[l,u,c,h]=Nf(s,i),p=ft({inputs:{x:i},backend:e,attrs:{shape:[u,r]}}),f=ft({inputs:{x:s},backend:e,attrs:{shape:[et(s.shape)/c,c]}});if(e.shouldExecuteOnCPU([s,i])||s.dtype==="string"){const w=e.readSync(i.dataId),k=e.bufferSync(s),C=gA(w,k,s.dtype,u,r,c,h,s.shape,a);return e.makeTensorInfo(l,s.dtype,C.values)}const m=new nM(r,[u,c]),g=[{type:"int32",data:[r]},{type:"int32",data:h}],b=e.runWebGPUProgram(m,[f,p],f.dtype,g),v=ft({inputs:{x:b},backend:e,attrs:{shape:l}});return e.disposeData(p.dataId),e.disposeData(f.dataId),e.disposeData(b.dataId),v}const iM={kernelName:If,backendName:"webgpu",kernelFunc:sM};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oM{constructor(t,e){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.slice(),this.aShape=t,this.outputShape=e,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="gather"}getUserCode(){const t=rM(this.aShape);return`
      ${ot("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let indexZ = i32(getIndices(resRC.x, resRC.z));
          let inBounds = select(0.0, 1.0, indexZ >= 0 && indexZ < uniforms.aShape[2]);
          setOutputAtIndex(index, inBounds * getA(${t}));
        }
      }
    `}}function rM(n){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],e=[];for(let s=0;s<n.length;s++)s===2?e.push("indexZ"):e.push(`${t[s]}`);return e.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ib(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,indices:o}=t,{axis:r,batchDims:a}=s,l=ee(r,i.shape)[0],u=$f(i,o,l,a),c=et(o.shape),h=[],p=ft({inputs:{x:i},backend:e,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),f=ft({inputs:{x:o},backend:e,attrs:{shape:[u.batchSize,c/u.batchSize]}});h.push(p),h.push(f);const m=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(e.shouldExecuteOnCPU([i,o])){const k=e.tensorMap.get(f.dataId).values,C=le(f.shape,f.dtype,k),N=e.tensorMap.get(p.dataId).values,$=le(p.shape,p.dtype,N),A=yA($,C,m);return h.forEach(z=>e.disposeData(z.dataId)),e.makeTensorInfo(u.outputShape,A.dtype,A.values)}const g=new oM(p.shape,m),b=e.runWebGPUProgram(g,[p,f],p.dtype);h.push(b);const v=ft({inputs:{x:b},backend:e,attrs:{shape:u.outputShape}});return h.forEach(w=>e.disposeData(w.dataId)),v}const aM={kernelName:Wl,backendName:"webgpu",kernelFunc:ib};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lM=Se({opType:vt.GREATER,cpuKernelImpl:xA,dtype:"bool"}),uM={kernelName:$1,backendName:"webgpu",kernelFunc:lM};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cM=Se({opType:vt.GREATER_EQUAL,dtype:"bool",cpuKernelImpl:bA}),hM={kernelName:Hd,backendName:"webgpu",kernelFunc:cM};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dM(n){const{inputs:t,backend:e}=n,{input:s}=t;return sb(s,!0,e)}const pM={kernelName:Df,backendName:"webgpu",kernelFunc:dM};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fM=Bt({opType:st.IS_FINITE,dtype:"bool"}),mM={kernelName:Nr,backendName:"webgpu",kernelFunc:fM};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gM=Bt({opType:st.IS_INF,dtype:"bool"}),yM={kernelName:$r,backendName:"webgpu",kernelFunc:gM};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bM=Bt({opType:st.IS_NAN,dtype:"bool"}),xM={kernelName:Dr,backendName:"webgpu",kernelFunc:bM};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wM(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{alpha:o}=s,r=[{type:"float32",data:[o]}],a=new Ti(i.shape,st.LEAKYRELU,"alpha : f32,");return e.runWebGPUProgram(a,[i],"float32",r)}const vM={kernelName:Vl,backendName:"webgpu",kernelFunc:wM};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CM=Se({opType:vt.LESS,dtype:"bool",cpuKernelImpl:vA}),kM={kernelName:D1,backendName:"webgpu",kernelFunc:CM};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SM=Se({opType:vt.LESS_EQUAL,dtype:"bool",cpuKernelImpl:wA}),IM={kernelName:R1,backendName:"webgpu",kernelFunc:SM};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class NM{constructor(t){this.variableNames=[],this.outputShape=[],this.uniforms="start : f32, step : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[t],this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="linSpace"}getUserCode(){return`
      ${ot("index")} {
        if (index < uniforms.size) {
          setOutputAtIndex(index, uniforms.start + f32(index) * uniforms.step);
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $M(n){const{backend:t,attrs:e}=n,{start:s,stop:i,num:o}=e,r=(i-s)/(o-1),a=new NM(o),l=[{type:"float32",data:[s]},{type:"float32",data:[r]}];return t.runWebGPUProgram(a,[],"float32",l)}const DM={kernelName:Rf,backendName:"webgpu",kernelFunc:$M};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RM=Bt({opType:st.LOG,cpuKernelImpl:CA}),AM={kernelName:Kd,backendName:"webgpu",kernelFunc:RM};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TM=Bt({opType:st.LOG1P}),zM={kernelName:Rr,backendName:"webgpu",kernelFunc:TM};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FM=Se({opType:vt.LOGICAL_AND,dtype:"bool"}),MM={kernelName:Fu,backendName:"webgpu",kernelFunc:FM};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PM=Bt({opType:st.LOGICAL_NOT}),EM={kernelName:Mu,backendName:"webgpu",kernelFunc:PM};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LM=Se({opType:vt.LOGICAL_OR}),OM={kernelName:Pu,backendName:"webgpu",kernelFunc:LM};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ob=`
  var powValue = 0.0;
  let basis = uniforms.bias + uniforms.alpha * sum;
  if (uniforms.beta == 0.5) {
    powValue = inverseSqrt(basis);
  } else if (uniforms.beta == 1.0) {
    powValue = 1.0 / basis;
  } else {
    powValue = exp(log(basis) * (-uniforms.beta));
  }
`;class _M{constructor(t){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn"}getUserCode(){return`
    ${ot("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];
        let d = coords[3];

        let x = getX(b, r, c, d);
        var sum = 0.0;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let idx = d + i;
          if (idx >= 0 && idx < uniforms.xShape[3]) {
            let z = getX(b, r, c, idx);
            sum = sum + z * z;
          }
        }
        ${ob}

        setOutputAtIndex(index, x * powValue);
      }
    }
  `}}class BM{constructor(t,e){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[256,1,1],this.maxAllowRadius=16,tt(e<=this.maxAllowRadius,()=>`Radius must be less than or equal to ${this.maxAllowRadius}, current radius is ${e}`),this.outputShape=t,this.elementsPerWorkgroup=this.workgroupSize[0]-2*this.maxAllowRadius,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=rt(this.dispatchLayout,this.outputShape,[this.elementsPerWorkgroup,this.workgroupSize[1],this.workgroupSize[2]]),this.shaderKey="lrn_shared"}getUserCode(){return`
    var <workgroup>lrnSub: array<f32, ${this.workgroupSize[0]}>;
    const elementsPerWorkgroup = ${this.elementsPerWorkgroup};
    const maxAllowRadius = ${this.maxAllowRadius};

    ${ot()} {
      let localDepth = i32(localId.x);
      let workgroupDepth = i32(workgroupId.x) * elementsPerWorkgroup;
      let xDepth = workgroupDepth + localDepth - maxAllowRadius;
      let b = i32(globalId.z) / uniforms.xShape[1];
      let r = i32(globalId.z) - b * uniforms.xShape[1];
      let c = i32(globalId.y);
      let d = workgroupDepth + localDepth;

      var x = 0.0;
      if (xDepth >= 0 && xDepth < uniforms.xShape[3]) {
        x = getX(b, r, c, xDepth);
      }
      lrnSub[localDepth] = x;
      workgroupBarrier();

      if (localDepth < elementsPerWorkgroup && d < uniforms.outShape[3]) {
        var sum = 0.0;
        let index = localDepth + maxAllowRadius;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let z = lrnSub[index + i];
          sum = sum + z * z;
        }
        ${ob}

        setOutputAtCoords(b, r, c, d, lrnSub[index] * powValue);
      }
    } `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WM(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{depthRadius:o,bias:r,alpha:a,beta:l}=s;let u;o>16?u=new _M(i.shape):u=new BM(i.shape,o);const c=[{type:"int32",data:[o]},{type:"float32",data:[r]},{type:"float32",data:[a]},{type:"float32",data:[l]}];return e.runWebGPUProgram(u,[i],i.dtype,c)}const VM={kernelName:Gl,backendName:"webgpu",kernelFunc:WM};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class UM{constructor(t){this.outputShape=[],this.variableNames=["inputImage","outputImage","dy"],this.uniforms="depthRadius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn_grad"}getUserCode(){return`
    ${ot("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];

        let MIN_DEPTH_BEGIN = 0;
        let MAX_DEPTH_END = uniforms.outShape[3];
        var result = 0.0;
        for (var d = MIN_DEPTH_BEGIN; d < MAX_DEPTH_END; d++) {
          let depthBegin = max(MIN_DEPTH_BEGIN, d - uniforms.depthRadius);
          let depthEnd = min(MAX_DEPTH_END, d + uniforms.depthRadius + 1);

          var norm = 0.0;
          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            } else {
              break;
            }
          }

          norm = uniforms.alpha * norm + uniforms.bias;

          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              var dyi = -2.0 * uniforms.alpha * uniforms.beta
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d) / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * uniforms.beta);
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            } else {
              break;
            }
          }
        }

        setOutputAtIndex(index, result);
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GM(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,y:o,dy:r}=t,{depthRadius:a,bias:l,alpha:u,beta:c}=s,h=new UM(i.shape),p=[{type:"int32",data:[a]},{type:"float32",data:[l]},{type:"float32",data:[u]},{type:"float32",data:[c]}];return e.runWebGPUProgram(h,[i,o,r],i.dtype,p)}const HM={kernelName:Ul,backendName:"webgpu",kernelFunc:GM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jM=Se({opType:vt.MAX,cpuKernelImpl:SA}),KM={kernelName:Xd,backendName:"webgpu",kernelFunc:jM};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XM(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{filterSize:o,strides:r,pad:a,dimRoundingMode:l}=s,c=Un(i.shape,o,r,1,a,l);return Ky(i,c,"max",e)}const qM={kernelName:ql,backendName:"webgpu",kernelFunc:XM};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YM(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{filterSize:o,strides:r,pad:a,dataFormat:l,dimRoundingMode:u}=s,c=[1,1,1],h=xs(i.shape,o,r,c,a,u,l),p=new hc(h,"max"),f=[{type:"int32",data:[h.strideDepth,h.strideHeight,h.strideWidth]},{type:"int32",data:[h.padInfo.front,h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.inDepth,h.inHeight,h.inWidth]},{type:"int32",data:[h.effectiveFilterDepth,h.effectiveFilterHeight,h.effectiveFilterWidth]}];return e.runWebGPUProgram(p,[i],i.dtype,f)}const ZM={kernelName:Kl,backendName:"webgpu",kernelFunc:YM};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class QM{constructor(t){this.variableNames=["dy","maxPos"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.inShape,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool2DBackprop"}getUserCode(){return`
      ${ot("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] - 1;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR += uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC += uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);
            let maxPosValue = lastIndex - i32(getMaxPos(batch, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            let curPosValue = wR * uniforms.filterDims[1] + wC;
            let mask = select(0.0, 1.0, maxPosValue == curPosValue);
            dotProd += dyValue * mask;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}class JM{constructor(t){this.variableNames=["dy","maxPos"],this.uniforms=`strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.inShape,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool3DBackprop"}getUserCode(){return`
      ${ot("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] * uniforms.filterDims[2] - 1;

        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              let maxPosValue = lastIndex - i32(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              let curPosValue = wD * uniforms.filterDims[1] * uniforms.filterDims[2] + wR * uniforms.filterDims[2] + wC;
              let mask = select(0.0, 1.0, maxPosValue == curPosValue);
              dotProd += dyValue * mask;
            }
          }
        }

        setOutputAtIndex(index, dotProd);
      }
    }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tP(n){const{inputs:t,backend:e,attrs:s}=n,{dy:i,input:o}=t,r=o,{filterSize:a,strides:l,pad:u,dimRoundingMode:c}=s,h=[1,1,1],p=xs(r.shape,a,l,h,u,c),f=new hc(p,"max",!0);let m=[{type:"int32",data:[p.strideDepth,p.strideHeight,p.strideWidth]},{type:"int32",data:[p.padInfo.front,p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.inDepth,p.inHeight,p.inWidth]},{type:"int32",data:[p.effectiveFilterDepth,p.effectiveFilterHeight,p.effectiveFilterWidth]}];const g=e.runWebGPUProgram(f,[r],"int32",m),b=new JM(p);m=[{type:"int32",data:[p.strideDepth,p.strideHeight,p.strideWidth]},{type:"int32",data:[p.effectiveFilterDepth-1-p.padInfo.front,p.effectiveFilterHeight-1-p.padInfo.top,p.effectiveFilterWidth-1-p.padInfo.left]},{type:"int32",data:[p.effectiveFilterDepth,p.effectiveFilterHeight,p.effectiveFilterWidth]},{type:"int32",data:[p.outDepth]},{type:"int32",data:[p.outHeight]},{type:"int32",data:[p.outWidth]}];const v=e.runWebGPUProgram(b,[i,g],r.dtype,m);return e.disposeData(g.dataId),v}const eP={kernelName:jl,backendName:"webgpu",kernelFunc:tP};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nP(n){const{inputs:t,backend:e,attrs:s}=n,{dy:i,input:o,output:r}=t,a=o;Wy([o,r],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:h}=s,p=Un(a.shape,l,u,1,c,h),f=new oo(p,"max",!0);let m=[{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.dilationHeight,p.dilationWidth]},{type:"int32",data:[p.inHeight,p.inWidth]},{type:"int32",data:[p.effectiveFilterHeight,p.effectiveFilterWidth]}];const g=e.runWebGPUProgram(f,[a],"int32",m),b=new QM(p);m=[{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.effectiveFilterHeight-1-p.padInfo.top,p.effectiveFilterWidth-1-p.padInfo.left]},{type:"int32",data:[p.dilationHeight,p.dilationWidth]},{type:"int32",data:[p.effectiveFilterHeight,p.effectiveFilterWidth]},{type:"int32",data:[p.outHeight]},{type:"int32",data:[p.outWidth]}];const v=e.runWebGPUProgram(b,[i,g],a.dtype,m);return e.disposeData(g.dataId),v}const sP={kernelName:Xl,backendName:"webgpu",kernelFunc:nP};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iP(n){const{inputs:t,backend:e,attrs:s}=n,{filterSize:i,strides:o,pad:r,includeBatchInIndex:a}=s,{x:l}=t;tt(l.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${l.shape.length}.`);const u=[1,1];tt(ki(o,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${u}'`);const c=Un(l.shape,i,o,u,r),h=[{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.padInfo.top,c.padInfo.left]},{type:"int32",data:[c.dilationHeight,c.dilationWidth]},{type:"int32",data:[c.inHeight,c.inWidth]},{type:"int32",data:[c.effectiveFilterHeight,c.effectiveFilterWidth]}];let p=new oo(c,"max",!1);const f=e.runWebGPUProgram(p,[l],l.dtype,h);p=new oo(c,"max",!0,!0,a);const m=e.runWebGPUProgram(p,[l],"int32",h);return[f,m]}const oP={kernelName:Af,backendName:"webgpu",kernelFunc:iP};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rP(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:o,keepDims:r}=s;return qs(i,o,r,"min",e)}const aP={kernelName:Zl,backendName:"webgpu",kernelFunc:rP};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lP=Se({opType:vt.MIN,cpuKernelImpl:IA}),uP={kernelName:Yd,backendName:"webgpu",kernelFunc:lP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cP{constructor(t,e,s){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.map((i,o)=>i[0]+t[o]+i[1]),this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=t,e.map((i,o)=>{this.uniforms+=` pad${o} : vec2<i32>,`}),this.offset=s==="reflect"?0:1,this.shaderKey=`mirrorPad_${s}`}getUserCode(){const t=this.xShape.length,e=this.xShape.map((u,c)=>`uniforms.pad${c}[0]`).join(","),s=this.xShape.map((u,c)=>`uniforms.pad${c}[0] + uniforms.xShape${t>1?`[${c}]`:""}`).join(","),i=t===1?"start":"start[i]",o=t===1?"end":"end[i]",r=t===1?"outC":"outC[i]",a=de(t),l=t>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,t):"coords";return`
      ${ot("index")} {
        if (index < uniforms.size) {
          let start = ${a}(${e});
          let end = ${a}(${s});
          var outC = getCoordsFromIndex(index);
          for (var i = 0; i < ${t}; i = i + 1) {
            if (${r} < ${i}) {
              ${r} = ${i} * 2 - ${r} - ${this.offset};
            } else if(${r} >= ${o}) {
              ${r} = (${o} - 1) * 2 - ${r} + ${this.offset};
            }
          }
          let coords = outC - start;
          setOutputAtIndex(index, getX(${l}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hP={kernelName:Ql,backendName:"webgpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:s}=n,{paddings:i,mode:o}=t,r=e,a=i.map(c=>({type:"int32",data:[c[0],c[1]]})),l=new cP(s.shape,i,o);return r.runWebGPUProgram(l,[s],s.dtype,a)}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dP=Se({opType:vt.MOD}),pP={kernelName:Ar,backendName:"webgpu",kernelFunc:dP};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fP{constructor(t,e){this.variableNames=["probs"],this.outputShape=[],this.uniforms="seed : f32, numOutcomes: i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[t,e],this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="multinomial"}getUserCode(){return`
    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    fn random (seed : f32, resultUV : vec2<f32>) -> f32 {
      let HASHSCALE1 = 443.8975;
      let p = resultUV * seed;
      var p3  = fract(vec3<f32>(p.xyx) * HASHSCALE1);
      p3 = p3 + dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${ot("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords[0];

        let resUV = vec2<f32>(f32(coords[1]) / f32(uniforms.outShape[1]),
            f32(coords[0]) / f32(uniforms.outShape[0]));
        let r = random(uniforms.seed, resUV);
        var cdf = 0.0;
        for (var i = 0; i < uniforms.numOutcomes - 1; i = i + 1) {
          cdf = cdf + getProbs(batch, i);

          if (r < cdf) {
            setOutputAtIndexI32(index, i);
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutputAtIndexI32(index, uniforms.numOutcomes - 1);
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mP{constructor(t){this.variableNames=["logits"],this.outputShape=t,this.dispatchLayout=ht(this.outputShape),this.dispatch=[this.outputShape[0],1,1],this.outputShape[1]>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.shaderKey="softmax"}getUserCode(){return`
    var<workgroup> buf : array<f32, ${this.workgroupSize[0]}>;
    var<workgroup> rowMaxShared : f32;
    var<workgroup> rowSumShared : f32;
    const blockSize = ${this.workgroupSize[0]};
    ${ot("index")} {
      let row = index / blockSize;
      let tid = i32(localId.x);
      let cols = uniforms.outShape[1];

      var threadMax = -3.402823e+38f;
      for (var col = tid; col < cols; col += blockSize) {
        let value = getLogits(row, col);
        threadMax = max(threadMax, value);
      }
      if (tid < cols) {
        buf[tid] = threadMax;
      }
      workgroupBarrier();

      var reduceSize = min(cols, blockSize);
      for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
        reduceSize = currSize + (reduceSize & 1);
        if (tid < currSize) {
          buf[tid] = max(buf[tid], buf[tid + reduceSize]);
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowMaxShared = buf[0];
      }
      workgroupBarrier();

      var threadSum = 0.0;
      for (var col = tid; col < cols; col += blockSize) {
        let subExp = exp(getLogits(row, col) - rowMaxShared);
        threadSum += subExp;
      }
      buf[tid] = threadSum;
      workgroupBarrier();

      for (var currSize = blockSize >> 1;  currSize > 0; currSize = currSize >> 1) {
        if (tid < currSize) {
          buf[tid] = buf[tid] + buf[tid + currSize];
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowSumShared = buf[0];
      }
      workgroupBarrier();

      for (var col = tid; col < cols; col += blockSize) {
        let value = exp(getLogits(row, col) - rowMaxShared) / rowSumShared;
        setOutputAtCoords(row, col, value);
      }
  }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rb(n){const{inputs:t,backend:e,attrs:s}=n,{logits:i}=t,{dim:o}=s,r=ft({inputs:{x:i},backend:e,attrs:{shape:[et(i.shape)/i.shape[o],i.shape[o]]}}),a=new mP(r.shape),l=e.runWebGPUProgram(a,[r],i.dtype),u=ft({inputs:{x:l},backend:e,attrs:{shape:i.shape}});return e.disposeData(r.dataId),e.disposeData(l.dataId),u}const gP={kernelName:mu,backendName:"webgpu",kernelFunc:rb};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yP(n){const{inputs:t,backend:e,attrs:s}=n,{logits:i}=t,{numSamples:o,seed:r,normalized:a}=s,l=a?i:rb({inputs:{logits:i},backend:e,attrs:{dim:i.shape.length-1}}),u=l.shape[0],c=l.shape[1],h=new fP(u,o),p=[{type:"float32",data:[r]},{type:"int32",data:[c]}],f=e.runWebGPUProgram(h,[l],"int32",p);return a||e.disposeData(l.dataId),f}const bP={kernelName:zf,backendName:"webgpu",kernelFunc:yP};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xP(n){const{inputs:t,backend:e}=n,{x:s}=t;if(e.shouldExecuteOnCPU([s])){const o=e.tensorMap.get(s.dataId),[r,a]=$A(o.values,s.shape,s.dtype);return e.makeTensorInfo(a,s.dtype,r)}const i=new Ti(s.shape,st.NEG);return e.runWebGPUProgram(i,[s],s.dtype)}const wP={kernelName:Qd,backendName:"webgpu",kernelFunc:xP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vP(n){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:s}=n,{boxes:i,scores:o}=t,{maxOutputSize:r,iouThreshold:a,scoreThreshold:l}=s,u=e.readSync(i.dataId),c=e.readSync(o.dataId),{selectedIndices:h}=Mf(u,c,r,a,l);return e.makeTensorInfo([h.length],"int32",new Int32Array(h))}const CP={kernelName:Ff,backendName:"webgpu",kernelFunc:vP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kP(n){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:s}=n,{boxes:i,scores:o}=t,{maxOutputSize:r,iouThreshold:a,scoreThreshold:l,softNmsSigma:u}=s,c=e.readSync(i.dataId),h=e.readSync(o.dataId),p=r,f=a,m=l,g=u,{selectedIndices:b,selectedScores:v}=Ef(c,h,p,f,m,g);return[e.makeTensorInfo([b.length],"int32",new Int32Array(b)),e.makeTensorInfo([v.length],"float32",new Float32Array(v))]}const SP={kernelName:Pf,backendName:"webgpu",kernelFunc:kP};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class IP{constructor(t,e){this.variableNames=["x"],this.uniforms="onValue : f32, offValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[t,e],this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="onehot"}getUserCode(){return`
      ${ot("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          setOutputAtIndex(index, mix(uniforms.offValue, uniforms.onValue,
                                      f32(i32(round(getX(coords.x))) == coords.y)));
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NP(n){const{inputs:t,backend:e,attrs:s}=n,{indices:i}=t,{dtype:o,depth:r,onValue:a,offValue:l}=s,u=et(i.shape),c=new IP(u,r),h=ft({inputs:{x:i},backend:e,attrs:{shape:[u]}}),p=[{type:"float32",data:[a]},{type:"float32",data:[l]}],f=e.runWebGPUProgram(c,[h],o,p);e.disposeData(h.dataId);const m=[...i.shape,r],g=ft({inputs:{x:f},backend:e,attrs:{shape:m}});return e.disposeData(f.dataId),g}const $P={kernelName:tu,backendName:"webgpu",kernelFunc:NP};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ur(n){const{inputs:t,backend:e}=n,{x:s}=t;if(s.dtype==="complex64"){const i=Co({inputs:{input:s},backend:e}),o=ur({inputs:{x:i},backend:e}),r=fa({inputs:{input:s},backend:e}),a=ur({inputs:{x:r},backend:e}),l=Xs({inputs:{real:o,imag:a},backend:e});return e.disposeData(i.dataId),e.disposeData(o.dataId),e.disposeData(r.dataId),e.disposeData(a.dataId),l}else return _e({attrs:{shape:s.shape,dtype:s.dtype,value:s.dtype==="string"?"":0},backend:e})}const DP={kernelName:Su,backendName:"webgpu",kernelFunc:ur};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ab(n){const{inputs:t,backend:e}=n,{x:s}=t;if(s.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(s.dtype==="complex64"){const i=Co({inputs:{input:s},backend:e}),o=ab({inputs:{x:i},backend:e}),r=fa({inputs:{input:s},backend:e}),a=ur({inputs:{x:r},backend:e}),l=Xs({inputs:{real:o,imag:a},backend:e});return e.disposeData(i.dataId),e.disposeData(o.dataId),e.disposeData(r.dataId),e.disposeData(a.dataId),l}else return _e({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:e})}const RP={kernelName:eu,backendName:"webgpu",kernelFunc:ab};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AP(n){const{inputs:t,backend:e,attrs:s}=n,{axis:i}=s;if(t.length===1)return fl({inputs:{input:t[0]},backend:e,attrs:{dim:i}});const o=t[0].shape,r=t[0].dtype;t.forEach(c=>{Lf(o,c.shape,"All tensors passed to stack must have matching shapes"),tt(r===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],l=t.map(c=>{const h=fl({inputs:{input:c},backend:e,attrs:{dim:i}});return a.push(h),h}),u=Yy({inputs:l,backend:e,attrs:{axis:i}});return a.forEach(c=>e.disposeData(c.dataId)),u}const TP={kernelName:nu,backendName:"webgpu",kernelFunc:AP};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lb(n,t=!1){const e=n.length,s=de(e),i=n.map((h,p)=>`uniforms.pad${p}[0]`).join(","),o=n.map((h,p)=>`uniforms.pad${p}[0] + uniforms.xShape${e>1?`[${p}]`:""}`).join(","),r=e>1?`${s}(${i})`:`${i}`,a=e>1?`${s}(${o})`:`${o}`,l=e>1?"any(paddedCoords < start)":"paddedCoords < start",u=e>1?"any(paddedCoords >= end)":"paddedCoords >= end",c=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`
        let start = ${r};
        let end = ${a};
        if (${l} || ${u}) {
          setOutputAtIndex(index, ${t?0:"uniforms.constantValue"});
        } else {
          let coords = paddedCoords - start;
          setOutputAtIndex(index, getX(${c}));
        }
  `}class zP{constructor(t,e){this.variableNames=["x"],this.uniforms="constantValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.map((s,i)=>s[0]+t[i]+s[1]),this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),e.map((s,i)=>{this.uniforms+=` pad${i} : vec2<i32>,`}),this.xShape=t,this.shaderKey="pad"}getUserCode(){return`
      ${ot("index")} {
        if (index < uniforms.size) {
          let paddedCoords = getCoordsFromIndex(index);
          ${lb(this.xShape)}
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FP=n=>{const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{paddings:o,constantValue:r}=s;if(o.every(u=>ke(u,[0,0])))return je({inputs:{x:i},backend:e});if(et(i.shape)===0){const u=o.map((c,h)=>c[0]+i.shape[h]+c[1]);return _e({backend:e,attrs:{shape:u,value:r,dtype:i.dtype}})}const a=[{type:"float32",data:[r]}];o.map(u=>a.push({type:"int32",data:[u[0],u[1]]}));const l=new zP(i.shape,o);return e.runWebGPUProgram(l,[i],i.dtype,a)},MP={kernelName:su,backendName:"webgpu",kernelFunc:FP};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PP=Se({opType:vt.POW}),EP={kernelName:Tr,backendName:"webgpu",kernelFunc:PP};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LP(n){const{inputs:t,backend:e}=n,{x:s,alpha:i}=t,o=new ar(vt.PRELU,s.shape,i.shape);return e.runWebGPUProgram(o,[s,i],"float32")}const OP={kernelName:iu,backendName:"webgpu",kernelFunc:LP};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _P(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:o,keepDims:r}=s;return qs(i,o,r,"prod",e)}const BP={kernelName:Jd,backendName:"webgpu",kernelFunc:_P};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WP=n=>{const{backend:t,attrs:e}=n,{start:s,stop:i,step:o,dtype:r}=e,a=AA(s,i,o,r);return t.makeTensorInfo([a.length],r,a)},VP={kernelName:Of,backendName:"webgpu",kernelFunc:WP};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UP=Se({opType:vt.DIV}),GP={kernelName:Fr,backendName:"webgpu",kernelFunc:UP};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HP=Bt({opType:st.RECIPROCAL}),jP={kernelName:Mr,backendName:"webgpu",kernelFunc:HP};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KP=Bt({opType:st.RELU}),XP={kernelName:Er,backendName:"webgpu",kernelFunc:KP};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qP=Bt({opType:st.RELU6}),YP={kernelName:Pr,backendName:"webgpu",kernelFunc:qP};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ZP{constructor(t,e,s){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, halfPixelCenters : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[t[0],e,s,t[3]],this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="resizeBilinear"}getUserCode(){return`
      ${ot("index")} {
        if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC =
            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *
            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);

          // Compute the four integer indices.
          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);
          let sourceCeilRC = vec2<i32>(
            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));

          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);
          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);
          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);
          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);

          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);

          let top = topLeft + (topRight - topLeft) * fracRC.y;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
          let newValue = top + (bottom - top) * fracRC.x;

          setOutputAtIndex(index, newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QP(n){const{inputs:t,backend:e,attrs:s}=n,{images:i}=t,{alignCorners:o,size:r,halfPixelCenters:a}=s,[l,u]=r,c=o&&l>1?1:0,h=o&&u>1?1:0,f=[{type:"float32",data:[c,h]},{type:"float32",data:[a?.5:0]}],m=new ZP(i.shape,l,u);return e.runWebGPUProgram(m,[i],"float32",f)}const JP={kernelName:ru,backendName:"webgpu",kernelFunc:QP};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tE{constructor(t,e){this.variableNames=["dy"],this.uniforms=`effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, heightScale : f32, widthScale : f32,
       invHeightScale : f32, invWidthScale : f32, winHeight : i32, winWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=e,this.shaderKey=`resizeBilinearBackprop_${e}`}getUserCode(){return`
      ${ot("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(startRLerp - f32(uniforms.winHeight / 2));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(startCLerp - f32(uniforms.winWidth / 2));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let dxR = f32(dyR) * uniforms.heightScale;
              let topDxRIndex = i32(floor(dxR));
              let bottomDxRIndex = i32(min(ceil(dxR), f32(uniforms.outShape[1] - 1)));
              let dxRLerp = dxR - f32(topDxRIndex);
              let inverseDxRLerp = 1.0 - dxRLerp;

              let dxC = f32(dyC) * uniforms.widthScale;
              let leftDxCIndex = i32(floor(dxC));
              let rightDxCIndex = i32(min(ceil(dxC), f32(uniforms.outShape[2] - 1)));
              let dxCLerp = dxC - f32(leftDxCIndex);
              let inverseDxCLerp = 1.0 - dxCLerp;

              if (r == topDxRIndex && c == leftDxCIndex) {
                // topLeft
                accumulator +=
                  getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
              }

              if (r == topDxRIndex && c == rightDxCIndex) {
                // topRight
                accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
              }

              if (r == bottomDxRIndex && c == leftDxCIndex) {
                // bottomLeft
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
              }

              if (r == bottomDxRIndex && c == rightDxCIndex) {
                // bottomRight
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eE(n){const{inputs:t,backend:e,attrs:s}=n,{images:i,dy:o}=t,{alignCorners:r}=s,[,a,l]=i.shape,[,u,c]=o.shape,h=[r&&u>1?a-1:a,r&&c>1?l-1:l],p=[r&&u>1?u-1:u,r&&c>1?c-1:c],f=h[0]/p[0],m=h[1]/p[1],g=1/f,b=1/m,v=Math.ceil(g)*2+2,w=Math.ceil(b)*2+2,k=new tE(i.shape,r),C=[{type:"int32",data:h},{type:"int32",data:p},{type:"float32",data:[f]},{type:"float32",data:[m]},{type:"float32",data:[g]},{type:"float32",data:[b]},{type:"int32",data:[v]},{type:"int32",data:[w]}];return e.runWebGPUProgram(k,[o],o.dtype,C)}const nE={kernelName:au,backendName:"webgpu",kernelFunc:eE};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sE{constructor(t,e,s,i){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, roundBase : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[t[0],e,s,t[3]],this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.halfPixelCenters=i,this.shaderKey=`resizeNearest_${i}`}getUserCode(){let t;return this.halfPixelCenters?t="max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))":t="vec2<f32>(rc) * effectiveInputOverOutputRatioRC",`
      ${ot("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC = ${t};

          // Compute the coordinators of nearest neighbor point.
          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));
          let sourceNearestRC = vec2<i32>(
            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));
          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);

          setOutputAtIndex(index, newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iE(n){const{inputs:t,backend:e,attrs:s}=n,{images:i}=t,{alignCorners:o,halfPixelCenters:r,size:a}=s,[l,u]=a,c=o&&l>1?1:0,h=o&&u>1?1:0,f=[{type:"float32",data:[c,h]},{type:"float32",data:[o?.5:0]}],m=new sE(i.shape,l,u,r);return e.runWebGPUProgram(m,[i],i.dtype,f)}const oE={kernelName:lu,backendName:"webgpu",kernelFunc:iE};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rE{constructor(t,e){this.variableNames=["dy"],this.uniforms=`effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, invHeightScale : f32, invWidthScale : f32,
       winHeight : i32, winWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=e,this.shaderKey=`resizeNearestNeigborBackprop_${e}`}getUserCode(){return`
      ${ot("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(floor(startRLerp - f32(uniforms.winHeight / 2)));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(floor(startCLerp - f32(uniforms.winWidth / 2)));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let sourceFracRow = f32(uniforms.effectiveXSize[0]) *
                  (f32(dyR) / f32(uniforms.effectiveYSize[0]));

              let sourceFracCol = f32(uniforms.effectiveXSize[1]) *
                  (f32(dyC) / f32(uniforms.effectiveYSize[1]));

              let sourceNearestRow =
                  i32(min(f32(uniforms.outShape[1] - 1),
                  ${this.alignCorners?"floor(sourceFracRow + 0.5)":"floor(sourceFracRow)"}));

              let sourceNearestCol =
                  i32(min(f32(uniforms.outShape[2] - 1),
                  ${this.alignCorners?"floor(sourceFracCol + 0.5)":"floor(sourceFracCol)"}));

              if (r == sourceNearestRow && c == sourceNearestCol) {
                accumulator += getDy(b, dyR, dyC, d);
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aE(n){const{inputs:t,backend:e,attrs:s}=n,{images:i,dy:o}=t,{alignCorners:r}=s,[,a,l]=i.shape,[,u,c]=o.shape,h=[r&&u>1?a-1:a,r&&c>1?l-1:l],p=[r&&u>1?u-1:u,r&&c>1?c-1:c],f=h[0]/p[0],m=h[1]/p[1],g=1/f,b=1/m,v=Math.ceil(g)*2+2,w=Math.ceil(b)*2+2,k=new rE(i.shape,r),C=[{type:"int32",data:h},{type:"int32",data:p},{type:"float32",data:[g]},{type:"float32",data:[b]},{type:"int32",data:[v]},{type:"int32",data:[w]}];return e.runWebGPUProgram(k,[o],o.dtype,C)}const lE={kernelName:uu,backendName:"webgpu",kernelFunc:aE};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uE{constructor(t){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=" axis : vec4<i32>,",this.shaderKey="reverse"}getUserCode(){return`
      
      // Using uniform variables as judging conditions, so the function has
      // coherent execution within all threads.
      fn getReverseCoords(coords : vec4<i32>) -> vec4<i32> {
        var reverseCoords = coords;
        if (uniforms.axis[0] == 1) {
          reverseCoords[0] = uniforms.xShape[0] - coords[0] - 1;
        }
        if (uniforms.axis[1] == 1) {
          reverseCoords[1] = uniforms.xShape[1] - coords[1] - 1;
        }
        if (uniforms.axis[2] == 1) {
          reverseCoords[2] = uniforms.xShape[2] - coords[2] - 1;
        }
        if (uniforms.axis[3] == 1) {
          reverseCoords[3] = uniforms.xShape[3] - coords[3] - 1;
        }

        return reverseCoords;
      }
    
      ${ot("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let reverseCoords = getReverseCoords(coords);
          setOutputAtIndex(index, getX(reverseCoords[0],
              reverseCoords[1], reverseCoords[2], reverseCoords[3]));
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cE(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{dims:o}=s,r=i.shape.length;if(r===0)return je({inputs:{x:i},backend:e});const a=i.shape,l=[1,1,1,1];a.forEach((b,v)=>{const w=v+4-r;l[w]=b});const u=ee(o,i.shape),c=[0,0,0,0];u.forEach(b=>{const v=b+4-r;c[v]=1});const h=[{type:"int32",data:c}],p=ft({inputs:{x:i},backend:e,attrs:{shape:l}}),f=new uE(l),m=e.runWebGPUProgram(f,[p],p.dtype,h);e.disposeData(p.dataId);const g=ft({inputs:{x:m},backend:e,attrs:{shape:a}});return e.disposeData(m.dataId),g}const hE={kernelName:cu,backendName:"webgpu",kernelFunc:cE};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dE{constructor(t,e){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=`centerX : f32, centerY : f32, sinRadians : f32,
          cosRadians : f32,`,this.shaderKey="rotate",this.outputShape=t,typeof e=="number"?(this.uniforms+=" fillValue : f32,",this.fillSnippet="var outputValue = uniforms.fillValue;",this.shaderKey+="_float"):(this.uniforms+=" fillValue : vec3<f32>,",this.fillSnippet="var outputValue = uniforms.fillValue[coords[3]];",this.shaderKey+="_vec3")}getUserCode(){return`
        ${ot("index")} {
          if (index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *
                uniforms.sinRadians;
            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *
                uniforms.cosRadians;
            let coordX = i32(round(coordXFloat + uniforms.centerX));
            let coordY = i32(round(coordYFloat + uniforms.centerY));
            ${this.fillSnippet}
            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&
                coordY < uniforms.xShape[1]) {
              outputValue = getX(coords[0], coordY, coordX, coords[3]);
            }
            setOutputAtIndex(index, outputValue);
          }
        }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pE={kernelName:_f,backendName:"webgpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:s}=n,{radians:i,fillValue:o,center:r}=t,a=e,l=new dE(s.shape,o),[u,c]=Bf(r,s.shape[1],s.shape[2]),h=[{type:"float32",data:[u]},{type:"float32",data:[c]},{type:"float32",data:[Math.sin(i)]},{type:"float32",data:[Math.cos(i)]}];return typeof o=="number"?h.push({type:"float32",data:[Number.parseFloat(o.toFixed(2))]}):h.push({type:"float32",data:o}),a.runWebGPUProgram(l,[s],s.dtype,h)}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fE=Bt({opType:st.ROUND}),mE={kernelName:Lr,backendName:"webgpu",kernelFunc:fE};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gE=Bt({opType:st.RSQRT,cpuKernelImpl:TA}),yE={kernelName:tp,backendName:"webgpu",kernelFunc:gE};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Yi{constructor(t,e,s,i,o,r,a,l=!0){this.variableNames=["updates","indices"],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=r,this.type=a,this.sumDupeIndices=l,this.dispatchLayout=ht(t),this.dispatch=rt(this.dispatchLayout,t,this.workgroupSize),this.sliceDimGreaterThanOne=e>1,this.shaderKey=`scatter_${s}_${i}_${this.sliceDimGreaterThanOne}_${a}_${l}_${o.length}`;const u=de(o.length);this.uniforms=`sliceDim : i32, strides: ${u}, updatesSize: i32,`,this.updatesRank=i,this.indicesRank=s}getUserCode(){let t="";this.indicesRank===1?t="coords[0]":this.indicesRank===2&&(t="coords[0], j");const e=`getIndices(${t})`,s=this.sliceDimGreaterThanOne?"uniforms.strides[j]":"uniforms.strides";let i="",o="";this.dispatchLayout.x.length===1?(i="flattenedIndex",o=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {
        return index;
      }
      `):this.dispatchLayout.x.length===2&&(i="vec2<i32>(flattenedIndex, coords[1])",o=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {
        // N.B. |updates| could be a scalar tensor, conceptually representing a
        // 2D tensor with all values equal to that. By design, its size must be
        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|
        // gives the other.
        let sliceSize = uniforms.outShape[1];
        let d0 = index / sliceSize;
        let d1 = index - d0 * sliceSize;
        return vec2<i32>(d0, d1);
      }
      `);const a=`getUpdates(${Array.from({length:this.updatesRank},(u,c)=>`coords[${c}]`).join(", ")})`;return`
    ${o}
      ${ot("index")} {
        if (index < uniforms.updatesSize) {
          let coords = getUpdatesCoordsFromFlatIndex(index);
          var flattenedIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexInside = i32(round(${e}));
            flattenedIndex = flattenedIndex + indexInside * ${s};
          }
          let updateValue =
              ${Rs(this.type)}(${a});
          let flatIndex = getOutputIndexFromCoords(${i});

          ${this.sumDupeIndices?Cs("&result[flatIndex]","updateValue",this.type):"atomicStore(&result[flatIndex], bitcast<i32>(updateValue));"}
        }
      }`}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bE(n){const{inputs:t,backend:e,attrs:s}=n,{indices:i,updates:o}=t,{shape:r}=s,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=Di(o,i,r),p=[h/u,u];if(h===0)return e.makeTensorInfo(r,i.dtype);const f=ft({inputs:{x:i},backend:e,attrs:{shape:[l,a]}}),m=ft({inputs:{x:o},backend:e,attrs:{shape:[l,u]}}),g=m.dtype,b=_e({backend:e,attrs:{shape:p,value:0,dtype:g}}),v=et(m.shape),w=[{type:"int32",data:[a]},{type:"int32",data:c},{type:"int32",data:[v]}],k=new Yi(m.shape,a,f.shape.length,m.shape.length,c,p,g),C=e.runWebGPUProgram(k,[m,f],g,w,b),I=ft({inputs:{x:C},backend:e,attrs:{shape:r}});return e.disposeData(f.dataId),e.disposeData(m.dataId),e.disposeData(C.dataId),I}const xE={kernelName:Wf,backendName:"webgpu",kernelFunc:bE};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wE{constructor(t,e){this.outputShape=[],this.variableNames=["sortedSequence","values"],this.uniforms="numInputs : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.side=e,this.shaderKey=`search_sorted_${e}`}getUserCode(){return`
      fn findBound(batch: i32, value: f32) -> i32 {
        var left = i32(0);
        var right = uniforms.numInputs;
        while (left < right) {
          var mid = (left + right) / 2;
          if (getSortedSequence(batch, mid) ${this.side==="left"?"<":"<="} value) {
            left = mid + 1;
          } else {
            right = mid;
          }
        }
        return right;
      }

      ${ot("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let value = getValuesByOutputIndex(index);
          setOutputAtIndexI32(index, findBound(coords[0], value));
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vE(n){const{inputs:t,backend:e,attrs:s}=n,{sortedSequence:i,values:o}=t,{side:r}=s,a=new wE([o.shape[0],o.shape[1]],r),l=[{type:"int32",data:[i.shape[1]]}];return e.runWebGPUProgram(a,[i,o],"int32",l)}const CE={kernelName:Vf,backendName:"webgpu",kernelFunc:vE};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kE{constructor(t,e,s){this.variableNames=["c","a","b"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.cRank=t,this.rank=s,this.shaderKey="select"}getUserCode(){let t,e;if(this.rank>4)throw Error(`Where for rank ${this.rank} is not yet supported`);if(this.rank===1)e="resRC",t="resRC";else{const i=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[],r=[];for(let a=0;a<this.outputShape.length;a++)r.push(`${i[a]}`),a<this.cRank&&o.push(`${i[a]}`);t=o.join(),e=r.join()}return`
      ${ot("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let cVal = getC(${t});
          if (cVal >= 1.0) {
            setOutputAtIndex(index, getA(${e}));
          } else {
            setOutputAtIndex(index, getB(${e}));
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SE(n){const{inputs:t,backend:e}=n,{condition:s,t:i,e:o}=t,r=new kE(s.shape.length,i.shape,i.shape.length);return e.runWebGPUProgram(r,[s,i,o],es(i.dtype,o.dtype))}const IE={kernelName:hu,backendName:"webgpu",kernelFunc:SE};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NE=Bt({opType:st.SELU}),$E={kernelName:Or,backendName:"webgpu",kernelFunc:NE};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DE=Bt({opType:st.SIGMOID}),RE={kernelName:np,backendName:"webgpu",kernelFunc:DE};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AE=Bt({opType:st.SIGN}),TE={kernelName:_r,backendName:"webgpu",kernelFunc:AE};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zE=Bt({opType:st.SIN}),FE={kernelName:Br,backendName:"webgpu",kernelFunc:zE};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ME=Bt({opType:st.SINH}),PE={kernelName:Wr,backendName:"webgpu",kernelFunc:ME};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EE=Bt({opType:st.SOFTPLUS}),LE={kernelName:Vr,backendName:"webgpu",kernelFunc:EE};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class OE{constructor(t,e,s,i,o,r){this.variableNames=["x"],this.outputShape=[],this.uniforms="",this.workgroupSize=[64,1,1],this.size=!0;const a=new Array(i.length);for(let l=0;l<a.length;l++)a[l]=i[o[l]];this.outputShape=a,this.newDim=o,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=t,this.paddedXShape=e,this.uniforms+=`reshapedPaddedXShape : ${de(i.length)}, paddedXShapeStrides : ${de(r)}, `,s.map((l,u)=>{this.uniforms+=` pad${u} : vec2<i32>,`}),this.shaderKey=`spaceToBatchND_${o}`}getUserCode(){const t=de(this.outputShape.length),e=Uy(this.newDim);return`
      ${Wo(this.paddedXShape,"PaddedX")}
      ${ot("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let switchedIndex = getIndexFromCoords${this.outputShape.length}D(${t}(${e}), uniforms.reshapedPaddedXShape);
          let paddedCoords = getPaddedXCoordsFromIndex(switchedIndex);
          ${lb(this.xShape,!0)}
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _E=n=>{const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{blockShape:o,paddings:r}=s;tt(i.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet");const a=o.reduce((w,k)=>w*k),l=[[0,0]];l.push(...r);for(let w=1+o.length;w<i.shape.length;++w)l.push([0,0]);const u=l.map((w,k)=>w[0]+i.shape[k]+w[1]),c=Yr(u,o,a,!1),h=Zr(c.length,o.length,!1),p=Qr(u,o,a,!1),f=Tt(u),m=new OE(i.shape,u,l,c,h,f.length),g=[{type:"int32",data:c},{type:"int32",data:f}];l.map(w=>g.push({type:"int32",data:[w[0],w[1]]}));const b=e.runWebGPUProgram(m,[i],i.dtype,g),v=ft({inputs:{x:b},backend:e,attrs:{shape:p}});return e.disposeData(b.dataId),v},BE={kernelName:gu,backendName:"webgpu",kernelFunc:_E};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class WE{constructor(t,e,s){this.variableNames=["input","indices","segmentIds"],this.outputShape=[],this.uniforms="segmentSize : i32, sparseSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=t,this.type=s,this.dispatchLayout=ht([e]),this.dispatch=rt(this.dispatchLayout,[e],this.workgroupSize),this.shaderKey="sparseSegmentSum"}getUserCode(){return`
    ${ot("index")} {
      if (index < uniforms.sparseSize) {
        let indexInSegmentIds = index / uniforms.segmentSize;
        let indexInSegment = index % uniforms.segmentSize;
        let indexInInput = indices[indexInSegmentIds];
        let segmentId = segmentIds[indexInSegmentIds];

        let value = input[indexInInput * uniforms.segmentSize + indexInSegment];
        let outIndex = segmentId * uniforms.segmentSize + indexInSegment;
        ${Cs("&result[outIndex]","value",this.type)}
      }
    }
  `}}class VE{constructor(t,e){this.variableNames=["segmentIds"],this.outputShape=[],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=[t],this.dispatchLayout=ht(e),this.dispatch=rt(this.dispatchLayout,e,this.workgroupSize),this.shaderKey="sparseSegmentIdCountProgram"}getUserCode(){return`
    ${ot("index")} {
      if (index < uniforms.segmentIdsShape) {
        let segmentId = segmentIds[index];
        ${Cs("&result[segmentId]","1","int32")}
      }
    }
  `}}class UE{constructor(t,e){this.variableNames=["segmentSum","sameSegmentIdCount"],this.outputShape=[],this.uniforms="segmentSize : i32",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.type=e,this.dispatchLayout=ht(t),this.dispatch=rt(this.dispatchLayout,t,this.workgroupSize),this.shaderKey="sparseSegmentMean"}getUserCode(){return`
    ${ot("index")} {
      if (index < uniforms.size) {
        let segmentId = index / uniforms.segmentSize;
        let count = sameSegmentIdCount[segmentId];
        if (count != 0) {
          ${this.type==="float32"?"setOutputAtIndex(index, segmentSum[index] / f32(count));":"setOutputAtIndexI32(index, segmentSum[index] / count);"}
        }
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ub(n,t,e,s=!1,i){const r=et(n.shape)/n.shape[0],a=n.dtype,l=et(t.shape),u=i.readSync(e.dataId),h=l>0?u[l-1]+1:0;let p;const f=n.shape.slice();f[0]=h;const m=l*r,g=_e({backend:i,attrs:{shape:f,value:0,dtype:a}});p=new WE(f,m,a);let b=[{type:"int32",data:[r]},{type:"int32",data:[m]}];const v=i.runWebGPUProgram(p,[n,t,e],a,b,g);if(s)return v;const w=_e({backend:i,attrs:{shape:[h],value:0,dtype:"int32"}});p=new VE(h,e.shape);const k=i.runWebGPUProgram(p,[e],"int32",null,w),C=_e({backend:i,attrs:{shape:f,value:0,dtype:a}});p=new UE(f,a),b=[{type:"int32",data:[r]}];const I=i.runWebGPUProgram(p,[v,k],a,b,C);return i.disposeData(v.dataId),i.disposeData(k.dataId),I}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GE(n){const{inputs:t,backend:e}=n,{data:s,indices:i,segmentIds:o}=t;return ub(s,i,o,!1,e)}const HE={kernelName:Uf,backendName:"webgpu",kernelFunc:GE};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jE(n){const{inputs:t,backend:e}=n,{data:s,indices:i,segmentIds:o}=t;return ub(s,i,o,!0,e)}const KE={kernelName:Hf,backendName:"webgpu",kernelFunc:jE};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XE{constructor(t,e){this.variableNames=["A"],this.workgroupSize=[64,1,1],this.size=!0;const s=new Array(t.length);for(let i=0;i<s.length;i++)s[i]=t[i]*e[i];this.outputShape=s,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.rank=this.outputShape.length,this.shaderKey="tile"}getUserCode(){const t=qE(this.rank,"uniforms.");return`
      ${ot("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          setOutputAtIndex(index, getA(${t}));
        }
      }
    `}}function qE(n,t=""){if(n>=5)throw Error(`Tile for rank ${n} is not yet supported`);if(n===1)return`(resRC % ${t}aShape)`;const e=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let i=0;i<n;i++)s.push(`(${e[i]} % ${t}aShape[${i}])`);return s.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dc(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{reps:o}=s;if(e.shouldExecuteOnCPU([i])||i.dtype==="string"||i.shape.length>=5){const l=e.readSync(i.dataId),u=i.dtype==="string"?l.map(p=>ho(p)):l,c=le(i.shape,i.dtype,u),h=OA(c,o);return e.makeTensorInfo(h.shape,h.dtype,h.values)}const r=new XE(i.shape,o);return e.runWebGPUProgram(r,[i],i.dtype)}const YE={kernelName:wu,backendName:"webgpu",kernelFunc:dc};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZE(n){const{inputs:t,backend:e,attrs:s}=n,{sparseIndices:i,sparseValues:o,defaultValue:r}=t,{outputShape:a}=s,{sliceRank:l,numUpdates:u,sliceSize:c,strides:h,outputSize:p}=Di(o,i,a),f=!1;if(o.dtype==="string"){const A=e.bufferSync(i),z=e.bufferSync(o),F=ho(e.readSync(r.dataId)[0]),E=zA(A,z,a,p,c,u,l,h,F,f);return e.makeTensorInfo(a,E.dtype,E.values)}const m=[p/c,c],g=ft({inputs:{x:i},backend:e,attrs:{shape:[u,l]}}),b=o.shape.length?ft({inputs:{x:o},backend:e,attrs:{shape:[u,c]}}):je({inputs:{x:o},backend:e}),v=b.dtype,w=e.makeTensorInfo([],v,ss(1,v)),k=ft({inputs:{x:r},backend:e,attrs:{shape:Array(m.length).fill(1)}}),C=dc({inputs:{x:k},backend:e,attrs:{reps:m}}),I=et([u,c]),N=[{type:"int32",data:[l]},{type:"int32",data:h},{type:"int32",data:[I]}];switch(u){case 0:break;case 1:{const A=new Yi([u,c],l,g.shape.length,b.shape.length,h,m,v,f);e.runWebGPUProgram(A,[b,g],v,N,C)}break;default:{const A=new Yi([u,c],l,g.shape.length,w.shape.length,h,m,v,f);e.runWebGPUProgram(A,[w,g],v,N,C)}{const A=new Yi([u,c],l,g.shape.length,b.shape.length,h,m,v);e.runWebGPUProgram(A,[b,g],v,N,C)}}const $=ft({inputs:{x:C},backend:e,attrs:{shape:a}});return e.disposeData(g.dataId),e.disposeData(b.dataId),e.disposeData(k.dataId),e.disposeData(w.dataId),e.disposeData(C.dataId),$}const QE={kernelName:jf,backendName:"webgpu",kernelFunc:ZE};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JE(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{numOrSizeSplits:o,axis:r}=s,a=ee(r,i.shape)[0],l=Kf(i,o,a),u=i.shape.length,c=new Array(u).fill(0),h=i.shape.slice();return l.map(p=>{const f=[...h];f[a]=p;const m=zi({inputs:{x:i},backend:e,attrs:{begin:c,size:f}});return c[a]+=p,m})}const tL={kernelName:yu,backendName:"webgpu",kernelFunc:JE};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eL=Bt({opType:st.SQRT}),nL={kernelName:ap,backendName:"webgpu",kernelFunc:eL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sL={kernelName:bu,backendName:"webgpu",kernelFunc:({inputs:n,backend:t})=>{const{x:e}=n,s=t,i=new Ti(e.shape,st.SQUARE);return s.runWebGPUProgram(i,[e],e.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iL=Se({opType:vt.SQUARED_DIFFERENCE}),oL={kernelName:lp,backendName:"webgpu",kernelFunc:iL};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rL({inputs:n,attrs:t,backend:e}){const{x:s}=n,i=new Ti(s.shape,st.STEP,"stepAlpha : f32,"),o=[{type:"float32",data:[t.alpha]}];return e.runWebGPUProgram(i,[s],s.dtype,o)}const aL={kernelName:Ur,backendName:"webgpu",kernelFunc:rL};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lL{constructor(t){this.variableNames=["x"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]);const e=de(this.outputShape.length);this.uniforms=`begin : ${e},  strides : ${e}, `,this.shaderKey="stridedSlice"}getUserCode(){const t=this.outputShape.length;let e="";if(t===1)e="coords * uniforms.strides + uniforms.begin";else{let i=0;e=this.outputShape.map((o,r)=>(i++,this.outputShape.length===1?`coords * uniforms.strides[${r}] + uniforms.begin[${r}]`:`coords[${i-1}] * uniforms.strides[${r}] + uniforms.begin[${r}]`)).join(",")}return`
       ${ot("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index);
           setOutputAtIndex(index, getX(${e}));
         }
       }
     `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uL(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{begin:o,end:r,strides:a,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:p}=s,{finalShapeSparse:f,finalShape:m,isIdentity:g,sliceDim0:b,isSimpleSlice:v,begin:w,end:k,strides:C}=qf(i.shape,o,r,a,l,u,c,h,p);let I;if(g)I=ft({inputs:{x:i},backend:e,attrs:{shape:m}});else if(b||v){tt(i.shape.length>=1,()=>`Input must have rank at least 1, got: ${i.shape.length}`);const N=Yf(w,k,C),$=zi({inputs:{x:i},backend:e,attrs:{begin:w,size:N}});I=ft({inputs:{x:$},backend:e,attrs:{shape:m}}),e.disposeData($.dataId)}else if(e.shouldExecuteOnCPU([i])){const $=e.readSync(i.dataId),A=le(i.shape,i.dtype,$),z=PA(f,A,C,w);I=e.makeTensorInfo(m,i.dtype,z.values)}else{const $=new lL(f),A=[{type:"int32",data:w},{type:"int32",data:C}],z=e.runWebGPUProgram($,[i],i.dtype,A);I=ft({inputs:{x:z},backend:e,attrs:{shape:m}}),e.disposeData(z.dataId)}return I}const cL={kernelName:Xf,backendName:"webgpu",kernelFunc:uL};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hL(n){const{inputs:t,backend:e,attrs:s}=n,{separator:i,nGramWidths:o,leftPad:r,rightPad:a,padWidth:l,preserveShortSequences:u}=s,{data:c,dataSplits:h}=t,p=e.readSync(c.dataId),f=e.readSync(h.dataId),[m,g]=EA(p,f,i,o,r,a,l,u);return[e.makeTensorInfo([m.length],"string",m),e.makeTensorInfo(h.shape,"int32",g)]}const dL={kernelName:Zf,backendName:"webgpu",kernelFunc:hL};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pL=Se({opType:vt.SUB,cpuKernelImpl:LA,supportsComplex:!0}),fL={kernelName:up,backendName:"webgpu",kernelFunc:pL};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mL=Bt({opType:st.TAN}),gL={kernelName:Gr,backendName:"webgpu",kernelFunc:mL};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yL=Bt({opType:st.TANH}),bL={kernelName:Hr,backendName:"webgpu",kernelFunc:yL};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xL(n){const{inputs:t,backend:e,attrs:s}=n,{tensor:i,indices:o,updates:r}=t,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=Di(r,o,i.shape),p=[h/u,u];if(h===0)return e.makeTensorInfo(i.shape,o.dtype);const f=[],m=ft({inputs:{x:o},backend:e,attrs:{shape:[l,a]}});f.push(m);const g=ft({inputs:{x:r},backend:e,attrs:{shape:[l,u]}});f.push(g);const b=ft({inputs:{x:i},backend:e,attrs:{shape:p}});f.push(b);const v=dc({inputs:{x:b},backend:e,attrs:{reps:Array(p.length).fill(1)}}),w=new Yi([l,u],a,m.shape.length,g.shape.length,c,p,i.dtype,!1),k=et([l,u]),C=[{type:"int32",data:[a]},{type:"int32",data:c},{type:"int32",data:[k]}],I=e.runWebGPUProgram(w,[g,m],b.dtype,C,v);f.push(I);const N=ft({inputs:{x:I},backend:e,attrs:{shape:i.shape}});return f.forEach($=>e.disposeData($.dataId)),N}const wL={kernelName:Qf,backendName:"webgpu",kernelFunc:xL};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vL{constructor(t){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=`inputSize : i32, firstPass : i32, negativeInf : f32,
        dir : i32, inc : i32,`,this.shaderKey="swap"}getUserCode(){return`
        ${ot("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // We compare elements pair-wise within a group of size 2 * inc.
            // The comparing rule for each group alternates between ascending
            // and descending. Within each group, we compare each pair at
            // positions i and i+inc. To decide whether an element at position i
            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
            // inc, it is in the first half of the group, we denote it as x0,
            // otherwise we denote it as x1.
            // For example, as shown in the Bitonic top K paper referenced
            // above, Figure5(a) shows that element[1] is in the second half of
            // the group when group size is 2, but it is in the first half of
            // the group when group size is 4.
            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;
            var i = 0;
            if (isFirstInPair) {
              i = elemIdx;
            } else {
              i = elemIdx - uniforms.inc;
            }

            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }

            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.inc;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.inc));
            }

            var x0 = f32(0.0);
            var x1 = f32(0.0);
            if (i0 < uniforms.inputSize) {
              x0 = getX(batch, i0);
            } else {
              x0 = uniforms.negativeInf;
            }
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = uniforms.negativeInf;
            }

            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;
            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
            if (reverse == isGreater) {
              // Elements in opposite order of direction
              let iTemp = i0;
              i0 = i1;
              i1 = iTemp;
            }
            if (isFirstInPair) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}}class CL{constructor(t){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="inputSize : i32, firstPass : i32, k : i32,",this.shaderKey="merge"}getUserCode(){return`
        ${ot("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // The output size is half of the previous size.
            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _
            // (k=4), we only need to output the indices at positions |, the
            // indices at positions _ can be thrown away, see Figure5(b) After
            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced
            // above.
            // For example, the paper shows we only need to output the orange
            // bars. The output sequence should look like this | | | | | | | |.
            // Because the sequence is halved, to map the output index back to
            // the previous sequence to find the corresponding value, we need
            // to double the index. When we double the index, we basically
            // interpolate a position, so 2i looks like
            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k
            // position of each 2k positions by - elemIdx % k. E.g. for output
            // at index 4,5,6,7, we want to get the corresponding element at
            // original index 8,9,10,11, for output at index 8,9,10,11,
            // we want to get the corresponding element at original index
            // 16,17,18,19, so on and so forth.

            var i = 0;
            if (elemIdx < uniforms.k) {
              i = elemIdx;
            } else {
              i = elemIdx * 2 - elemIdx % uniforms.k;
            }
            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }
            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.k;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.k));
            }

            let x0 = getX(batch, i0);
            var x1 = f32(0.0);
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = x0;
            }

            if (x0 >= x1) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ni(n,t){t!==null&&n.disposeData(t.dataId)}function Zh(n){let t=1;for(;t<n;)t*=2;return t}function kL(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{k:o,sorted:r}=s,a=i.shape,l=a[a.length-1];if(e.shouldExecuteOnCPU([i])){const I=e.readSync(i.dataId),[N,$]=_A(I,a,i.dtype,o,r);return[e.makeTensorInfo(N.shape,N.dtype,N.values),e.makeTensorInfo($.shape,$.dtype,$.values)]}if(o===0)return a[a.length-1]=0,[e.makeTensorInfo(a,i.dtype,[]),e.makeTensorInfo(a,"int32",[])];if(l===1)return[i,_e({attrs:{shape:a,dtype:"int32",value:0},backend:e})];const c=et(a)/l,h=ft({inputs:{x:i},attrs:{shape:[c,l]},backend:e}),p=Zh(o),f=Zh(l);let m=null;const g=()=>m===null?[h,h]:[h,m],b=(I,N,$)=>{const A=g(),z=new vL($),E=[{type:"int32",data:[l]},{type:"int32",data:[m===null?1:0]},{type:"float32",data:[Number.NEGATIVE_INFINITY]},{type:"int32",data:[I]},{type:"int32",data:[N]}],U=m;m=e.runWebGPUProgram(z,A,"int32",E),ni(e,U)};for(let I=1;I<p;I*=2){const N=I*2;for(let $=I;$>=1;$/=2)b(N,$,[c,f])}for(let I=f;I>p;I/=2){const N=g(),$=new CL([c,I/2]),z=[{type:"int32",data:[l]},{type:"int32",data:[m===null?1:0]},{type:"int32",data:[p]}],F=m;m=e.runWebGPUProgram($,N,"int32",z),ni(e,F);const E=p/2,U=E*2;for(let L=E;L>=1;L/=2)b(U,L,m.shape)}let v=m;m=zi({inputs:{x:m},backend:e,attrs:{begin:0,size:[c,o]}}),ni(e,v);let w=ib({inputs:{x:h,indices:m},backend:e,attrs:{axis:1,batchDims:1}});ni(e,h);const k=a.slice(0,-1);k.push(o),v=m,m=ft({inputs:{x:m},attrs:{shape:k},backend:e}),ni(e,v);const C=w;return w=ft({inputs:{x:w},attrs:{shape:k},backend:e}),ni(e,C),[w,m]}const SL={kernelName:Jf,backendName:"webgpu",kernelFunc:kL};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class IL{constructor(t){this.variableNames=["Image","Transforms"],this.uniforms="interpolationModeId : i32, fillModeId : i32, fillValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="transform"}getUserCode(){return`
          fn mapCoord(outCoord : f32, len : f32) -> f32{
            var inCoord = outCoord;
            if(uniforms.fillModeId == 2) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  if (inCoord < sz2) {
                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +
                    inCoord;
                  }
                  if (inCoord < -len) {
                    inCoord = inCoord + sz2;
                  } else {
                    inCoord = -inCoord - 1.0;
                  }
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));
                  if (inCoord >= len) {
                    inCoord = sz2 - inCoord - 1.0;
                  }
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 3) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 4) {
              return clamp(outCoord, 0.0, len - 1.0);
            }
            return outCoord;
          }
          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,
            channel : i32) -> f32 {
            var outputValue : f32;
            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {
                outputValue = getImage(batch, coordY, coordX, channel);
            } else {
              outputValue = uniforms.fillValue;
            }
            return outputValue;
          }

          ${ot("index")} {
            if (index < uniforms.size) {
              let coords = getCoordsFromIndex(index);
              var outputValue : f32;
              let batch = coords[0];
              let x = coords[2];
              let y = coords[1];
              let channel = coords[3];
              let xf = f32(x);
              let yf = f32(y);
              let a1 = getTransforms(batch, 0);
              let a2 = getTransforms(batch, 1);
              let a3 = getTransforms(batch, 2);
              let b1 = getTransforms(batch, 3);
              let b2 = getTransforms(batch, 4);
              let b3 = getTransforms(batch, 5);
              let c1 = getTransforms(batch, 6);
              let c2 = getTransforms(batch, 7);
              let projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = uniforms.fillValue;
              } else {
                let inX = (a1 * xf + a2 * yf + a3) / projection;
                let inY = (b1 * xf + b2 * yf + b3) / projection;
                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));
                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));

                if (uniforms.interpolationModeId == 1) {
                  let coordY = i32(round(mapY));
                  let coordX = i32(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  let yFloor = floor(mapY);
                  let xFloor = floor(mapX);
                  let yCeil = yFloor + 1.0;
                  let xCeil = xFloor + 1.0;
                  let valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);
                  let valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutputAtIndex(index, outputValue);
            }
          }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NL(n){const{inputs:t,backend:e,attrs:s}=n,{image:i,transforms:o}=t,{interpolation:r,fillMode:a,fillValue:l,outputShape:u}=s,[c,h,p,f]=i.shape,[m,g]=u??[h,p],b=[c,m,g,f],v=new IL(b),w=r==="nearest"?1:2;let k;switch(a){case"constant":k=1;break;case"reflect":k=2;break;case"wrap":k=3;break;case"nearest":k=4;break;default:k=1;break}const C=[{type:"int32",data:[w]},{type:"int32",data:[k]},{type:"float32",data:[l]}];return e.runWebGPUProgram(v,[i,o],"float32",C)}const $L={kernelName:tm,backendName:"webgpu",kernelFunc:NL};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DL(n){const{inputs:t,backend:e,attrs:s}=n,{value:i}=t;let{axis:o}=s;o<0&&(o+=i.shape.length);const r=i,a=r.shape.length,l=i.shape[o],u=new Array(a-1);let c=0;for(let g=0;g<a;g++)g!==o&&(u[c++]=r.shape[g]);const h=[],p=new Array(a).fill(0),f=r.shape.slice();f[o]=1;const m=new Array(l);for(let g=0;g<m.length;g++){p[o]=g;const b=zi({inputs:{x:r},backend:e,attrs:{begin:p,size:f}}),v=ft({inputs:{x:b},backend:e,attrs:{shape:u}});m[g]=v,h.push(b)}return h.forEach(g=>e.disposeData(g.dataId)),m}const RL={kernelName:vu,backendName:"webgpu",kernelFunc:DL};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class AL{constructor(t,e,s){if(this.outputShape=[],this.variableNames=["x","segmentIds"],this.uniforms="numSegments : i32, xSize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e,this.dispatchLayout=ht(t),this.dispatch=rt(this.dispatchLayout,t,this.workgroupSize),s!=="float32"&&s!=="int32")throw new Error(`UnsortedSegmentSum only supports float32 and int32
              types, does not support ${s} type.`);this.type=s,this.shaderKey="unsortedSegmentSum"}getUserCode(){return`
    ${ot("index")} {
      if (index < uniforms.xSize) {
        let coords = getXCoordsFromIndex(index);
        let b = coords[0];
        let inCol = coords[1];

        let segmentId = i32(getSegmentIds(inCol));
        if (segmentId >= 0) {
          let flatIndex = b * uniforms.numSegments + segmentId % uniforms.numSegments;
          let value = getX(b, inCol);

          ${Cs("&result[flatIndex]","value",this.type)}
        }
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TL(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,segmentIds:o}=t,{numSegments:r}=s,a=i.shape.length,l=[];let u=0;const c=Pe([u],a);let h=i;c!=null&&(h=_n({inputs:{x:i},backend:e,attrs:{perm:c}}),l.push(h),u=Ke(1,a)[0]);const p=A1(h.shape,u,r),f=et([h.shape[u]]),m=ft({inputs:{x:h},backend:e,attrs:{shape:[-1,f]}});l.push(m);const g=i.dtype,b=[m.shape[0],r],v=_e({backend:e,attrs:{shape:b,value:0,dtype:g}}),w=new AL(m.shape,b,g),k=[{type:"int32",data:[r]},{type:"int32",data:[et(m.shape)]}],C=e.runWebGPUProgram(w,[m,o],g,k,v),I=ft({inputs:{x:C},backend:e,attrs:{shape:p}});l.push(C);let N=I;if(c!=null){l.push(I);const $=_s(c);N=_n({inputs:{x:N},backend:e,attrs:{perm:$}})}return l.forEach($=>e.disposeData($.dataId)),N}const zL={kernelName:Cu,backendName:"webgpu",kernelFunc:TL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FL=[iA,VA,GA,jA,XA,ZA,iT,rT,lT,cT,dT,fT,gT,bT,wT,IT,$T,TT,FT,PT,BT,GT,KT,ZT,JT,sz,rA,rz,cz,bz,Sz,Dz,Tz,Fz,Pz,Lz,_z,Vz,Gz,jz,Xz,Zz,iF,rF,tF,uF,dF,gF,bF,vF,IF,$F,RF,TF,FF,PF,EF,OF,BF,eA,VF,XF,GF,jF,ZF,JF,eM,iM,aM,uM,hM,oA,pM,lz,mM,yM,xM,vM,kM,IM,DM,zM,AM,MM,EM,OM,VM,HM,CT,KM,qM,sP,ZM,eP,oP,kT,aP,uP,hP,pP,bP,CF,wP,CP,SP,XT,$P,RP,TP,MP,EP,OP,BP,VP,qT,GP,jP,XP,YP,nA,JP,nE,oE,lE,hE,pE,mE,yE,xE,CE,IE,$E,RE,TE,FE,PE,OT,aL,cL,dL,gP,LE,BE,HE,KE,QE,tL,nL,sL,oL,fL,kF,gL,bL,wL,YE,SL,$L,tT,RL,zL,DP];for(const n of FL)em(n);/**
    * @license
    * Copyright 2023 Google LLC. All Rights Reserved.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    */var cb=function(n,t){return(cb=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,s){e.__proto__=s}||function(e,s){for(var i in s)Object.prototype.hasOwnProperty.call(s,i)&&(e[i]=s[i])})(n,t)};function hb(n,t){if(typeof t!="function"&&t!==null)throw new TypeError("Class extends value "+String(t)+" is not a constructor or null");function e(){this.constructor=n}cb(n,t),n.prototype=t===null?Object.create(t):(e.prototype=t.prototype,new e)}var Zt=function(){return(Zt=Object.assign||function(n){for(var t,e=1,s=arguments.length;e<s;e++)for(var i in t=arguments[e])Object.prototype.hasOwnProperty.call(t,i)&&(n[i]=t[i]);return n}).apply(this,arguments)};function Ot(n,t,e,s){return new(e||(e=Promise))(function(i,o){function r(u){try{l(s.next(u))}catch(c){o(c)}}function a(u){try{l(s.throw(u))}catch(c){o(c)}}function l(u){var c;u.done?i(u.value):(c=u.value,c instanceof e?c:new e(function(h){h(c)})).then(r,a)}l((s=s.apply(n,[])).next())})}function _t(n,t){var e,s,i,o,r={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return o={next:a(0),throw:a(1),return:a(2)},typeof Symbol=="function"&&(o[Symbol.iterator]=function(){return this}),o;function a(l){return function(u){return function(c){if(e)throw new TypeError("Generator is already executing.");for(;r;)try{if(e=1,s&&(i=2&c[0]?s.return:c[0]?s.throw||((i=s.return)&&i.call(s),0):s.next)&&!(i=i.call(s,c[1])).done)return i;switch(s=0,i&&(c=[2&c[0],i.value]),c[0]){case 0:case 1:i=c;break;case 4:return r.label++,{value:c[1],done:!1};case 5:r.label++,s=c[1],c=[0];continue;case 7:c=r.ops.pop(),r.trys.pop();continue;default:if(i=r.trys,!((i=i.length>0&&i[i.length-1])||c[0]!==6&&c[0]!==2)){r=0;continue}if(c[0]===3&&(!i||c[1]>i[0]&&c[1]<i[3])){r.label=c[1];break}if(c[0]===6&&r.label<i[1]){r.label=i[1],i=c;break}if(i&&r.label<i[2]){r.label=i[2],r.ops.push(c);break}i[2]&&r.ops.pop(),r.trys.pop();continue}c=t.call(n,r)}catch(h){c=[6,h],s=0}finally{e=i=0}if(5&c[0])throw c[1];return{value:c[0]?c[1]:void 0,done:!0}}([l,u])}}}function Ts(n,t,e){if(e||arguments.length===2)for(var s,i=0,o=t.length;i<o;i++)!s&&i in t||(s||(s=Array.prototype.slice.call(t,0,i)),s[i]=t[i]);return n.concat(s||Array.prototype.slice.call(t))}var Bn=["nose","left_eye","right_eye","left_ear","right_ear","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle"],ao=["nose","left_eye_inner","left_eye","left_eye_outer","right_eye_inner","right_eye","right_eye_outer","left_ear","right_ear","mouth_left","mouth_right","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_pinky","right_pinky","left_index","right_index","left_thumb","right_thumb","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle","left_heel","right_heel","left_foot_index","right_foot_index"],ML={left:[1,2,3,7,9,11,13,15,17,19,21,23,25,27,29,31],right:[4,5,6,8,10,12,14,16,18,20,22,24,26,28,30,32],middle:[0]},PL={left:[1,3,5,7,9,11,13,15],right:[2,4,6,8,10,12,14,16],middle:[0]},EL=[[0,1],[0,2],[1,3],[2,4],[5,6],[5,7],[5,11],[6,8],[6,12],[7,9],[8,10],[11,12],[11,13],[12,14],[13,15],[14,16]],LL=[[0,1],[0,4],[1,2],[2,3],[3,7],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[11,23],[12,14],[14,16],[12,24],[13,15],[15,17],[16,18],[16,20],[15,17],[15,19],[15,21],[16,22],[17,19],[18,20],[23,25],[23,24],[24,26],[25,27],[26,28],[27,29],[28,30],[27,31],[28,32],[29,31],[30,32]];function cr(n){return n instanceof SVGAnimatedLength?n.baseVal.value:n}function db(n){return Ot(this,void 0,void 0,function(){var t,e;return _t(this,function(s){switch(s.label){case 0:return t=document.createElement("canvas"),n instanceof Ge?[4,Lu(n,t)]:[3,2];case 1:return s.sent(),[3,3];case 2:t.width=cr(n.width),t.height=cr(n.height),e=t.getContext("2d"),n instanceof ImageData?e.putImageData(n,0,0):e.drawImage(n,0,0),s.label=3;case 3:return[2,t]}})})}function pb(n){return Ot(this,void 0,void 0,function(){var t,e,s,i,o,r;return _t(this,function(a){switch(a.label){case 0:return n instanceof Ge?(t=n.shape.slice(0,2),e=t[0],s=t[1],i=ImageData.bind,[4,Lu(n)]):[3,2];case 1:return[2,new(i.apply(ImageData,[void 0,a.sent(),s,e]))];case 2:return o=document.createElement("canvas"),r=o.getContext("2d"),o.width=cr(n.width),o.height=cr(n.height),r.drawImage(n,0,0),[2,r.getImageData(0,0,o.width,o.height)]}})})}function OL(n){return Ot(this,void 0,void 0,function(){var t,e;return _t(this,function(s){switch(s.label){case 0:return n instanceof SVGImageElement||n instanceof OffscreenCanvas?[4,db(n)]:[3,2];case 1:return e=s.sent(),[3,3];case 2:e=n,s.label=3;case 3:return t=e,[2,sm(t,4)]}})})}function fb(n){if(n<0||n>=256)throw new Error("Mask value must be in range [0, 255] but got ".concat(n));if(!Number.isInteger(n))throw new Error("Mask value must be an integer but got ".concat(n))}var Gi={runtime:"mediapipe",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,modelType:"full"},_L=function(){function n(t){this.mask=t}return n.prototype.toCanvasImageSource=function(){return Ot(this,void 0,void 0,function(){return _t(this,function(t){return[2,this.mask]})})},n.prototype.toImageData=function(){return Ot(this,void 0,void 0,function(){return _t(this,function(t){return[2,pb(this.mask)]})})},n.prototype.toTensor=function(){return Ot(this,void 0,void 0,function(){return _t(this,function(t){return[2,OL(this.mask)]})})},n.prototype.getUnderlyingType=function(){return"canvasimagesource"},n}();function BL(n){return fb(n),"person"}var WL=function(){function n(t){var e,s=this;switch(this.width=0,this.height=0,this.selfieMode=!1,this.poseSolution=new nD.Pose({locateFile:function(i,o){if(t.solutionPath){var r=t.solutionPath.replace(/\/+$/,"");return"".concat(r,"/").concat(i)}return"".concat(o,"/").concat(i)}}),t.modelType){case"lite":e=0;break;case"heavy":e=2;break;case"full":default:e=1}this.poseSolution.setOptions({modelComplexity:e,smoothLandmarks:t.enableSmoothing,enableSegmentation:t.enableSegmentation,smoothSegmentation:t.smoothSegmentation,selfieMode:this.selfieMode}),this.poseSolution.onResults(function(i){if(s.height=i.image.height,s.width=i.image.width,i.poseLandmarks==null)s.poses=[];else{var o=s.translateOutput(i.poseLandmarks,i.poseWorldLandmarks);i.segmentationMask&&(o.segmentation={maskValueToLabel:BL,mask:new _L(i.segmentationMask)}),s.poses=[o]}})}return n.prototype.translateOutput=function(t,e){var s=this,i={keypoints:t.map(function(o,r){return{x:o.x*s.width,y:o.y*s.height,z:o.z,score:o.visibility,name:ao[r]}})};return e!=null&&(i.keypoints3D=e.map(function(o,r){return{x:o.x,y:o.y,z:o.z,score:o.visibility,name:ao[r]}})),i},n.prototype.estimatePoses=function(t,e,s){return Ot(this,void 0,void 0,function(){var i,o;return _t(this,function(r){switch(r.label){case 0:return e&&e.flipHorizontal&&e.flipHorizontal!==this.selfieMode&&(this.selfieMode=e.flipHorizontal,this.poseSolution.setOptions({selfieMode:this.selfieMode})),t instanceof Ge?(o=ImageData.bind,[4,Lu(t)]):[3,2];case 1:return i=new(o.apply(ImageData,[void 0,r.sent(),t.shape[1],t.shape[0]])),[3,3];case 2:i=t,r.label=3;case 3:return t=i,[4,this.poseSolution.send({image:t},s)];case 4:return r.sent(),[2,this.poses]}})})},n.prototype.dispose=function(){this.poseSolution.close()},n.prototype.reset=function(){this.poseSolution.reset()},n.prototype.initialize=function(){return this.poseSolution.initialize()},n}();function VL(n){return Ot(this,void 0,void 0,function(){var t,e;return _t(this,function(s){switch(s.label){case 0:return t=function(i){if(i==null)return Zt({},Gi);var o=Zt({},i);return o.runtime="mediapipe",o.enableSegmentation==null&&(o.enableSegmentation=Gi.enableSegmentation),o.enableSmoothing==null&&(o.enableSmoothing=Gi.enableSmoothing),o.smoothSegmentation==null&&(o.smoothSegmentation=Gi.smoothSegmentation),o.modelType==null&&(o.modelType=Gi.modelType),o}(n),[4,(e=new WL(t)).initialize()];case 1:return s.sent(),[2,e]}})})}function xi(n){return n instanceof Ge?{height:n.shape[0],width:n.shape[1]}:{height:n.height,width:n.width}}function mb(n){return n-2*Math.PI*Math.floor((n+Math.PI)/(2*Math.PI))}function pc(n){return n instanceof Ge?n:sm(n)}function gb(n,t,e){return ml(e,"inputResolution"),[1/e.width*n[0][0]*t.width,1/e.height*n[0][1]*t.width,n[0][3]*t.width,1/e.width*n[1][0]*t.height,1/e.height*n[1][1]*t.height,n[1][3]*t.height,0,0]}function ml(n,t){tt(n.width!==0,function(){return"".concat(t," width cannot be 0.")}),tt(n.height!==0,function(){return"".concat(t," height cannot be 0.")})}function Va(n,t,e){var s=e.rotationVectorStartKeypointIndex,i=e.rotationVectorEndKeypointIndex,o=n.locationData,r=o.relativeKeypoints[s].x*t.width,a=o.relativeKeypoints[s].y*t.height,l=o.relativeKeypoints[i].x*t.width,u=o.relativeKeypoints[i].y*t.height,c=2*Math.sqrt((l-r)*(l-r)+(u-a)*(u-a)),h=function(p,f,m){var g,b=p.locationData,v=m.rotationVectorStartKeypointIndex,w=m.rotationVectorEndKeypointIndex;g=m.rotationVectorTargetAngle?m.rotationVectorTargetAngle:Math.PI*m.rotationVectorTargetAngleDegree/180;var k=b.relativeKeypoints[v].x*f.width,C=b.relativeKeypoints[v].y*f.height,I=b.relativeKeypoints[w].x*f.width,N=b.relativeKeypoints[w].y*f.height;return mb(g-Math.atan2(-(N-C),I-k))}(n,t,e);return{xCenter:r/t.width,yCenter:a/t.height,width:c/t.width,height:c/t.height,rotation:h}}function yb(n){if(n.length!==16)throw new Error("Array length must be 16 but got ".concat(n.length));return[[n[0],n[1],n[2],n[3]],[n[4],n[5],n[6],n[7]],[n[8],n[9],n[10],n[11]],[n[12],n[13],n[14],n[15]]]}function Ua(n,t,e,s,i,o,r){return n[t][i]*(n[e][o]*n[s][r]-n[e][r]*n[s][o])}function ze(n,t,e){var s=(t+1)%4,i=(t+2)%4,o=(t+3)%4,r=(e+1)%4,a=(e+2)%4,l=(e+3)%4;return Ua(n,s,i,o,r,a,l)+Ua(n,i,o,s,r,a,l)+Ua(n,o,s,i,r,a,l)}function Qh(n,t,e){e===void 0&&(e={ignoreRotation:!1});for(var s=[],i=0,o=n;i<o.length;i++){var r=o[i],a=r.x-.5,l=r.y-.5,u=e.ignoreRotation?0:t.rotation,c=Math.cos(u)*a-Math.sin(u)*l,h=Math.sin(u)*a+Math.cos(u)*l;c=c*t.width+t.xCenter,h=h*t.height+t.yCenter;var p=r.z*t.width,f=Zt({},r);f.x=c,f.y=h,f.z=p,s.push(f)}return s}function bb(n,t){var e=function(s,i,o,r){var a=i-s,l=r-o,u=l/a;return{scale:u,offset:o-s*u}}(0,255,t[0],t[1]);return B(function(){return ct(O(n,e.scale),e.offset)})}function gl(n,t,e){var s,i,o,r,a,l,u,c,h,p,f,m,g,b,v=t.outputTensorSize,w=t.keepAspectRatio,k=t.borderMode,C=t.outputTensorFloatRange,I=xi(n),N=function(z,F){return F?{xCenter:F.xCenter*z.width,yCenter:F.yCenter*z.height,width:F.width*z.width,height:F.height*z.height,rotation:F.rotation}:{xCenter:.5*z.width,yCenter:.5*z.height,width:z.width,height:z.height,rotation:0}}(I,e),$=function(z,F,E){if(E===void 0&&(E=!1),!E)return{top:0,left:0,right:0,bottom:0};var U=F.height,L=F.width;ml(F,"targetSize"),ml(z,"roi");var W,_,V=U/L,X=z.height/z.width,j=0,K=0;return V>X?(W=z.width,_=z.width*V,K=(1-X/V)/2):(W=z.height/V,_=z.height,j=(1-V/X)/2),z.width=W,z.height=_,{top:K,left:j,right:j,bottom:K}}(N,v,w),A=(s=N,i=I.width,o=I.height,r=!1,a=s.width,l=s.height,u=r?-1:1,c=Math.cos(s.rotation),h=Math.sin(s.rotation),p=s.xCenter,f=s.yCenter,m=1/i,g=1/o,(b=new Array(16))[0]=a*c*u*m,b[1]=-l*h*m,b[2]=0,b[3]=(-.5*a*c*u+.5*l*h+p)*m,b[4]=a*h*u*g,b[5]=l*c*g,b[6]=0,b[7]=(-.5*l*c-.5*a*h*u+f)*g,b[8]=0,b[9]=0,b[10]=a*m,b[11]=0,b[12]=0,b[13]=0,b[14]=0,b[15]=1,yb(b));return{imageTensor:B(function(){var z=pc(n),F=zs(gb(A,I,v),[1,8]),E=k==="zero"?"constant":"nearest",U=Oe.transform(Ye(mt(z,"float32")),F,"bilinear",E,0,[v.height,v.width]);return C!=null?bb(U,C):U}),padding:$,transformationMatrix:A}}function Jh(n,t,e,s){return s===1?.5*(n+t):n+(t-n)*e/(s-1)}function UL(n){return B(function(){var t=function(i){return B(function(){return[ue(i,[0,0,0],[1,-1,1]),ue(i,[0,0,1],[1,-1,-1])]})}(n),e=t[0],s=t[1];return{boxes:Xt(s),logits:Xt(e)}})}function xb(n){return n!=null&&n.currentTime!=null}function td(n){for(var t={locationData:{relativeKeypoints:[]}},e=Number.MAX_SAFE_INTEGER,s=Number.MIN_SAFE_INTEGER,i=Number.MAX_SAFE_INTEGER,o=Number.MIN_SAFE_INTEGER,r=0;r<n.length;++r){var a=n[r];e=Math.min(e,a.x),s=Math.max(s,a.x),i=Math.min(i,a.y),o=Math.max(o,a.y),t.locationData.relativeKeypoints.push({x:a.x,y:a.y})}return t.locationData.relativeBoundingBox={xMin:e,yMin:i,xMax:s,yMax:o,width:s-e,height:o-i},t}function GL(n,t,e,s){return Ot(this,void 0,void 0,function(){var i,o,r,a,l;return _t(this,function(u){switch(u.label){case 0:return n.sort(function(c,h){return Math.max.apply(Math,h.score)-Math.max.apply(Math,c.score)}),i=zs(n.map(function(c){return[c.locationData.relativeBoundingBox.yMin,c.locationData.relativeBoundingBox.xMin,c.locationData.relativeBoundingBox.yMax,c.locationData.relativeBoundingBox.xMax]})),o=jn(n.map(function(c){return c.score[0]})),[4,Oe.nonMaxSuppressionAsync(i,o,t,e)];case 1:return[4,(r=u.sent()).array()];case 2:return a=u.sent(),l=n.filter(function(c,h){return a.indexOf(h)>-1}),zt([i,o,r]),[2,l]}})})}function wb(n,t){return n.map(function(e){var s=Zt(Zt({},e),{x:e.x*t.width,y:e.y*t.height});return e.z!=null&&(s.z=e.z*t.width),s})}function HL(n,t,e){return Ot(this,void 0,void 0,function(){var s,i,o,r,a,l,u,c,h,p,f,m,g,b,v,w,k,C,I,N,$,A,z,F;return _t(this,function(E){switch(E.label){case 0:if(s=Xt(t,[0]),i=s.shape,o=i[0],r=i[1],a=i[2],n.length!==a)throw new Error("Expected heatmap to have same number of channels as the number of landmarks. But got landmarks length: "+"".concat(n.length,", heatmap length: ").concat(a));return l=[],[4,s.buffer()];case 1:for(u=E.sent(),c=0;c<n.length;c++)if(h=n[c],p=Zt({},h),l.push(p),f=Math.trunc(p.x*r),m=Math.trunc(p.y*o),!(f<0||f>=r||m<0||f>=o)){for(g=Math.trunc((e.kernelSize-1)/2),b=Math.max(0,f-g),v=Math.min(r,f+g+1),w=Math.max(0,m-g),k=Math.min(o,m+g+1),C=0,I=0,N=0,$=0,A=w;A<k;++A)for(z=b;z<v;++z)F=u.get(A,z,c),C+=F,$=Math.max($,F),I+=z*F,N+=A*F;$>=e.minConfidenceToRefine&&C>0&&(p.x=I/r/C,p.y=N/o/C)}return s.dispose(),[2,l]}})})}function ed(n,t){var e=t.left,s=t.top,i=t.left+t.right,o=t.top+t.bottom;return n.map(function(r){return Zt(Zt({},r),{x:(r.x-e)/(1-i),y:(r.y-s)/(1-o),z:r.z/(1-i)})})}function jL(n,t,e){return Xo()==="webgl"?function(s,i,o){var r=o.combineWithPreviousRatio.toFixed(2),a={variableNames:["prevMask","newMask"],outputShape:s.shape,userCode:`
  void main() {
      ivec2 coords = getOutputCoords();
      int height = coords[0];
      int width = coords[1];

      float prevMaskValue = getPrevMask(height, width);
      float newMaskValue = getNewMask(height, width);

      /*
      * Assume p := newMaskValue
      * H(p) := 1 + (p * log(p) + (1-p) * log(1-p)) / log(2)
      * uncertainty alpha(p) =
      *   Clamp(1 - (1 - H(p)) * (1 - H(p)), 0, 1) [squaring the
      * uncertainty]
      *
      * The following polynomial approximates uncertainty alpha as a
      * function of (p + 0.5):
      */
      const float c1 = 5.68842;
      const float c2 = -0.748699;
      const float c3 = -57.8051;
      const float c4 = 291.309;
      const float c5 = -624.717;
      float t = newMaskValue - 0.5;
      float x = t * t;

      float uncertainty =
        1.0 - min(1.0, x * (c1 + x * (c2 + x * (c3 + x * (c4 + x * c5)))));

      float outputValue = newMaskValue + (prevMaskValue - newMaskValue) *
                             (uncertainty * `.concat(r,`);

      setOutput(outputValue);
    }
`)},l=hi();return B(function(){var u=l.compileAndRun(a,[s,i]);return us().makeTensorFromDataId(u.dataId,u.shape,u.dtype)})}(n,t,e):B(function(){var s=Lt(t,.5),i=Ie(s),o=Lt(1,jr(1,O(i,ct(5.68842,O(i,ct(-.748699,O(i,ct(-57.8051,O(i,ct(291.309,O(i,-624.717)))))))))));return ct(t,O(Lt(n,t),O(o,e.combineWithPreviousRatio)))})}function KL(n,t,e){return Ot(this,void 0,void 0,function(){var s,i,o,r,a;return _t(this,function(l){switch(l.label){case 0:return s=n[0],i=n[1],o=function(u,c,h){return B(function(){var p,f,m,g;h.reverseOutputOrder?(f=Xt(ue(u,[0,h.boxCoordOffset+0],[-1,1])),p=Xt(ue(u,[0,h.boxCoordOffset+1],[-1,1])),g=Xt(ue(u,[0,h.boxCoordOffset+2],[-1,1])),m=Xt(ue(u,[0,h.boxCoordOffset+3],[-1,1]))):(p=Xt(ue(u,[0,h.boxCoordOffset+0],[-1,1])),f=Xt(ue(u,[0,h.boxCoordOffset+1],[-1,1])),m=Xt(ue(u,[0,h.boxCoordOffset+2],[-1,1])),g=Xt(ue(u,[0,h.boxCoordOffset+3],[-1,1]))),f=ct(O(Ct(f,h.xScale),c.w),c.x),p=ct(O(Ct(p,h.yScale),c.h),c.y),h.applyExponentialOnBoxSize?(m=O(Qn(Ct(m,h.hScale)),c.h),g=O(Qn(Ct(g,h.wScale)),c.w)):(m=O(Ct(m,h.hScale),c.h),g=O(Ct(g,h.wScale),c.h));var b=Lt(p,Ct(m,2)),v=Lt(f,Ct(g,2)),w=ct(p,Ct(m,2)),k=ct(f,Ct(g,2)),C=fs([Q(b,[h.numBoxes,1]),Q(v,[h.numBoxes,1]),Q(w,[h.numBoxes,1]),Q(k,[h.numBoxes,1])],1);if(h.numKeypoints)for(var I=0;I<h.numKeypoints;++I){var N=h.keypointCoordOffset+I*h.numValuesPerKeypoint,$=void 0,A=void 0;h.reverseOutputOrder?($=Xt(ue(u,[0,N],[-1,1])),A=Xt(ue(u,[0,N+1],[-1,1]))):(A=Xt(ue(u,[0,N],[-1,1])),$=Xt(ue(u,[0,N+1],[-1,1])));var z=ct(O(Ct($,h.xScale),c.w),c.x),F=ct(O(Ct(A,h.yScale),c.h),c.y);C=fs([C,Q(z,[h.numBoxes,1]),Q(F,[h.numBoxes,1])],1)}return C})}(i,t,e),r=B(function(){var u=s;return e.sigmoidScore?(e.scoreClippingThresh!=null&&(u=Ue(s,-e.scoreClippingThresh,e.scoreClippingThresh)),u=Ws(u)):u}),[4,XL(o,r,e)];case 1:return a=l.sent(),zt([o,r]),[2,a]}})})}function XL(n,t,e){return Ot(this,void 0,void 0,function(){var s,i,o,r,a,l,u,c,h,p,f,m;return _t(this,function(g){switch(g.label){case 0:return s=[],[4,n.data()];case 1:return i=g.sent(),[4,t.data()];case 2:for(o=g.sent(),r=0;r<e.numBoxes;++r)if(!(e.minScoreThresh!=null&&o[r]<e.minScoreThresh||(a=r*e.numCoords,l=qL(i[a+0],i[a+1],i[a+2],i[a+3],o[r],e.flipVertically,r),(u=l.locationData.relativeBoundingBox).width<0||u.height<0))){if(e.numKeypoints>0)for((c=l.locationData).relativeKeypoints=[],h=e.numKeypoints*e.numValuesPerKeypoint,p=0;p<h;p+=e.numValuesPerKeypoint)f=a+e.keypointCoordOffset+p,m={x:i[f+0],y:e.flipVertically?1-i[f+1]:i[f+1]},c.relativeKeypoints.push(m);s.push(l)}return[2,s]}})})}function qL(n,t,e,s,i,o,r){return{score:[i],ind:r,locationData:{relativeBoundingBox:{xMin:t,yMin:o?1-e:n,xMax:s,yMax:o?1-n:e,width:s-t,height:e-n}}}}function YL(n,t){return n==="none"?t:function(e){return 1/(1+Math.exp(-e))}(t)}function nd(n,t,e,s){return Ot(this,void 0,void 0,function(){var i,o,r,a,l,u,c,h;return _t(this,function(p){switch(p.label){case 0:return e=e||t.flipHorizontally||!1,s=s||t.flipVertically||!1,i=n.size,o=i/t.numLandmarks,[4,n.data()];case 1:for(r=p.sent(),a=[],l=0;l<t.numLandmarks;++l)u=l*o,(h={x:0,y:0}).x=e?t.inputImageWidth-r[u]:r[u],o>1&&(h.y=s?t.inputImageHeight-r[u+1]:r[u+1]),o>2&&(h.z=r[u+2]),o>3&&(h.score=YL(t.visibilityActivation,r[u+3])),a.push(h);for(c=0;c<a.length;++c)(h=a[c]).x=h.x/t.inputImageWidth,h.y=h.y/t.inputImageHeight,h.z=h.z/t.inputImageWidth/(t.normalizeZ||1);return[2,a]}})})}function sd(n,t,e){var s=n.width,i=n.height,o=n.rotation;if(e.rotation==null&&e.rotationDegree==null||(o=function(u,c){return c.rotation!=null?u+=c.rotation:c.rotationDegree!=null&&(u+=Math.PI*c.rotationDegree/180),mb(u)}(o,e)),o===0)n.xCenter=n.xCenter+s*e.shiftX,n.yCenter=n.yCenter+i*e.shiftY;else{var r=(t.width*s*e.shiftX*Math.cos(o)-t.height*i*e.shiftY*Math.sin(o))/t.width,a=(t.width*s*e.shiftX*Math.sin(o)+t.height*i*e.shiftY*Math.cos(o))/t.height;n.xCenter=n.xCenter+r,n.yCenter=n.yCenter+a}{var l=Math.max(s*t.width,i*t.height);s=l/t.width,i=l/t.height}return n.width=s*e.scaleX,n.height=i*e.scaleY,n}function ZL(n,t){return n.map(function(e){var s=Zt(Zt({},e),{x:e.x/t.width,y:e.y/t.height});return e.z!=null&&(e.z=e.z/t.width),s})}var ls=function(){function n(t){this.alpha=t,this.initialized=!1}return n.prototype.apply=function(t,e){var s;return this.initialized?s=e==null?this.storedValue+this.alpha*(t-this.storedValue):this.storedValue+this.alpha*e*Math.asinh((t-this.storedValue)/e):(s=t,this.initialized=!0),this.rawValue=t,this.storedValue=s,s},n.prototype.applyWithAlpha=function(t,e,s){return this.alpha=e,this.apply(t,s)},n.prototype.hasLastRawValue=function(){return this.initialized},n.prototype.lastRawValue=function(){return this.rawValue},n.prototype.reset=function(){this.initialized=!1},n}(),Ga=function(){function n(t){this.frequency=t.frequency,this.minCutOff=t.minCutOff,this.beta=t.beta,this.thresholdCutOff=t.thresholdCutOff,this.thresholdBeta=t.thresholdBeta,this.derivateCutOff=t.derivateCutOff,this.x=new ls(this.getAlpha(this.minCutOff)),this.dx=new ls(this.getAlpha(this.derivateCutOff)),this.lastTimestamp=0}return n.prototype.apply=function(t,e,s){if(t==null)return t;var i=Math.trunc(e);if(this.lastTimestamp>=i)return t;this.lastTimestamp!==0&&i!==0&&(this.frequency=1/(1e-6*(i-this.lastTimestamp))),this.lastTimestamp=i;var o=this.x.hasLastRawValue()?(t-this.x.lastRawValue())*s*this.frequency:0,r=this.dx.applyWithAlpha(o,this.getAlpha(this.derivateCutOff)),a=this.minCutOff+this.beta*Math.abs(r),l=this.thresholdCutOff!=null?this.thresholdCutOff+this.thresholdBeta*Math.abs(r):null;return this.x.applyWithAlpha(t,this.getAlpha(a),l)},n.prototype.getAlpha=function(t){return 1/(1+this.frequency/(2*Math.PI*t))},n}(),yl=function(){function n(t){this.config=t}return n.prototype.apply=function(t,e,s){var i=this;if(t==null)return this.reset(),null;this.initializeFiltersIfEmpty(t);var o=1;if(!this.config.disableValueScaling){if(s<this.config.minAllowedObjectScale)return Ts([],t,!0);o=1/s}return t.map(function(r,a){var l=Zt(Zt({},r),{x:i.xFilters[a].apply(r.x,e,o),y:i.yFilters[a].apply(r.y,e,o)});return r.z!=null&&(l.z=i.zFilters[a].apply(r.z,e,o)),l})},n.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},n.prototype.initializeFiltersIfEmpty=function(t){var e=this;this.xFilters!=null&&this.xFilters.length===t.length||(this.xFilters=t.map(function(s){return new Ga(e.config)}),this.yFilters=t.map(function(s){return new Ga(e.config)}),this.zFilters=t.map(function(s){return new Ga(e.config)}))},n}(),Ha=function(){function n(t){this.config=t,this.window=[],this.lowPassFilter=new ls(1),this.lastValue=0,this.lastValueScale=1,this.lastTimestamp=-1}return n.prototype.apply=function(t,e,s){if(t==null)return t;var i,o=Math.trunc(e);if(this.lastTimestamp>=o)return t;if(this.lastTimestamp===-1)i=1;else{for(var r=t*s-this.lastValue*this.lastValueScale,a=o-this.lastTimestamp,l=r,u=a,c=(1+this.window.length)*(1e6/30),h=0,p=this.window;h<p.length;h++){var f=p[h];if(u+f.duration>c)break;l+=f.distance,u+=f.duration}var m=l/(1e-6*u);i=1-1/(1+this.config.velocityScale*Math.abs(m)),this.window.unshift({distance:r,duration:a}),this.window.length>this.config.windowSize&&this.window.pop()}return this.lastValue=t,this.lastValueScale=s,this.lastTimestamp=o,this.lowPassFilter.applyWithAlpha(t,i)},n}(),QL=function(){function n(t){this.config=t}return n.prototype.apply=function(t,e,s){var i=this;if(t==null)return this.reset(),null;var o=1;if(!this.config.disableValueScaling){if(s<this.config.minAllowedObjectScale)return Ts([],t,!0);o=1/s}return this.initializeFiltersIfEmpty(t),t.map(function(r,a){var l=Zt(Zt({},r),{x:i.xFilters[a].apply(r.x,e,o),y:i.yFilters[a].apply(r.y,e,o)});return r.z!=null&&(l.z=i.zFilters[a].apply(r.z,e,o)),l})},n.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},n.prototype.initializeFiltersIfEmpty=function(t){var e=this;this.xFilters!=null&&this.xFilters.length===t.length||(this.xFilters=t.map(function(s){return new Ha(e.config)}),this.yFilters=t.map(function(s){return new Ha(e.config)}),this.zFilters=t.map(function(s){return new Ha(e.config)}))},n}(),ja=function(){function n(t){if(t.velocityFilter!=null)this.keypointsFilter=new QL(t.velocityFilter);else{if(t.oneEuroFilter==null)throw new Error("Either configure velocityFilter or oneEuroFilter, but got "+"".concat(t,"."));this.keypointsFilter=new yl(t.oneEuroFilter)}}return n.prototype.apply=function(t,e,s,i,o){if(i===void 0&&(i=!1),t==null)return this.keypointsFilter.reset(),null;var r=o!=null?function(u,c){return(u.width*c.width+u.height*c.height)/2}(o,s):1,a=i?wb(t,s):t,l=this.keypointsFilter.apply(a,e,r);return i?ZL(l,s):l},n}(),id=function(){function n(t){this.alpha=t.alpha}return n.prototype.apply=function(t){var e=this;if(t==null)return this.visibilityFilters=null,null;this.visibilityFilters!=null&&this.visibilityFilters.length===t.length||(this.visibilityFilters=t.map(function(a){return new ls(e.alpha)}));for(var s=[],i=0;i<t.length;++i){var o=t[i],r=Zt({},o);r.score=this.visibilityFilters[i].apply(o.score),s.push(r)}return s},n}(),JL={reduceBoxesInLowestlayer:!1,interpolatedScaleAspectRatio:1,featureMapHeight:[],featureMapWidth:[],numLayers:5,minScale:.1484375,maxScale:.75,inputSizeHeight:224,inputSizeWidth:224,anchorOffsetX:.5,anchorOffsetY:.5,strides:[8,16,32,32,32],aspectRatios:[1],fixedAnchorSize:!0},si={runtime:"tfjs",modelType:"full",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,detectorModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/detector/1",landmarkModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"},tO={maxPoses:1,flipHorizontal:!1},eO={applyExponentialOnBoxSize:!1,flipVertically:!1,ignoreClasses:[],numClasses:1,numBoxes:2254,numCoords:12,boxCoordOffset:0,keypointCoordOffset:4,numKeypoints:4,numValuesPerKeypoint:2,sigmoidScore:!0,scoreClippingThresh:100,reverseOutputOrder:!0,xScale:224,yScale:224,hScale:224,wScale:224,minScoreThresh:.5},nO=.3,od={shiftX:0,shiftY:0,scaleX:1.25,scaleY:1.25,squareLong:!0},sO={outputTensorSize:{width:224,height:224},keepAspectRatio:!0,outputTensorFloatRange:[-1,1],borderMode:"zero"},iO={outputTensorSize:{width:256,height:256},keepAspectRatio:!0,outputTensorFloatRange:[0,1],borderMode:"zero"},oO={numLandmarks:39,inputImageWidth:256,inputImageHeight:256,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},rO={numLandmarks:39,inputImageWidth:1,inputImageHeight:1,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},aO={kernelSize:7,minConfidenceToRefine:.5},rd={alpha:.1},lO={oneEuroFilter:{frequency:30,minCutOff:.05,beta:80,derivateCutOff:1,minAllowedObjectScale:1e-6}},uO={oneEuroFilter:{frequency:30,minCutOff:.01,beta:10,derivateCutOff:1,minAllowedObjectScale:1e-6}},cO={oneEuroFilter:{frequency:30,minCutOff:.1,beta:40,derivateCutOff:1,minAllowedObjectScale:1e-6,disableValueScaling:!0}},hO={activation:"none"},dO={combineWithPreviousRatio:.7},pO=function(){function n(t){this.mask=t}return n.prototype.toCanvasImageSource=function(){return Ot(this,void 0,void 0,function(){return _t(this,function(t){return[2,db(this.mask)]})})},n.prototype.toImageData=function(){return Ot(this,void 0,void 0,function(){return _t(this,function(t){return[2,pb(this.mask)]})})},n.prototype.toTensor=function(){return Ot(this,void 0,void 0,function(){return _t(this,function(t){return[2,this.mask]})})},n.prototype.getUnderlyingType=function(){return"tensor"},n}();function fO(n){return fb(n),"person"}var mO=function(){function n(t,e,s,i,o,r){this.detectorModel=t,this.landmarkModel=e,this.enableSmoothing=s,this.enableSegmentation=i,this.smoothSegmentation=o,this.modelType=r,this.regionOfInterest=null,this.prevFilteredSegmentationMask=null,this.anchors=function(h){h.reduceBoxesInLowestLayer==null&&(h.reduceBoxesInLowestLayer=!1),h.interpolatedScaleAspectRatio==null&&(h.interpolatedScaleAspectRatio=1),h.fixedAnchorSize==null&&(h.fixedAnchorSize=!1);for(var p=[],f=0;f<h.numLayers;){for(var m=[],g=[],b=[],v=[],w=f;w<h.strides.length&&h.strides[w]===h.strides[f];){var k=Jh(h.minScale,h.maxScale,w,h.strides.length);if(w===0&&h.reduceBoxesInLowestLayer)b.push(1),b.push(2),b.push(.5),v.push(.1),v.push(k),v.push(k);else{for(var C=0;C<h.aspectRatios.length;++C)b.push(h.aspectRatios[C]),v.push(k);if(h.interpolatedScaleAspectRatio>0){var I=w===h.strides.length-1?1:Jh(h.minScale,h.maxScale,w+1,h.strides.length);v.push(Math.sqrt(k*I)),b.push(h.interpolatedScaleAspectRatio)}}w++}for(var N=0;N<b.length;++N){var $=Math.sqrt(b[N]);m.push(v[N]/$),g.push(v[N]*$)}var A=0,z=0;if(h.featureMapHeight.length>0)A=h.featureMapHeight[f],z=h.featureMapWidth[f];else{var F=h.strides[f];A=Math.ceil(h.inputSizeHeight/F),z=Math.ceil(h.inputSizeWidth/F)}for(var E=0;E<A;++E)for(var U=0;U<z;++U)for(var L=0;L<m.length;++L){var W={xCenter:(U+h.anchorOffsetX)/z,yCenter:(E+h.anchorOffsetY)/A,width:0,height:0};h.fixedAnchorSize?(W.width=1,W.height=1):(W.width=g[L],W.height=m[L]),p.push(W)}f=w}return p}(JL);var a=jn(this.anchors.map(function(h){return h.width})),l=jn(this.anchors.map(function(h){return h.height})),u=jn(this.anchors.map(function(h){return h.xCenter})),c=jn(this.anchors.map(function(h){return h.yCenter}));this.anchorTensor={x:u,y:c,w:a,h:l},this.prevFilteredSegmentationMask=this.enableSegmentation?zs([],[0,0]):null}return n.prototype.estimatePoses=function(t,e,s){return Ot(this,void 0,void 0,function(){var i,o,r,a,l,u,c,h,p,f,m,g,b,v,w,k,C,I,N,$,A,z,F;return _t(this,function(E){switch(E.label){case 0:return i=function(U){var L;if((L=U==null?tO:Zt({},U)).maxPoses==null&&(L.maxPoses=1),L.maxPoses<=0)throw new Error("Invalid maxPoses ".concat(L.maxPoses,". Should be > 0."));if(L.maxPoses>1)throw new Error("Multi-pose detection is not implemented yet. Please set maxPoses to 1.");return L}(e),t==null?(this.reset(),[2,[]]):(this.maxPoses=i.maxPoses,this.timestamp=s!=null?1e3*s:xb(t)?1e6*t.currentTime:null,o=xi(t),r=B(function(){return mt(pc(t),"float32")}),(a=this.regionOfInterest)!=null?[3,2]:[4,this.detectPose(r)]);case 1:if((l=E.sent()).length===0)return this.reset(),r.dispose(),[2,[]];u=l[0],a=this.poseDetectionToRoi(u,o),E.label=2;case 2:return[4,this.poseLandmarksByRoi(a,r)];case 3:return c=E.sent(),r.dispose(),c==null?(this.reset(),[2,[]]):(h=c.landmarks,p=c.auxiliaryLandmarks,f=c.poseScore,m=c.worldLandmarks,g=c.segmentationMask,b=this.poseLandmarkFiltering(h,p,m,o),v=b.actualLandmarksFiltered,w=b.auxiliaryLandmarksFiltered,k=b.actualWorldLandmarksFiltered,C=this.poseLandmarksToRoi(w,o),this.regionOfInterest=C,I=this.smoothSegmentation&&g!=null?this.poseSegmentationFiltering(g):g,(N=v!=null?wb(v,o):null)!=null&&N.forEach(function(U,L){U.name=ao[L]}),($=k)!=null&&$.forEach(function(U,L){U.name=ao[L]}),A={score:f,keypoints:N,keypoints3D:$},I!==null&&(z=B(function(){var U=Ye(I,2),L=li(U,[[0,0],[0,0],[0,1]]);return kp(L,[[0,0],[0,0],[0,2]],"symmetric")}),this.smoothSegmentation||zt(I),F={maskValueToLabel:fO,mask:new pO(z)},A.segmentation=F),[2,[A]])}})})},n.prototype.poseSegmentationFiltering=function(t){var e=this.prevFilteredSegmentationMask;return e.size===0?this.prevFilteredSegmentationMask=t:(this.prevFilteredSegmentationMask=jL(e,t,dO),zt(t)),zt(e),this.prevFilteredSegmentationMask},n.prototype.dispose=function(){this.detectorModel.dispose(),this.landmarkModel.dispose(),zt([this.anchorTensor.x,this.anchorTensor.y,this.anchorTensor.w,this.anchorTensor.h,this.prevFilteredSegmentationMask])},n.prototype.reset=function(){this.regionOfInterest=null,this.enableSegmentation&&(zt(this.prevFilteredSegmentationMask),this.prevFilteredSegmentationMask=zs([],[0,0])),this.visibilitySmoothingFilterActual=null,this.visibilitySmoothingFilterAuxiliary=null,this.landmarksSmoothingFilterActual=null,this.landmarksSmoothingFilterAuxiliary=null},n.prototype.detectPose=function(t){return Ot(this,void 0,void 0,function(){var e,s,i,o,r,a,l,u,c,h;return _t(this,function(p){switch(p.label){case 0:return e=gl(t,sO),s=e.imageTensor,i=e.padding,o=this.detectorModel.predict(s),r=UL(o),a=r.boxes,[4,KL([l=r.logits,a],this.anchorTensor,eO)];case 1:return(u=p.sent()).length===0?(zt([s,o,l,a]),[2,u]):[4,GL(u,this.maxPoses,nO)];case 2:return c=p.sent(),h=function(f,m){f===void 0&&(f=[]);for(var g=m.left,b=m.top,v=m.left+m.right,w=m.top+m.bottom,k=0;k<f.length;k++){var C=f[k],I=C.locationData.relativeBoundingBox,N=(I.xMin-g)/(1-v),$=(I.yMin-b)/(1-w),A=I.width/(1-v),z=I.height/(1-w);I.xMin=N,I.yMin=$,I.width=A,I.height=z,I.xMax=N+A,I.yMax=$+z;var F=C.locationData.relativeKeypoints;F&&F.forEach(function(E){var U=(E.x-g)/(1-v),L=(E.y-b)/(1-w);E.x=U,E.y=L})}return f}(c,i),zt([s,o,l,a]),[2,h]}})})},n.prototype.poseDetectionToRoi=function(t,e){return sd(Va(t,e,{rotationVectorEndKeypointIndex:1,rotationVectorStartKeypointIndex:0,rotationVectorTargetAngleDegree:90}),e,od)},n.prototype.poseLandmarksByRoi=function(t,e){return Ot(this,void 0,void 0,function(){var s,i,o,r,a,l,u,c,h,p,f,m,g,b;return _t(this,function(v){switch(v.label){case 0:if(s=xi(e),i=gl(e,iO,t),o=i.imageTensor,r=i.padding,a=i.transformationMatrix,this.modelType!=="lite"&&this.modelType!=="full"&&this.modelType!=="heavy")throw new Error("Model type must be one of lite, full or heavy,"+"but got ".concat(this.modelType));return l=["ld_3d","output_poseflag","activation_heatmap","world_3d"],this.enableSegmentation&&l.push("activation_segmentation"),u=this.landmarkModel.execute(o,l),[4,this.tensorsToPoseLandmarksAndSegmentation(u)];case 1:return(c=v.sent())==null?(zt(u),zt(o),[2,null]):(h=c.landmarks,p=c.auxiliaryLandmarks,f=c.poseScore,m=c.worldLandmarks,g=c.segmentationMask,[4,this.poseLandmarksAndSegmentationInverseProjection(s,t,r,a,h,p,m,g)]);case 2:return b=v.sent(),zt(u),zt(o),[2,Zt({poseScore:f},b)]}})})},n.prototype.poseLandmarksAndSegmentationInverseProjection=function(t,e,s,i,o,r,a,l){return Ot(this,void 0,void 0,function(){var u,c,h,p,f,m;return _t(this,function(g){return u=ed(o,s),c=ed(r,s),h=Qh(u,e),p=Qh(c,e),f=function(b,v){for(var w=[],k=0,C=b;k<C.length;k++){var I=C[k],N=I.x,$=I.y,A=v.rotation,z=Math.cos(A)*N-Math.sin(A)*$,F=Math.sin(A)*N+Math.cos(A)*$,E=Zt({},I);E.x=z,E.y=F,w.push(E)}return w}(a,e),m=null,this.enableSegmentation&&(m=B(function(){var b=l.shape,v=b[0],w=b[1],k=function(N){var $=yb(new Array(16).fill(0));$[0][0]=ze(N,0,0),$[1][0]=-ze(N,0,1),$[2][0]=ze(N,0,2),$[3][0]=-ze(N,0,3),$[0][2]=ze(N,2,0),$[1][2]=-ze(N,2,1),$[2][2]=ze(N,2,2),$[3][2]=-ze(N,2,3),$[0][1]=-ze(N,1,0),$[1][1]=ze(N,1,1),$[2][1]=-ze(N,1,2),$[3][1]=ze(N,1,3),$[0][3]=-ze(N,3,0),$[1][3]=ze(N,3,1),$[2][3]=-ze(N,3,2),$[3][3]=ze(N,3,3);for(var A=N[0][0]*$[0][0]+N[1][0]*$[0][1]+N[2][0]*$[0][2]+N[3][0]*$[0][3],z=0;z<$.length;z++)for(var F=0;F<$.length;F++)$[z][F]/=A;return $}(i),C=zs(gb(k,{width:w,height:v},t),[1,8]),I=[1,v,w,1];return Xt(Oe.transform(Q(l,I),C,"bilinear","constant",0,[t.height,t.width]),[0,3])}),zt(l)),[2,{landmarks:h,auxiliaryLandmarks:p,worldLandmarks:f,segmentationMask:m}]})})},n.prototype.tensorsToPoseLandmarksAndSegmentation=function(t){return Ot(this,void 0,void 0,function(){var e,s,i,o,r,a,l,u,c,h,p,f,m;return _t(this,function(g){switch(g.label){case 0:return e=t[0],s=t[1],i=t[2],o=t[3],r=this.enableSegmentation?t[4]:null,[4,s.data()];case 1:return(a=g.sent()[0])<.5?[2,null]:[4,nd(e,oO)];case 2:return[4,HL(g.sent(),i,aO)];case 3:return l=g.sent(),u=l.slice(0,33),c=l.slice(33,35),[4,nd(o,rO)];case 4:return h=g.sent(),p=h.slice(0,33),f=function(b,v,w){for(var k=[],C=0;C<b.length;C++){var I=Zt({},v[C]);I.score=b[C].score,k.push(I)}return k}(u,p),m=this.enableSegmentation?function(b,v,w){return B(function(){var k=Xt(b,[0]),C=k.shape[2];if(C===1){var I=k;switch(v.activation){case"none":break;case"sigmoid":I=Ws(I);break;case"softmax":throw new Error("Softmax activation requires two channels.");default:throw new Error("Activation not supported (".concat(v.activation,")"))}var N=I;return Xt(N,[2])}throw new Error("Unsupported number of tensor channels ".concat(C))})}(r,hO):null,[2,{landmarks:u,auxiliaryLandmarks:c,poseScore:a,worldLandmarks:f,segmentationMask:m}]}})})},n.prototype.poseLandmarksToRoi=function(t,e){return sd(Va(td(t),e,{rotationVectorStartKeypointIndex:0,rotationVectorEndKeypointIndex:1,rotationVectorTargetAngleDegree:90}),e,od)},n.prototype.poseLandmarkFiltering=function(t,e,s,i){var o,r,a;if(this.timestamp!=null&&this.enableSmoothing){var l=Va(td(e),i,{rotationVectorEndKeypointIndex:0,rotationVectorStartKeypointIndex:1,rotationVectorTargetAngleDegree:90});this.visibilitySmoothingFilterActual==null&&(this.visibilitySmoothingFilterActual=new id(rd)),o=this.visibilitySmoothingFilterActual.apply(t),this.visibilitySmoothingFilterAuxiliary==null&&(this.visibilitySmoothingFilterAuxiliary=new id(rd)),r=this.visibilitySmoothingFilterAuxiliary.apply(e),a=this.visibilitySmoothingFilterActual.apply(s),this.landmarksSmoothingFilterActual==null&&(this.landmarksSmoothingFilterActual=new ja(lO)),o=this.landmarksSmoothingFilterActual.apply(o,this.timestamp,i,!0,l),this.landmarksSmoothingFilterAuxiliary==null&&(this.landmarksSmoothingFilterAuxiliary=new ja(uO)),r=this.landmarksSmoothingFilterAuxiliary.apply(r,this.timestamp,i,!0,l),this.worldLandmarksSmoothingFilterActual==null&&(this.worldLandmarksSmoothingFilterActual=new ja(cO)),a=this.worldLandmarksSmoothingFilterActual.apply(s,this.timestamp)}else o=t,r=e,a=s;return{actualLandmarksFiltered:o,auxiliaryLandmarksFiltered:r,actualWorldLandmarksFiltered:a}},n}();function gO(n){return Ot(this,void 0,void 0,function(){var t,e,s,i,o,r;return _t(this,function(a){switch(a.label){case 0:return t=function(l){var u=Zt({},l??si);if(u.enableSmoothing==null&&(u.enableSmoothing=si.enableSmoothing),u.enableSegmentation==null&&(u.enableSegmentation=si.enableSegmentation),u.smoothSegmentation==null&&(u.smoothSegmentation=si.smoothSegmentation),u.modelType==null&&(u.modelType=si.modelType),u.detectorModelUrl==null&&(u.detectorModelUrl=si.detectorModelUrl),u.landmarkModelUrl==null)switch(u.modelType){case"lite":u.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/lite/2";break;case"heavy":u.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/heavy/2";break;case"full":default:u.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"}return u}(n),e=typeof t.detectorModelUrl=="string"&&t.detectorModelUrl.indexOf("https://tfhub.dev")>-1,s=typeof t.landmarkModelUrl=="string"&&t.landmarkModelUrl.indexOf("https://tfhub.dev")>-1,[4,Promise.all([fi(t.detectorModelUrl,{fromTFHub:e}),fi(t.landmarkModelUrl,{fromTFHub:s})])];case 1:return i=a.sent(),o=i[0],r=i[1],[2,new mO(o,r,t.enableSmoothing,t.enableSegmentation,t.smoothSegmentation,t.modelType)]}})})}var Es,Fe,vb=function(){function n(t){(function(e){if(e.maxTracks<1)throw new Error("Must specify 'maxTracks' to be at least 1, but "+"encountered ".concat(e.maxTracks));if(e.maxAge<=0)throw new Error("Must specify 'maxAge' to be positive, but "+"encountered ".concat(e.maxAge));if(e.keypointTrackerParams!==void 0){if(e.keypointTrackerParams.keypointConfidenceThreshold<0||e.keypointTrackerParams.keypointConfidenceThreshold>1)throw new Error("Must specify 'keypointConfidenceThreshold' to be in the range [0, 1], but encountered "+"".concat(e.keypointTrackerParams.keypointConfidenceThreshold));if(e.keypointTrackerParams.minNumberOfKeypoints<1)throw new Error("Must specify 'minNumberOfKeypoints' to be at least 1, but "+"encountered ".concat(e.keypointTrackerParams.minNumberOfKeypoints));for(var s=0,i=e.keypointTrackerParams.keypointFalloff;s<i.length;s++){var o=i[s];if(o<=0)throw new Error("Must specify each keypoint falloff parameterto be positive "+"but encountered ".concat(o))}}})(t),this.tracks=[],this.maxTracks=t.maxTracks,this.maxAge=1e3*t.maxAge,this.minSimilarity=t.minSimilarity,this.nextID=1}return n.prototype.apply=function(t,e){this.filterOldTracks(e);var s=this.computeSimilarity(t);return this.assignTracks(t,s,e),this.updateTracks(e),t},n.prototype.getTracks=function(){return this.tracks.slice()},n.prototype.getTrackIDs=function(){return new Set(this.tracks.map(function(t){return t.id}))},n.prototype.filterOldTracks=function(t){var e=this;this.tracks=this.tracks.filter(function(s){return t-s.lastTimestamp<=e.maxAge})},n.prototype.assignTracks=function(t,e,s){for(var i=Array.from(Array(e[0].length).keys()),o=[],r=0,a=Array.from(Array(t.length).keys());r<a.length;r++){var l=a[r];if(i.length!==0){for(var u=-1,c=-1,h=0,p=i;h<p.length;h++){var f=p[h],m=e[l][f];m>=this.minSimilarity&&m>c&&(u=f,c=m)}if(u>=0){var g=this.tracks[u];g=Object.assign(g,this.createTrack(t[l],s,g.id)),t[l].id=g.id;var b=i.indexOf(u);i.splice(b,1)}else o.push(l)}else o.push(l)}for(var v=0,w=o;v<w.length;v++){l=w[v];var k=this.createTrack(t[l],s);this.tracks.push(k),t[l].id=k.id}},n.prototype.updateTracks=function(t){this.tracks.sort(function(e,s){return s.lastTimestamp-e.lastTimestamp}),this.tracks=this.tracks.slice(0,this.maxTracks)},n.prototype.createTrack=function(t,e,s){var i={id:s||this.nextTrackID(),lastTimestamp:e,keypoints:Ts([],t.keypoints,!0).map(function(o){return Zt({},o)})};return t.box!==void 0&&(i.box=Zt({},t.box)),i},n.prototype.nextTrackID=function(){var t=this.nextID;return this.nextID+=1,t},n.prototype.remove=function(){for(var t=[],e=0;e<arguments.length;e++)t[e]=arguments[e];this.tracks=this.tracks.filter(function(s){return!t.includes(s.id)})},n.prototype.reset=function(){this.tracks=[]},n}(),yO=function(n){function t(e){return n.call(this,e)||this}return hb(t,n),t.prototype.computeSimilarity=function(e){var s=this;return e.length===0||this.tracks.length===0?[[]]:e.map(function(i){return s.tracks.map(function(o){return s.iou(i,o)})})},t.prototype.iou=function(e,s){var i=Math.max(e.box.xMin,s.box.xMin),o=Math.max(e.box.yMin,s.box.yMin),r=Math.min(e.box.xMax,s.box.xMax),a=Math.min(e.box.yMax,s.box.yMax);if(i>=r||o>=a)return 0;var l=(r-i)*(a-o);return l/(e.box.width*e.box.height+s.box.width*s.box.height-l)},t}(vb),bO=function(n){function t(e){var s=n.call(this,e)||this;return s.keypointThreshold=e.keypointTrackerParams.keypointConfidenceThreshold,s.keypointFalloff=e.keypointTrackerParams.keypointFalloff,s.minNumKeyoints=e.keypointTrackerParams.minNumberOfKeypoints,s}return hb(t,n),t.prototype.computeSimilarity=function(e){if(e.length===0||this.tracks.length===0)return[[]];for(var s=[],i=0,o=e;i<o.length;i++){for(var r=o[i],a=[],l=0,u=this.tracks;l<u.length;l++){var c=u[l];a.push(this.oks(r,c))}s.push(a)}return s},t.prototype.oks=function(e,s){for(var i=this.area(s.keypoints)+1e-6,o=0,r=0,a=0;a<e.keypoints.length;++a){var l=e.keypoints[a],u=s.keypoints[a];if(!(l.score<this.keypointThreshold||u.score<this.keypointThreshold)){r+=1;var c=Math.pow(l.x-u.x,2)+Math.pow(l.y-u.y,2),h=2*this.keypointFalloff[a];o+=Math.exp(-1*c/(2*i*Math.pow(h,2)))}}return r<this.minNumKeyoints?0:o/r},t.prototype.area=function(e){var s=this,i=e.filter(function(l){return l.score>s.keypointThreshold}),o=Math.min.apply(Math,Ts([1],i.map(function(l){return l.x}),!1)),r=Math.max.apply(Math,Ts([0],i.map(function(l){return l.x}),!1)),a=Math.min.apply(Math,Ts([1],i.map(function(l){return l.y}),!1));return(r-o)*(Math.max.apply(Math,Ts([0],i.map(function(l){return l.y}),!1))-a)},t}(vb);function Cb(n){switch(n){case Fe.BlazePose:return ao.reduce(function(t,e,s){return t[e]=s,t},{});case Fe.PoseNet:case Fe.MoveNet:return Bn.reduce(function(t,e,s){return t[e]=s,t},{});default:throw new Error("Model ".concat(n," is not supported."))}}(function(n){n.Keypoint="keypoint",n.BoundingBox="boundingBox"})(Es||(Es={})),function(n){n.MoveNet="MoveNet",n.BlazePose="BlazePose",n.PoseNet="PoseNet"}(Fe||(Fe={}));var ad=Object.freeze({__proto__:null,getKeypointIndexBySide:function(n){switch(n){case Fe.BlazePose:return ML;case Fe.PoseNet:case Fe.MoveNet:return PL;default:throw new Error("Model ".concat(n," is not supported."))}},getAdjacentPairs:function(n){switch(n){case Fe.BlazePose:return LL;case Fe.PoseNet:case Fe.MoveNet:return EL;default:throw new Error("Model ".concat(n," is not supported."))}},getKeypointIndexByName:Cb}),ld=["SinglePose.Lightning","SinglePose.Thunder","MultiPose.Lightning"],kb={modelType:"SinglePose.Lightning",enableSmoothing:!0},ud={},cd={frequency:30,minCutOff:2.5,beta:300,derivateCutOff:2.5,thresholdCutOff:.5,thresholdBeta:5,disableValueScaling:!0},Ka={maxTracks:18,maxAge:1e3,minSimilarity:.2,keypointTrackerParams:{keypointConfidenceThreshold:.3,keypointFalloff:[.026,.025,.025,.035,.035,.079,.079,.072,.072,.062,.062,.107,.107,.087,.087,.089,.089],minNumberOfKeypoints:4}},hd={maxTracks:18,maxAge:1e3,minSimilarity:.15,trackerParams:{}};function xO(n,t,e,s){for(var i={},o=0,r=Bn;o<r.length;o++){var a=r[o];i[a]=[t[e[a]].y*s.height,t[e[a]].x*s.width]}if(function(w,k){return(w[k.left_hip].score>.2||w[k.right_hip].score>.2)&&(w[k.left_shoulder].score>.2||w[k.right_shoulder].score>.2)}(t,e)){var l=(i.left_hip[0]+i.right_hip[0])/2,u=(i.left_hip[1]+i.right_hip[1])/2,c=function(w,k,C,I,N){for(var $=["left_shoulder","right_shoulder","left_hip","right_hip"],A=0,z=0,F=0;F<$.length;F++)(_=Math.abs(I-C[$[F]][0]))>A&&(A=_),(V=Math.abs(N-C[$[F]][1]))>z&&(z=V);for(var E=0,U=0,L=0,W=Object.keys(C);L<W.length;L++){var _,V,X=W[L];w[k[X]].score<.2||((_=Math.abs(I-C[X][0]))>E&&(E=_),(V=Math.abs(N-C[X][1]))>U&&(U=V))}return[A,z,E,U]}(t,e,i,l,u),h=c[0],p=c[1],f=c[2],m=c[3],g=Math.max(1.9*p,1.9*h,1.2*f,1.2*m),b=[l-(g=Math.min(g,Math.max(u,s.width-u,l,s.height-l))),u-g];if(g>Math.max(s.width,s.height)/2)return bl(n==null,s);var v=2*g;return{yMin:b[0]/s.height,xMin:b[1]/s.width,yMax:(b[0]+v)/s.height,xMax:(b[1]+v)/s.width,height:(b[0]+v)/s.height-b[0]/s.height,width:(b[1]+v)/s.width-b[1]/s.width}}return bl(n==null,s)}function bl(n,t){var e,s,i,o;return n?t.width>t.height?(e=1,s=t.height/t.width,i=0,o=(t.width/2-t.height/2)/t.width):(e=t.width/t.height,s=1,i=(t.height/2-t.width/2)/t.height,o=0):t.width>t.height?(e=t.width/t.height,s=1,i=(t.height/2-t.width/2)/t.height,o=0):(e=1,s=t.height/t.width,i=0,o=(t.width/2-t.height/2)/t.width),{yMin:i,xMin:o,yMax:i+e,xMax:o+s,height:e,width:s}}function wO(n){var t,e=n==null?kb:Zt({},n);if(e.modelType==null)e.modelType="SinglePose.Lightning";else if(ld.indexOf(e.modelType)<0)throw new Error("Invalid architecture ".concat(e.modelType,". ")+"Should be one of ".concat(ld));if(e.enableSmoothing==null&&(e.enableSmoothing=!0),e.minPoseScore!=null&&(e.minPoseScore<0||e.minPoseScore>1))throw new Error("minPoseScore should be between 0.0 and 1.0");if(e.multiPoseMaxDimension!=null&&(e.multiPoseMaxDimension%32!=0||e.multiPoseMaxDimension<32))throw new Error("multiPoseMaxDimension must be a multiple of 32 and higher than 0");if(e.modelType==="MultiPose.Lightning"&&e.enableTracking==null&&(e.enableTracking=!0),e.modelType==="MultiPose.Lightning"&&e.enableTracking===!0)if(e.trackerType==null&&(e.trackerType=Es.BoundingBox),e.trackerType===Es.Keypoint)e.trackerConfig!=null?e.trackerConfig=function(s){var i=dd(Ka,s);return i.keypointTrackerParams=Zt({},Ka.keypointTrackerParams),s.keypointTrackerParams!=null&&(s.keypointTrackerParams.keypointConfidenceThreshold!=null&&(i.keypointTrackerParams.keypointConfidenceThreshold=s.keypointTrackerParams.keypointConfidenceThreshold),s.keypointTrackerParams.keypointFalloff!=null&&(i.keypointTrackerParams.keypointFalloff=s.keypointTrackerParams.keypointFalloff),s.keypointTrackerParams.minNumberOfKeypoints!=null&&(i.keypointTrackerParams.minNumberOfKeypoints=s.keypointTrackerParams.minNumberOfKeypoints)),i}(e.trackerConfig):e.trackerConfig=Ka;else{if(e.trackerType!==Es.BoundingBox)throw new Error("Tracker type not supported by MoveNet");e.trackerConfig!=null?e.trackerConfig=(t=e.trackerConfig,dd(hd,t)):e.trackerConfig=hd}return e}function dd(n,t){var e={maxTracks:n.maxTracks,maxAge:n.maxAge,minSimilarity:n.minSimilarity};return t.maxTracks!=null&&(e.maxTracks=t.maxTracks),t.maxAge!=null&&(e.maxAge=t.maxAge),t.minSimilarity!=null&&(e.minSimilarity=t.minSimilarity),e}var vO=function(){function n(t,e){this.moveNetModel=t,this.modelInputResolution={height:0,width:0},this.keypointIndexByName=Cb(Fe.MoveNet),e.modelType==="SinglePose.Lightning"?(this.modelInputResolution.width=192,this.modelInputResolution.height=192):e.modelType==="SinglePose.Thunder"&&(this.modelInputResolution.width=256,this.modelInputResolution.height=256),this.multiPoseModel=e.modelType==="MultiPose.Lightning",this.multiPoseModel||(this.keypointFilter=new yl(cd),this.cropRegionFilterYMin=new ls(.9),this.cropRegionFilterXMin=new ls(.9),this.cropRegionFilterYMax=new ls(.9),this.cropRegionFilterXMax=new ls(.9)),this.enableSmoothing=e.enableSmoothing,e.minPoseScore?this.minPoseScore=e.minPoseScore:this.minPoseScore=.25,e.multiPoseMaxDimension?this.multiPoseMaxDimension=e.multiPoseMaxDimension:this.multiPoseMaxDimension=256,this.enableTracking=e.enableTracking,this.multiPoseModel&&this.enableTracking&&(e.trackerType===Es.Keypoint?this.tracker=new bO(e.trackerConfig):e.trackerType===Es.BoundingBox&&(this.tracker=new yO(e.trackerConfig)),this.enableSmoothing&&(this.keypointFilterMap=new Map))}return n.prototype.runSinglePersonPoseModel=function(t){return Ot(this,void 0,void 0,function(){var e,s,i,o,r;return _t(this,function(a){switch(a.label){case 0:if((e=this.moveNetModel.execute(t)).shape.length!==4||e.shape[0]!==1||e.shape[1]!==1||e.shape[2]!==17||e.shape[3]!==3)throw e.dispose(),new Error("Unexpected output shape from model: [".concat(e.shape,"]"));return Xo()==="webgpu"?[3,1]:(s=e.dataSync(),[3,3]);case 1:return[4,e.data()];case 2:s=a.sent(),a.label=3;case 3:for(e.dispose(),i={keypoints:[],score:0},o=0,r=0;r<17;++r)i.keypoints[r]={y:s[3*r],x:s[3*r+1],score:s[3*r+2]},i.keypoints[r].score>.2&&(++o,i.score+=i.keypoints[r].score);return o>0&&(i.score/=o),[2,i]}})})},n.prototype.runMultiPersonPoseModel=function(t){return Ot(this,void 0,void 0,function(){var e,s,i,o,r,a,l,u;return _t(this,function(c){switch(c.label){case 0:if((e=this.moveNetModel.execute(t)).shape.length!==3||e.shape[0]!==1||e.shape[2]!==56)throw e.dispose(),new Error("Unexpected output shape from model: [".concat(e.shape,"]"));return Xo()==="webgpu"?[3,1]:(s=e.dataSync(),[3,3]);case 1:return[4,e.data()];case 2:s=c.sent(),c.label=3;case 3:for(e.dispose(),i=[],o=s.length/56,r=0;r<o;++r)for(i[r]={keypoints:[]},a=56*r+51,i[r].box={yMin:s[a],xMin:s[a+1],yMax:s[a+2],xMax:s[a+3],width:s[a+3]-s[a+1],height:s[a+2]-s[a]},l=56*r+55,i[r].score=s[l],i[r].keypoints=[],u=0;u<17;++u)i[r].keypoints[u]={y:s[56*r+3*u],x:s[56*r+3*u+1],score:s[56*r+3*u+2]};return[2,i]}})})},n.prototype.estimatePoses=function(t,e,s){return e===void 0&&(e=ud),Ot(this,void 0,void 0,function(){var i,o,r,a,l,u;return _t(this,function(c){switch(c.label){case 0:return e=function(h){return h==null?ud:Zt({},h)}(e),t==null?(this.reset(),[2,[]]):(s==null?xb(t)&&(s=1e6*t.currentTime):s*=1e3,i=pc(t),o=xi(i),r=Ye(i,0),t instanceof Ge||i.dispose(),a=[],this.multiPoseModel?[3,2]:[4,this.estimateSinglePose(r,o,s)]);case 1:return a=c.sent(),[3,4];case 2:return[4,this.estimateMultiplePoses(r,o,s)];case 3:a=c.sent(),c.label=4;case 4:for(l=0;l<a.length;++l)for(u=0;u<a[l].keypoints.length;++u)a[l].keypoints[u].name=Bn[u],a[l].keypoints[u].y*=o.height,a[l].keypoints[u].x*=o.width;return[2,a]}})})},n.prototype.estimateSinglePose=function(t,e,s){return Ot(this,void 0,void 0,function(){var i,o,r,a,l=this;return _t(this,function(u){switch(u.label){case 0:return this.cropRegion||(this.cropRegion=bl(this.cropRegion==null,e)),i=B(function(){var c=zs([[l.cropRegion.yMin,l.cropRegion.xMin,l.cropRegion.yMax,l.cropRegion.xMax]]),h=Le([1],"int32"),p=[l.modelInputResolution.height,l.modelInputResolution.width];return mt(Oe.cropAndResize(t,c,h,p,"bilinear",0),"int32")}),t.dispose(),[4,this.runSinglePersonPoseModel(i)];case 1:if(o=u.sent(),i.dispose(),o.score<this.minPoseScore)return this.reset(),[2,[]];for(r=0;r<o.keypoints.length;++r)o.keypoints[r].y=this.cropRegion.yMin+o.keypoints[r].y*this.cropRegion.height,o.keypoints[r].x=this.cropRegion.xMin+o.keypoints[r].x*this.cropRegion.width;return s!=null&&this.enableSmoothing&&(o.keypoints=this.keypointFilter.apply(o.keypoints,s,1)),a=xO(this.cropRegion,o.keypoints,this.keypointIndexByName,e),this.cropRegion=this.filterCropRegion(a),[2,[o]]}})})},n.prototype.estimateMultiplePoses=function(t,e,s){return Ot(this,void 0,void 0,function(){var i,o,r,a,l,u,c,h,p,f,m,g=this;return _t(this,function(b){switch(b.label){case 0:return e.width>e.height?(o=this.multiPoseMaxDimension,r=Math.round(this.multiPoseMaxDimension*e.height/e.width),i=Oe.resizeBilinear(t,[r,o]),l=o,u=32*Math.ceil(r/32),a=li(i,[[0,0],[0,u-r],[0,0],[0,0]])):(o=Math.round(this.multiPoseMaxDimension*e.width/e.height),r=this.multiPoseMaxDimension,i=Oe.resizeBilinear(t,[r,o]),l=32*Math.ceil(o/32),u=r,a=li(i,[[0,0],[0,0],[0,l-o],[0,0]])),i.dispose(),t.dispose(),c=mt(a,"int32"),a.dispose(),[4,this.runMultiPersonPoseModel(c)];case 1:for(h=b.sent(),c.dispose(),h=h.filter(function(v){return v.score>=g.minPoseScore}),f=0;f<h.length;++f)for(p=0;p<h[f].keypoints.length;++p)h[f].keypoints[p].y*=u/r,h[f].keypoints[p].x*=l/o;if(this.enableTracking&&(this.tracker.apply(h,s),this.enableSmoothing)){for(f=0;f<h.length;++f)this.keypointFilterMap.has(h[f].id)||this.keypointFilterMap.set(h[f].id,new yl(cd)),h[f].keypoints=this.keypointFilterMap.get(h[f].id).apply(h[f].keypoints,s,1);m=this.tracker.getTrackIDs(),this.keypointFilterMap.forEach(function(v,w){m.has(w)||g.keypointFilterMap.delete(w)})}return[2,h]}})})},n.prototype.filterCropRegion=function(t){if(t){var e=this.cropRegionFilterYMin.apply(t.yMin),s=this.cropRegionFilterXMin.apply(t.xMin),i=this.cropRegionFilterYMax.apply(t.yMax),o=this.cropRegionFilterXMax.apply(t.xMax);return{yMin:e,xMin:s,yMax:i,xMax:o,height:i-e,width:o-s}}return this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset(),null},n.prototype.dispose=function(){this.moveNetModel.dispose()},n.prototype.reset=function(){this.cropRegion=null,this.resetFilters()},n.prototype.resetFilters=function(){this.keypointFilter.reset(),this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset()},n}();function CO(n){return n===void 0&&(n=kb),Ot(this,void 0,void 0,function(){var t,e,s,i;return _t(this,function(o){switch(o.label){case 0:return t=wO(n),s=!0,t.modelUrl?(s=typeof t.modelUrl=="string"&&t.modelUrl.indexOf("https://tfhub.dev")>-1,[4,fi(t.modelUrl,{fromTFHub:s})]):[3,2];case 1:return e=o.sent(),[3,4];case 2:return i=void 0,t.modelType==="SinglePose.Lightning"?i="https://tfhub.dev/google/tfjs-model/movenet/singlepose/lightning/4":t.modelType==="SinglePose.Thunder"?i="https://tfhub.dev/google/tfjs-model/movenet/singlepose/thunder/4":t.modelType==="MultiPose.Lightning"&&(i="https://tfhub.dev/google/tfjs-model/movenet/multipose/lightning/1"),[4,fi(i,{fromTFHub:s})];case 3:e=o.sent(),o.label=4;case 4:return Xo()==="webgl"&&he().set("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",0),[2,new vO(e,t)]}})})}var pd={architecture:"MobileNetV1",outputStride:16,multiplier:.75,inputResolution:{height:257,width:257}},fd=["MobileNetV1","ResNet50"],md={MobileNetV1:[8,16],ResNet50:[16]},kO=[8,16,32],gd={MobileNetV1:[.5,.75,1],ResNet50:[1]},yd=[1,2,4],bd={maxPoses:1,flipHorizontal:!1},SO={maxPoses:5,flipHorizontal:!1,scoreThreshold:.5,nmsRadius:20},IO=[-123.15,-115.9,-103.06];function Xa(n){return Math.floor(n/2)}var NO=function(){function n(t,e){this.priorityQueue=new Array(t),this.numberOfElements=-1,this.getElementValue=e}return n.prototype.enqueue=function(t){this.priorityQueue[++this.numberOfElements]=t,this.swim(this.numberOfElements)},n.prototype.dequeue=function(){var t=this.priorityQueue[0];return this.exchange(0,this.numberOfElements--),this.sink(0),this.priorityQueue[this.numberOfElements+1]=null,t},n.prototype.empty=function(){return this.numberOfElements===-1},n.prototype.size=function(){return this.numberOfElements+1},n.prototype.all=function(){return this.priorityQueue.slice(0,this.numberOfElements+1)},n.prototype.max=function(){return this.priorityQueue[0]},n.prototype.swim=function(t){for(;t>0&&this.less(Xa(t),t);)this.exchange(t,Xa(t)),t=Xa(t)},n.prototype.sink=function(t){for(;2*t<=this.numberOfElements;){var e=2*t;if(e<this.numberOfElements&&this.less(e,e+1)&&e++,!this.less(t,e))break;this.exchange(t,e),t=e}},n.prototype.getValueAt=function(t){return this.getElementValue(this.priorityQueue[t])},n.prototype.less=function(t,e){return this.getValueAt(t)<this.getValueAt(e)},n.prototype.exchange=function(t,e){var s=this.priorityQueue[t];this.priorityQueue[t]=this.priorityQueue[e],this.priorityQueue[e]=s},n}();function $O(n,t,e,s,i,o){for(var r=o.shape,a=r[0],l=r[1],u=!0,c=Math.max(e-i,0),h=Math.min(e+i+1,a),p=c;p<h;++p){for(var f=Math.max(s-i,0),m=Math.min(s+i+1,l),g=f;g<m;++g)if(o.get(p,g,n)>t){u=!1;break}if(!u)break}return u}function DO(n){return Ot(this,void 0,void 0,function(){return _t(this,function(t){return[2,Promise.all(n.map(function(e){return e.buffer()}))]})})}function Sb(n,t,e,s){return{y:s.get(n,t,e),x:s.get(n,t,e+17)}}function Ib(n,t,e){var s=Sb(n.heatmapY,n.heatmapX,n.id,e),i=s.y,o=s.x;return{x:n.heatmapX*t+o,y:n.heatmapY*t+i}}function Nb(n,t,e,s){var i=e.x,o=e.y;return n.some(function(r){var a,l,u,c,h,p,f=r.keypoints;return a=o,l=i,u=f[s].y,c=f[s].x,(h=u-a)*h+(p=c-l)*p<=t})}var xd=Bn.reduce(function(n,t,e){return n[t]=e,n},{}),$b=[["nose","left_eye"],["left_eye","left_ear"],["nose","right_eye"],["right_eye","right_ear"],["nose","left_shoulder"],["left_shoulder","left_elbow"],["left_elbow","left_wrist"],["left_shoulder","left_hip"],["left_hip","left_knee"],["left_knee","left_ankle"],["nose","right_shoulder"],["right_shoulder","right_elbow"],["right_elbow","right_wrist"],["right_shoulder","right_hip"],["right_hip","right_knee"],["right_knee","right_ankle"]].map(function(n){var t=n[0],e=n[1];return[xd[t],xd[e]]}),qa=$b.map(function(n){return n[1]}),wd=$b.map(function(n){return n[0]});function vd(n,t,e){return n<t?t:n>e?e:n}function Ya(n,t,e,s){return{y:vd(Math.round(n.y/t),0,e-1),x:vd(Math.round(n.x/t),0,s-1)}}function Cd(n,t){return{x:n.x+t.x,y:n.y+t.y}}function kd(n,t,e,s,i,o,r,a){a===void 0&&(a=2);for(var l=s.shape,u=l[0],c=l[1],h={y:t.y,x:t.x},p=Cd(h,function(w,k,C){var I=C.shape[2]/2;return{y:C.get(k.y,k.x,w),x:C.get(k.y,k.x,I+w)}}(n,Ya(h,o,u,c),r)),f=0;f<a;f++){var m=Ya(p,o,u,c),g=Sb(m.y,m.x,e,i);p=Cd({x:m.x*o,y:m.y*o},{x:g.x,y:g.y})}var b=Ya(p,o,u,c),v=s.get(b.y,b.x,e);return{y:p.y,x:p.x,name:Bn[e],score:v}}function RO(n,t,e,s,i,o){var r=t.shape[2],a=qa.length,l=new Array(r),u=n.part,c=n.score,h=Ib(u,s,e);l[u.id]={score:c,name:Bn[u.id],y:h.y,x:h.x};for(var p=a-1;p>=0;--p){var f=qa[p],m=wd[p];l[f]&&!l[m]&&(l[m]=kd(p,l[f],m,t,e,s,o))}for(p=0;p<a;++p)f=wd[p],m=qa[p],l[f]&&!l[m]&&(l[m]=kd(p,l[f],m,t,e,s,i));return l}function AO(n,t,e){return e.reduce(function(s,i,o){var r=i.y,a=i.x,l=i.score;return Nb(n,t,{y:r,x:a},o)||(s+=l),s},0)/e.length}function TO(n,t,e,s,i,o,r,a){return r===void 0&&(r=.5),a===void 0&&(a=20),Ot(this,void 0,void 0,function(){var l,u,c,h,p,f,m,g,b,v,w,k;return _t(this,function(C){switch(C.label){case 0:return[4,DO([n,t,e,s])];case 1:for(l=C.sent(),u=l[0],c=l[1],h=l[2],p=l[3],f=[],m=function(I,N,$){for(var A=$.shape,z=A[0],F=A[1],E=A[2],U=new NO(z*F*E,function(X){return X.score}),L=0;L<z;++L)for(var W=0;W<F;++W)for(var _=0;_<E;++_){var V=$.get(L,W,_);V<I||$O(_,V,L,W,N,$)&&U.enqueue({score:V,part:{heatmapY:L,heatmapX:W,id:_}})}return U}(r,1,u),g=a*a;f.length<o&&!m.empty();)b=m.dequeue(),v=Ib(b.part,i,c),Nb(f,g,v,b.part.id)||(w=RO(b,u,c,i,h,p),k=AO(f,g,w),f.push({keypoints:w,score:k}));return[2,f]}})})}function Db(){for(var n,t=[],e=0;e<arguments.length;e++)t[e]=arguments[e];switch(t.length){case 0:n="fn main() ";break;case 1:n="fn main(".concat(t[0]," : i32)");break;default:throw Error("Unreachable")}return n}var zO=function(){function n(t){this.variableNames=["A","B"],this.size=!0,this.workgroupSize=[32,1,1],this.outputShape=[t[0],1],this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="getpointsConfidenceOp"}return n.prototype.getUserCode=function(){return`
        `.concat(Db("index"),` {
          if (index < uniforms.size) {
            let y = B[index * 2];
            let x = B[index * 2 + 1];
            let outIndex = y * uniforms.aShape.x * uniforms.aShape.z + x * uniforms.aShape.z + index;
            result[index] = A[outIndex];
          }
        }
        `)},n}();function FO(n,t){if(hi()instanceof Ai)return function(e,s){var i=hi(),o=new zO(s.shape),r=i.runWebGPUProgram(o,[e,s],"float32");return us().makeTensorFromTensorInfo(r)}(n,t);throw new Error("getPointsConfidenceWebGPU is not supported in this backend!")}var MO=function(){function n(t){if(this.variableNames=["A","B"],this.size=!0,this.supportedLastDimension=2,t.length!==2||t[1]!==this.supportedLastDimension)throw new Error("GetOffsetVectorsProgram only supports shape of [x, ".concat(this.supportedLastDimension,"], but current shape is ").concat(t));this.workgroupSize=[32,1,1],this.outputShape=t;var e=[t[0],1];this.dispatchLayout=ht(e),this.dispatch=rt(this.dispatchLayout,e,this.workgroupSize),this.shaderKey="GetOffsetVectors"}return n.prototype.getUserCode=function(){return`
    fn getOffsetPoint(y: i32, x: i32, index: i32) -> vec2<i32> {
      let outIndexY = y * uniforms.bShape.x * uniforms.bShape.y + x * uniforms.bShape.y + index;
      let outIndexX = outIndexY + uniforms.bShape.z;
      let outY = i32(B[outIndexY]);
      let outX = i32(B[outIndexX]);
      return vec2<i32>(outY, outX);
    }

    `.concat(Db("index"),` {
      if (index < uniforms.size) {
        let indexY = index * `).concat(this.supportedLastDimension,`;
        let indexX = indexY + 1;
        let heatmapY = A[indexY];
        let heatmapX = A[indexX];
        let out = getOffsetPoint(i32(heatmapY), i32(heatmapX), index);
        result[indexY] = f32(out[0]);
        result[indexX] = f32(out[1]);
      }
    }
    `)},n}();function PO(n,t){if(hi()instanceof Ai)return function(e,s){var i=hi(),o=new MO(e.shape),r=i.runWebGPUProgram(o,[e,s],"float32");return us().makeTensorFromTensorInfo(r)}(n,t);throw new Error("getOffsetVectorsGPU is not supported in this backend!")}function Rb(n){var t=n.shape,e=t[0],s=t[1],i=t[2];return B(function(){var o,r,a=Q(n,[e*s,i]),l=ui(a,0),u=Ye(Ct(l,se(s,"int32")),1),c=Ye((o=l,r=s,B(function(){var h=Ct(o,se(r,"int32"));return Lt(o,O(h,se(r,"int32")))})),1);return fs([u,c],1)})}function EO(n,t,e){return B(function(){var s=function(i,o){for(var r=[],a=0;a<Bn.length;a++){var l=i.get(a,0).valueOf(),u=i.get(a,1).valueOf(),c=LO(l,u,a,o),h=c.x,p=c.y;r.push(p),r.push(h)}return zs(r,[Bn.length,2])}(n,e);return ct(mt(O(n.toTensor(),se(t,"int32")),"float32"),s)})}function LO(n,t,e,s){return{y:s.get(n,t,e),x:s.get(n,t,e+Bn.length)}}function OO(n,t,e){return Ot(this,void 0,void 0,function(){var s,i,o,r,a,l,u,c,h,p;return _t(this,function(f){switch(f.label){case 0:return s=0,i=Rb(n),[4,Promise.all([n.buffer(),t.buffer(),i.buffer()])];case 1:return o=f.sent(),r=o[0],a=o[1],l=o[2],[4,(u=EO(l,e,a)).buffer()];case 2:return c=f.sent(),h=Array.from(function(m,g){for(var b=g.shape[0],v=new Float32Array(b),w=0;w<b;w++){var k=g.get(w,0),C=g.get(w,1);v[w]=m.get(k,C,w)}return v}(r,l)),p=h.map(function(m,g){return s+=m,{y:c.get(g,0),x:c.get(g,1),score:m,name:Bn[g]}}),i.dispose(),u.dispose(),[2,{keypoints:p,score:s/p.length}]}})})}function _O(n,t,e){return Ot(this,void 0,void 0,function(){var s,i,o;return _t(this,function(r){return s=Rb(n),i=function(a,l,u){return B(function(){var c=PO(a,u);return ct(mt(O(a,se(l,"int32")),"float32"),c)})}(s,e,t),o=FO(n,s),[2,[i,o]]})})}function Sd(n,t){return(n-1)%t==0}var Id="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/mobilenet/",Nd="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/resnet50/";function $d(n,t){return function(e,s){return(e-1)%s==0}(n,t)?n:Math.floor(n/t)*t+1}var Dd=function(){function n(t,e){this.posenetModel=t;var s=this.posenetModel.inputs[0].shape;tt(s[1]===-1&&s[2]===-1,function(){return"Input shape [".concat(s[1],", ").concat(s[2],"] ")+"must both be equal to or -1"});var i,o,r=(i=e.inputResolution,o=e.outputStride,{height:$d(i.height,o),width:$d(i.width,o)});(function(a){tt(kO.indexOf(a)>=0,function(){return"outputStride of ".concat(a," is invalid. ")+"It must be either 8 or 16."})})(e.outputStride),function(a,l){tt(Sd(a.height,l),function(){return"height of ".concat(a.height," is invalid for output stride ")+"".concat(l,".")}),tt(Sd(a.width,l),function(){return"width of ".concat(a.width," is invalid for output stride ")+"".concat(l,".")})}(r,e.outputStride),this.inputResolution=r,this.outputStride=e.outputStride,this.architecture=e.architecture}return n.prototype.estimatePoses=function(t,e){return e===void 0&&(e=bd),Ot(this,void 0,void 0,function(){return _t(this,function(s){return[2,this.estimatePosesGPU(t,e,!1)]})})},n.prototype.estimatePosesGPU=function(t,e,s){return e===void 0&&(e=bd),s===void 0&&(s=!1),Ot(this,void 0,void 0,function(){var i,o,r,a,l,u,c,h,p,f,m,g,b,v,w,k,C,I;return _t(this,function(N){switch(N.label){case 0:return i=function($){var A=$;if(A.maxPoses==null&&(A.maxPoses=1),A.maxPoses<=0)throw new Error("Invalid maxPoses ".concat(A.maxPoses,". Should be > 0."));if(A.maxPoses>1){if((A=Zt(Zt({},SO),A)).scoreThreshold<0||A.scoreThreshold>1)throw new Error("Invalid scoreThreshold ".concat(A.scoreThreshold,". ")+"Should be in range [0.0, 1.0]");if(A.nmsRadius<=0)throw new Error("Invalid nmsRadius ".concat(A.nmsRadius,"."))}return A}(e),t==null?[2,s?[[],[]]:[]]:(this.maxPoses=i.maxPoses,o=gl(t,{outputTensorSize:this.inputResolution,keepAspectRatio:!0,borderMode:"replicate"}),r=o.imageTensor,a=o.padding,l=this.architecture==="ResNet50"?ct(r,IO):bb(r,[-1,1]),u=this.posenetModel.predict(l),this.architecture==="ResNet50"?(c=Xt(u[2],[0]),h=Xt(u[3],[0]),p=Xt(u[0],[0]),f=Xt(u[1],[0])):(c=Xt(u[0],[0]),h=Xt(u[1],[0]),p=Xt(u[2],[0]),f=Xt(u[3],[0])),m=Ws(h),this.maxPoses!==1?[3,5]:s?[4,_O(m,c,this.outputStride)]:[3,2]);case 1:return b=N.sent(),w=b[0],v=b[1],g=[w,v],[3,4];case 2:return[4,OO(m,c,this.outputStride)];case 3:w=N.sent(),g=[w],N.label=4;case 4:return[3,7];case 5:if(s)throw new Error("GPU renderer only supports single pose!");return[4,TO(m,c,p,f,this.outputStride,this.maxPoses,i.scoreThreshold,i.nmsRadius)];case 6:g=N.sent(),N.label=7;case 7:if(s){if(i.flipHorizontal===!0)throw new Error("flipHorizontal is not supported!");k=this.getCanvasInfo(xi(t),this.inputResolution,a)}else I=xi(t),C=function($,A,z,F){var E=A.height,U=A.width,L=E/(z.height*(1-F.top-F.bottom)),W=U/(z.width*(1-F.left-F.right)),_=-F.top*z.height,V=-F.left*z.width;if(W===1&&L===1&&_===0&&V===0)return $;for(var X=0,j=$;X<j.length;X++)for(var K=0,Z=j[X].keypoints;K<Z.length;K++){var Y=Z[K];Y.x=(Y.x+V)*W,Y.y=(Y.y+_)*L}return $}(g,I,this.inputResolution,a),i.flipHorizontal&&(C=function($,A){for(var z=0,F=$;z<F.length;z++)for(var E=0,U=F[z].keypoints;E<U.length;E++){var L=U[E];L.x=A.width-1-L.x}return $}(C,I));return r.dispose(),l.dispose(),zt(u),c.dispose(),h.dispose(),p.dispose(),f.dispose(),m.dispose(),[2,s?[g,k]:C]}})})},n.prototype.getCanvasInfo=function(t,e,s){var i=t.height,o=t.width,r=i/(e.height*(1-s.top-s.bottom)),a=o/(e.width*(1-s.left-s.right)),l=-s.top*e.height;return[-s.left*e.width,l,a,r,t.width,t.height]},n.prototype.dispose=function(){this.posenetModel.dispose()},n.prototype.reset=function(){},n}();function BO(n){return n===void 0&&(n=pd),Ot(this,void 0,void 0,function(){var t,e,s,i,o;return _t(this,function(r){switch(r.label){case 0:return(t=function(c){var h=c||pd;if(h.architecture==null&&(h.architecture="MobileNetV1"),fd.indexOf(h.architecture)<0)throw new Error("Invalid architecture ".concat(h.architecture,". ")+"Should be one of ".concat(fd));if(h.inputResolution==null&&(h.inputResolution={height:257,width:257}),h.outputStride==null&&(h.outputStride=16),md[h.architecture].indexOf(h.outputStride)<0)throw new Error("Invalid outputStride ".concat(h.outputStride,". ")+"Should be one of ".concat(md[h.architecture]," ")+"for architecture ".concat(h.architecture,"."));if(h.multiplier==null&&(h.multiplier=1),gd[h.architecture].indexOf(h.multiplier)<0)throw new Error("Invalid multiplier ".concat(h.multiplier,". ")+"Should be one of ".concat(gd[h.architecture]," ")+"for architecture ".concat(h.architecture,"."));if(h.quantBytes==null&&(h.quantBytes=4),yd.indexOf(h.quantBytes)<0)throw new Error("Invalid quantBytes ".concat(h.quantBytes,". ")+"Should be one of ".concat(yd," ")+"for architecture ".concat(h.architecture,"."));if(h.architecture==="MobileNetV1"&&h.outputStride===32&&h.multiplier!==1)throw new Error("When using an output stride of 32, you must select 1 as the multiplier.");return h}(n)).architecture!=="ResNet50"?[3,2]:(a=t.outputStride,l=t.quantBytes,u="model-stride".concat(a,".json"),e=l===4?Nd+"float/"+u:Nd+"quant".concat(l,"/")+u,[4,fi(t.modelUrl||e)]);case 1:return s=r.sent(),[2,new Dd(s,t)];case 2:return i=function(c,h,p){var f={1:"100",.75:"075",.5:"050"},m="model-stride".concat(c,".json");return p===4?Id+"float/".concat(f[h],"/")+m:Id+"quant".concat(p,"/").concat(f[h],"/")+m}(t.outputStride,t.multiplier,t.quantBytes),[4,fi(t.modelUrl||i)];case 3:return o=r.sent(),[2,new Dd(o,t)]}var a,l,u})})}function WO(n,t){return Ot(this,void 0,void 0,function(){var e,s;return _t(this,function(i){switch(n){case Fe.PoseNet:return[2,BO(t)];case Fe.BlazePose:if(s=void 0,(e=t)!=null){if(e.runtime==="tfjs")return[2,gO(t)];if(e.runtime==="mediapipe")return[2,VL(t)];s=e.runtime}throw new Error("Expect modelConfig.runtime to be either 'tfjs' "+"or 'mediapipe', but got ".concat(s));case Fe.MoveNet:return[2,CO(t)];default:throw new Error("".concat(n," is not a supported model name."))}})})}const VO={className:"flex items-center justify-center w-full flex-grow"},UO={className:"ml-auto mr-auto relative w-[1280px] h-[720px]"},Rd=2,GO=4,Za=.5,JO=F1({__name:"PoseDetection",setup(n){const{resetLoading:t,loaded:e}=O1();t();const s=ih(null),i=ih(null),o=Fe.MoveNet;let r,a;const l=async()=>{r=await WO(o,{quantBytes:4,outputStride:16,multiplier:.75}),u()},u=async()=>{const f=s.value,m=i.value;if(typeof f<"u"&&f!==null&&f.video.readyState===4){const g=f.video,b=g.videoWidth,v=g.videoHeight;g.width=b,g.height=v,m.width=b,m.height=v;const w=await r.estimatePoses(g,{flipHorizontal:!1,maxPoses:1});e(),c(m.getContext("2d"),w[0].keypoints),p(m.getContext("2d"),w[0].keypoints,w.id),a=requestAnimationFrame(()=>u())}};function c(f,m){const g=ad.getKeypointIndexBySide(o);f.strokeStyle="White",f.lineWidth=Rd,f.fillStyle="Red";for(const b of g.middle)h(f,m[b]);f.fillStyle="Green";for(const b of g.left)h(f,m[b]);f.fillStyle="Orange";for(const b of g.right)h(f,m[b])}function h(f,m){if((m.score!=null?m.score:1)>=Za){const b=new Path2D;b.arc(m.x,m.y,GO,0,2*Math.PI),f.fill(b),f.stroke(b)}}function p(f,m,g){const b="White";f.fillStyle=b,f.strokeStyle=b,f.lineWidth=Rd,ad.getAdjacentPairs(o).forEach(([v,w])=>{const k=m[v],C=m[w],I=k.score!=null?k.score:1,N=C.score!=null?C.score:1;I>=Za&&N>=Za&&(f.beginPath(),f.moveTo(k.x,k.y),f.lineTo(C.x,C.y),f.stroke())})}return M1(async()=>{await T1("webgl"),l()}),P1(()=>{r==null||r.dispose(),r=null,cancelAnimationFrame(a)}),(f,m)=>(_1(),E1("div",VO,[oh("div",UO,[L1(z1,{ref_key:"webcamRef",ref:s,className:"w-full h-full absolute"},null,512),oh("canvas",{ref_key:"canvasRef",ref:i,className:"w-full h-full top-0 left-0 absolute z-10"},null,512)])]))}});export{JO as default};
