import{S as fx,M as mx,R as gx,C as yx,D as bx,E as xx,F as wx,G as Id,m as O,H as hr,c as mt,I as dr,J as Ie,K as ns,i as Lt,L as se,N as Fe,h as Ct,O as pr,P as Nd,Q as Ne,U as $e,V as Et,r as Q,W as bu,X as xu,Y as ce,Z as wu,$ as fr,a0 as mr,g as ct,a1 as gr,a2 as yr,a3 as br,a4 as wi,a5 as Mn,z as tt,a6 as xr,a7 as yn,a8 as vu,a9 as Cu,aa as ku,ab as Su,ac as Iu,ad as Dn,ae as Nu,af as $d,ag as vx,ah as Dd,ai as Rd,aj as wr,ak as Zn,al as vi,am as Ci,an as vr,ao as $u,ap as Du,aq as ee,ar as Kn,as as Ru,at as Au,au as Cx,av as Ad,aw as Tu,ax as Vo,ay as zu,az as Fu,aA as kx,aB as Cr,aC as Td,aD as kr,aE as zd,aF as Mu,aG as Me,aH as Fd,aI as Vt,aJ as Pu,aK as ki,aL as Sx,aM as Ix,aN as Eu,aO as Uo,aP as Go,aQ as Sr,aR as Lu,aS as Ir,A as Qn,aT as Md,aU as Ou,aV as Pd,aW as Ed,aX as Ld,aY as _u,aZ as Od,a_ as As,a$ as Bu,b0 as _d,b1 as _s,b2 as uo,b3 as Bd,b4 as Wd,b5 as Nr,b6 as $r,b7 as Dr,b8 as Wu,b9 as Wn,ba as Rr,bb as Vd,bc as Nx,bd as Vu,be as Uu,bf as Jn,bg as ts,bh as Gu,bi as Ud,bj as Gd,bk as Hu,bl as ju,bm as Ku,bn as Xu,bo as qu,bp as ln,bq as et,br as Bs,bs as Yu,bt as Hd,bu as Zu,s as le,bv as Ar,bw as Qu,bx as jd,by as Kd,bz as Ju,bA as Le,bB as tl,bC as el,bD as Zi,bE as nl,bF as Tr,bG as zr,bH as ps,bI as sl,bJ as Xd,bK as Za,bL as Fr,bM as Mr,bN as Pr,bO as Er,bP as il,bQ as ol,bR as rl,bS as al,bT as ul,bU as ll,bV as Qi,bW as Lr,bX as qd,bY as cl,bZ as Yd,b_ as Or,b$ as hl,c0 as dl,c1 as Zd,c2 as _r,c3 as Br,c4 as pl,c5 as Wr,c6 as Qd,c7 as Jd,c8 as tp,c9 as ui,ca as fl,cb as Vr,p as Ws,cc as ml,cd as ep,ce as gl,x as fs,cf as np,cg as yl,ch as sp,ci as Ur,cj as ip,ck as bl,cl as Gr,cm as Hr,cn as xl,co as op,cp as wl,cq as vl,cr as Vs,cs as Cl,e as Ye,ct as kl,cu as $x,cv as H,cw as Ls,cx as Dx,cy as Rx,cz as rp,cA as Qa,cB as li,cC as Ax,cD as Tx,cE as zx,cF as Fx,cG as Mx,cH as Px,cI as ap,cJ as Ex,cK as Lx,cL as Ox,y as Ue,T as Ge,cM as up,cN as lp,cO as _x,cP as cp,cQ as Bx,cR as Wx,cS as Vx,cT as Sl,cU as hp,cV as Ux,cW as Gx,cX as Hx,cY as jx,cZ as Kx,c_ as Xx,c$ as qx,d0 as Yx,d1 as Zx,d2 as dp,d3 as Qx,d4 as Jx,d5 as pp,d6 as fp,d7 as mp,d8 as tw,d9 as ew,da as gp,db as ci,dc as ve,dd as yp,de as jr,df as bp,dg as nw,dh as sw,di as Ho,dj as xp,dk as un,dl as iw,dm as wp,dn as ow,dp as rw,dq as Si,dr as aw,ds as uw,dt as lw,du as cw,dv as hw,dw as vp,dx as Cp,dy as dw,dz as Il,dA as Kr,dB as pw,o as Xt,dC as fw,dD as mw,dE as Xr,dF as gw,dG as yw,dH as jo,dI as hi,dJ as bw,t as B,dK as Ko,dL as Nl,dM as kp,dN as $l,dO as xw,dP as ww,j as vw,dQ as Cw,dR as qc,d as jn,dS as kw,dT as q,dU as qr,dV as Sp,dW as lo,dX as Sw,dY as Iw,dZ as co,d_ as Nw,d$ as ke,w as zt,n as he,e0 as Xn,e1 as $w,e2 as Yc,e3 as Dw,e4 as Rw,e5 as Aw,e6 as Tw,e7 as Zc,e8 as zw,e9 as Qc,ea as Fw,eb as Mw,q as Oe,ec as Pw,ed as Ew,ee as Dl,ef as Lw,eg as Ow,eh as _w,ei as Bw,ej as Ww,ek as Vw,el as Uw,em as Jc,en as Ip,eo as Np,ep as ls,eq as Gw,er as $p,es as Dp,et as di,eu as Bo,ev as ho,ew as ue,ex as yt,ey as Hw,ez as Rp,eA as Qt,eB as Ln,eC as Us,eD as Gs,eE as jw,eF as Ap,eG as Tt,eH as Tp,eI as Ji,eJ as zp,eK as Ze,eL as Ke,eM as Vn,eN as ss,eO as Fp,eP as Ii,eQ as Un,eR as xs,eS as Yr,eT as Zr,eU as Qr,eV as Mp,eW as Pp,eX as pi,eY as Ep,eZ as Lp,e_ as Op,e$ as _p,f0 as Bp,f1 as cs,f2 as to,f3 as Fn,f4 as Kw,f5 as ws,f6 as Xe,f7 as Ve,f8 as Wp,f9 as Ni,fa as Vp,fb as Up,fc as Gp,fd as es,fe as Xw,ff as Hp,fg as qw,fh as jp,fi as Kp,fj as Xp,fk as qp,fl as $i,fm as Jr,fn as Xi,fo as Rl,fp as oi,fq as Yp,fr as Zp,fs as Al,ft as Yw,fu as Qp,fv as Jp,fw as tf,fx as ef,fy as nf,fz as sf,fA as Tl,fB as of,fC as rf,fD as af,fE as uf,fF as lf,fG as cf,fH as hf,fI as df,fJ as Zw,fK as Qw,fL as Jw,fM as t0,fN as pf,fO as e0,fP as n0,fQ as ff,fR as mf,fS as gf,fT as yf,fU as bf,fV as xf,fW as wf,fX as vf,fY as s0,fZ as Cf,f_ as i0,f$ as kf,g0 as Sf,g1 as o0,g2 as zl,g3 as Fl,g4 as Ml,g5 as r0,g6 as a0,g7 as If,g8 as Nf,g9 as u0,ga as $f,gb as l0,gc as Df,gd as Rf,ge as c0,gf as h0,gg as Af,gh as Tf,gi as zf,gj as d0,gk as p0,gl as f0,gm as m0,gn as g0,go as y0,gp as Ff,gq as b0,gr as Mf,gs as Pf,gt as Ef,gu as Di,gv as ii,gw as Lf,gx as x0,gy as w0,gz as v0,gA as C0,gB as Of,gC as _f,gD as Bf,gE as Wf,gF as Vf,gG as Uf,gH as Gf,gI as Hf,gJ as k0,gK as jf,gL as S0,gM as I0,gN as N0,gO as $0,gP as D0,gQ as Kf,gR as R0,gS as Xf,gT as A0,gU as qf,gV as Pl,gW as T0,gX as z0,gY as F0,gZ as Yf,g_ as M0,g$ as P0,h0 as E0,h1 as L0,h2 as O0,h3 as _0,h4 as B0,h5 as W0,h6 as V0,h7 as U0,h8 as G0,h9 as H0,ha as j0,hb as K0,hc as X0,hd as q0,he as Y0,hf as Z0,hg as Q0,hh as J0,hi as t1,hj as e1,hk as n1,hl as s1,hm as i1,hn as o1,ho as r1,hp as a1,hq as u1,hr as l1,hs as c1,ht as h1,u as Ma,hu as Zf,hv as th,hw as d1,hx as eh,hy as p1,hz as nh,hA as f1,hB as m1,hC as g1,hD as y1,hE as b1,hF as x1,hG as w1,hH as v1,hI as C1,hJ as k1,hK as S1,hL as I1,l as fi,k as Xo,v as El,b as zs,a as Qf}from"./VueWebcam.vue_vue_type_script_setup_true_lang-DOhUs8EB.js";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class N1{static sgd(t){return new fx(t)}static momentum(t,e,s=!1){return new mx(t,e,s)}static rmsprop(t,e=.9,s=0,i=null,o=!1){return new gx(t,e,s,i,o)}static adam(t=.001,e=.9,s=.999,i=null){return new yx(t,e,s,i)}static adadelta(t=.001,e=.95,s=null){return new bx(t,e,s)}static adamax(t=.002,e=.9,s=.999,i=null,o=0){return new xx(t,e,s,i,o)}static adagrad(t,e=.1){return new wx(t,e)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Js=N1;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jf={kernelName:Id,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>O(n,hr(mt(e,"float32"),-1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $1={kernelName:dr,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const s=Ie(mt(e,"float32")),i=ns(Lt(se(1),s));return Fe(Ct(n,i))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const D1={kernelName:pr,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const s=ns(Lt(Ie(mt(e,"float32")),1));return Ct(n,s)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const R1={kernelName:Nd,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,i=Ne(e.shape,s.shape);return{a:()=>{let a=n;const u=$e(e.shape,i);return u.length>0&&(a=Et(a,u)),Q(a,e.shape)},b:()=>{let a=n;const u=$e(s.shape,i);return u.length>0&&(a=Et(a,u)),Q(a,s.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const A1={kernelName:bu,saveAllInputs:!0,gradFunc:(n,t)=>{const e={};return t.forEach((s,i)=>{e[i]=()=>n.clone()}),e}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const T1={kernelName:xu,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>ce(e)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const z1={kernelName:wu,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>ce(e)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const F1={kernelName:fr,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Ct(n,ns(Lt(se(1),Ie(mt(e,"float32")))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const M1={kernelName:mr,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const s=ns(ct(se(1),Ie(mt(e,"float32"))));return Ct(n,s)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const P1={kernelName:gr,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,i=Ne(e.shape,s.shape);return{a:()=>{const a=ct(Ie(e),Ie(s));let u=O(n,Ct(s,a));const l=$e(e.shape,i);return l.length>0&&(u=Et(u,l)),Q(u,e.shape)},b:()=>{const a=ct(Ie(e),Ie(s));let u=Fe(O(n,Ct(e,a)));const l=$e(s.shape,i);return l.length>0&&(u=Et(u,l)),Q(u,s.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const E1={kernelName:yr,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Ct(n,ct(Ie(mt(e,"float32")),1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const L1={kernelName:br,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Ct(n,Lt(se(1),Ie(mt(e,"float32"))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O1(n,t,e,s,i,o){const r=Mn(n,"dy","avgPool3dGrad"),a=Mn(t,"input","avgPool3dGrad");let u=r,l=a,c=!1;a.rank===4&&(c=!0,u=Q(r,[1,r.shape[0],r.shape[1],r.shape[2],r.shape[3]]),l=Q(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),tt(u.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`),tt(l.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${l.rank}.`),xr("avgPool3dGrad",i,o);const h={dy:u,input:l},p={filterSize:e,strides:s,pad:i,dimRoundingMode:o},f=yn.runKernel(vu,h,p);return c?Q(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const _1=wi({avgPool3dGrad_:O1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const B1={kernelName:Cu,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{filterSize:i,strides:o,pad:r,dimRoundingMode:a}=e;return{x:()=>_1(n,s,i,o,r,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W1(n,t,e,s,i){const o=Mn(n,"dy","avgPoolGrad"),r=Mn(t,"input","avgPoolGrad");tt(r.rank===o.rank,()=>`Rank of input (${r.rank}) does not match rank of dy (${o.rank})`);let a=r,u=o,l=!1;r.rank===3&&(l=!0,a=Q(r,[1,r.shape[0],r.shape[1],r.shape[2]]),u=Q(o,[1,o.shape[0],o.shape[1],o.shape[2]])),tt(u.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${u.rank}.`),tt(a.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`);const c={dy:u,input:a},h={filterSize:e,strides:s,pad:i},p=yn.runKernel(ku,c,h);return l?Q(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const V1=wi({avgPoolGrad_:W1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const U1={kernelName:Su,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{filterSize:i,strides:o,pad:r}=e;return{x:()=>V1(n,s,i,o,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const G1={kernelName:Iu,inputsToSave:["a","b"],gradFunc:(n,t,e)=>{const[s,i]=t,{transposeA:o,transposeB:r}=e;return!o&&!r?{a:()=>Dn(n,i,!1,!0),b:()=>Dn(s,n,!0,!1)}:!o&&r?{a:()=>Dn(n,i,!1,!1),b:()=>Dn(n,s,!0,!1)}:o&&!r?{a:()=>Dn(i,n,!1,!0),b:()=>Dn(s,n,!1,!1)}:{a:()=>Dn(i,n,!0,!0),b:()=>Dn(n,s,!0,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H1={kernelName:Nu,gradFunc:(n,t,e)=>{const{blockShape:s,crops:i}=e;return{x:()=>$d(n,s,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const j1={kernelName:vx,gradFunc:(n,t,e)=>{const s=e,i=s.inputShape,o=s.shape,r=Array.from(o);for(let u=i.length-1;u>=0;u--)if(i[u]===o[u])r[u]=1;else if(i[u]!==1)throw new Error(`broadcastTo(): [${i}] cannot be broadcast to [${o}].`);const a=[];for(let u=0;u<r.length;u++)r[u]>1&&a.push(u);return{x:()=>Et(n,a,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const K1={kernelName:Dd,gradFunc:n=>({x:()=>n.clone()})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const X1={kernelName:Rd,gradFunc:n=>({x:()=>ce(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const q1={kernelName:wr,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{clipValueMin:i,clipValueMax:o}=e;return{x:()=>Zn(vi(Ci(s,i),vr(s,o)),n,ce(n))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Y1={kernelName:$u,inputsToSave:["x"],gradFunc:Jf.gradFunc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Z1={kernelName:Du,saveAllInputs:!0,gradFunc:(n,t,e)=>{const s=t.map(u=>u.shape),{axis:i}=e,o=ee(i,t[0].shape)[0],r=s.map(u=>u[o]);return Kn(n,r,o).map(u=>()=>u)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Q1={kernelName:Ru,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const[s,i]=t,{dilations:o,strides:r,pad:a,dataFormat:u}=e;return tt(Au(o),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`),{x:()=>Cx(s.shape,n,i,r,a,u),filter:()=>Ad(s,n,i.shape,r,a,u)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const J1={kernelName:Tu,inputsToSave:["dy","filter"],gradFunc:(n,t,e)=>{const[s,i]=t,{strides:o,pad:r,dataFormat:a,dimRoundingMode:u}=e;return{dy:()=>Vo(n,i,o,r,a,1,u),filter:()=>Ad(n,s,i.shape,o,r,a,u)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t2(n,t,e,s,i){let o=n;n.rank===4&&(o=Q(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));let r=t;r.rank===4&&(r=Q(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),tt(o.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${o.shape}.`),tt(r.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${r.shape}.`),tt(e.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${e}.`),tt(o.shape[4]===e[3],()=>`Error in conv3dDerFilter: depth of input ${o.shape[4]}) must match input depth in filter (${e[3]}.`),tt(r.shape[4]===e[4],()=>`Error in conv3dDerFilter: depth of dy (${r.shape[4]}) must match output depth for filter (${e[4]}).`);const a={x:o,dy:r},u={strides:s,pad:i,filterShape:e};return yn.runKernel(zu,a,u)}const e2=wi({conv3DBackpropFilter_:t2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const n2={kernelName:Fu,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const{dilations:s,strides:i,pad:o}=e;tt(Au(s),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);const[r,a]=t;return{x:()=>kx(r.shape,n,a,i,o),filter:()=>e2(r,n,a.shape,i,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const s2={kernelName:Cr,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>O(Fe(Td(mt(e,"float32"))),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i2={kernelName:kr,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>O(zd(mt(e,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o2={kernelName:Mu,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{axis:i,exclusive:o,reverse:r}=e;return{x:()=>{const a=Me([i],s.rank);let u=Fd(n,i,o,!r);return a!=null&&(u=Vt(u,a)),u}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r2={kernelName:Pu,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const{dilations:s,strides:i,pad:o,dimRoundingMode:r}=e,a=s??[1,1];tt(Au(a),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[u,l]=t;return tt(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${u.rank}.`),tt(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${l.rank}.`),tt(u.shape[3]===l.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${l.shape[2]}.`),tt(ki(i,a),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${i} and dilations '${a}'.`),xr("depthwiseConv2d",o,r),{x:()=>Sx(u.shape,n,l,i,o,a,r),filter:()=>Ix(u,n,l.shape,i,o,a,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a2={kernelName:Eu,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const[s,i]=t,o={x:s,filter:i,dy:n},r={x:s,filter:i,dy:n};return{x:()=>yn.runKernel(Uo,o,e),filter:()=>yn.runKernel(Go,r,e)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const u2={kernelName:Sr,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t,s={dy:n,y:e};return{x:()=>yn.runKernel(Lu,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const l2={kernelName:Ir,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t,s=O(Qn(Fe(Ie(e))),2/Math.sqrt(Math.PI));return{x:()=>O(n,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c2={kernelName:Md,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>O(n,e)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h2={kernelName:Ou,inputsToSave:["input"],gradFunc:(n,t)=>{const[e]=t;return{input:()=>Q(n,e.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const d2={kernelName:Pd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>O(n,Qn(e))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const p2={kernelName:Ed,gradFunc:n=>({x:()=>ce(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const f2={kernelName:Ld,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,i=Ne(e.shape,s.shape);return{a:()=>{const a=Ct(n,mt(s,"float32")),u=$e(e.shape,i);return u.length>0?Q(Et(a,u),e.shape):a},b:()=>{let a=O(n,mt(e,"float32"));const u=$e(s.shape,i);u.length>0&&(a=Q(Et(a,u),s.shape));const l=Ie(s);return Fe(Ct(a,mt(l,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m2={kernelName:_u,inputsToSave:["x","mean","variance","scale"],gradFunc:(n,t,e)=>{const{varianceEpsilon:s}=e,[i,o,r,a]=t,u=a??se(1),l=$e(o.shape,i.shape),c=[];if(o.rank===1){for(let C=0;C<i.shape.length-1;++C)c.push(i.shape[C]);c.push(1)}const h=Lt(i,o),p=O(n,u),f=Od(ct(r,se(s))),m=O(O(O(f,f),f),se(-.5));return{x:()=>o.rank===1?Q(O(O(n,As(Q(f,[1,1,1,o.shape[0]]),c)),u),i.shape):Q(O(O(n,f),u),i.shape),mean:()=>{let C=O(O(f,se(-1)),p);return o.rank===1&&(C=Et(C,l)),Q(C,o.shape)},variance:()=>{let C=O(O(m,h),p);return o.rank===1&&(C=Et(C,l)),Q(C,o.shape)},scale:()=>{const C=O(h,f);let I=O(n,C);return o.rank===1&&(I=Et(I,l)),Q(I,o.shape)},offset:()=>{let C=n;return o.rank===1&&(C=Et(C,l)),Q(C,o.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const g2={kernelName:Bu,inputsToSave:["x","indices"],gradFunc:(n,t,e)=>{const[s,i]=t,{axis:o,batchDims:r}=e,a=ee(o,s.shape)[0],u=(l,c,h)=>()=>{const p=l.shape,f=c.size,m=p.slice(0,a),g=m.length,b=p.slice(o,p.length).slice(1),v=b.length,w=sh(0,g),k=sh(g+1,g+1+v),C=ih([m,[f],b]),I=Q(h,C),N=Q(c,[f]),$=ih([[g],w,k]),A=Vt(I,$);let z=_d(A,N,l.shape[a]);const F=_s($);return z=Vt(z,F),z};if(r===1){const l=s.shape[0],c=s.split(l,0);return{x:()=>uo(c.map((f,m)=>u(f,i.slice(m,1),n.slice(m,1))())).reshape(s.shape),indices:()=>i}}else return{x:u(s,i,n),indices:()=>i}}};function sh(n,t){const e=[];for(let s=n;s<t;++s)e.push(s);return e}function ih(n){const t=[];for(let e=0;e<n.length;++e)for(let s=0;s<n[e].length;++s)t.push(n[e][s]);return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const y2={kernelName:Bd,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t;return{a:()=>ce(e),b:()=>ce(s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b2={kernelName:Wd,gradFunc:n=>({x:()=>mt(n,"float32")})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const x2={kernelName:Nr,gradFunc:n=>({x:()=>ce(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const w2={kernelName:$r,gradFunc:n=>({x:()=>ce(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v2={kernelName:Dr,gradFunc:n=>({x:()=>ce(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const C2={kernelName:Wu,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{alpha:i}=e,o=Wn(s,0);return{x:()=>Zn(o,n,O(n,i))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const k2={kernelName:Rr,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Ct(n,ct(e,1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const S2={kernelName:Vd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Ct(n,mt(e,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const I2={kernelName:Nx,inputsToSave:[],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s]=t,{axis:i}=e;return{logits:()=>{const r=Qn(s);return Lt(n,O(Et(n,i,!0),r))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N2(n,t,e,s=5,i=1,o=1,r=.5){const a={x:n,y:t,dy:e},u={depthRadius:s,bias:i,alpha:o,beta:r};return yn.runKernel(Vu,a,u)}const $2=wi({localResponseNormalizationBackprop_:N2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const D2={kernelName:Uu,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s,i]=t,{depthRadius:o,bias:r,alpha:a,beta:u}=e;return{x:()=>$2(s,i,n,o,r,a,u)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tm(n,t,e,s){return t.rank<e.rank&&(t=Q(t,Jn(t.shape,s))),n.rank<e.rank&&(n=Q(n,Jn(n.shape,s))),{x:()=>O(n,mt(ts(e,t),n.dtype))}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oh={kernelName:Gu,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const s=e,{reductionIndices:i}=s,o=t[0],r=t[1],a=ee(i,o.shape),u=tm(n,r,o,a);return{x:()=>u.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const R2={kernelName:Ud,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t;return{a:()=>O(n,mt(Ci(e,s),"float32")),b:()=>O(n,mt(Gd(e,s),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A2(n,t,e,s,i,o,r){const a=Mn(n,"dy","maxPool3dGrad"),u=Mn(t,"input","maxPool3dGrad"),l=Mn(e,"output","maxPool3dGrad");let c=a,h=u,p=l,f=!1;u.rank===4&&(f=!0,c=Q(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),h=Q(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]]),p=Q(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]])),tt(c.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),tt(h.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${h.rank}.`),tt(p.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${p.rank}.`),xr("maxPool3dGrad",o,r);const m={dy:c,input:h,output:p},g={filterSize:s,strides:i,pad:o,dimRoundingMode:r},b=yn.runKernel(Hu,m,g);return f?Q(b,[b.shape[1],b.shape[2],b.shape[3],b.shape[4]]):b}const T2=wi({maxPool3dGrad_:A2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const z2={kernelName:ju,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s,i]=t,{filterSize:o,strides:r,pad:a,dimRoundingMode:u}=e;return{x:()=>T2(n,s,i,o,r,a,u)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F2(n,t,e,s,i,o,r){const a=Mn(n,"dy","maxPoolGrad"),u=Mn(t,"input","maxPoolGrad"),l=Mn(e,"output","maxPoolGrad");tt(u.rank===a.rank,()=>`Rank of input (${u.rank}) does not match rank of dy (${a.rank})`),tt(a.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`),tt(u.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${u.rank}.`),xr("maxPoolGrad",o,r);const c={dy:a,input:u,output:l},h={filterSize:s,strides:i,pad:o,dimRoundingMode:r};return yn.runKernel(Ku,c,h)}const M2=wi({maxPoolGrad_:F2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const P2={kernelName:Xu,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s,i]=t,{filterSize:o,strides:r,pad:a}=e;return{x:()=>M2(n,s,i,o,r,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const E2={kernelName:qu,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{axis:i}=e,o=ee(i,s.shape),a=ln(s.shape,o)[1],u=et(a);return{x:()=>{const c=s.shape.slice();o.forEach(f=>{c[f]=1});const h=Q(n,c);return Ct(O(h,Bs(s.shape,"float32")),u)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const L2={kernelName:Yu,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const s=e,{axis:i}=s,[o,r]=t,a=ee(i,o.shape),u=tm(n,r,o,a);return{x:()=>u.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const O2={kernelName:Hd,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t;return{a:()=>O(n,mt(vr(e,s),"float32")),b:()=>O(n,mt(Wn(e,s),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _2={kernelName:Zu,inputsToSave:["x"],gradFunc:(n,t,e)=>{const s=t[0],{paddings:i}=e,o=i.map(r=>r[0]);return{x:()=>le(n,o,s.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const B2={kernelName:Ar,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,i=Ne(e.shape,s.shape);return{a:()=>{const a=$e(e.shape,i);return a.length>0?Q(Et(n,a),e.shape):n},b:()=>{const a=O(n,Fe(Qu(Ct(e,s)))),u=$e(s.shape,i);return u.length>0?Q(Et(a,u),s.shape):a}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const W2={kernelName:jd,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,i=Ne(e.shape,s.shape);return{a:()=>{const a=O(n,mt(s,"float32")),u=$e(e.shape,i);return u.length>0?Q(Et(a,u),e.shape):a},b:()=>{const a=O(n,mt(e,"float32")),u=$e(s.shape,i);return u.length>0?Q(Et(a,u),s.shape):a}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const V2={kernelName:Kd,gradFunc:n=>({x:()=>Fe(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const U2={kernelName:Ju,inputsToSave:["indices"],gradFunc:(n,t)=>{const e=t[0];return{indices:()=>Le(e.shape,"float32")}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const G2={kernelName:tl,gradFunc:n=>({x:()=>ce(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H2={kernelName:el,saveAllInputs:!0,gradFunc:(n,t,e)=>{const{axis:s}=e;return Zi(n,s).map(o=>()=>o)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rh={kernelName:nl,inputsToSave:["x"],gradFunc:(n,t,e)=>{const s=t[0],{paddings:i}=e,o=i.map(r=>r[0]);return{x:()=>le(n,o,s.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const j2={kernelName:Tr,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(n,t)=>{const[e,s,i]=t,o=e,r=s,a=Ne(o.shape,r.shape);return{a:()=>{const c=mt(r,"float32");let h=O(n,O(c,zr(o,Lt(c,se(1)))));const p=$e(o.shape,a);return p.length>0&&(h=Et(h,p)),Q(h,o.shape)},b:()=>{const c=Wn(o,0),h=Zn(c,ps(o),ce(o));let p=O(n,O(i,h));const f=$e(r.shape,a);return f.length>0&&(p=Et(p,f)),Q(p,r.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const K2={kernelName:sl,inputsToSave:["x","alpha"],gradFunc:(n,t)=>{const[e,s]=t,i=Wn(e,0);return{x:()=>Zn(i,n,O(n,s)),alpha:()=>{let o=Zn(i,ce(n),O(n,e));const r=$e(s.shape,n.shape);return r.length>0&&(o=Et(o,r)),Q(o,s.shape)}}}};/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X2(n,t,e){const s=n.shape.slice();s[e]=1;const i=Q(t,s),o=Za(n,e,!0,!1),r=Za(n,e,!0,!0),a=O(o,r);return O(i,a)}function q2(n,t,e){const s=n.shape.length,i=s-e.length,o=Me(e,s);let r=n;o!=null&&(r=Vt(n,o));const a=r.shape.slice(),l=a.splice(s-e.length,e.length).reduce((p,f)=>p*f,1);a.push(l);const c=r.reshape(a);let h=X2(c,t,i);if(h=h.reshape(r.shape),o!=null){const p=_s(o);h=Vt(h,p)}return h}const Y2={kernelName:Xd,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{axis:i}=e;let o=[];return i==null?o=s.shape.map((r,a)=>a):typeof i=="number"?o=[i]:o=i,{x:()=>q2(s,n,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Z2={kernelName:Fr,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,i=Ne(e.shape,s.shape);return{a:()=>{const a=Ct(n,mt(s,"float32")),u=$e(e.shape,i);return u.length>0?Q(Et(a,u),e.shape):a},b:()=>{let a=O(n,mt(e,"float32"));const u=$e(s.shape,i);u.length>0&&(a=Q(Et(a,u),s.shape));const l=Ie(s);return Fe(Ct(a,mt(l,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Q2={kernelName:Mr,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Ct(n,Fe(Ie(e)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const J2={kernelName:Pr,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t,s=O(vr(e,6),hr(e));return{x:()=>O(n,mt(s,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tv={kernelName:Er,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>O(n,mt(hr(e),"float32"))}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ev={kernelName:il,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Q(n,e.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nv={kernelName:ol,inputsToSave:["images"],gradFunc:(n,t,e)=>{const[s]=t,i={dy:n,images:s};return{images:()=>yn.runKernel(rl,i,e)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sv={kernelName:al,inputsToSave:["images"],gradFunc:(n,t,e)=>{const[s]=t,i={dy:n,images:s};return{images:()=>yn.runKernel(ul,i,e)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iv={kernelName:ll,gradFunc:(n,t,e)=>{const{dims:s}=e,i=ee(s,n.shape);return{x:()=>Qi(n,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ov={kernelName:Lr,gradFunc:n=>({x:()=>ce(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rv={kernelName:qd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Fe(Ct(n,O(zr(e,1.5),2)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const av={kernelName:cl,inputsToSave:["condition"],gradFunc:(n,t)=>{const[e]=t;return{condition:()=>mt(ce(e),"float32"),t:()=>O(n,mt(e,n.dtype)),e:()=>O(n,mt(Yd(e),n.dtype))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uv={kernelName:Or,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const s=Wn(e,se(0)),i=se(hl),o=se(dl),r=O(n,o),a=O(O(n,i),Qn(mt(e,"float32")));return Zn(s,r,a)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lv={kernelName:Zd,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>O(n,O(e,Lt(se(1),e)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cv={kernelName:_r,gradFunc:n=>({x:()=>ce(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hv={kernelName:Br,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>O(pl(mt(e,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dv={kernelName:Wr,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>O(Qd(mt(e,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pv={kernelName:Jd,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{begin:i,size:o}=e,r=s.shape,[a,u]=tp(s,i,o),l=[];for(let c=0;c<n.rank;c++)l.push([a[c],r[c]-a[c]-u[c]]);return{x:()=>ui(n,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fv={kernelName:fl,outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s]=t,{dim:i}=e,o=!0,r=O(n,s);return{logits:()=>Lt(r,O(Et(r,[i],o),s))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mv={kernelName:Vr,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>O(n,Ws(e))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ah={kernelName:ml,gradFunc:(n,t,e)=>{const{blockShape:s,paddings:i}=e;return{x:()=>ep(n,s,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uh={kernelName:gl,gradFunc:(n,t,e)=>{const{axis:s}=e;return{x:()=>fs(n,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gv={kernelName:np,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Ct(n,O(ns(mt(e,"float32")),2))}}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yv={kernelName:yl,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>O(n,O(mt(e,"float32"),2))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bv={kernelName:sp,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,i=se(2);return{a:()=>O(n,O(i,Lt(e,s))),b:()=>O(n,O(i,Lt(s,e)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xv={kernelName:Ur,gradFunc:n=>({x:()=>ce(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wv={kernelName:ip,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,i=Ne(e.shape,s.shape);return{a:()=>{let a=n;const u=$e(e.shape,i);return u.length>0&&(a=Et(a,u)),Q(a,e.shape)},b:()=>{let a=n;const u=$e(s.shape,i);return u.length>0&&(a=Et(a,u)),Q(Fe(a),s.shape)}}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vv={kernelName:bl,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,i=s.shape.slice(),{axis:o}=e;ee(o,s.shape).forEach(l=>{i[l]=1});const a=Q(n,i),u=O(a,Bs(s.shape,"float32"));return{x:()=>u}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cv={kernelName:Gr,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Ct(n,Ie(pl(e)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kv={kernelName:Hr,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>O(Lt(se(1),Ie(e)),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sv={kernelName:xl,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{reps:i}=e;return{x:()=>{let r=ce(s);if(s.rank===1)for(let a=0;a<i[0];++a)r=ct(r,le(n,[a*s.shape[0]],[s.shape[0]]));else if(s.rank===2)for(let a=0;a<i[0];++a)for(let u=0;u<i[1];++u)r=ct(r,le(n,[a*s.shape[0],u*s.shape[1]],[s.shape[0],s.shape[1]]));else if(s.rank===3)for(let a=0;a<i[0];++a)for(let u=0;u<i[1];++u)for(let l=0;l<i[2];++l)r=ct(r,le(n,[a*s.shape[0],u*s.shape[1],l*s.shape[2]],[s.shape[0],s.shape[1],s.shape[2]]));else if(s.rank===4)for(let a=0;a<i[0];++a)for(let u=0;u<i[1];++u)for(let l=0;l<i[2];++l)for(let c=0;c<i[3];++c)r=ct(r,le(n,[a*s.shape[0],u*s.shape[1],l*s.shape[2],c*s.shape[3]],[s.shape[0],s.shape[1],s.shape[2],s.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${s.rank} tensors yet.`);return r}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Iv={kernelName:op,gradFunc:(n,t,e)=>{const s=e,{perm:i}=s,o=_s(i);return{x:()=>Vt(n,o)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nv={kernelName:wl,gradFunc:(n,t,e)=>{const s=e,{axis:i}=s;return{value:()=>uo(n,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $v={kernelName:vl,inputsToSave:["segmentIds"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Dv(n,e)}}};function Dv(n,t){const e=Vs(t,ce(t)),s=Cl(n,e);let i=Ci(t,se(0,"int32"));const o=s.rank-i.rank;for(let a=0;a<o;++a)i=Ye(i,a+1);i=vi(i,Bs(s.shape,"bool"));const r=ce(s);return Zn(i,s,r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rv={kernelName:kl,gradFunc:n=>({x:()=>ce(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Av=[Jf,$1,D1,R1,A1,T1,z1,F1,M1,P1,E1,L1,B1,U1,G1,H1,j1,K1,X1,q1,Y1,Z1,J1,Q1,n2,s2,i2,o2,r2,a2,Z2,u2,l2,c2,h2,d2,f2,p2,m2,g2,y2,b2,x2,w2,v2,C2,k2,S2,I2,D2,oh,oh,R2,z2,P2,E2,L2,O2,_2,B2,W2,V2,U2,G2,H2,rh,rh,j2,K2,Y2,Q2,J2,tv,ev,nv,sv,iv,ov,rv,av,uv,lv,cv,hv,dv,pv,fv,mv,ah,ah,uh,uh,gv,bv,yv,xv,wv,vv,Cv,kv,Sv,Iv,Nv,$v,Rv];for(const n of Av)$x(n);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.abs=function(){return this.throwIfDisposed(),Ls(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.acos=function(){return this.throwIfDisposed(),Dx(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.acosh=function(){return this.throwIfDisposed(),Rx(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.add=function(n){return this.throwIfDisposed(),ct(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.all=function(n,t){return this.throwIfDisposed(),rp(this,n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.any=function(n,t){return this.throwIfDisposed(),Qa(this,n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.argMax=function(n){return this.throwIfDisposed(),li(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.argMin=function(n){return this.throwIfDisposed(),Ax(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.asScalar=function(){return this.throwIfDisposed(),tt(this.size===1,()=>"The array must have only 1 element."),Q(this,[])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.asType=function(n){return this.throwIfDisposed(),mt(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.as1D=function(){return this.throwIfDisposed(),Q(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.as2D=function(n,t){return this.throwIfDisposed(),Q(this,[n,t])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.as3D=function(n,t,e){return this.throwIfDisposed(),Q(this,[n,t,e])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.as4D=function(n,t,e,s){return this.throwIfDisposed(),Q(this,[n,t,e,s])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.as5D=function(n,t,e,s,i){return this.throwIfDisposed(),Q(this,[n,t,e,s,i])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.asin=function(){return this.throwIfDisposed(),Tx(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.asinh=function(){return this.throwIfDisposed(),zx(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.atan=function(){return this.throwIfDisposed(),Fx(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.atan2=function(n){return this.throwIfDisposed(),Mx(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.atanh=function(){return this.throwIfDisposed(),Px(this)};H().prototype.avgPool=function(n,t,e,s){return this.throwIfDisposed(),ap(this,n,t,e,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.batchToSpaceND=function(n,t){return this.throwIfDisposed(),ep(this,n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.batchNorm=function(n,t,e,s,i){return this.throwIfDisposed(),Ex(this,n,t,e,s,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.broadcastTo=function(n){return this.throwIfDisposed(),Lx(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.cast=function(n){return this.throwIfDisposed(),mt(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.ceil=function(){return this.throwIfDisposed(),Ox(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.clipByValue=function(n,t){return this.throwIfDisposed(),Ue(this,n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.concat=function(n,t){return this.throwIfDisposed(),n instanceof Ge&&(n=[n]),fs([this,...n],t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.conv1d=function(n,t,e,s,i,o){return this.throwIfDisposed(),up(this,n,t,e,s,i,o)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.conv2dTranspose=function(n,t,e,s,i){return this.throwIfDisposed(),lp(this,n,t,e,s,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.conv2d=function(n,t,e,s,i,o){return this.throwIfDisposed(),Vo(this,n,t,e,s,i,o)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.cos=function(){return this.throwIfDisposed(),pl(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.cosh=function(){return this.throwIfDisposed(),Qd(this)};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.cumprod=function(n,t,e){return this.throwIfDisposed(),Za(this,n,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.cumsum=function(n,t,e){return this.throwIfDisposed(),Fd(this,n,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.depthToSpace=function(n,t){return this.throwIfDisposed(),_x(this,n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.depthwiseConv2d=function(n,t,e,s,i,o){return this.throwIfDisposed(),cp(this,n,t,e,s,i,o)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.dilation2d=function(n,t,e,s,i){return this.throwIfDisposed(),Bx(this,n,t,e,s,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.divNoNan=function(n){return this.throwIfDisposed(),Wx(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.div=function(n){return this.throwIfDisposed(),Ct(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.dot=function(n){return this.throwIfDisposed(),Vx(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.elu=function(){return this.throwIfDisposed(),Sl(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.equal=function(n){return this.throwIfDisposed(),ts(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.erf=function(){return this.throwIfDisposed(),hp(this)};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.euclideanNorm=function(n,t){return this.throwIfDisposed(),Ux(this,n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.exp=function(){return this.throwIfDisposed(),Qn(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.expandDims=function(n){return this.throwIfDisposed(),Ye(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.expm1=function(){return this.throwIfDisposed(),Gx(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.fft=function(){return this.throwIfDisposed(),Hx(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.flatten=function(){return this.throwIfDisposed(),Q(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.floor=function(){return this.throwIfDisposed(),Qu(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.floorDiv=function(n){return this.throwIfDisposed(),jx(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.gather=function(n,t,e){return this.throwIfDisposed(),Cl(this,n,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.greaterEqual=function(n){return this.throwIfDisposed(),Ci(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.greater=function(n){return this.throwIfDisposed(),Wn(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.ifft=function(){return this.throwIfDisposed(),Kx(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.irfft=function(){return this.throwIfDisposed(),Xx(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.isFinite=function(){return this.throwIfDisposed(),qx(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.isInf=function(){return this.throwIfDisposed(),Yx(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.isNaN=function(){return this.throwIfDisposed(),Zx(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.leakyRelu=function(n){return this.throwIfDisposed(),dp(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.lessEqual=function(n){return this.throwIfDisposed(),vr(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.less=function(n){return this.throwIfDisposed(),Gd(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.localResponseNormalization=function(n,t,e,s){return this.throwIfDisposed(),Qx(this,n,t,e,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.logSigmoid=function(){return this.throwIfDisposed(),Jx(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.logSoftmax=function(n){return this.throwIfDisposed(),pp(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.logSumExp=function(n,t){return this.throwIfDisposed(),fp(this,n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.log=function(){return this.throwIfDisposed(),ps(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.log1p=function(){return this.throwIfDisposed(),mp(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.logicalAnd=function(n){return this.throwIfDisposed(),vi(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.logicalNot=function(){return this.throwIfDisposed(),Yd(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.logicalOr=function(n){return this.throwIfDisposed(),tw(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.logicalXor=function(n){return this.throwIfDisposed(),ew(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.matMul=function(n,t,e){return this.throwIfDisposed(),Dn(this,n,t,e)};H().prototype.maxPool=function(n,t,e,s){return this.throwIfDisposed(),gp(this,n,t,e,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.max=function(n,t){return this.throwIfDisposed(),ci(this,n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.maximum=function(n){return this.throwIfDisposed(),Vs(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.mean=function(n,t){return this.throwIfDisposed(),ve(this,n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.min=function(n,t){return this.throwIfDisposed(),yp(this,n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.minimum=function(n){return this.throwIfDisposed(),jr(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.mirrorPad=function(n,t){return this.throwIfDisposed(),bp(this,n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.mod=function(n){return this.throwIfDisposed(),nw(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.mul=function(n){return this.throwIfDisposed(),O(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.neg=function(){return this.throwIfDisposed(),Fe(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.norm=function(n,t,e){return this.throwIfDisposed(),sw(this,n,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.notEqual=function(n){return this.throwIfDisposed(),Ho(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.oneHot=function(n,t=1,e=0){return this.throwIfDisposed(),xp(this,n,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.onesLike=function(){return this.throwIfDisposed(),un(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.pad=function(n,t){return this.throwIfDisposed(),ui(this,n,t)};H().prototype.pool=function(n,t,e,s,i,o){return this.throwIfDisposed(),iw(this,n,t,e,s,i,o)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.pow=function(n){return this.throwIfDisposed(),zr(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.prelu=function(n){return this.throwIfDisposed(),wp(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.prod=function(n,t){return this.throwIfDisposed(),ow(this,n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.reciprocal=function(){return this.throwIfDisposed(),rw(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.relu=function(){return this.throwIfDisposed(),Si(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.relu6=function(){return this.throwIfDisposed(),aw(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.reshapeAs=function(n){return this.throwIfDisposed(),Q(this,n.shape)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.reshape=function(n){return this.throwIfDisposed(),Q(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.resizeBilinear=function(n,t,e){return this.throwIfDisposed(),uw(this,n,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.resizeNearestNeighbor=function(n,t,e){return this.throwIfDisposed(),lw(this,n,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.reverse=function(n){return this.throwIfDisposed(),Qi(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.rfft=function(){return this.throwIfDisposed(),cw(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.round=function(){return this.throwIfDisposed(),hw(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.rsqrt=function(){return this.throwIfDisposed(),Od(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.selu=function(){return this.throwIfDisposed(),vp(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.separableConv2d=function(n,t,e,s,i,o){return this.throwIfDisposed(),Cp(this,n,t,e,s,i,o)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.sigmoid=function(){return this.throwIfDisposed(),Ws(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.sign=function(){return this.throwIfDisposed(),dw(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.sin=function(){return this.throwIfDisposed(),Td(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.sinh=function(){return this.throwIfDisposed(),zd(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.slice=function(n,t){return this.throwIfDisposed(),le(this,n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.softmax=function(n){return this.throwIfDisposed(),Il(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.softplus=function(){return this.throwIfDisposed(),Kr(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.spaceToBatchND=function(n,t){return this.throwIfDisposed(),$d(this,n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.split=function(n,t){return this.throwIfDisposed(),Kn(this,n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.sqrt=function(){return this.throwIfDisposed(),ns(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.square=function(){return this.throwIfDisposed(),Ie(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.squaredDifference=function(n){return this.throwIfDisposed(),pw(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.squeeze=function(n){return this.throwIfDisposed(),Xt(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.stack=function(n,t){this.throwIfDisposed();const e=n instanceof Ge?[this,n]:[this,...n];return uo(e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.step=function(n){return this.throwIfDisposed(),hr(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.stridedSlice=function(n,t,e,s,i,o,r,a){return this.throwIfDisposed(),fw(this,n,t,e,s,i,o,r,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.sub=function(n){return this.throwIfDisposed(),Lt(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.sum=function(n,t){return this.throwIfDisposed(),Et(this,n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.tan=function(){return this.throwIfDisposed(),mw(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.tanh=function(){return this.throwIfDisposed(),Xr(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.tile=function(n){return this.throwIfDisposed(),As(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.toBool=function(){return this.throwIfDisposed(),mt(this,"bool")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.toFloat=function(){return this.throwIfDisposed(),mt(this,"float32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.toInt=function(){return this.throwIfDisposed(),mt(this,"int32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.topk=function(n,t){return this.throwIfDisposed(),gw(this,n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.transpose=function(n){return this.throwIfDisposed(),Vt(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.unique=function(n){return this.throwIfDisposed(),yw(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.unsortedSegmentSum=function(n,t){return this.throwIfDisposed(),_d(this,n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.unstack=function(n){return this.throwIfDisposed(),Zi(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.where=function(n,t){return this.throwIfDisposed(),Zn(n,this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H().prototype.zerosLike=function(){return this.throwIfDisposed(),ce(this)};/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class An extends Error{constructor(t){super(t),Object.setPrototypeOf(this,An.prototype)}}class an extends Error{constructor(t){super(t),Object.setPrototypeOf(this,an.prototype)}}class M extends Error{constructor(t){super(t),Object.setPrototypeOf(this,M.prototype)}}class At extends Error{constructor(t){super(t),Object.setPrototypeOf(this,At.prototype)}}class Ll extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Ll.prototype)}}/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class em{constructor(t){this.maxEntries=t||100,this.cache=new Map}get(t){let e;return this.cache.has(t)&&(e=this.cache.get(t),this.cache.delete(t),this.cache.set(t,e)),e}put(t,e){if(this.cache.has(t))this.cache.delete(t);else if(this.cache.size>=this.maxEntries){const s=this.cache.keys().next().value;this.cache.delete(s)}this.cache.set(t,e)}getMaxEntries(){return this.maxEntries}setMaxEntries(t){if(t<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${t}.`);if(this.maxEntries>t)for(let e=0;e<this.maxEntries-t;e++){const s=this.cache.keys().next().value;this.cache.delete(s)}this.maxEntries=t}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Os(n,t){if(Array.isArray(n)){let e=[];for(let s=0;s<t;s++)e=e.concat(n);return e}else{const e=new Array(t);return e.fill(n),e}}function Tn(n,t){if(!n)throw new Ll(t)}function lh(n,t){let e=0;for(const s of n)s===t&&e++;return e}function Pe(n){return n.length===1?n[0]:n}function Kt(n){return Array.isArray(n)?n:[n]}function Hn(n){const e=n.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return e[0]!=="_"?e:"private"+e}function Ds(n){return n.length<=1||n.indexOf("_")===-1?n:n.replace(/[_]+(\w|$)/g,(t,e)=>e.toUpperCase())}let on={};function Ol(n){if(n==null)return null;const t={};return t.className=n.getClassName(),t.config=n.getConfig(),t}function Ja(n){if(!(n==null||typeof n!="object"))if(Array.isArray(n))n.forEach(t=>Ja(t));else{const t=Object.keys(n);for(const e of t){const s=n[e];s!=null&&typeof s=="object"&&(!Array.isArray(s)&&s.type==="ndarray"&&typeof s.value=="number"?n[e]=s.value:Ja(s))}}}function po(n,t={},e={},s="object",i=!1){if(typeof n=="string"){const o=n;let r;if(o in e)r=e[o];else if(o in on)r=on[o];else if(r=t[o],r==null)throw new M(`Unknown ${s}: ${n}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return r}else{const o=n;if(o.className==null||o.config==null)throw new M(`${s}: Improper config format: ${JSON.stringify(o)}.
'className' and 'config' must set.`);const r=o.className;let a,u;if(r in e?[a,u]=e[r]:r in on?[a,u]=on.className:r in t&&([a,u]=t[r]),a==null)throw new M(`Unknown ${s}: ${r}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(u!=null){const l={};for(const f of Object.keys(on))l[f]=on[f];for(const f of Object.keys(e))l[f]=e[f];const c=o.config;c.customObjects=l;const h=Object.assign({},on);for(const f of Object.keys(e))on[f]=e[f];Ja(o.config);const p=u(a,o.config,e,i);return on=Object.assign({},h),p}else{const l=Object.assign({},on);for(const h of Object.keys(e))on[h]=e[h];const c=new a(o.config);return on=Object.assign({},l),c}}}function Tv(n,t){return n<t?-1:n>t?1:0}function Eo(n,t){return-1*Tv(n,t)}function hs(n){if(n==null)return n;const t=[];for(const e of n)t.indexOf(e)===-1&&t.push(e);return t}function zv(n){if(n==null)throw new M(`Invalid value in obj: ${JSON.stringify(n)}`);for(const t in n)if(n.hasOwnProperty(t))return!1;return!0}function Hs(n,t,e){if(e!=null&&n.indexOf(e)<0)throw new M(`${e} is not a valid ${t}.  Valid values are ${n} or null/undefined.`)}function _l(n,t,e=0,s=1/0){return Tn(e>=0),Tn(s>=e),Array.isArray(n)&&n.length>=e&&n.length<=s&&n.every(i=>typeof i===t)}function Ce(n,t){Array.isArray(n)?(tt(n.length>0,()=>`${t} is unexpectedly an empty array.`),n.forEach((e,s)=>Ce(e,`element ${s+1} of ${t}`))):tt(Number.isInteger(n)&&n>0,()=>`Expected ${t} to be a positive integer, but got ${nm(n)}.`)}function nm(n){return n===null?"null":Array.isArray(n)?"["+n.map(t=>nm(t)).join(",")+"]":typeof n=="string"?`"${n}"`:`${n}`}function Fv(n,t,e){let s=e!=null?e():jo(),i;return(...r)=>{const a=e!=null?e():jo();return a-s<t||(s=a,i=n(...r)),i}}function sm(n){return n==="relu"?"relu":n==="linear"?"linear":n==="elu"?"elu":null}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let Mv=0;function im(){return Mv++}const Lo={};function ta(n=""){return n in Lo||(Lo[n]=0),Lo[n]+=1,n+Lo[n].toString()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Pv=["channelsFirst","channelsLast"],Ev=["nearest","bilinear"],Lv=["valid","same","causal"],Ov=["max","avg"],_v=["sum","mul","concat","ave"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const ti=new Map;function pe(n){Hs(Pv,"DataFormat",n)}function Bv(n){Hs(Ev,"InterpolationFormat",n)}function Qe(n){Hs(Lv,"PaddingMode",n)}function om(n){Hs(Ov,"PoolMode",n)}const qi=[],ch="/";function Fs(n,t){qi.push(n);try{const e=t();return qi.pop(),e}catch(e){throw qi.pop(),e}}function Wv(){return qi.length===0?"":qi.join(ch)+ch}function rm(n){if(!um(n))throw new Error("Not a valid tensor name: '"+n+"'");return Wv()+n}function am(n){if(!um(n))throw new Error("Not a valid tensor name: '"+n+"'");ti.has(n)||ti.set(n,0);const t=ti.get(n);if(ti.set(n,ti.get(n)+1),t>0){const e=`${n}_${t}`;return ti.set(e,1),e}else return n}const Vv=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function um(n){return!!n.match(Vv)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Uv(n){return n===parseInt(n.toString(),10)}function ds(n,t,e){t==null&&(t=0),e==null&&(e=n.length);let s=1;for(let i=t;i<e;++i)s*=n[i];return s}function mi(n){if(n.length===0)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let e=0;e<n.length;e++){const s=n[e];s<t&&(t=s)}return t}function ms(n){if(n.length===0)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let e=0;e<n.length;e++){const s=n[e];s>t&&(t=s)}return t}function bn(n,t){if(t<n)throw new M(`end (${t}) < begin (${n}) is forbidden.`);const e=[];for(let s=n;s<t;++s)e.push(s);return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let Pa;function ge(){return Pa==null&&(Pa=hi().epsilon()),Pa}function xn(){return"channelsLast"}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Pn(n,t){return mt(n,t)}function fo(n,t=-1){const e=n.shape.slice();return t<0&&(t=e.length+t+1),e.splice(t,0,1),Q(n,e)}function Gv(n,t){return B(()=>{if(n.shape.length!==2)throw new M(`repeat() expects a rank-2 tensor, but received a rank-${n.shape.length} tensor.`);const e=fo(n,1);return tu(e,[1,t,1])})}function Hv(n){const t=[ds(n.shape)];return Q(n,t)}function jv(n){if(n.rank<=1)throw new M(`batchFlatten requires a minimum rank of 2. Got rank: ${n.rank}.`);const t=[n.shape[0],ds(n.shape,1)];return Q(n,t)}function Ms(n,t,e){return B(()=>{switch(n.rank){case 1:return $l(n,t,e);case 2:return kp(n,[t,0],[e,n.shape[1]]);case 3:return Nl(n,[t,0,0],[e,n.shape[1],n.shape[2]]);case 4:return Ko(n,[t,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3]]);case 5:return le(n,[t,0,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3],n.shape[4]]);case 6:return le(n,[t,0,0,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3],n.shape[4],n.shape[5]]);default:throw new M(`sliceAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}})}function Ea(n,t,e){return B(()=>{switch(n.rank){case 1:return $l(n,t,e);case 2:return kp(n,[0,t],[n.shape[0],e]);case 3:return Nl(n,[0,0,t],[n.shape[0],n.shape[1],e]);case 4:return Ko(n,[0,0,0,t],[n.shape[0],n.shape[1],n.shape[2],e]);default:throw new M(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function Oo(n,t,e,s){return B(()=>{switch(n.rank){case 1:return $l(n,t,e);case 2:switch(s){case 1:return Ms(n,t,e);case 2:return Ea(n,t,e);default:throw new M(`The axis is not within the rank of the tensor ${s}`)}case 3:switch(s){case 1:return Ms(n,t,e);case 2:return Nl(n,[0,t,0],[n.shape[0],e,n.shape[2]]);case 3:return Ea(n,t,e);default:throw new M(`The axis is not within the rank of the tensor ${s}`)}case 4:switch(s){case 1:return Ms(n,t,e);case 2:return Ko(n,[0,t,0,0],[n.shape[0],e,n.shape[2],n.shape[3]]);case 3:return Ko(n,[0,0,t,0],[n.shape[0],n.shape[1],e,n.shape[3]]);case 4:return Ea(n,t,e);default:throw new M(`The axis is not within the rank of the tensor ${s}`)}default:throw new M(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function Bl(n,t=-1){let e;return t<0&&(e=n[0].rank,e!==0?t=e:t=0),t===n[0].rank&&(t=-1),fs(n,t)}function hh(n,t){switch(n.rank){case 1:return Cw([n,t]);case 2:return vw([n,t],0);case 3:return ww([n,t],0);case 4:return xw([n,t],0);default:throw new M(`concatAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}}function tu(n,t){if(Array.isArray(t)||(t=[t]),n.rank!==t.length)throw new M(`The length of input n (${t.length}) does not match the number of dimensions in input x (${n.rank})`);return As(n,t)}function ea(n,t=0,e=1,s,i){return bw(n,t,e,s,i)}function En(n,t,e,s){if(n.rank<2||t.rank<2)throw new At(`dot requires both inputs to be rank >= 2 but got x shape = ${n.shape} and y shape = ${t.shape}`);if(t.rank>=3){const i=n.shape.slice(-1)[0],o=t.shape.slice(-2)[0];if(i!==o)throw new At(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${n.shape} and  y shape = ${t.shape}`)}if(n.rank===2&&t.rank===2)return qc({a:n,b:t,transposeA:!1,transposeB:!1,bias:s?eu(n.rank,s,xn()):null,activation:e});{const i=n.shape.slice(),o=i.pop();n=Q(n,[-1,o]);const r=t.shape.slice(),a=r.pop(),u=r.pop(),l=[...r,a],c=Array.from({length:t.rank},(m,g)=>g===0?t.rank-2:g<=t.rank-2?g-1:g);t=Q(Vt(t,c),[u,-1]);const h=[...i,...l];return Q(qc({a:n,b:t,transposeA:!1,transposeB:!1,bias:s?eu(n.rank,s,xn()):null,activation:e}),h)}}function lm(n,t,e){return B(()=>(Array.isArray(t)?t=jn(t,"int32"):t=mt(t,"int32"),Cl(n,t,e)))}function mo(n){return O(n,n)}function eu(n,t,e){const s=t.shape;if(t.rank!==1&&t.rank!==n)throw new M(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${n}`);if(n===5){if(e==="channelsFirst")return s.length===1?Q(t,[1,s[0],1,1,1]):Q(t,[1,s[3],s[0],s[1],s[2]]);if(e==="channelsLast")return s.length===1?Q(t,[1,1,1,1,s[0]]):Q(t,[1].concat(s))}else if(n===4){if(e==="channelsFirst")return s.length===1?Q(t,[1,s[0],1,1]):Q(t,[1,s[2],s[0],s[1]]);if(e==="channelsLast")return s.length===1?Q(t,[1,1,1,s[0]]):Q(t,[1].concat(s))}else if(n===3){if(e==="channelsFirst")return s.length===1?Q(t,[1,s[0],1]):Q(t,[1,s[1],s[0]]);if(e==="channelsLast")return s.length===1?Q(t,[1,1,s[0]]):Q(t,[1].concat(s))}else if(n<3)return t;throw new M(`Unsupported input rank by biasAdd: ${t.rank}`)}function wn(n,t,e){return B(()=>(e==null&&(e=xn()),pe(e),ct(n,eu(n.rank,t,e))))}function Kv(n,t=1){if(t!==1)throw new At(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return Sl(n)}function Xv(n){return B(()=>Ct(n,ct(Ls(n),1)))}function cm(n,t,e,s){return B(()=>kw(n,t,e,s))}function qv(n){return B(()=>{const t=ct(.5,O(.2,n));return Ue(t,0,1)})}function go(n,t,e=!1){return e?n():t()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Yv=["fanIn","fanOut","fanAvg"],Zv=["normal","uniform","truncatedNormal"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Qv(n){Hs(Yv,"FanMode",n)}function Jv(n){Hs(Zv,"Distribution",n)}class cn extends lo{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class hm extends cn{apply(t,e){return Le(t,e)}}hm.className="Zeros";q(hm);class Wl extends cn{apply(t,e){return Bs(t,e)}}Wl.className="Ones";q(Wl);class dm extends cn{constructor(t){if(super(),typeof t!="object")throw new M(`Expected argument of type ConstantConfig but got ${t}`);if(t.value===void 0)throw new M(`config must have value set but got ${t}`);this.value=t.value}apply(t,e){return B(()=>O(se(this.value),Bs(t,e)))}getConfig(){return{value:this.value}}}dm.className="Constant";q(dm);class pm extends cn{constructor(t){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=t.minval||this.DEFAULT_MINVAL,this.maxval=t.maxval||this.DEFAULT_MAXVAL,this.seed=t.seed}apply(t,e){return qr(t,this.minval,this.maxval,e,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}pm.className="RandomUniform";q(pm);class fm extends cn{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if(e=e||"float32",e!=="float32"&&e!=="int32")throw new At(`randomNormal does not support dType ${e}.`);return ea(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}fm.className="RandomNormal";q(fm);class mm extends cn{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if(e=e||"float32",e!=="float32"&&e!=="int32")throw new At(`truncatedNormal does not support dType ${e}.`);return Sp(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}mm.className="TruncatedNormal";q(mm);class gm extends cn{constructor(t){super(),this.gain=t.gain!=null?t.gain:1}apply(t,e){return B(()=>{if(t.length!==2||t[0]!==t[1])throw new M("Identity matrix initializer can only be used for 2D square matrices.");return O(this.gain,Sw(t[0]))})}getConfig(){return{gain:this.gain}}}gm.className="Identity";q(gm);function tC(n,t="channelsLast"){let e,s;if(pe(t),n.length===2)e=n[0],s=n[1];else if([3,4,5].indexOf(n.length)!==-1){if(t==="channelsFirst"){const i=ds(n,2);e=n[1]*i,s=n[0]*i}else if(t==="channelsLast"){const i=ds(n,0,n.length-2);e=n[n.length-2]*i,s=n[n.length-1]*i}}else{const i=ds(n);e=Math.sqrt(i),s=Math.sqrt(i)}return[e,s]}class He extends cn{constructor(t){if(super(),t.scale<0)throw new M(`scale must be a positive float. Got: ${t.scale}`);this.scale=t.scale==null?1:t.scale,this.mode=t.mode==null?"fanIn":t.mode,Qv(this.mode),this.distribution=t.distribution==null?"normal":t.distribution,Jv(this.distribution),this.seed=t.seed}apply(t,e){const s=tC(t),i=s[0],o=s[1];let r=this.scale;if(this.mode==="fanIn"?r/=Math.max(1,i):this.mode==="fanOut"?r/=Math.max(1,o):r/=Math.max(1,(i+o)/2),this.distribution==="normal"){const a=Math.sqrt(r);if(e=e||"float32",e!=="float32"&&e!=="int32")throw new At(`${this.getClassName()} does not support dType ${e}.`);return Sp(t,0,a,e,this.seed)}else{const a=Math.sqrt(3*r);return qr(t,-a,a,e,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}He.className="VarianceScaling";q(He);class Vl extends He{constructor(t){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return He.className}}Vl.className="GlorotUniform";q(Vl);class Ul extends He{constructor(t){super({scale:1,mode:"fanAvg",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return He.className}}Ul.className="GlorotNormal";q(Ul);class Gl extends He{constructor(t){super({scale:2,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return He.className}}Gl.className="HeNormal";q(Gl);class Hl extends He{constructor(t){super({scale:2,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return He.className}}Hl.className="HeUniform";q(Hl);class jl extends He{constructor(t){super({scale:1,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return He.className}}jl.className="LeCunNormal";q(jl);class Kl extends He{constructor(t){super({scale:1,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return He.className}}Kl.className="LeCunUniform";q(Kl);class ym extends cn{constructor(t){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=t.gain==null?this.DEFAULT_GAIN:t.gain,this.seed=t.seed}apply(t,e){return B(()=>{if(t.length<2)throw new At("Shape must be at least 2D.");if(e!=="int32"&&e!=="float32"&&e!==void 0)throw new TypeError(`Unsupported data type ${e}.`);e=e;const s=et(t.slice(0,-1)),i=t[t.length-1],o=s*i;o>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${o}) elements: Slowness may result.`);const r=[Math.max(i,s),Math.min(i,s)],a=ea(r,0,1,e,this.seed),u=Iw.qr(a,!1);let l=u[0];const h=u[1].flatten().stridedSlice([0],[Math.min(i,s)*Math.min(i,s)],[Math.min(i,s)+1]);return l=O(l,h.sign()),s<i&&(l=l.transpose()),O(se(this.gain),l.reshape(t))})}getConfig(){return{gain:this.gain,seed:this.seed}}}ym.className="Orthogonal";q(ym);const dh={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function ph(n,t={}){return po(n,co.getMap().classNameMap,t,"initializer")}function ae(n){return Ol(n)}function oe(n){if(typeof n=="string"){const t=n in dh?dh[n]:n;if(t==="GlorotNormal")return new Ul;if(t==="GlorotUniform")return new Vl;if(t==="HeNormal")return new Gl;if(t==="HeUniform")return new Hl;if(t==="LeCunNormal")return new jl;if(t==="LeCunUniform")return new Kl;{const e={};return e.className=t,e.config={},ph(e)}}else return n instanceof cn?n:ph(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function nu(n){return Array.isArray(n)&&Array.isArray(n[0])}function qo(n){return n.length===0?[]:Array.isArray(n[0])?n:[n]}function kt(n){let t;if(Array.isArray(n)){if(n.length!==1)throw new M(`Expected Tensor length to be 1; got ${n.length}`);t=n[0]}else t=n;return t}function Wt(n){if(Array.isArray(n)&&Array.isArray(n[0])){if(n.length===1)return n=n,n[0];throw new M(`Expected exactly 1 Shape; got ${n.length}`)}else return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Yo(n){let t=0;for(const e of n)e.shape.length===0?t+=1:t+=e.shape.reduce((s,i)=>s*i);return t}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const fh="Variable";class eC{constructor(t,e="float32",s=fh,i=!0,o=null){this.dtype=e??"float32",this.shape=t.shape,this.id=im(),s=s??fh,this.originalName=rm(s),this.name=am(this.originalName),this.trainable_=i,this.constraint=o,this.val=Nw(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),nC(this.val,t),this.val.id!==t.id&&(this.val.assign(t),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}}function nC(n,t){if(n.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(n.shape)+" vs. "+JSON.stringify(t.shape))}function su(n){return n.map(t=>t.read())}function Xl(n){n.forEach(t=>{t[0].write(t[1])})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class ye{constructor(t){this.dtype=t.dtype,this.shape=t.shape,t.shape!=null?this.ndim=t.shape.length:this.ndim=t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}}class On{constructor(t,e,s,i,o,r,a){this.dtype=t,this.shape=e,this.sourceLayer=s,this.inputs=i,this.callArgs=o,this.outputTensorIndex=a,this.id=im(),r!=null&&(this.originalName=rm(r),this.name=am(this.originalName)),this.rank=e.length}}let sC=0;class na{constructor(t,e){this.callArgs=e,this.id=sC++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(const s of t.inboundLayers)s!=null&&s.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){const t=[];for(const e of this.inboundLayers)e!=null?t.push(e.name):t.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let iC=0;class Ft extends lo{constructor(t={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=iC++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=t.name;if(!e){const s=this.getClassName();e=Hn(s)+"_"+ta(s)}if(this.name=e,this.trainable_=t.trainable==null?!0:t.trainable,t.inputShape!=null||t.batchInputShape!=null){let s;if(t.batchInputShape!=null)s=t.batchInputShape;else if(t.inputShape!=null){let o=null;t.batchSize!=null&&(o=t.batchSize),s=[o].concat(t.inputShape)}this.batchInputShape=s;let i=t.dtype;i==null&&(i=t.inputDType),i==null&&(i="float32"),this.dtype=i}t.weights!=null?this.initialWeights=t.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,e){return t.name+"_ib-"+e.toString()}getNodeAtIndex(t,e){if(this.inboundNodes.length===0)throw new an(`The layer has never been called and thus has no defined ${e}.`);if(this.inboundNodes.length<=t)throw new M(`Asked to get ${e} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[t]}getInputAt(t){return Pe(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return Pe(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new An(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new An(`Layer ${this.name} is not connected, no input to return.`);return Pe(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new An(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new An(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Pe(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(t=>t())}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach(e=>e.trainable=t),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(t=>t.trainable):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(t=>!t.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){const e=Kt(t);if(this.inputSpec==null||this.inputSpec.length===0)return;const s=Kt(this.inputSpec);if(e.length!==s.length)throw new M(`Layer ${this.name} expects ${s.length} inputs, but it received ${e.length} input tensors. Input received: ${t}`);for(let i=0;i<e.length;i++){const o=e[i],r=s[i];if(r==null)continue;const a=o.rank;if(r.ndim!=null&&a!==r.ndim)throw new M(`Input ${i} is incompatible with layer ${this.name}: expected ndim=${r.ndim}, found ndim=${a}`);if(r.maxNDim!=null&&a>r.maxNDim)throw new M(`Input ${i} is incompatible with layer ${this.name}: expected max_ndim=${r.maxNDim}, found ndim=${a}`);if(r.minNDim!=null&&a<r.minNDim)throw new M(`Input ${i} is incompatible with layer ${this.name}: expected min_ndim=${r.minNDim}, found ndim=${a}.`);if(r.dtype!=null&&o.dtype!==r.dtype)throw new M(`Input ${i} is incompatible with layer ${this.name} : expected dtype=${r.dtype}, found dtype=${o.dtype}.`);if(r.axes){const u=o.shape;for(const l in r.axes){const c=Number(l),h=r.axes[l],p=c>=0?u[c]:u[u.length+c];if(h!=null&&[h,null].indexOf(p)===-1)throw new M(`Input ${i} is incompatible with layer ${this.name}: expected axis ${c} of input shape to have value ${h} but got shape ${u}.`)}}if(r.shape!=null)for(let u=0;u<r.shape.length;++u){const l=r.shape[u],c=o.shape[u];if(l!=null&&c!=null&&l!==c)throw new M(`Input ${i} is incompatible with layer ${this.name}: expected shape=${r.shape}, found shape=${o.shape}.`)}}}call(t,e){return t}invokeCallHook(t,e){this._callHook!=null&&this._callHook(t,e)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,e){e=e||{},this.assertNotDisposed();const s=Kt(t),i=aC(t),o=uC(t);if(i===o)throw new M("Arguments to apply() must be all SymbolicTensors or all Tensors");return Fs(this.name,()=>{if(!this.built){this.assertInputCompatibility(t);const r=[];for(const a of Kt(t))r.push(a.shape);this.build(Pe(r)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&o&&(this._refCount=1)}if(this.assertInputCompatibility(t),o){let r=this.call(t,e);this.supportsMasking&&this.setMaskMetadata(t,r);const a=Kt(r),u=[];for(let l of a)s.indexOf(l)!==-1&&(l=l.clone()),u.push(l);if(r=Pe(u),this.activityRegularizer!=null)throw new At("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}else{const r=oC(t),a=this.computeOutputShape(r);let u;const l=rC(t);if(this.warnOnIncompatibleInputShape(Array.isArray(t)?r[0]:r),a!=null&&a.length>0&&Array.isArray(a[0])?u=a.map((c,h)=>new On(l,c,this,Kt(t),e,this.name,h)):u=new On(l,a,this,Kt(t),e,this.name),this.addInboundNode(t,u,null,null,r,a,e),this._refCount++,this.activityRegularizer!=null)throw new At("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return u}})}warnOnIncompatibleInputShape(t){if(this.batchInputShape!=null)if(t.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(t)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let e=!1;this.batchInputShape.forEach((s,i)=>{s!=null&&t[i]!=null&&t[i]!==s&&(e=!0)}),e&&console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new An(`The layer ${this.name} has never been called and thus has no defined output shape.`);const t=[];for(const e of this.inboundNodes){const s=JSON.stringify(e.outputShapes);t.indexOf(s)===-1&&t.push(s)}if(t.length===1){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&e.length===1?e[0]:e}else throw new An(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new an(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return Yo(this.weights)}build(t){this.built=!0}getWeights(t=!1){return su(t?this.trainableWeights:this.weights)}setWeights(t){B(()=>{const e=this.weights;if(e.length!==t.length)throw new M(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${e.length} weights. Provided weights: ${t}...`);if(e.length===0)return;const s=[],i=su(e);for(let o=0;o<i.length;++o){const r=i[o],a=e[o],u=t[o];if(!ke(r.shape,u.shape))throw new M(`Layer weight shape ${r.shape} not compatible with provided weight shape ${u.shape}`);s.push([a,u])}Xl(s)})}addWeight(t,e,s,i,o,r,a,u){if(this._addedWeightNames.indexOf(t)!==-1)throw new M(`Duplicate weight name ${t} for layer ${this.name}`);this._addedWeightNames.push(t),s==null&&(s="float32"),this.fastWeightInitDuringBuild&&(i=u!=null?u():oe("zeros"));const l=i.apply(e,s),c=new eC(l,s,t,r,a);return l.dispose(),o!=null&&this.addLoss(()=>o.apply(c.read())),r==null&&(r=!0),r?this._trainableWeights.push(c):this._nonTrainableWeights.push(c),c}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){t==null||Array.isArray(t)&&t.length===0||(t=Kt(t),this._losses!==void 0&&this._losses!==null&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,e){if(!this.supportsMasking){if(e!=null)if(Array.isArray(e))e.forEach(s=>{if(s!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return e}setMaskMetadata(t,e,s){if(!this.supportsMasking)return;const i=this.computeMask(t,s),o=Kt(e),r=Kt(i);if(o.length!==r.length)throw new Error(`${this.name} outputs ${o.length} tensors but ${o.length} masks for those tensors`);for(let a=0;a<o.length;a++)o[a].kerasMask=r[a]}addInboundNode(t,e,s,i,o,r,a=null){const u=Kt(t);e=Kt(e),s=Kt(s),i=Kt(i),o=qo(o),r=qo(r);const l=[],c=[],h=[];for(const p of u)l.push(p.sourceLayer),c.push(p.nodeIndex),h.push(p.tensorIndex);new na({outboundLayer:this,inboundLayers:l,nodeIndices:c,tensorIndices:h,inputTensors:u,outputTensors:e,inputMasks:s,outputMasks:i,inputShapes:o,outputShapes:r},a);for(let p=0;p<e.length;p++)e[p].sourceLayer=this,e[p].nodeIndex=this.inboundNodes.length-1,e[p].tensorIndex=p}getConfig(){const t={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(t.batchInputShape=this.batchInputShape),this.dtype!=null&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach(t=>t.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let t=0;return--this._refCount===0&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}}function oC(n){n=Kt(n);const t=[];for(const e of n)t.push(e.shape);return Pe(t)}function rC(n){return"float32"}function bm(n,t,e){if((t==null||e!=null&&e>0)&&(t=n.sourceLayer,e=n.nodeIndex),t.inboundNodes.length===0)return[n];{const s=t.inboundNodes[e];if(s.inboundLayers.length===0)return s.inputTensors;{const i=[];for(let o=0;o<s.inboundLayers.length;o++){const r=s.inputTensors[o],a=s.inboundLayers[o],u=s.nodeIndices[o],l=bm(r,a,u);for(const c of l)i.indexOf(c)===-1&&i.push(c)}return i}}}function aC(n){let t=!0;for(const e of Kt(n))if(!(e instanceof On)){t=!1;break}return t}function uC(n){let t=!0;for(const e of Kt(n))if(e instanceof On){t=!1;break}return t}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class yo extends Ft{constructor(t){if(super({dtype:t.dtype,name:t.name!=null?t.name:ta("input").toString()}),t.batchSize==null&&(t.batchSize=null),t.sparse==null&&(t.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=t.sparse,t.inputShape!=null&&t.batchInputShape!=null)throw new M("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let e=t.batchInputShape;if(e==null){if(t.inputShape==null)throw new M("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");e=[t.batchSize].concat(t.inputShape)}else if(t.batchSize!=null)throw new M("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const s=t.dtype||"float32";this.batchInputShape=e,this.dtype=s,this.inputSpec=[{shape:e}];const i=new On(this.dtype,this.batchInputShape,this,[],{},this.name);i.nodeIndex=0,i.tensorIndex=0,new na({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[i],outputTensors:[i],inputMasks:[null],outputMasks:[null],inputShapes:[e],outputShapes:[e]})}apply(t,e){throw new M(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}yo.className="InputLayer";q(yo);function lC(n){if(n.batchShape==null&&n.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(n.batchShape!=null&&n.shape!=null)throw new M("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=n.batchShape;n.shape!=null&&t==null&&(t=[null].concat(n.shape));let e=n.dtype;return e==null&&(e="float32"),new yo({batchInputShape:t,name:n.name,dtype:e,sparse:n.sparse}).inboundNodes[0].outputTensors[0]}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function cC(n,t){if(n.dtype==null||n.dtype===t.dtype)return t;try{return mt(t,n.dtype)}catch{throw new M(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${n.name}' (${n.dtype}).`)}}class as{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof as)for(const e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(t==null)return;for(const e of t)this.add(e.key,e.value)}}add(t,e,s){if(this.id2Value[t.id]==null)this.id2Value[t.id]=cC(t,e),this.name2Id[t.name]=t.id,s!=null&&(this.id2Mask[t.id]=s);else throw new M(`Duplicate key: name=${t.name}, id=${t.id}`);return this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return this.id2Value[t.id]!=null}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof On){if(this.id2Value[t.id]==null)throw new M(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}else{const e=this.name2Id[t];if(e==null)throw new M(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[e]}}getMask(t){if(t instanceof On){if(this.id2Value[t.id]==null)throw new M(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}else{const e=this.name2Id[t];if(e==null)throw new M(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[e]}}disposeMasks(){this.id2Mask!=null&&zt(this.id2Mask)}}const Zo=new em,Qo=new em;function hC(n){Zo!=null&&Zo.setMaxEntries(n),Qo!=null&&Qo.setMaxEntries(n)}function Hi(n,t,e,s){const i=e==null?!1:e.training,o=Array.isArray(n),r=o?n:[n],a=r.map(m=>m.name),u=[],l=t.names();for(const m of a)l.indexOf(m)!==-1?u.push(t.getValue(m)):u.push(null);const c=a.join(",")+"|"+t.names().sort().join(",");let h=Zo.get(c),p;if(h==null){const m=dC(r,t);h=m.sorted,p=m.recipientCounts,Zo.put(c,h),Qo.put(c,p)}p={},i||Object.assign(p,Qo.get(c));const f=new as(t);for(let m=0;m<h.length;++m){const g=h[m],b=g.sourceLayer;if(b instanceof yo)continue;const v=[],w=[],k=[];let C=!1;for(const z of g.inputs){const F=f.getValue(z),E=f.getMask(z);v.push(F),w.push(E),E!=null&&(C=!0),i||(p[z.name]--,p[z.name]===0&&!t.hasKey(z)&&a.indexOf(z.name)===-1&&!F.isDisposed&&z.sourceLayer.stateful!==!0&&k.push(F))}C&&(e=e||{},e.mask=w[0]);const I=Kt(b.apply(v,e));let N=null;b.supportsMasking&&(N=b.computeMask(v,w));const $=fC(g),A=Array.isArray($)?$:[$];for(let z=0;z<A.length;++z){f.hasKey(A[z])||f.add(A[z],I[z],Array.isArray(N)?N[0]:N);const F=a.indexOf(A[z].name);F!==-1&&(u[F]=I[z])}i||zt(k)}return f.disposeMasks(),o?u:u[0]}function dC(n,t){tt(n!=null&&n.length>0,()=>"Expected at least one fetch, got none");let e=[],s={};if(n.length===1){const i=mh(n[0],t);e=i.sorted,s=i.recipientMap}else{const i=new Set;for(const o of n){const{sorted:r,recipientMap:a}=mh(o,t);for(const u of r)i.has(u.name)||(e.push(u),i.add(u.name));for(const u in a)s[u]==null&&(s[u]=new Set),a[u].forEach(l=>s[u].add(l))}}return{sorted:e,recipientCounts:pC(s)}}function pC(n){const t={};for(const e in n)t[e]=n[e].size;return t}function mh(n,t){const e=new Set,s=[],i={};for(const a of t.names())e.add(a);const o=[],r=[];for(o.push(n);o.length>0;){const a=o[o.length-1];if(e.has(a.name)){o.pop();continue}const u=r[r.length-1]===o.length-1;if(a.inputs.length===0||u)o.pop(),s.push(a),e.add(a.name),u&&r.pop();else{r.push(o.length-1);for(const l of a.inputs)i[l.name]==null&&(i[l.name]=new Set),i[l.name].add(a.name),!e.has(l.name)&&o.push(l)}}return{sorted:s,recipientMap:i}}function fC(n){let t;if(n.sourceLayer.inboundNodes.length===1)t=n.sourceLayer.output;else{let e=null;for(let s=0;s<n.sourceLayer.inboundNodes.length;++s)for(const i of n.sourceLayer.inboundNodes[s].outputTensors)if(i.id===n.id){e=s;break}t=n.sourceLayer.getOutputAt(e)}return t}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mC=he();mC.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,hC);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function ql(n,t){return B(()=>ns(Et(O(n,n),t,!0)))}class bo extends lo{getConfig(){return{}}}class xm extends bo{constructor(t){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return B(()=>{const e=ql(t,this.axis),s=Ue(e,0,this.maxValue);return O(t,Ct(s,ct(ge(),e)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}xm.className="MaxNorm";q(xm);class wm extends bo{constructor(t){super(),this.defaultAxis=0,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return B(()=>Ct(t,ct(ge(),ql(t,this.axis))))}getConfig(){return{axis:this.axis}}}wm.className="UnitNorm";q(wm);class vm extends bo{apply(t){return Si(t)}}vm.className="NonNeg";q(vm);class Cm extends bo{constructor(t){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=t.minValue!=null?t.minValue:this.defaultMinValue,this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue,this.rate=t.rate!=null?t.rate:this.defaultRate,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return B(()=>{const e=ql(t,this.axis),s=ct(O(this.rate,Ue(e,this.minValue,this.maxValue)),O(1-this.rate,e));return O(t,Ct(s,ct(ge(),e)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}Cm.className="MinMaxNorm";q(Cm);const gh={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function be(n){return Ol(n)}function yh(n,t={}){return po(n,co.getMap().classNameMap,t,"constraint")}function xe(n){if(n==null)return null;if(typeof n=="string"){const e={className:n in gh?gh[n]:n,config:{}};return yh(e)}else return n instanceof bo?n:yh(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */async function Ns(n){if(n==null)return;const t=[],e=[],s=[];for(const i in n){const o=n[i];if(typeof o!="number"){const r=o;t.push(r.data()),e.push(i),s.push(r)}}if(t.length>0){const i=await Promise.all(t);for(let o=0;o<i.length;++o)n[e[o]]=i[o][0];zt(s)}}function km(n){if(n!=null)for(const t in n){const e=n[t];typeof e!="number"&&e.dispose()}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var bh;(function(n){n[n.SILENT=0]="SILENT",n[n.VERBOSE=1]="VERBOSE"})(bh||(bh={}));const gC=125;class eo{constructor(){this.validationData=null}setParams(t){this.params=t}async onEpochBegin(t,e){}async onEpochEnd(t,e){}async onBatchBegin(t,e){}async onBatchEnd(t,e){}async onTrainBegin(t){}async onTrainEnd(t){}setModel(t){}}class yC{constructor(t,e=10){t==null&&(t=[]),this.callbacks=t,this.queueLength=e}append(t){this.callbacks.push(t)}setParams(t){for(const e of this.callbacks)e.setParams(t)}setModel(t){for(const e of this.callbacks)e.setModel(t)}async onEpochBegin(t,e){e==null&&(e={});for(const s of this.callbacks)await s.onEpochBegin(t,e)}async onEpochEnd(t,e){e==null&&(e={});for(const s of this.callbacks)await s.onEpochEnd(t,e)}async onBatchBegin(t,e){e==null&&(e={});for(const s of this.callbacks)await s.onBatchBegin(t,e)}async onBatchEnd(t,e){e==null&&(e={});for(const s of this.callbacks)await s.onBatchEnd(t,e)}async onTrainBegin(t){t==null&&(t={});for(const e of this.callbacks)await e.onTrainBegin(t)}async onTrainEnd(t){t==null&&(t={});for(const e of this.callbacks)await e.onTrainEnd(t)}}class bC extends eo{constructor(){super()}async onEpochBegin(t){this.seen=0,this.totals={}}async onBatchEnd(t,e){e==null&&(e={});const s=e.size==null?0:e.size;this.seen+=s;for(const i in e){const o=e[i];if(typeof o=="number")this.totals.hasOwnProperty(i)||(this.totals[i]=0),this.totals[i]=this.totals[i]+o*s;else{let r;i in this.totals?r=this.totals[i]:this.totals[i]=0;const a=B(()=>ct(this.totals[i],O(o,s)));this.totals[i]=a,r!=null&&r.dispose()}}}async onEpochEnd(t,e){if(e!=null)for(const s of this.params.metrics)this.totals[s]!=null&&(typeof this.totals[s]=="number"?e[s]=this.totals[s]/this.seen:B(()=>{const i=O(Ct(1,this.seen),this.totals[s]);e[s]=i,this.totals[s].dispose(),Xn(e[s])}))}}class xC extends eo{async onTrainBegin(t){this.epoch=[],this.history={}}async onEpochEnd(t,e){e==null&&(e={}),this.epoch.push(t);for(const s in e)this.history[s]==null&&(this.history[s]=[]),this.history[s].push(e[s])}async syncData(){const t=[],e=[],s=[];for(const o in this.history){const r=this.history[o];for(let a=0;a<r.length;++a)if(typeof r[a]!="number"){const u=r[a];t.push(u.data()),e.push(o),s.push(a)}}const i=await Promise.all(t);for(let o=0;o<i.length;++o)this.history[e[o]][s[o]].dispose(),this.history[e[o]][s[o]]=i[o][0]}}class wC extends eo{constructor(t,e){if(super(),this.currentEpoch=0,this.nowFunc=t.nowFunc,this.nextFrameFunc=t.nextFrameFunc||$w,this.yieldEvery=e||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=gC),this.yieldEvery==="never"&&t.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");Yc(this.yieldEvery)&&(this.maybeWait=Fv(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}async maybeWait(t,e,s){const i=[];this.yield!=null&&(await Ns(s),i.push(this.yield(t,e,s))),i.push(this.nextFrameFunc()),await Promise.all(i)}async onEpochBegin(t,e){this.currentEpoch=t,this.epochBegin!=null&&(await Ns(e),await this.epochBegin(t,e))}async onEpochEnd(t,e){const s=[];this.epochEnd!=null&&(await Ns(e),s.push(this.epochEnd(t,e))),this.yieldEvery==="epoch"&&s.push(this.nextFrameFunc()),await Promise.all(s)}async onBatchBegin(t,e){this.batchBegin!=null&&(await Ns(e),await this.batchBegin(t,e))}async onBatchEnd(t,e){const s=[];this.batchEnd!=null&&(await Ns(e),s.push(this.batchEnd(t,e))),this.yieldEvery==="batch"?s.push(this.nextFrameFunc()):Yc(this.yieldEvery)&&s.push(this.maybeWait(this.currentEpoch,t,e)),await Promise.all(s)}async onTrainBegin(t){this.trainBegin!=null&&(await Ns(t),await this.trainBegin(t))}async onTrainEnd(t){this.trainEnd!=null&&(await Ns(t),await this.trainEnd(t))}}function Sm(n,t){return n==null&&(n={}),n instanceof eo?[n]:Array.isArray(n)&&n[0]instanceof eo?n:Kt(n).map(s=>new wC(s,t))}class rn{constructor(){}static registerCallbackConstructor(t,e){tt(t>=0&&Number.isInteger(t),()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`),rn.checkForDuplicate(e),rn.constructors[t]==null&&(rn.constructors[t]=[]),rn.constructors[t].push(e)}static checkForDuplicate(t){for(const e in rn.constructors)rn.constructors[+e].forEach(i=>{if(i===t)throw new M("Duplicate callback constructor.")})}static clear(){rn.constructors={}}static createCallbacks(t){const e=[];for(const s in rn.constructors){const i=+s;t>=i&&e.push(...rn.constructors[i])}return e.map(s=>new s)}}rn.constructors={};function Im(n,t,e,s,i,o,r,a,u){const l=new xC,c=[new bC,...rn.createCallbacks(t)];n!=null&&c.push(...n),c.push(l);const h=new yC(c);return h.setParams({epochs:e,initialEpoch:s,samples:i,steps:o,batchSize:r,verbose:t,doValidation:a,metrics:u}),{callbackList:h,history:l}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function qn(n,t={},e=!1){return po(n,co.getMap().classNameMap,t,"layer",e)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Jo(n,t){return B(()=>{n.dtype!=="float32"&&(n=mt(n,"float32"));const e=Et(mo(n),t,!0),s=Dw(e.shape,ge()),i=ns(Vs(e,s));return Ct(n,i)})}function sa(n,t){return B(()=>ve(mo(Lt(t,n)),-1))}function Yl(n,t){return B(()=>ve(Ls(Lt(t,n)),-1))}function Zl(n,t){return B(()=>{const e=Lt(n,t),s=Ue(Ls(n),ge(),Number.MAX_VALUE),i=Ls(Ct(e,s));return O(100,ve(i,-1))})}function vC(n,t){return B(()=>{const e=Ue(t,ge(),Number.MAX_VALUE),s=ps(ct(1,e)),i=Ue(n,ge(),Number.MAX_VALUE),o=ps(ct(1,i));return ve(mo(Lt(s,o)),-1)})}function CC(n,t){return B(()=>{const e=Vs(0,Lt(1,O(n,t)));return ve(mo(e),-1)})}function kC(n,t){return B(()=>{const e=Vs(0,Lt(1,O(n,t)));return ve(e,-1)})}function SC(n,t){return B(()=>{const e=Et(O(n,t),-1),s=ci(O(Lt(1,n),t),-1);return Vs(0,ct(1,Lt(s,e)))})}function IC(n,t){return B(()=>{const e=Math.log(2),s=Lt(t,n),i=Lt(ct(s,Kr(O(-2,s))),e);return ve(i,-1)})}function no(n,t,e=!1){return B(()=>{if(e)t=Il(t);else{const s=Et(t,t.shape.length-1,!0);t=Ct(t,s)}return t=Ue(t,ge(),1-ge()),Fe(Et(O(mt(n,"float32"),ps(t)),t.shape.length-1))})}function tr(n,t,e=!1){return B(()=>{const s=mt(Qu(Hv(n)),"int32");t=Ue(t,ge(),1-ge());const i=t.shape,o=Q(xp(s,i[i.length-1]),i);return no(o,t,e)})}function NC(n,t){if(!ke(n.shape,t.shape))throw new M(`logits and labels must have the same shape, but got shapes ${JSON.stringify(n.shape)} and ${JSON.stringify(t.shape)}`);return B(()=>{const e=Si(t),s=Fe(Ls(t));return ct(Lt(e,O(t,n)),mp(Qn(s)))})}function ia(n,t){return B(()=>{let e;return e=Ue(t,ge(),1-ge()),e=ps(Ct(e,Lt(1,e))),ve(NC(n,e),-1)})}function $C(n,t){return B(()=>{const e=Ue(n,ge(),1),s=Ue(t,ge(),1);return Et(O(n,ps(Ct(e,s))),-1)})}function DC(n,t){return B(()=>{const e=ps(ct(ge(),t));return ve(Lt(t,O(n,e)),-1)})}function Nm(n,t){return B(()=>{const e=Jo(n,-1),s=Jo(t,-1),i=O(e,s);return Fe(Et(i,-1))})}const er={meanSquaredError:sa,meanAbsoluteError:Yl,meanAbsolutePercentageError:Zl,meanSquaredLogarithmicError:vC,squaredHinge:CC,hinge:kC,categoricalHinge:SC,logcosh:IC,categoricalCrossentropy:no,sparseCategoricalCrossentropy:tr,binaryCrossentropy:ia,kullbackLeiblerDivergence:$C,poisson:DC,cosineProximity:Nm};function La(n){if(typeof n=="string"){if(n in er)return er[n];let t=`Unknown loss ${n}`;throw n.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${n}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new M(t)}else return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function $m(n,t){return B(()=>{const e=O(.5,un(t)),s=Pn(Wn(t,e),n.dtype);return ve(ts(n,s),-1)})}function Dm(n,t){return B(()=>Pn(ts(li(n,-1),li(t,-1)),"float32"))}function RC(n,t){return B(()=>mt(Et(vi(ts(n,1),ts(t,1))),"float32"))}function AC(n,t){return B(()=>mt(Et(vi(ts(n,0),ts(t,1))),"float32"))}function TC(n,t){return B(()=>{const e=RC(n,t),s=AC(n,t),i=ct(e,s);return mt(Zn(Wn(i,0),Ct(e,i),0),"float32")})}function zC(n,t){return ia(n,t)}function FC(n,t){return n.rank===t.rank&&(n=Xt(n,[n.rank-1])),t=li(t,-1),t.dtype!==n.dtype&&(t=mt(t,n.dtype)),mt(ts(n,t),"float32")}const MC=sa,PC=sa,EC=Yl,LC=Yl,OC=Zl,_C=Zl,Rm=no,BC=Nm,Am=tr,nr={binaryAccuracy:$m,categoricalAccuracy:Dm,precision:TC,categoricalCrossentropy:Rm,sparseCategoricalCrossentropy:Am,mse:MC,MSE:PC,mae:EC,MAE:LC,mape:OC,MAPE:_C,cosine:BC};function WC(n){if(typeof n=="string"&&n in nr)return nr[n];if(typeof n!="string"&&n!=null)return n;throw new M(`Unknown metric ${n}`)}function _o(n){if(Tn(n!==null,`Unknown LossOrMetricFn ${n}`),typeof n=="string")return n;{let t;for(const e of Object.keys(er))if(er[e]===n){t=e;break}if(t!==void 0)return t;for(const e of Object.keys(nr))if(nr[e]===n){t=e;break}return t!==void 0?t:n.name}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function VC(n){const t={Adagrad:()=>Js.adagrad(.01),Adadelta:()=>Js.adadelta(1,.95,ge()),Adam:()=>Js.adam(.001,.9,.999,ge()),Adamax:()=>Js.adamax(.002,.9,.999,ge(),0),RMSProp:()=>Js.rmsprop(.001,.9,0,ge()),SGD:()=>Js.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,n in t)return t[n]();throw new M(`Unknown Optimizer ${n}`)}/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const xh=1*1024*1024;function wh(n,t,e=!1){if(n==null||typeof n!="object"||Object.getPrototypeOf(n)!==Object.prototype||!iu(n))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(e){const s=JSON.stringify(n);s.length>xh&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${s.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${xh}.`)}}function iu(n){if(n===null)return!0;if(typeof n=="object")if(Object.getPrototypeOf(n)===Object.prototype){const t=Object.keys(n);for(const e of t)if(typeof e!="string"||!iu(n[e]))return!1;return!0}else if(Array.isArray(n)){for(const t of n)if(!iu(t))return!1;return!0}else return!1;else{const t=typeof n;return t==="string"||t==="number"||t==="boolean"}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function UC(n,t,e,s=console.log){const i=HC(n),o=["Layer (type)","Input Shape","Output shape","Param #"];i?(t=t||90,e=e||[.32,.61,.89,1]):(t=t||115,e=e||[.24,.48,.7,.8,1]),e[e.length-1]<=1&&(e=e.map(c=>Math.floor(t*c)));let r;if(!i){o.push("Receives inputs"),r=[];for(const c in n.nodesByDepth)r.push(...n.nodesByDepth[c])}s("_".repeat(t)),sr(o,e,s),s("=".repeat(t));const a=n.layers;for(let c=0;c<a.length;++c)i?jC(a[c],e,s):KC(a[c],e,r,s),s((c===a.length-1?"=":"_").repeat(t));n.checkTrainableWeightsConsistency();const u=GC(n),l=Yo(n.nonTrainableWeights);s(`Total params: ${u+l}`),s(`Trainable params: ${u}`),s(`Non-trainable params: ${l}`),s("_".repeat(t))}function GC(n){let t;return n.collectedTrainableWeights!=null?t=Yo(n.collectedTrainableWeights):t=Yo(n.trainableWeights),t}function HC(n){let t=!0;const e=[],s=[];for(const i in n.nodesByDepth)e.push(n.nodesByDepth[i]);for(const i of e){if(i.length>1||i.length===1&&i[0].inboundLayers.length>1){t=!1;break}s.push(...i)}if(t)for(const i of n.layers){let o=!1;for(const r of i.inboundNodes)if(s.indexOf(r)!==-1)if(o){t=!1;break}else o=!0;if(!t)break}return t}function sr(n,t,e=console.log){let s="";for(let i=0;i<n.length;++i)i>0&&(s=s.slice(0,s.length-1)+" "),s+=n[i],s=s.slice(0,t[i]),s+=" ".repeat(t[i]-s.length);e(s)}function jC(n,t,e){let s,i;try{i=n.inboundNodes.map(u=>JSON.stringify(u.inputShapes)).join(",")}catch{i="multiple"}try{s=JSON.stringify(n.outputShape)}catch{s="multiple"}const o=n.name,r=n.getClassName(),a=[`${o} (${r})`,i,s,n.countParams().toString()];sr(a,t,e)}function KC(n,t,e,s){let i,o;try{o=n.inboundNodes.map(h=>JSON.stringify(h.inputShapes)).join(",")}catch{o="multiple"}try{i=JSON.stringify(n.outputShape)}catch{i="multiple"}const r=[];for(const h of n.inboundNodes)if(!(e!=null&&e.length>0&&e.indexOf(h)===-1))for(let p=0;p<h.inboundLayers.length;++p){const f=h.inboundLayers[p].name,m=h.nodeIndices[p],g=h.tensorIndices[p];r.push(`${f}[${m}][${g}]`)}const a=n.name,u=n.getClassName(),l=r.length===0?"":r[0],c=[`${a} (${u})`,o,i,n.countParams().toString(),l];sr(c,t,s);for(let h=1;h<r.length;++h)sr(["","","","",r[h]],t,s)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Tm(n,t,e){return(n==="inboundNodes"||n==="outputLayers"||n==="inputLayers")&&t===0&&typeof e=="string"}function ou(n,t){if(n===null)return null;if(typeof n=="string")return Ds(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const e=[],s=n.length;for(let i=0;i<s;++i){const o=n[i];Tm(t,i,o)?e.push(o):e.push(ou(o,t))}return e}else{const e={};for(const s of Object.keys(n)){const i=n[s];if(s==="name"&&typeof i=="string")e[s]=i;else{const o=Ds(s);e[o]=ou(i,o)}}return e}}function ru(n,t){if(n==null)return null;if(typeof n=="string")return Hn(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const e=[],s=n.length;for(let i=0;i<s;++i){const o=n[i];Tm(t,i,o)?e.push(o):e.push(ru(o,t))}return e}else{const e={};for(const s of Object.keys(n)){const i=n[s],o=Hn(s);(s==="name"||s==="className")&&typeof i=="string"?e[o]=i:e[o]=ru(i,s)}return e}}/** @license See the LICENSE file. */const zm="4.20.0";/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const XC=n=>{const t=Object.keys(n);if(t.length===0)return!1;const e=t[0].split("/");return!isNaN(parseInt(e[e.length-1],10))};class mn extends Ft{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,this.name==null){const w=this.getClassName().toLowerCase();this.name=ta(w)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],hs(this.inputs).length!==this.inputs.length)throw new M(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(w=>w.name)}`);hs(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(w=>w.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const w of this.outputs){const k=w.sourceLayer,C=w.nodeIndex,I=w.tensorIndex;this.outputLayers.push(k),this.outputLayersNodeIndices.push(C),this.outputLayersTensorIndices.push(I)}for(const w of this.inputs){const k=w.sourceLayer,C=w.nodeIndex,I=w.tensorIndex;Tn(C===0,"input layer has >1 nodes"),Tn(I===0,"input layer has >1 tensors"),this.inputLayers.push(k),this.inputLayersNodeIndices.push(C),this.inputLayersTensorIndices.push(I)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let w=0;w<this.inputLayers.length;w++){const k=this.inputLayers[w];if(!(k instanceof yo))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${w} (0-based) originates from layer type ${k.getClassName()}.`);this.inputNames.push(k.name),this.feedInputShapes.push(k.batchInputShape),this.feedInputNames.push(k.name)}for(const w of this.outputLayers)this.outputNames.push(w.name);this.internalInputShapes=this.inputs.map(w=>w.shape),this.internalOutputShapes=this.outputs.map(w=>w.shape);const e={},s={},i={},o={},r={},a=[],u=(w,k,C,I,N,$)=>{(I==null||N==null||$==null)&&(I=w.sourceLayer,N=w.nodeIndex,$=w.tensorIndex);const A=I.inboundNodes[N];if(C.indexOf(A)!==-1)throw new an(`The tensor ${w.name} at layer "${I.name}" is part of a cycle.`);if(k.indexOf(A)!==-1)return;this.containerNodes.add(mn.nodeKey(I,N)),I.id in r||(r[I.id]=Object.keys(r).length),C.indexOf(A)===-1&&C.push(A);const z=A.inboundLayers.length;for(let F=0;F<z;F++){const E=A.inputTensors[F],U=A.inboundLayers[F],L=A.nodeIndices[F],W=A.tensorIndices[F];u(E,k,C,U,L,W)}for(k.push(A);C.indexOf(A)>=0;)C.splice(C.indexOf(A),1);a.push(A)},l=[],c=[];for(const w of this.outputs)u(w,l,c);const h=a.slice().reverse();for(const w of h){s[w.id]=w,w.id in e||(e[w.id]=0);let k=e[w.id];const C=i[w.outboundLayer.id]==null?0:i[w.outboundLayer.id];k=Math.max(k,C),i[w.outboundLayer.id]=k,o[w.outboundLayer.id]=w.outboundLayer,e[w.id]=k;for(let I=0;I<w.inboundLayers.length;I++){const N=w.inboundLayers[I],$=w.nodeIndices[I],A=N.inboundNodes[$],z=e[A.id]==null?0:e[A.id];e[A.id]=Math.max(k+1,z),s[A.id]=A}}const p={};for(const w in e){const k=e[w];k in p||(p[k]=[]),p[k].push(s[w])}const f={};for(const w in i){const k=i[w];k in f||(f[k]=[]),f[k].push(o[w])}let m=Object.keys(f).map(w=>parseInt(w,10)).sort(Eo);this.layers=[];for(const w of m){const k=f[w];k.sort((C,I)=>{const N=r[C.id],$=r[I.id];return N<$?-1:N>$?1:0});for(const C of k)C instanceof mn&&this.internalContainerRefs.push(C),this.layers.push(C)}this.layersByDepth=f,m=Object.keys(p).map(w=>parseInt(w,10)).sort(Eo);const g=this.inputs.slice(),b=[];for(const w of m)for(const k of p[w]){const C=k.outboundLayer;if(C!=null){for(const I of k.inputTensors)if(g.indexOf(I)===-1)throw new an(`Graph disconnected: cannot obtain value for tensor ${I} at layer "${C.name}". The following previous layers were accessed without issue: ${b}`);for(const I of k.outputTensors)g.push(I);b.push(C.name)}}this.nodesByDepth=p;const v=this.layers.map(w=>w.name);for(const w of v){const k=v.filter(C=>C===w).length;if(k!==1)throw new an(`The name "${w}" is used ${k} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(v))}this.outboundNodes=[],this.inboundNodes=[],new na({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(w=>null),outputMasks:this.outputs.map(w=>null),inputShapes:this.inputs.map(w=>w.shape),outputShapes:this.outputs.map(w=>w.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const t={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(const e of this.layers)t.numDisposedVariables+=e.dispose().numDisposedVariables;for(const e of this.internalContainerRefs)t.numDisposedVariables+=e.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(e=>{e._trainableWeights.forEach(s=>s.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new M("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(const e of this.layers)t=t.concat(e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.layers)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const s of this.layers)e.push(...s.trainableWeights);return e.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,e=!0){const s={};let i=0;const o=XC(t);o&&this.parseWeights(t);for(const a of this.layers)for(const[u,l]of a.weights.entries()){const c=o?`${l.name.split("/").slice(0,-1).join("/")+"/"}${u}`:l.originalName;if(s[c]!=null)throw new M(`Duplicate weight name: ${c}`);s[c]=l,i++}const r=[];for(const a in t){let u=a;if(s[a]==null){const l=a.split("/");u=l.slice(0,-2).concat([l[l.length-1]]).join("/")}if(s[u]!=null)r.push([s[u],t[a]]);else if(e)throw new M(`Provided weight data has no target variable: ${a}`);delete s[u]}if(e){const a=[];for(const u in s)a.push(u);if(a.length>0)throw new M(`${a.length} of ${i} weights are not set: ${a}`)}Xl(r)}parseWeights(t){for(const e in Object.keys(t)){const s=e.split("/"),i=["vars","layer_checkpoint_dependencies"],o=s.map(r=>r.startsWith("_")?r.slice(1):r).filter(r=>!i.includes(r)).join("/");o!==e&&(t[o]=t[e],delete t[e])}}updatedConfig(){const t=this.getConfig(),e={};return e.className=this.getClassName(),e.config=t,e.kerasVersion=`tfjs-layers ${zm}`,e.backend="TensorFlow.js",e}toJSON(t,e=!0){const s=ru(this.updatedConfig());return e?JSON.stringify(s):s}call(t,e){return B(()=>{t=Kt(t);const s=new as;for(let i=0;i<this.inputs.length;++i)s.add(this.inputs[i],t[i]);return Hi(this.outputs,s,e)})}computeMask(t,e){return B(()=>{t=Kt(t);let s;return e==null?s=Os(null,t.length):s=Kt(e),this.runInternalGraph(t,s)[1]})}computeOutputShape(t){const e=qo(t);if(e.length!==this.inputLayers.length)throw new M(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);const s={};for(let a=0;a<e.length;a++){const u=this.inputLayers[a],l=e[a],c=u.name+"_0_0";s[c]=l}const i=Object.keys(this.nodesByDepth).map(a=>parseInt(a,10)).sort(Eo);if(i.length>1)for(const a of i){const u=this.nodesByDepth[a];for(const l of u){const c=l.outboundLayer;if(this.inputLayers.map(g=>g.id).indexOf(c.id)!==-1)continue;const h=[];for(let g=0;g<l.inboundLayers.length;g++){const b=l.inboundLayers[g],v=l.nodeIndices[g],w=l.tensorIndices[g],k=`${b.name}_${v}_${w}`,C=s[k];h.push(C)}const p=c.computeOutputShape(Pe(h)),f=qo(p),m=c.inboundNodes.indexOf(l);for(let g=0;g<f.length;g++){const b=`${c.name}_${m}_${g}`;s[b]=f[g]}}}const o=[],r=[];for(let a=0;a<this.outputLayers.length;a++){const u=this.outputLayers[a],l=this.outputLayersNodeIndices[a],c=this.outputLayersTensorIndices[a],h=`${u.name}_${l}_${c}`;r.push(h)}for(let a=0;a<r.length;a++){const u=r[a];Tn(u in s),o.push(s[u])}return Pe(o)}runInternalGraph(t,e){e==null&&(e=Os(null,t.length));const s={};for(let u=0;u<this.inputs.length;++u){const l=this.inputs[u],c=t[u],h=e[u];s[l.id]=[c,h]}const i=Object.keys(this.nodesByDepth).map(u=>parseInt(u,10)).sort(Eo);for(const u of i){const l=this.nodesByDepth[u];for(const c of l){const h=c.outboundLayer,p=c.inputTensors,f=c.outputTensors,m=new Array;for(const g of p)g.id in s&&m.push(s[g.id]);if(m.length===p.length){let g={},b,v,w,k;if(c.callArgs!=null&&(g=c.callArgs),m.length===1){const[C,I]=m[0];g.mask==null&&(g.mask=I),w=Kt(h.call(C,g)),k=Kt(h.computeMask(C,I)),b=[C],v=[I]}else b=m.map(C=>C[0]),v=m.map(C=>C[1]),g.mask==null&&(g.mask=v),w=Kt(h.call(b,g)),k=Kt(h.computeMask(b,v));if(h.activityRegularizer)throw new At("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let C=0;C<f.length;++C){const I=f[C],N=w[C],$=k[C];s[I.id]=[N,$]}}}}const o=[],r=[],a=[];for(const u of this.outputs){Tn(u.id in s,`Could not compute output ${u.name} : ${u.id}`);const[l,c]=s[u.id];a.push(l.shape),o.push(l),r.push(c)}return[o,r,a]}buildNodeConversionMap(t){const e={};let s;for(const i of this.layers){s=i instanceof mn?1:0;for(let o=0;o<i.inboundNodes.length;o++){const r=mn.nodeKey(i,o);this.containerNodes.has(r)&&(e[r]=s,s+=1)}}return e}getLayer(t,e){if(e!=null)return this.findLayer(e);if(t==null)throw new M("Provide either a layer name or layer index");if(typeof t=="number")return this.findLayer(t);for(const s of this.layers)if(s.name===t)return s;throw new M(`No such layer: ${t}`)}findLayer(t){if(this.layers.length<=t)throw new M(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}calculateLosses(){return B(()=>{const t=[];for(const e of this.layers)for(let s=0;s<e.inboundNodes.length;++s){const i=mn.nodeKey(e,s);this.containerNodes.has(i)&&t.push(...e.calculateLosses())}return t})}getConfig(){const t={name:this.name},e=this.buildNodeConversionMap(this.layers),s=[];for(const r of this.layers){const a=r.getClassName(),u=r.getConfig(),l=[];for(let h=0;h<r.inboundNodes.length;h++){const p=r.inboundNodes[h],f=mn.nodeKey(r,h);let m={};if(this.containerNodes.has(f)){if(p.callArgs)try{JSON.stringify(p.callArgs),m=p.callArgs}catch{console.warn(`Layer ${r.name} was passed non-serializable keyword arguments: ${p.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),m={}}if(p.inboundLayers.length>0){const g=[];for(let b=0;b<p.inboundLayers.length;b++){const v=p.inboundLayers[b],w=p.nodeIndices[b],k=p.tensorIndices[b],C=mn.nodeKey(v,w);let I=e[C];I==null&&(I=0),g.push([v.name,I,k,m])}l.push(g)}}}const c={};c.name=r.name,c.className=a,c.config=u,c.inboundNodes=l,s.push(c)}t.layers=s;const i=[];for(let r=0;r<this.inputLayers.length;r++){const a=this.inputLayers[r],u=this.inputLayersNodeIndices[r],l=mn.nodeKey(a,u);if(!this.containerNodes.has(l))continue;let c=e[l];c==null&&(c=0);const h=this.inputLayersTensorIndices[r];i.push([a.name,c,h])}t.inputLayers=i;const o=[];for(let r=0;r<this.outputLayers.length;r++){const a=this.outputLayers[r],u=this.outputLayersNodeIndices[r],l=mn.nodeKey(a,u);if(!this.containerNodes.has(l))continue;let c=e[l];c==null&&(c=0);const h=this.outputLayersTensorIndices[r];o.push([a.name,c,h])}return t.outputLayers=o,t}static fromConfig(t,e,s={},i=!1){const o={},r={};function a(b,v){b.name in r?r[b.name].push(v):r[b.name]=[v]}function u(b,v){const w=[];let k;for(const C of v){const I=C[0],N=C[1],$=C[2];if(k=C[3]==null?{}:C[3],!(I in o)){a(b,v);return}const A=o[I];if(A.inboundNodes.length<=N){a(b,v);return}const z=A.inboundNodes[N];w.push(z.outputTensors[$])}w.length>0&&b.apply(Pe(w),k)}function l(b){const v=b.name,w=qn(b,e.customObjects!=null?e.customObjects:{});w.setFastWeightInitDuringBuild(i),o[v]=w,b.inboundNodes.forEach(C=>{if(!(C instanceof Array))throw new M(`Corrupted configuration, expected array for nodeData: ${C}`);a(w,C)})}const c=e.name,h=e.layers;for(const b of h)l(b);for(;!zv(r);)for(const b of h){const v=o[b.name];if(v.name in r){const w=r[v.name];delete r[v.name];for(const k of w)u(v,k)}}const p=[],f=[],m=e.inputLayers;for(const b of m){const v=b[0],w=b[1],k=b[2];Tn(v in o);const I=o[v].inboundNodes[w].outputTensors;p.push(I[k])}const g=e.outputLayers;for(const b of g){const v=b[0],w=b[1],k=b[2];Tn(v in o);const I=o[v].inboundNodes[w].outputTensors;f.push(I[k])}return new t({inputs:p,outputs:f,name:c})}get stateful(){if(this._stateful)throw new M("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const t of this.layers)if(t.stateful)return!0;return!1}resetStates(){B(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function qC(n,t,e){const s=t.length;if(n==null||Array.isArray(n)&&n.length===0)return t.map(i=>null);if(s===1)return Array.isArray(n)&&n.length===1?n:typeof n=="object"&&t[0]in n?[n[t[0]]]:[n];if(Array.isArray(n)){if(n.length!==s)throw new Error(`Provided ${e} is an array of ${n.length} element(s), but the model has ${s} outputs. Make sure a set of weights is provided for each model output.`);return n}else if(typeof n=="object"&&Object.keys(n).length>0&&typeof n[Object.keys(n)[0]]=="object"){const i=[];return t.forEach(o=>{o in n?i.push(n[o]):i.push(null)}),i}else throw new Error(`The model has multiple (${s}) outputs, so ${e} must be either an array with ${s} elements or an object with ${t} keys. Provided ${e} not understood: ${JSON.stringify(n)}`)}function Fm(n,t){return qC(n,t,"classWeight")}async function Mm(n,t,e,s){if(e!=null){const i=B(()=>{if(n.shape.length===1)return Rw(n);if(n.shape.length===2){if(n.shape[1]>1)return li(n,1);if(n.shape[1]===1)return Q(n,[n.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${n.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${n.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),o=Array.from(await i.data());zt(i);const r=[];return o.forEach(a=>{if(e[a]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${a} exists in the data but not in classWeight`);r.push(e[a])}),jn(r,"float32")}else return null}function YC(n,t){return O(n,t)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const ZC=32;function Pm(n,t){let e,s;const i=t;e=i.xs,s=i.ys,tt(e!=null&&s!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);const o=vh("input",n.inputNames,e),r=vh("output",n.outputNames,s),a=o[0].shape[0];tt(o.length===n.inputs.length,()=>`LayersModel has ${n.inputs.length} inputs, but the dataset provides ${o.length} inputs.  (Expected input keys: ${JSON.stringify(n.inputNames)})`),tt(r.length===n.outputs.length,()=>`LayersModel has ${n.outputs.length} outputs, but the dataset provides ${r.length} outputs.  (Expected output keys: ${JSON.stringify(n.outputNames)})`);for(let u=0;u<o.length;u++)tt(o[u].shape[0]===a,()=>`Batch size mismatch: input ${n.inputNames[u]} has ${o[u].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);for(let u=0;u<r.length;u++)tt(r[u].shape[0]===a,()=>`Batch size mismatch: output ${n.outputNames[u]} has ${r[u].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);return{xs:o,ys:r}}function vh(n,t,e){if(e instanceof Ge)return[e];if(Array.isArray(e))return tt(e.length===t.length,()=>`Received an array of ${e.length} Tensors, but expected ${t.length} to match the ${n} keys ${t}.`),e;{const s=[];for(const i of t){if(e[i]==null)throw new M(`The feature data generated by the dataset lacks the required ${n} key '${i}'.`);s.push(e[i])}return s}}function QC(n){if(n.length===3)throw new At("Validation with sample weights is not implemented yet.");return{xs:n[0],ys:n[1]}}async function JC(n,t,e){const s=e.batchesPerEpoch!=null;if(tt(n.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),tt(e!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),tt(e.epochs!=null&&e.epochs>0&&Number.isInteger(e.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${e.epochs}`),tt(!s||e.batchesPerEpoch>0&&Number.isInteger(e.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${e.batchesPerEpoch}`),tt(e.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),n.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");n.isTraining=!0;try{const i=e.validationData!=null;let o,r;if(i)if(Ch(e.validationData))tt(e.validationBatches==null||e.validationBatches>0&&Number.isInteger(e.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${e.validationBatches}`);else{const b=QC(e.validationData);o=b.xs,r=b.ys}const a=n.makeTrainFunction(),u=n.getDedupedMetricsNames();let l;i?l=u.slice().concat(u.map(b=>"val_"+b)):l=u.slice();const c=Sm(e.callbacks,e.yieldEvery),h=e.verbose==null?1:e.verbose,{callbackList:p,history:f}=Im(c,h,e.epochs,null,null,tk(t,e),null,i,l);p.setModel(n),n.history=f,await p.onTrainBegin(),n.stopTraining_=!1;let m=e.initialEpoch==null?0:e.initialEpoch,g=await t.iterator();for(;m<e.epochs;){const b={};await p.onEpochBegin(m);let v=0,w=0;for(s||(g=await t.iterator());!s||v<e.batchesPerEpoch;){const k=await g.next();if(s&&k.done){console.warn(`You provided \`batchesPerEpoch\` as ${e.batchesPerEpoch}, but your dataset iterator ran out of data after ${v} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${e.batchesPerEpoch*e.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(k.value!=null){const{xs:C,ys:I}=Pm(n,k.value),N={};N.batch=w,N.size=C[0].shape[0],await p.onBatchBegin(w,N);const $=[];if(e.classWeight!=null){const F=Fm(e.classWeight,n.outputNames);for(let E=0;E<F.length;++E)$.push(await Mm(I[E],null,F[E]))}const A=C.concat(I).concat($),z=a(A);zt(A);for(let F=0;F<u.length;++F){const E=u[F],U=z[F];N[E]=U,Xn(U)}await p.onBatchEnd(w,N),km(N),w++,v++}if(s?v>=e.batchesPerEpoch:k.done){if(i){let C;Ch(e.validationData)?C=Kt(await n.evaluateDataset(e.validationData,{batches:e.validationBatches})):C=Kt(n.evaluate(o,r,{batchSize:e.validationBatchSize==null?ZC:e.validationBatchSize,verbose:0}));for(let I=0;I<n.metricsNames.length;++I)b[`val_${n.metricsNames[I]}`]=C[I]}break}if(n.stopTraining_)break}if(await p.onEpochEnd(m,b),m++,n.stopTraining_)break}return await p.onTrainEnd(),await n.history.syncData(),n.history}finally{n.isTraining=!1}}function tk(n,t){let e=null;return t.batchesPerEpoch!=null?e=t.batchesPerEpoch:Number.isFinite(n.size)&&(e=n.size),e}function Ch(n){return typeof n.iterator=="function"}function ek(n){return typeof n.next=="function"}async function nk(n,t,e){e=e||{};const s=e.batches!=null,i=n.testFunction;let o=[];if(e.verbose>0)throw new At("Verbose mode is not implemented yet.");tt(!s||e.batches>0&&Number.isInteger(e.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(e.batches)}`);const r=ek(t)?t:await t.iterator();let a=0,u=0;for(;!s||u<e.batches;){const l=await r.next();if(o=B(()=>{if(l.value){const{xs:c,ys:h}=Pm(n,l.value),p=c.concat(h),f=B(()=>i(p));if(zt(p),u===0)for(let g=0;g<f.length;++g)o.push(se(0));const m=p[0].shape[0];for(let g=0;g<f.length;++g){const b=f[g],v=o[g];o[g]=B(()=>ct(o[g],O(m,b))),u>0&&zt(v)}zt(f),a+=m,++u}return o}),l.done){s&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${e.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let l=0;l<o.length;++l){const c=o[l];o[l]=Ct(o[l],a),zt(c)}return Pe(o)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Oa(n){tt(n>0&&Number.isInteger(n),()=>`batchSize is required to be a positive integer, but got ${n}`)}function Vi(n,t,e){return n==null?[null]:Array.isArray(n)?n.map(s=>Ms(s,t,e-t)):Ms(n,t,e-t)}function au(n,t){return B(()=>n==null?null:Array.isArray(n)?n.map(e=>au(e,t)):lm(n,t.dtype==="int32"?t:mt(t,"int32")))}function _a(n,t){const e=[];let s=0,i=null;for(;s<n;)i=s+t,i>=n&&(i=n),e.push([s,i]),s=i;return e}function Em(n){const t=[];n instanceof Ge&&(n=[n]);for(let e=0;e<n.length;++e){const s=n[e];if(s.rank===1)t.push(fo(s,1));else{if(s.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(s)}}return t}function fn(n,t){if(n==null)return;const e=[];if(t instanceof Ge)e.push(t.id);else if(Array.isArray(t))t.forEach(i=>e.push(i.id));else if(t!=null)for(const i in t){const o=t[i];e.push(o.id)}const s=[];if(n instanceof Ge)e.indexOf(n.id)===-1&&s.push(n);else if(Array.isArray(n))n.forEach(i=>{e.indexOf(i.id)===-1&&s.push(i)});else if(n!=null)for(const i in n){const o=n[i];e.indexOf(o.id)===-1&&s.push(o)}s.forEach(i=>{i.isDisposed||i.dispose()})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function sk(n){return n instanceof Ge}function uu(n){return Array.isArray(n)}function kh(n){return!sk(n)&&!uu(n)}function Sh(n,t,e,s=!0,i=""){if(t==null||t.length===0){if(n!=null){let r=!1;if(uu(n)&&n.length>0)r=!0;else if(kh(n)){for(const a in n)if(n.hasOwnProperty(a)){r=!0;break}}else r=!0;if(r)throw new M(`Error when checking model ${i} expected no data, but got ${n}`)}return[]}if(n==null)return t.map(r=>null);let o;if(kh(n)){n=n,o=[];for(const r of t){if(n[r]==null)throw new M(`No data provided for "${r}". Need data for each key in: ${t}`);o.push(n[r])}}else if(uu(n)){if(n=n,n.length!==t.length)throw new M(`Error when checking model ${i}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${n}`);o=n}else{if(n=n,t.length>1)throw new M(`The model ${i} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${n.shape}`);o=[n]}if(o=Em(o),e!=null)for(let r=0;r<t.length;++r){if(e[r]==null)continue;const a=o[r];if(a.shape.length!==e[r].length)throw new M(`Error when checking ${i}: expected ${t[r]} to have ${e[r].length} dimension(s). but got array with shape ${a.shape}`);for(let u=0;u<e[r].length;++u){if(u===0&&!s)continue;const l=a.shape[u],c=e[r][u];if(c!=null&&c>=0&&l!==c)throw new M(`${i} expected a batch of elements where each example has shape [${e[r].slice(1,e[r].length)}] (i.e.,tensor shape [*,${e[r].slice(1,e[r].length)}]) but the ${i} received an input with ${a.shape[0]} examples, each with shape [${a.shape.slice(1,a.shape.length)}] (tensor shape [${a.shape}])`)}}return o}function ik(n,t,e){const s=hs(n.map(o=>o.shape[0]));s.sort();const i=hs(t.map(o=>o.shape[0]));if(i.sort(),s.length>1)throw new M(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(o=>o.shape))}`);if(i.length>1)throw new M(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(o=>o.shape))}`);if(s.length>0&&i.length>0&&!ke(s,i))throw new M(`Input Tensors should have the same number of samples as target Tensors. Found ${s[0]} input sample(s) and ${i[0]} target sample(s).`)}function ok(n,t,e){const s=[sa,ia,no];for(let i=0;i<n.length;++i){const o=n[i],r=t[i],a=e[i];if(r!=null){if(r===no&&o.shape[o.shape.length-1]===1)throw new M(`You are passing a target array of shape ${o.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(s.indexOf(r)!==-1){const u=o.shape.slice(1),l=a.slice(1);for(let c=0;c<u.length;++c){const h=u[c],p=l[c];if(p!=null&&h!==p)throw new M(`A target Tensor with shape ${o.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function Ih(n,t,e,s=!0,i=""){let o;if(Array.isArray(n)){if(n.length!==t.length)throw new M(`Error when checking model ${i}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${n.length} Tensors(s).`);o=n}else{if(t.length>1)throw new M(`The model expects ${t.length} ${i} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(n.shape)}.`);o=[n]}if(e!=null)for(let r=0;r<t.length;++r){if(e[r]==null)continue;const a=o[r];if(a.shape.length!==e[r].length)throw new M(`Error when checking ${i}: expected ${t[r]} to have ${e[r].length} dimension(s), but got array with shape ${JSON.stringify(a.shape)}`);for(let u=0;u<e[r].length;++u){if(u===0&&!s)continue;const l=a.shape[u],c=e[r][u];if(c!=null&&c!==l)throw new M(`Error when checking ${i}: expected ${t[r]} to have shape ${JSON.stringify(e[r])} but got array with shape ${JSON.stringify(a.shape)}.`)}}}function rk(n,t){if(n==null||Array.isArray(n)&&n.length===0)return t.map(s=>[]);let e;if(typeof n=="string"||typeof n=="function")e=[n];else if(Array.isArray(n)||typeof n=="object")e=n;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${n}`);if(Array.isArray(e))return t.map(s=>e);{const s=[];for(const i of t){let o=e.hasOwnProperty(i)?e[i]:[];Array.isArray(o)||(o=[o]),s.push(o)}return s}}const ak="layers-model";class ri extends mn{constructor(t){super(t),this.isTraining=!1}summary(t,e,s=console.log){if(!this.built)throw new M("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");UC(this,t,e,s)}compile(t){if(t.loss==null&&(t.loss=[]),this.loss=t.loss,typeof t.optimizer=="string")this.optimizer_=VC(t.optimizer),this.isOptimizerOwned=!0;else{if(!(t.optimizer instanceof Aw))throw new M("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=t.optimizer,this.isOptimizerOwned=!1}let e=[];if(!Array.isArray(t.loss)&&typeof t.loss!="string"&&typeof t.loss!="function"){t.loss=t.loss;for(const r in t.loss)if(this.outputNames.indexOf(r)===-1)throw new M(`Unknown entry in loss dictionary: "${r}". Only expected the following keys: ${this.outputNames}`);for(const r of this.outputNames)t.loss[r]==null&&console.warn(`Output "${r}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${r} during training`),e.push(La(t.loss[r]))}else if(Array.isArray(t.loss)){if(t.loss.length!==this.outputs.length)throw new M(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${t.loss}.`);e=t.loss.map(a=>La(a))}else{const r=La(t.loss);this.outputs.forEach(a=>{e.push(r)})}this.lossFunctions=e,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let r=0;r<this.outputs.length;++r){const a=this.internalOutputShapes[r],u=this.outputNames[r];this.feedOutputNames.push(u),this.feedOutputShapes.push(a),this.feedLossFns.push(this.lossFunctions[r])}const s=[];this.metrics=t.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Fs("loss",()=>{for(let r=0;r<this.outputs.length;++r){if(s.indexOf(r)!==-1)continue;const a=this.lossFunctions[r];this.outputs.length>1&&(this.metricsTensors.push([a,r]),this.metricsNames.push(this.outputNames[r]+"_loss"))}});const i=rk(t.metrics,this.outputNames),o=(r,a,u)=>{this.outputNames.length>1&&(a=this.outputNames[r]+"_"+a),this.metricsNames.push(a),this.metricsTensors.push([u,r])};Fs("metric",()=>{for(let r=0;r<this.outputs.length;++r){if(s.indexOf(r)!==-1)continue;const a=i[r];(l=>{const c="";let h,p,f;for(const m of l){if(typeof m=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(m)!==-1){const b=this.internalOutputShapes[r];b[b.length-1]===1||this.lossFunctions[r]===ia?["accuracy","acc"].indexOf(m)!==-1?p=$m:["crossentropy","ce"].indexOf(m)!==-1&&(p=zC):this.lossFunctions[r]===tr?["accuracy","acc"].indexOf(m)!==-1?p=FC:["crossentropy","ce"].indexOf(m)!==-1&&(p=Am):["accuracy","acc"].indexOf(m)!==-1?p=Dm:["crossentropy","ce"].indexOf(m)!==-1&&(p=Rm);let v;["accuracy","acc"].indexOf(m)!==-1?v="acc":["crossentropy","ce"].indexOf(m)!==-1&&(v="ce"),f=p,h=c+v}else f=WC(m),h=c+_o(m);let g;Fs(h,()=>{g=f}),o(r,h,g)}})(a)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(t,e,s={}){const i=s.batchSize==null?32:s.batchSize;Oa(i);const r=this.standardizeUserDataXY(t,e,!0,i);try{const a=r[0].concat(r[1]);this.makeTestFunction();const u=this.testFunction,l=this.testLoop(u,a,i,s.verbose,s.steps);return Pe(l)}finally{fn(r[0],t),fn(r[1],e)}}async evaluateDataset(t,e){return this.makeTestFunction(),nk(this,t,e)}checkNumSamples(t,e,s,i="steps"){let o;if(s!=null){if(o=null,e!=null)throw new M(`If ${i} is set, batchSize must be null or undefined.Got batchSize = ${e}`)}else if(t!=null)Array.isArray(t)?o=t[0].shape[0]:o=t.shape[0];else throw new M(`Either the input data should have a defined shape, or ${i} shoud be specified.`);return o}execute(t,e){if(Array.isArray(e)&&e.length===0)throw new M("`outputs` is an empty Array, which is not allowed.");const s=Array.isArray(e),i=s?e:[e],o=this.retrieveSymbolicTensors(i),r=new as;if(t instanceof Ge&&(t=[t]),Array.isArray(t)){if(t.length!==this.inputs.length)throw new M(`The number of inputs provided (${t.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let u=0;u<this.inputs.length;++u)r.add(this.inputs[u],t[u])}else for(const u of this.inputs){const l=t[u.name];if(l==null)throw new M(`No value is provided for the model's input ${u.name}`);r.add(u,l)}const a=Hi(o,r);return s?a:a[0]}retrieveSymbolicTensors(t){const e=Os(null,t.length);let s=t.length;for(const i of this.layers){const o=Array.isArray(i.output)?i.output:[i.output],r=o.map(a=>a.name);for(let a=0;a<t.length;++a){const u=r.indexOf(t[a]);if(u!==-1&&(e[a]=o[u],s--),s===0)break}if(s===0)break}if(s>0){const i=[];throw e.forEach((o,r)=>{o==null&&i.push(t[r])}),new M(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(i)}`)}return e}predictLoop(t,e=32,s=!1){return B(()=>{const i=this.checkNumSamples(t);if(s)throw new At("Verbose predictLoop() is not implemented yet.");const o=_a(i,e),r=this.outputs.map(a=>[]);for(let a=0;a<o.length;++a)B(()=>{const l=o[a][0],c=o[a][1],h=Vi(t,l,c),p=[];if(Array.isArray(h))for(let m=0;m<h.length;++m)p.push({key:this.inputs[m],value:h[m]});else p.push({key:this.inputs[0],value:h});const f=new as(p);return Hi(this.outputs,f)}).forEach((l,c)=>r[c].push(l));return Pe(r.map(a=>fs(a,0)))})}predict(t,e={}){const s=Em(t);Ih(s,this.inputNames,this.feedInputShapes,!1);try{const i=e.batchSize==null?32:e.batchSize;return Oa(i),this.predictLoop(s,i)}finally{fn(s,t)}}predictOnBatch(t){Ih(t,this.inputNames,this.feedInputShapes,!0);const e=(Array.isArray(t)?t[0]:t).shape[0];return this.predictLoop(t,e)}standardizeUserDataXY(t,e,s=!0,i){if(this.optimizer_==null)throw new an("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const o=[];for(let r=0;r<this.feedOutputShapes.length;++r){const a=this.feedOutputShapes[r];this.feedLossFns[r]===tr?o.push(a.slice(0,a.length-1).concat([1])):o.push(a)}if(t=Sh(t,this.feedInputNames,this.feedInputShapes,!1,"input"),e=Sh(e,this.feedOutputNames,o,!1,"target"),ik(t,e),ok(e,this.feedLossFns,this.feedOutputShapes),this.stateful&&i!=null&&i>0&&t[0].shape[0]%i!==0)throw new M(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${i}. Found: ${t[0].shape[0]} sample(s).`);return[t,e]}async standardizeUserData(t,e,s,i,o=!0,r){const[a,u]=this.standardizeUserDataXY(t,e,o,r);if(s!=null)throw new Error("sample weight is not supported yet.");let l=null;if(i!=null){const c=Fm(i,this.outputNames);l=[];for(let h=0;h<c.length;++h)l.push(await Mm(u[h],null,c[h]))}return[a,u,l]}testLoop(t,e,s,i=0,o){return B(()=>{const r=this.checkNumSamples(e,s,o,"steps"),a=[];if(i>0)throw new At("Verbose mode is not implemented yet.");if(o!=null)throw new At("steps mode in testLoop() is not implemented yet");{const u=_a(r,s),l=jn(bn(0,r));for(let c=0;c<u.length;++c){const h=u[c][0],p=u[c][1],f=Ms(l,h,p-h),m=au(e,f),g=t(m);if(c===0)for(let b=0;b<g.length;++b)a.push(se(0));for(let b=0;b<g.length;++b){const v=g[b];a[b]=ct(a[b],O(p-h,v))}}for(let c=0;c<a.length;++c)a[c]=Ct(a[c],r)}return a})}getDedupedMetricsNames(){const t=this.metricsNames,e=[];for(let s=0;s<t.length;++s){const i=t[s];let o=i;if(lh(t,i)>1){const r=lh(t.slice(0,s),i);o+=`_${r}`}e.push(o)}return e}makeTrainFunction(){return t=>{const e=[],s=t.slice(0,this.inputs.length),i=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),o=t.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),r=[],a=()=>{const h=[];for(let g=0;g<this.inputs.length;++g)h.push({key:this.inputs[g],value:s[g]});const p=new as(h),f=Hi(this.outputs,p,{training:!0});let m;for(let g=0;g<this.lossFunctions.length;++g){const b=this.lossFunctions[g];let v=b(i[g],f[g]);o[g]!=null&&(v=YC(v,o[g]));const w=ve(v);e.push(w),g===0?m=v:m=ct(m,v)}for(let g=0;g<this.metricsTensors.length;++g){let b;if(this.outputs.length>1&&g<this.outputs.length)b=e[g];else{const v=this.metricsTensors[g][0],w=this.metricsTensors[g][1];b=ve(v(i[w],f[w]))}Xn(b),r.push(b)}return m=ve(m),this.calculateLosses().forEach(g=>{m=ct(m,g)}),m},u=this.collectedTrainableWeights.map(h=>h.read());return[this.optimizer_.minimize(a,!0,u)].concat(r)}}makeTestFunction(){this.testFunction=t=>B(()=>{const e=[];let s;const i=t.slice(0,this.inputs.length),o=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),r=[];for(let l=0;l<this.inputs.length;++l)r.push({key:this.inputs[l],value:i[l]});const a=new as(r),u=Hi(this.outputs,a);for(let l=0;l<this.lossFunctions.length;++l){const c=this.lossFunctions[l],h=ve(c(o[l],u[l]));l===0?s=h:s=ct(s,h),e.push(s)}for(let l=0;l<this.metricsTensors.length;++l){const c=this.metricsTensors[l][0],h=this.metricsTensors[l][1],p=ve(c(o[h],u[h]));e.push(p)}return e})}async fit(t,e,s={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let i,o,r,a,u,l,c,h,p;try{const f=s.batchSize==null?32:s.batchSize;Oa(f);const g=await this.standardizeUserData(t,e,s.sampleWeight,s.classWeight,!1,f);i=g[0],o=g[1],p=g[2];let b=!1,v;if(s.validationData!=null&&s.validationData.length>0){if(b=!0,s.validationData.length===2)u=s.validationData[0],l=s.validationData[1];else throw s.validationData.length===3?new At("validationData including sample weights is not supported yet."):new M(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${s.validationData} is invalid.`);const F=await this.standardizeUserData(u,l,null,null,!0,f);c=F[0],h=F[1],v=c.concat(h)}else if(s.validationSplit!=null&&s.validationSplit>0&&s.validationSplit<1){b=!0;const z=Math.floor(i[0].shape[0]*(1-s.validationSplit)),F=i[0].shape[0];c=Vi(i,z,F),r=i,i=Vi(i,0,z),h=Vi(o,z,F),a=o,o=Vi(o,0,z),v=c.concat(h)}else s.validationSteps!=null&&(b=!0);const w=i.concat(o).concat(p);this.checkTrainableWeightsConsistency();const k=this.makeTrainFunction(),C=this.getDedupedMetricsNames();let I,N;b?(this.makeTestFunction(),I=this.testFunction,N=C.slice().concat(C.map(z=>"val_"+z))):(I=null,v=[],N=C.slice());const $=Sm(s.callbacks,s.yieldEvery);return await this.fitLoop(k,w,C,f,s.epochs,s.verbose,$,I,v,s.shuffle,N,s.initialEpoch,null,null)}finally{this.isTraining=!1,fn(i,t),fn(o,e),fn(r,t),fn(a,e),fn(c,u),fn(h,l),p!=null&&zt(p)}}async fitLoop(t,e,s,i,o,r,a,u,l,c,h,p,f,m){i==null&&(i=32),o==null&&(o=1),c==null&&(c=!0),p==null&&(p=0);let g=!1;if(u!=null&&l!=null&&(g=!0),m!=null&&(g=!0,f==null))throw new M("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const b=this.checkNumSamples(e,i,f,"steps_per_epoch");let v;b!=null&&(v=bn(0,b)),r==null&&(r=1);const{callbackList:w,history:k}=Im(a,r,o,p,b,f,i,g,h);w.setModel(this),this.history=k,await w.onTrainBegin(),this.stopTraining_=!1;for(let C=p;C<o;++C){await w.onEpochBegin(C);const I={};if(f!=null)throw new At("stepsPerEpoch mode is not implemented yet.");{if(c==="batch")throw new At("batch shuffling is not implemneted yet");c&&Tw(v);const N=jn(v),$=_a(b,i);for(let A=0;A<$.length;++A){const z={};if(await w.onBatchBegin(A,z),B(()=>{const F=$[A][0],E=$[A][1],U=Ms(N,F,E-F);z.batch=A,z.size=E-F;const L=au(e,U),W=t(L);for(let _=0;_<s.length;++_){const V=s[_],X=W[_];z[V]=X,Xn(X)}if(A===$.length-1&&g){const _=this.testLoop(u,l,i);for(let V=0;V<s.length;++V){const X=s[V],j=_[V];Xn(j),I["val_"+X]=j}}}),await w.onBatchEnd(A,z),km(z),this.stopTraining_)break}N.dispose()}if(await w.onEpochEnd(C,I),this.stopTraining_)break}return await w.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(t,e){return JC(this,t,e)}async trainOnBatch(t,e){const s=await this.standardizeUserData(t,e),i=s[0],o=s[1],a=this.makeTrainFunction()(i.concat(o)),u=[];for(const l of a){const c=await l.data();u.push(c[0])}return zt(a),fn(s[0],t),fn(s[1],e),Pe(u)}getNamedWeights(t){const e=[],s=t!=null&&t.trainableOnly,i=s?this.trainableWeights:this.weights,o=this.getWeights(s);for(let r=0;r<i.length;++r)s&&!i[r].trainable||e.push({name:i[r].originalName,tensor:o[r]});return e}set stopTraining(t){this.stopTraining_=t}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(t){this.optimizer_!==t&&(this.optimizer_=t,this.isOptimizerOwned=!1)}dispose(){const t=super.dispose();if(t.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const e=Zc().numTensors;this.optimizer_.dispose(),t.numDisposedVariables+=e-Zc().numTensors}return t}getLossIdentifiers(){let t;if(typeof this.loss=="string")t=Hn(this.loss);else if(Array.isArray(this.loss)){for(const e of this.loss)if(typeof e!="string")throw new Error("Serialization of non-string loss is not supported.");t=this.loss.map(e=>Hn(e))}else{const e=Object.keys(this.loss);t={};const s=this.loss;for(const i of e)if(typeof s[i]=="string")t[i]=Hn(s[i]);else throw new Error("Serialization of non-string loss is not supported.")}return t}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[Hn(_o(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(t=>Hn(_o(t)));{const t={};for(const e in this.metrics)t[e]=Hn(_o(this.metrics[e]));return t}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(t){if(t.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(t.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(t.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");const e=ou(t.optimizer_config),s=qn(e);let i;if(typeof t.loss=="string")i=Ds(t.loss);else if(Array.isArray(t.loss))i=t.loss.map(r=>Ds(r));else if(t.loss!=null){i={};for(const r in t.loss)i[r]=Ds(t.loss[r])}let o;if(Array.isArray(t.metrics))o=t.metrics.map(r=>Ds(r));else if(t.metrics!=null){o={};for(const r in t.metrics)o[r]=Ds(t.metrics[r])}this.compile({loss:i,metrics:o,optimizer:s})}async save(t,e){if(typeof t=="string"){const l=zw(t);if(l.length===0)throw new M(`Cannot find any save handlers for URL '${t}'`);if(l.length>1)throw new M(`Found more than one (${l.length}) save handlers for URL '${t}'`);t=l[0]}if(t.save==null)throw new M("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const s=await Qc(this.getNamedWeights(e)),a={modelTopology:this.toJSON(null,!1),format:ak,generatedBy:`TensorFlow.js tfjs-layers v${zm}`,convertedBy:null};if((e==null?!1:e.includeOptimizer)&&this.optimizer!=null){a.trainingConfig=this.getTrainingConfig();const l="optimizer",{data:c,specs:h}=await Qc(await this.optimizer.getWeights(),l);s.specs.push(...h),s.data=Fw([s.data,c])}return this.userDefinedMetadata!=null&&(wh(this.userDefinedMetadata,this.name,!0),a.userDefinedMetadata=this.userDefinedMetadata),a.weightData=s.data,a.weightSpecs=s.specs,t.save(a)}setUserDefinedMetadata(t){wh(t,this.name),this.userDefinedMetadata=t}getUserDefinedMetadata(){return this.userDefinedMetadata}}ri.className="Model";q(ri);class Lm extends ri{}Lm.className="Functional";q(Lm);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class so extends ri{constructor(t){if(super({inputs:[],outputs:[]}),t=t||{},this.trainable=!0,this.built=!1,this.name=t.name!=null?t.name:ta("sequential_"),t.layers!=null)for(const e of t.layers)this.add(e)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some(s=>s<0))throw new M(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`)}add(t){const e=t instanceof so||t instanceof ri;let s;if(e){if(s=t,s.outputs.length!==1)throw new M("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(s.inputs.length!==1)throw new M("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(t.inboundNodes.length===0){if(t.batchInputShape==null)throw new M("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const i=lC({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(i)}if(e)this.outputs=s.outputs,this.inputs=s.inputs;else{if(t.inboundNodes.length!==1)throw new M(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(t.inboundNodes[0].outputTensors.length!==1)throw new M("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=bm(this.outputs[0])}this.inboundNodes=[],new na({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Os(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(i=>i.shape),outputShapes:this.outputs[0].shape})}else{const i=t.apply(this.outputs[0]);if(Array.isArray(i))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[i],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,e){return this.model==null&&this.build(),this.model.call(t,e)}build(t){if(Wt(t),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new ri({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,e,s=console.log){this.built||this.build(),super.summary(t,e,s)}setWeights(t){this.model==null&&this.build(),this.model.setWeights(t)}evaluate(t,e,s={}){if(!this.built)throw new an("The model needs to be compiled before being used.");return this.model.evaluate(t,e,s)}async evaluateDataset(t,e){if(!this.built)throw new an("The model needs to be compiled before being used.");return this.model.evaluateDataset(t,e)}predict(t,e={}){return this.model==null&&this.build(),this.model.predict(t,e)}predictOnBatch(t){return this.model==null&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,e,s={}){if(!this.built)throw new an("The model needs to be compiled before being used.");return this.model.fit(t,e,s)}async fitDataset(t,e){if(!this.built)throw new an("The model needs to be compiled before being used.");return this.model.fitDataset(t,e)}async trainOnBatch(t,e){return this.model.trainOnBatch(t,e)}static fromConfig(t,e,s={},i=!1){let o,r={};if(e instanceof Array){if(e[0].className==null||e[0].className==="Merge")throw new M("Legacy serialization format not supported yet.");o=e}else tt(e.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),o=e.layers,delete e.layers,r=e;const a=new t(r);if(!(a instanceof so))throw new At(`Sequential.fromConfig called on non-Sequential input: ${a}`);for(const u of o){const c=qn(u,void 0,i);i&&c.setFastWeightInitDuringBuild(!0),a.add(c)}return a}set stopTraining(t){if(this.model==null)throw new M("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(this.model==null)throw new M("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const t=[];for(const e of this.layers){const s={};s.className=e.getClassName(),s.config=e.getConfig(),t.push(s)}return{name:this.name,layers:t}}}so.className="Sequential";q(so);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let Te=class extends lo{getConfig(){return{}}};class Om extends Te{apply(t,e=1){return Kv(t,e)}}Om.className="elu";q(Om);class _m extends Te{apply(t){return vp(t)}}_m.className="selu";q(_m);class Bm extends Te{apply(t){return Si(t)}}Bm.className="relu";q(Bm);class Wm extends Te{apply(t){return B(()=>jr(6,Si(t)))}}Wm.className="relu6";q(Wm);class Vm extends Te{apply(t){return t}}Vm.className="linear";q(Vm);class Um extends Te{apply(t){return Ws(t)}}Um.className="sigmoid";q(Um);class Gm extends Te{apply(t){return qv(t)}}Gm.className="hardSigmoid";q(Gm);class Hm extends Te{apply(t){return Kr(t)}}Hm.className="softplus";q(Hm);class jm extends Te{apply(t){return Xv(t)}}jm.className="softsign";q(jm);class Km extends Te{apply(t){return Xr(t)}}Km.className="tanh";q(Km);let Ql=class extends Te{apply(t,e=-1){return Il(t,e)}};Ql.className="softmax";q(Ql);class Xm extends Te{apply(t,e=-1){return pp(t,e)}}Xm.className="logSoftmax";q(Xm);class qm extends Te{apply(t){return B(()=>B(()=>{const e=Math.sqrt(2),s=O(.5,ct(1,hp(Ct(t,e))));return O(t,s)}))}}qm.className="gelu";q(qm);class Ym extends Te{apply(t){return B(()=>O(.5,O(t,ct(1,Xr(O(ns(Ct(2,Math.PI)),ct(t,O(.044715,zr(t,3)))))))))}}Ym.className="gelu_new";q(Ym);class Zm extends Te{apply(t){return B(()=>O(t,Xr(Kr(t))))}}Zm.className="mish";q(Zm);class Qm extends Te{apply(t,e=1){return B(()=>O(Ws(O(t,e)),t))}}Qm.className="swish";q(Qm);function gs(n){return n.getClassName()}function Ba(n,t={}){return po(n,co.getMap().classNameMap,t,"activation")}function ys(n){if(n==null){const t={};return t.className="linear",t.config={},Ba(t)}if(typeof n=="string"){const t={};return t.className=n,t.config={},Ba(t)}else return n instanceof Te?n:Ba(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function uk(n){if(n!=null&&typeof n!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${n}`)}class Jm extends lo{}class tg extends Jm{constructor(t){super(),uk(t),this.l1=t==null||t.l1==null?.01:t.l1,this.l2=t==null||t.l2==null?.01:t.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(t){return B(()=>{let e=Le([1]);return this.hasL1&&(e=ct(e,Et(O(this.l1,Ls(t))))),this.hasL2&&(e=ct(e,Et(O(this.l2,mo(t))))),Q(e,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(t,e){return new t({l1:e.l1,l2:e.l2})}}tg.className="L1L2";q(tg);const Nh={l1l2:"L1L2"};function Yt(n){return Ol(n)}function $h(n,t={}){return po(n,co.getMap().classNameMap,t,"regularizer")}function re(n){if(n==null)return null;if(typeof n=="string"){const e={className:n in Nh?Nh[n]:n,config:{}};return $h(e)}else return n instanceof Jm?n:$h(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class eg extends Ft{constructor(t){super(t??{}),this.supportsMasking=!0,t!=null&&(this.maxValue=t.maxValue)}call(t,e){t=kt(t);let s=Si(t);return this.maxValue!=null&&(s=Ue(s,0,this.maxValue)),s}computeOutputShape(t){return t}getConfig(){const t={maxValue:this.maxValue},e=super.getConfig();return Object.assign(t,e),t}}eg.className="ReLU";q(eg);class ng extends Ft{constructor(t){super(t??{}),this.DEFAULT_ALPHA=.3,t==null&&(t={}),this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,e){const s=kt(t);return dp(s,this.alpha)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}}ng.className="LeakyReLU";q(ng);class sg extends Ft{constructor(t){if(super(t??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",t==null&&(t={}),this.supportsMasking=!0,this.alphaInitializer=oe(t.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=re(t.alphaRegularizer),this.alphaConstraint=xe(t.alphaConstraint),t.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(t.sharedAxes))this.sharedAxes=t.sharedAxes;else if(typeof t.sharedAxes=="number")this.sharedAxes=[t.sharedAxes];else throw new M(`Expected sharedAxes to be a number or an array of numbers, but got ${t.sharedAxes}`)}build(t){t=Wt(t);const e=t.slice(1);if(this.sharedAxes!=null)for(const i of this.sharedAxes)e[i-1]=1;this.alpha=this.addWeight("alpha",e,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const s={};if(this.sharedAxes!=null)for(let i=1;i<t.length;++i)s[i]=t[i];this.inputSpec=[new ye({ndim:t.length,axes:s})],this.built=!0}call(t,e){return t=kt(t),wp(t,this.alpha.read())}getConfig(){const t={alphaInitializer:ae(this.alphaInitializer),alphaRegularizer:Yt(this.alphaRegularizer),alphaConstraint:be(this.alphaConstraint),sharedAxes:this.sharedAxes},e=super.getConfig();return Object.assign(t,e),t}}sg.className="PReLU";q(sg);let ig=class extends Ft{constructor(t){if(super(t??{}),this.DEFAULT_ALPHA=1,t==null&&(t={}),t.alpha!=null&&t.alpha!==this.DEFAULT_ALPHA)throw new At(`Non-default alpha value (${t.alpha}) is not supported by the ELU layer yet.`);this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,e){const s=kt(t);return Sl(s)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}};ig.className="ELU";q(ig);class og extends Ft{constructor(t){super(t??{}),this.DEFAULT_THETA=1,t==null&&(t={}),this.theta=t.theta==null?this.DEFAULT_THETA:t.theta}call(t,e){const s=kt(t);return O(s,mt(Wn(s,this.theta),"float32"))}computeOutputShape(t){return t}getConfig(){const t={theta:this.theta},e=super.getConfig();return Object.assign(t,e),t}}og.className="ThresholdedReLU";q(og);class rg extends Ft{constructor(t){super(t??{}),this.DEFAULT_AXIS=1,t==null&&(t={}),this.softmax=new Ql().apply,this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis}call(t,e){return B(()=>{let s=kt(t);const i=e.mask;if(i!=null){const o=O(Lt(Bs(s.shape),mt(i,s.dtype)),se(-1e9));s=ct(s,o)}return this.axis instanceof Array?this.axis.length>1?Qn(Lt(s,fp(s,this.axis,!0))):this.softmax(s,this.axis[0]):this.softmax(s,this.axis)})}computeOutputShape(t){return t}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}rg.className="Softmax";q(rg);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function ai(n,t,e){if(typeof n=="number")return Os(n,t);if(n.length!==t)throw new M(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${n.length} elements.`);for(let s=0;s<t;++s){const i=n[s];if(!Uv(i))throw new M(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(n)} including a non-integer number ${i}`)}return n}function gn(n,t,e,s,i=1){if(n==null)return n;const o=t+(t-1)*(i-1);let r;return e==="same"?r=n:r=n-o+1,Math.floor((r+s-1)/s)}function zn(n,t,e,s){if(n==null)return null;if(s==="valid")n=n*t+ms([e-t,0]);else if(s==="same")n=n*t;else throw new M(`Unsupport padding mode: ${s}.`);return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Jl(n,t){return B(()=>(pe(t),t==="channelsFirst"?Vt(n,[0,2,3,1]):n))}function ag(n,t){return B(()=>(pe(t),t==="channelsFirst"?Vt(n,[0,2,3,4,1]):n))}function lk(n,t,e,s=1,i="valid",o,r=1){return B(()=>{if(o==null&&(o=xn()),pe(o),n.shape.length!==3)throw new M(`The input of a conv1dWithBias operation should be 3, but is ${n.shape.length} instead.`);if(t.shape.length!==3)throw new M(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(e!=null&&e.shape.length!==1)throw new M(`The bias for a conv1dWithBias operation should be 1, but is ${e.shape.length} instead`);if(o==="channelsFirst"&&(n=Vt(n,[0,2,1])),i==="causal")throw new At("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let a=up(n,t,s,i==="same"?"same":"valid","NWC",r);return e!=null&&(a=wn(a,e)),a})}function Dh(n,t,e,s=[1,1],i="valid",o,r,a=null){return B(()=>{if(o==null&&(o=xn()),pe(o),n.rank!==3&&n.rank!==4)throw new M(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${n.rank}.`);if(t.rank!==3&&t.rank!==4)throw new M(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${n.rank}.`);let u=Jl(n,o);if(i==="causal")throw new At("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return u=Pw({x:u,filter:t,strides:s,pad:i==="same"?"same":"valid",dilations:r,dataFormat:"NHWC",bias:e,activation:a}),o==="channelsFirst"&&(u=Vt(u,[0,3,1,2])),u})}function ck(n,t,e,s=[1,1,1],i="valid",o,r){return B(()=>{if(o==null&&(o=xn()),pe(o),n.rank!==4&&n.rank!==5)throw new M(`conv3dWithBias expects input to be of rank 4 or 5, but received ${n.rank}.`);if(t.rank!==4&&t.rank!==5)throw new M(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${n.rank}.`);let a=ag(n,o);if(i==="causal")throw new At("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return a=Ew(a,t,s,i==="same"?"same":"valid","NDHWC",r),e!=null&&(a=wn(a,e)),o==="channelsFirst"&&(a=Vt(a,[0,4,1,2,3])),a})}class oa extends Ft{constructor(t,e){if(super(e),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",oa.verifyArgs(e),this.rank=t,Ce(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new At(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=ai(e.kernelSize,t,"kernelSize"),this.strides=ai(e.strides==null?1:e.strides,t,"strides"),this.padding=e.padding==null?"valid":e.padding,Qe(this.padding),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,pe(this.dataFormat),this.activation=ys(e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.biasInitializer=oe(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=xe(e.biasConstraint),this.biasRegularizer=re(e.biasRegularizer),this.activityRegularizer=re(e.activityRegularizer),this.dilationRate=ai(e.dilationRate==null?1:e.dilationRate,t,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new M(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new M(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new M(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(t){if(Tn("kernelSize"in t,"required key 'kernelSize' not in config"),typeof t.kernelSize!="number"&&!_l(t.kernelSize,"number",1,3))throw new M(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){const t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:gs(this.activation),useBias:this.useBias,biasInitializer:ae(this.biasInitializer),biasRegularizer:Yt(this.biasRegularizer),activityRegularizer:Yt(this.activityRegularizer),biasConstraint:be(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}class Ri extends oa{constructor(t,e){super(t,e),this.kernel=null,Ri.verifyArgs(e),this.filters=e.filters,Ce(this.filters,"filters"),this.kernelInitializer=oe(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=xe(e.kernelConstraint),this.kernelRegularizer=re(e.kernelRegularizer)}build(t){t=Wt(t);const e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null)throw new M(`The channel dimension of the input should be defined. Found ${t[e]}`);const s=t[e],i=this.kernelSize.concat([s,this.filters]);this.kernel=this.addWeight("kernel",i,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:s}}],this.built=!0}call(t,e){return B(()=>{t=kt(t);let s;const i=this.bias==null?null:this.bias.read(),o=sm(this.activation.getClassName());if(o!=null&&this.rank===2)s=Dh(t,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate,o);else{if(this.rank===1)s=lk(t,this.kernel.read(),i,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)s=Dh(t,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)s=ck(t,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new At("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(s=this.activation.apply(s))}return s})}computeOutputShape(t){t=Wt(t);const e=[],s=this.dataFormat==="channelsLast"?t.slice(1,t.length-1):t.slice(2);for(let o=0;o<s.length;++o){const r=gn(s[o],this.kernelSize[o],this.padding,this.strides[o],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[o]);e.push(r)}let i=[t[0]];return this.dataFormat==="channelsLast"?(i=i.concat(e),i.push(this.filters)):(i.push(this.filters),i=i.concat(e)),i}getConfig(){const t={filters:this.filters,kernelInitializer:ae(this.kernelInitializer),kernelRegularizer:Yt(this.kernelRegularizer),kernelConstraint:be(this.kernelConstraint)},e=super.getConfig();return Object.assign(t,e),t}static verifyArgs(t){if(!("filters"in t)||typeof t.filters!="number"||t.filters<1)throw new M(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}}class xo extends Ri{constructor(t){super(2,t),xo.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!_l(t.kernelSize,"number",1,2))throw new M(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}}xo.className="Conv2D";q(xo);class wo extends Ri{constructor(t){super(3,t),wo.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!(Array.isArray(t.kernelSize)&&(t.kernelSize.length===1||t.kernelSize.length===3)))throw new M(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}}wo.className="Conv3D";q(wo);class ug extends xo{constructor(t){if(super(t),this.inputSpec=[new ye({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new M(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(t=Wt(t),t.length!==4)throw new M("Input should have rank 4; Received input shape: "+JSON.stringify(t));const e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null)throw new M("The channel dimension of the inputs should be defined. Found `None`.");const s=t[e],i=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",i,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new ye({ndim:4,axes:{[e]:s}})],this.built=!0}call(t,e){return B(()=>{let s=kt(t);if(s.shape.length!==4)throw new M(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const i=s.shape,o=i[0];let r,a;this.dataFormat==="channelsFirst"?(r=2,a=3):(r=1,a=2);const u=i[r],l=i[a],c=this.kernelSize[0],h=this.kernelSize[1],p=this.strides[0],f=this.strides[1],m=zn(u,p,c,this.padding),g=zn(l,f,h,this.padding),b=[o,m,g,this.filters];this.dataFormat!=="channelsLast"&&(s=Vt(s,[0,2,3,1]));let v=lp(s,this.kernel.read(),b,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(v=Vt(v,[0,3,1,2])),this.bias!=null&&(v=wn(v,this.bias.read(),this.dataFormat)),this.activation!=null&&(v=this.activation.apply(v)),v})}computeOutputShape(t){t=Wt(t);const e=t.slice();let s,i,o;this.dataFormat==="channelsFirst"?(s=1,i=2,o=3):(s=3,i=1,o=2);const r=this.kernelSize[0],a=this.kernelSize[1],u=this.strides[0],l=this.strides[1];return e[s]=this.filters,e[i]=zn(e[i],u,r,this.padding),e[o]=zn(e[o],l,a,this.padding),e}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}ug.className="Conv2DTranspose";q(ug);class lg extends wo{constructor(t){if(super(t),this.inputSpec=[new ye({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new M(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(t=Wt(t),t.length!==5)throw new M("Input should have rank 5; Received input shape: "+JSON.stringify(t));const e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null)throw new M("The channel dimension of the inputs should be defined. Found `None`.");const s=t[e],i=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",i,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new ye({ndim:5,axes:{[e]:s}})],this.built=!0}call(t,e){return B(()=>{let s=kt(t);if(s.shape.length!==5)throw new M(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const i=s.shape,o=i[0];let r,a,u;this.dataFormat==="channelsFirst"?(u=2,r=3,a=4):(u=1,r=2,a=3);const l=i[u],c=i[r],h=i[a],p=this.kernelSize[0],f=this.kernelSize[1],m=this.kernelSize[2],g=this.strides[0],b=this.strides[1],v=this.strides[2],w=zn(l,g,p,this.padding),k=zn(c,b,f,this.padding),C=zn(h,v,m,this.padding),I=[o,w,k,C,this.filters];this.dataFormat!=="channelsLast"&&(s=Vt(s,[0,2,3,4,1]));let N=Mw(s,this.kernel.read(),I,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(N=Vt(N,[0,4,1,2,3])),this.bias!==null&&(N=wn(N,this.bias.read(),this.dataFormat)),this.activation!==null&&(N=this.activation.apply(N)),N})}computeOutputShape(t){t=Wt(t);const e=t.slice();let s,i,o,r;this.dataFormat==="channelsFirst"?(s=1,i=2,o=3,r=4):(s=4,i=1,o=2,r=3);const a=this.kernelSize[0],u=this.kernelSize[1],l=this.kernelSize[2],c=this.strides[0],h=this.strides[1],p=this.strides[2];return e[s]=this.filters,e[i]=zn(e[i],c,a,this.padding),e[o]=zn(e[o],h,u,this.padding),e[r]=zn(e[r],p,l,this.padding),e}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}lg.className="Conv3DTranspose";q(lg);class cg extends Ri{constructor(t,e){if(super(t,e),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,e.filters==null)throw new M("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(e.kernelInitializer!=null||e.kernelRegularizer!=null||e.kernelConstraint!=null)throw new M("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(e.padding!=null&&e.padding!=="same"&&e.padding!=="valid")throw new M(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(e.padding)}`);this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=oe(e.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=re(e.depthwiseRegularizer),this.depthwiseConstraint=xe(e.depthwiseConstraint),this.pointwiseInitializer=oe(e.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=re(e.pointwiseRegularizer),this.pointwiseConstraint=xe(e.pointwiseConstraint)}build(t){if(t=Wt(t),t.length<this.rank+2)throw new M(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(t)}`);const e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null||t[e]<0)throw new M(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(t[e])}`);const s=t[e],i=this.kernelSize.concat([s,this.depthMultiplier]),o=[];for(let a=0;a<this.rank;++a)o.push(1);o.push(s*this.depthMultiplier,this.filters);const r=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",i,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,r,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",o,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,r,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,r,this.biasConstraint):this.bias=null,this.inputSpec=[new ye({ndim:this.rank+2,axes:{[e]:s}})],this.built=!0}call(t,e){return B(()=>{t=kt(t);let s;if(this.rank===1)throw new At("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(t=Vt(t,[0,2,3,1])),s=Cp(t,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(s=wn(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),this.dataFormat==="channelsFirst"&&(s=Vt(s,[0,3,1,2])),s})}getConfig(){const t=super.getConfig();return delete t.rank,delete t.kernelInitializer,delete t.kernelRegularizer,delete t.kernelConstraint,t.depthwiseInitializer=ae(this.depthwiseInitializer),t.pointwiseInitializer=ae(this.pointwiseInitializer),t.depthwiseRegularizer=Yt(this.depthwiseRegularizer),t.pointwiseRegularizer=Yt(this.pointwiseRegularizer),t.depthwiseConstraint=be(this.depthwiseConstraint),t.pointwiseConstraint=be(this.pointwiseConstraint),t}}cg.className="SeparableConv";class hg extends cg{constructor(t){super(2,t)}}hg.className="SeparableConv2D";q(hg);class ra extends Ri{constructor(t){super(1,t),ra.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){const t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!_l(t.kernelSize,"number",1,1))throw new M(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}}ra.className="Conv1D";q(ra);class dg extends Ft{constructor(t){super(t),typeof t.cropping=="number"?this.cropping=[[t.cropping,t.cropping],[t.cropping,t.cropping]]:typeof t.cropping[0]=="number"?this.cropping=[[t.cropping[0],t.cropping[0]],[t.cropping[1],t.cropping[1]]]:this.cropping=t.cropping,this.dataFormat=t.dataFormat===void 0?"channelsLast":t.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(t){return this.dataFormat==="channelsFirst"?[t[0],t[1],t[2]-this.cropping[0][0]-this.cropping[0][1],t[3]-this.cropping[1][0]-this.cropping[1][1]]:[t[0],t[1]-this.cropping[0][0]-this.cropping[0][1],t[2]-this.cropping[1][0]-this.cropping[1][1],t[3]]}call(t,e){return B(()=>{if(t=kt(t),this.dataFormat==="channelsLast"){const s=Oo(t,this.cropping[0][0],t.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Oo(s,this.cropping[1][0],t.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{const s=Oo(t,this.cropping[0][0],t.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Oo(s,this.cropping[1][0],t.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const t={cropping:this.cropping,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}dg.className="Cropping2D";q(dg);class pg extends Ft{constructor(t){super(t),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=t.size==null?this.DEFAULT_SIZE:t.size,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,pe(this.dataFormat),this.interpolation=t.interpolation==null?"nearest":t.interpolation,Bv(this.interpolation)}computeOutputShape(t){if(this.dataFormat==="channelsFirst"){const e=t[2]==null?null:this.size[0]*t[2],s=t[3]==null?null:this.size[1]*t[3];return[t[0],t[1],e,s]}else{const e=t[1]==null?null:this.size[0]*t[1],s=t[2]==null?null:this.size[1]*t[2];return[t[0],e,s,t[3]]}}call(t,e){return B(()=>{let s=kt(t);const i=s.shape;if(this.dataFormat==="channelsFirst"){s=Vt(s,[0,2,3,1]);const o=this.size[0]*i[2],r=this.size[1]*i[3],a=this.interpolation==="nearest"?Oe.resizeNearestNeighbor(s,[o,r]):Oe.resizeBilinear(s,[o,r]);return Vt(a,[0,3,1,2])}else{const o=this.size[0]*i[1],r=this.size[1]*i[2];return this.interpolation==="nearest"?Oe.resizeNearestNeighbor(s,[o,r]):Oe.resizeBilinear(s,[o,r])}})}getConfig(){const t={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},e=super.getConfig();return Object.assign(t,e),t}}pg.className="UpSampling2D";q(pg);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function hk(n,t,e=[1,1],s="valid",i,o){return B(()=>{i==null&&(i=xn()),pe(i);let r=Jl(n,i);if(n.rank!==4)throw new M(`Input for depthwiseConv2d is required to be 4-D, but is instead ${n.rank}-D`);if(t.rank!==4)throw new M(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return r=cp(r,t,e,s==="same"?"same":"valid","NHWC",o),i==="channelsFirst"&&(r=Vt(r,[0,3,1,2])),r})}class fg extends oa{constructor(t){super(2,t),this.depthwiseKernel=null,this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=oe(t.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=xe(t.depthwiseConstraint),this.depthwiseRegularizer=re(t.depthwiseRegularizer)}build(t){if(t=Wt(t),t.length<4)throw new M(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(t)}.`);const e=this.dataFormat==="channelsFirst"?1:3;if(t[e]==null||t[e]<0)throw new M(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${t[e]}).`);const s=t[e],i=[this.kernelSize[0],this.kernelSize[1],s,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",i,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[s*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return B(()=>{t=kt(t);let s=hk(t,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(s=wn(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),s})}computeOutputShape(t){t=Wt(t);const e=this.dataFormat==="channelsFirst"?t[2]:t[1],s=this.dataFormat==="channelsFirst"?t[3]:t[2],i=this.dataFormat==="channelsFirst"?t[1]*this.depthMultiplier:t[3]*this.depthMultiplier,o=gn(e,this.kernelSize[0],this.padding,this.strides[0]),r=gn(s,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[t[0],i,o,r]:[t[0],o,r,i]}getConfig(){const t=super.getConfig();return t.depthMultiplier=this.depthMultiplier,t.depthwiseInitializer=ae(this.depthwiseInitializer),t.depthwiseRegularizer=Yt(this.depthwiseRegularizer),t.depthwiseConstraint=be(this.depthwiseRegularizer),t}}fg.className="DepthwiseConv2D";q(fg);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function mg(n,t,e,s){if(Array.isArray(n)){if(t!=null||e!=null)throw new M("When inputs is an array, neither initialState or constants should be provided");s!=null&&(e=n.slice(n.length-s,n.length),n=n.slice(0,n.length-s)),n.length>1&&(t=n.slice(1,n.length)),n=n[0]}function i(o){return o==null||Array.isArray(o)?o:[o]}return t=i(t),e=i(e),{inputs:n,initialState:t,constants:e}}function gg(n,t,e,s=!1,i,o,r=!1,a=!1){return B(()=>{const u=t.shape.length;if(u<3)throw new M(`Input should be at least 3D, but is ${u}D.`);const l=[1,0].concat(bn(2,u));t=Vt(t,l),r&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),i!=null&&(i=mt(mt(i,"bool"),"float32"),i.rank===u-1&&(i=Ye(i,-1)),i=Vt(i,l)),s&&(t=Qi(t,0),i!=null&&(i=Qi(i,0)));const c=[];let h,p=e;const f=t.shape[0],m=Zi(t);let g;i!=null&&(g=Zi(i));for(let v=0;v<f;++v){const w=m[v],k=B(()=>n(w,p));if(i==null)h=k[0],p=k[1];else{const C=B(()=>{const I=g[v],N=Lt(un(I),I),$=ct(O(k[0],I),O(p[0],N)),A=p.map((z,F)=>ct(O(k[1][F],I),O(z,N)));return{output:$,newStates:A}});h=C.output,p=C.newStates}a&&c.push(h)}let b;return a&&(b=uo(c,1)),[h,b,p]})}class vs extends Ft{constructor(t){super(t);let e;if(t.cell==null)throw new M("cell property is missing for the constructor of RNN.");if(Array.isArray(t.cell)?e=new nc({cells:t.cell}):e=t.cell,e.stateSize==null)throw new M("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=e,this.returnSequences=t.returnSequences==null?!1:t.returnSequences,this.returnState=t.returnState==null?!1:t.returnState,this.goBackwards=t.goBackwards==null?!1:t.goBackwards,this._stateful=t.stateful==null?!1:t.stateful,this.unroll=t.unroll==null?!1:t.unroll,this.supportsMasking=!0,this.inputSpec=[new ye({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return bn(0,t).map(e=>null)}else return this.states_}setStates(t){this.states_=t}computeOutputShape(t){nu(t)&&(t=t[0]),t=t;let e=this.cell.stateSize;Array.isArray(e)||(e=[e]);const s=e[0];let i;if(this.returnSequences?i=[t[0],t[1],s]:i=[t[0],s],this.returnState){const o=[];for(const r of e)o.push([t[0],r]);return[i].concat(o)}else return i}computeMask(t,e){return B(()=>{Array.isArray(e)&&(e=e[0]);const s=this.returnSequences?e:null;if(this.returnState){const i=this.states.map(o=>null);return[s].concat(i)}else return s})}get states(){if(this.states_==null){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,e=[];for(let s=0;s<t;++s)e.push(null);return e}else return this.states_}set states(t){this.states_=t}build(t){if(this.numConstants!=null)throw new At("Constants support is not implemented in RNN yet.");nu(t)&&(t=t[0]),t=t;const e=this.stateful?t[0]:null,s=t.slice(2);this.inputSpec[0]=new ye({shape:[e,null,...s]});const i=[t[0]].concat(t.slice(2));this.cell.build(i);let o;if(Array.isArray(this.cell.stateSize)?o=this.cell.stateSize:o=[this.cell.stateSize],this.stateSpec!=null){if(!ke(this.stateSpec.map(r=>r.shape[r.shape.length-1]),o))throw new M(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=o.map(r=>new ye({shape:[null,r]}));this.stateful&&this.resetStates()}resetStates(t,e=!1){B(()=>{if(!this.stateful)throw new An("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape[0];if(s==null)throw new M("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(i=>Le([s,i])):this.states_=[Le([s,this.cell.stateSize])];else if(t==null)zt(this.states_),this.keptStates!=null&&(zt(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(i=>Le([s,i])):this.states_[0]=Le([s,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new M(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);e===!0?this.keptStates.push(this.states_.slice()):zt(this.states_);for(let i=0;i<this.states_.length;++i){const o=t[i],r=Array.isArray(this.cell.stateSize)?this.cell.stateSize[i]:this.cell.stateSize,a=[s,r];if(!ke(o.shape,a))throw new M(`State ${i} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${o.shape}`);this.states_[i]=o}}this.states_=this.states_.map(i=>Xn(i.clone()))})}apply(t,e){let s=e==null?null:e.initialState,i=e==null?null:e.constants;e==null&&(e={});const o=mg(t,s,i,this.numConstants);t=o.inputs,s=o.initialState,i=o.constants;let r=[],a=[];if(s!=null){e.initialState=s,r=r.concat(s),this.stateSpec=[];for(const l of s)this.stateSpec.push(new ye({shape:l.shape}));a=a.concat(this.stateSpec)}if(i!=null&&(e.constants=i,r=r.concat(i),this.numConstants=i.length),r[0]instanceof On){const l=[t].concat(r),c=this.inputSpec.concat(a),h=this.inputSpec;this.inputSpec=c;const p=super.apply(l,e);return this.inputSpec=h,p}else return super.apply(t,e)}call(t,e){return B(()=>{const s=e==null?null:e.mask,i=e==null?null:e.training;let o=e==null?null:e.initialState;t=kt(t),o==null&&(this.stateful?o=this.states_:o=this.getInitialState(t));const r=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(o.length!==r)throw new M(`RNN Layer has ${r} state(s) but was passed ${o.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const a={training:i},l=gg((m,g)=>{const b=this.cell.call([m].concat(g),a);return[b[0],b.slice(1)]},t,o,this.goBackwards,s,null,this.unroll,this.returnSequences),c=l[0],h=l[1],p=l[2];this.stateful&&this.resetStates(p,i);const f=this.returnSequences?h:c;return this.returnState?[f].concat(p):f})}getInitialState(t){return B(()=>{let e=Le(t.shape);return e=Et(e,[1,2]),e=fo(e),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(s=>s>1?tu(e,[1,s]):e):this.cell.stateSize>1?[tu(e,[1,this.cell.stateSize])]:[e]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){const t=super.getConfig(),e={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(e.numConstants=this.numConstants);const s=this.cell.getConfig();return this.getClassName()===vs.className&&(e.cell={className:this.cell.getClassName(),config:s}),Object.assign(Object.assign(Object.assign({},s),t),e)}static fromConfig(t,e,s={}){const i=e.cell,o=qn(i,s);return new t(Object.assign(e,{cell:o}))}}vs.className="RNN";q(vs);class aa extends Ft{}class tc extends aa{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,Ce(this.units,"units"),this.activation=ys(t.activation==null?this.DEFAULT_ACTIVATION:t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=oe(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=oe(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=oe(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=re(t.kernelRegularizer),this.recurrentRegularizer=re(t.recurrentRegularizer),this.biasRegularizer=re(t.biasRegularizer),this.kernelConstraint=xe(t.kernelConstraint),this.recurrentConstraint=xe(t.recurrentConstraint),this.biasConstraint=xe(t.biasConstraint),this.dropout=mi([1,ms([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=mi([1,ms([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=Wt(t),this.kernel=this.addWeight("kernel",[t[t.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return B(()=>{if(t=t,t.length!==2)throw new M(`SimpleRNNCell expects 2 input Tensors, got ${t.length}.`);let s=t[1];t=t[0];const i=e.training==null?!1:e.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=bs({ones:()=>un(t),rate:this.dropout,training:i,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=bs({ones:()=>un(s),rate:this.recurrentDropout,training:i,dropoutFunc:this.dropoutFunc}));let o;const r=this.dropoutMask,a=this.recurrentDropoutMask;r!=null?o=En(O(t,r),this.kernel.read()):o=En(t,this.kernel.read()),this.bias!=null&&(o=wn(o,this.bias.read())),a!=null&&(s=O(s,a));let u=ct(o,En(s,this.recurrentKernel.read()));return this.activation!=null&&(u=this.activation.apply(u)),[u,u]})}getConfig(){const t=super.getConfig(),e={units:this.units,activation:gs(this.activation),useBias:this.useBias,kernelInitializer:ae(this.kernelInitializer),recurrentInitializer:ae(this.recurrentInitializer),biasInitializer:ae(this.biasInitializer),kernelRegularizer:Yt(this.kernelRegularizer),recurrentRegularizer:Yt(this.recurrentRegularizer),biasRegularizer:Yt(this.biasRegularizer),activityRegularizer:Yt(this.activityRegularizer),kernelConstraint:be(this.kernelConstraint),recurrentConstraint:be(this.recurrentConstraint),biasConstraint:be(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},t),e)}}tc.className="SimpleRNNCell";q(tc);class yg extends vs{constructor(t){t.cell=new tc(t),super(t)}call(t,e){return B(()=>{this.cell.dropoutMask!=null&&(zt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(zt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=e==null?null:e.mask,i=e==null?null:e.training,o=e==null?null:e.initialState;return super.call(t,{mask:s,training:i,initialState:o})})}static fromConfig(t,e){return new t(e)}}yg.className="SimpleRNN";q(yg);class ec extends aa{constructor(t){if(super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.resetAfter)throw new M("GRUCell does not support reset_after parameter set to true.");this.units=t.units,Ce(this.units,"units"),this.activation=ys(t.activation===void 0?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=ys(t.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=oe(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=oe(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=oe(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=re(t.kernelRegularizer),this.recurrentRegularizer=re(t.recurrentRegularizer),this.biasRegularizer=re(t.biasRegularizer),this.kernelConstraint=xe(t.kernelConstraint),this.recurrentConstraint=xe(t.recurrentConstraint),this.biasConstraint=xe(t.biasConstraint),this.dropout=mi([1,ms([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=mi([1,ms([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=Wt(t);const e=t[t.length-1];this.kernel=this.addWeight("kernel",[e,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return B(()=>{if(t=t,t.length!==2)throw new M(`GRUCell expects 2 input Tensors (inputs, h, c), got ${t.length}.`);const s=e.training==null?!1:e.training;let i=t[1];t=t[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=bs({ones:()=>un(t),rate:this.dropout,training:s,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=bs({ones:()=>un(i),rate:this.recurrentDropout,training:s,count:3,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,r=this.recurrentDropoutMask;let a,u,l;0<this.dropout&&this.dropout<1&&(t=O(t,o[0]));let c=En(t,this.kernel.read());this.useBias&&(c=wn(c,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(i=O(i,r[0]));const h=this.recurrentKernel.read(),[p,f]=Kn(h,[2*this.units,this.units],h.rank-1),m=En(i,p),[g,b,v]=Kn(c,3,c.rank-1),[w,k]=Kn(m,2,m.rank-1);a=this.recurrentActivation.apply(ct(g,w)),u=this.recurrentActivation.apply(ct(b,k));const C=En(O(u,i),f);l=this.activation.apply(ct(v,C));const I=ct(O(a,i),O(ct(1,Fe(a)),l));return[I,I]})}getConfig(){const t=super.getConfig(),e={units:this.units,activation:gs(this.activation),recurrentActivation:gs(this.recurrentActivation),useBias:this.useBias,kernelInitializer:ae(this.kernelInitializer),recurrentInitializer:ae(this.recurrentInitializer),biasInitializer:ae(this.biasInitializer),kernelRegularizer:Yt(this.kernelRegularizer),recurrentRegularizer:Yt(this.recurrentRegularizer),biasRegularizer:Yt(this.biasRegularizer),activityRegularizer:Yt(this.activityRegularizer),kernelConstraint:be(this.kernelConstraint),recurrentConstraint:be(this.recurrentConstraint),biasConstraint:be(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},t),e)}}ec.className="GRUCell";q(ec);class bg extends vs{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new ec(t),super(t)}call(t,e){return B(()=>{this.cell.dropoutMask!=null&&(zt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(zt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=e==null?null:e.mask,i=e==null?null:e.training,o=e==null?null:e.initialState;return super.call(t,{mask:s,training:i,initialState:o})})}static fromConfig(t,e){return e.implmentation===0&&(e.implementation=1),new t(e)}}bg.className="GRU";q(bg);class ua extends aa{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,Ce(this.units,"units"),this.activation=ys(t.activation===void 0?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=ys(t.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=oe(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=oe(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=oe(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=t.unitForgetBias,this.kernelRegularizer=re(t.kernelRegularizer),this.recurrentRegularizer=re(t.recurrentRegularizer),this.biasRegularizer=re(t.biasRegularizer),this.kernelConstraint=xe(t.kernelConstraint),this.recurrentConstraint=xe(t.recurrentConstraint),this.biasConstraint=xe(t.biasConstraint),this.dropout=mi([1,ms([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=mi([1,ms([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){var e;t=Wt(t);const s=t[t.length-1];this.kernel=this.addWeight("kernel",[s,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let i;if(this.useBias){if(this.unitForgetBias){const o=this.biasInitializer,r=this.units;i=new(e=class extends cn{apply(u,l){const c=o.apply([r]),h=new Wl().apply([r]),p=o.apply([r*2]);return hh(hh(c,h),p)}},e.className="CustomInit",e)}else i=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,i,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(t,e){return B(()=>{const s=e.training==null?!1:e.training;if(t=t,t.length!==3)throw new M(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);let i=t[1];const o=t[2];t=t[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=bs({ones:()=>un(t),rate:this.dropout,training:s,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=bs({ones:()=>un(i),rate:this.recurrentDropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const r=this.dropoutMask,a=this.recurrentDropoutMask;let u,l,c,h;0<this.dropout&&this.dropout<1&&(t=O(t,r[0]));let p=En(t,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(i=O(i,a[0])),p=ct(p,En(i,this.recurrentKernel.read())),this.useBias&&(p=wn(p,this.bias.read()));const[f,m,g,b]=Kn(p,4,p.rank-1);u=this.recurrentActivation.apply(f),l=this.recurrentActivation.apply(m),c=ct(O(l,o),O(u,this.activation.apply(g))),h=this.recurrentActivation.apply(b);const v=O(h,this.activation.apply(c));return[v,v,c]})}getConfig(){const t=super.getConfig(),e={units:this.units,activation:gs(this.activation),recurrentActivation:gs(this.recurrentActivation),useBias:this.useBias,kernelInitializer:ae(this.kernelInitializer),recurrentInitializer:ae(this.recurrentInitializer),biasInitializer:ae(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Yt(this.kernelRegularizer),recurrentRegularizer:Yt(this.recurrentRegularizer),biasRegularizer:Yt(this.biasRegularizer),activityRegularizer:Yt(this.activityRegularizer),kernelConstraint:be(this.kernelConstraint),recurrentConstraint:be(this.recurrentConstraint),biasConstraint:be(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},t),e)}}ua.className="LSTMCell";q(ua);class xg extends vs{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new ua(t),super(t)}call(t,e){return B(()=>{this.cell.dropoutMask!=null&&(zt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(zt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=e==null?null:e.mask,i=e==null?null:e.training,o=e==null?null:e.initialState;return super.call(t,{mask:s,training:i,initialState:o})})}static fromConfig(t,e){return e.implmentation===0&&(e.implementation=1),new t(e)}}xg.className="LSTM";q(xg);class nc extends aa{constructor(t){super(t),this.cells=t.cells}get stateSize(){const t=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?t.push(...e.stateSize):t.push(e.stateSize);return t}call(t,e){return B(()=>{t=t;let s=t.slice(1);const i=[];for(const a of this.cells.slice().reverse())Array.isArray(a.stateSize)?i.push(s.splice(0,a.stateSize.length)):i.push(s.splice(0,1));i.reverse();const o=[];let r;for(let a=0;a<this.cells.length;++a){const u=this.cells[a];s=i[a],a===0?r=[t[0]].concat(s):r=[r[0]].concat(s),r=u.call(r,e),o.push(r.slice(1))}s=[];for(const a of o.slice().reverse())s.push(...a);return[r[0]].concat(s)})}build(t){nu(t)&&(t=t[0]),t=t;let e;this.cells.forEach((s,i)=>{Fs(`RNNCell_${i}`,()=>{s.build(t),Array.isArray(s.stateSize)?e=s.stateSize[0]:e=s.stateSize,t=[t[0],e]})}),this.built=!0}getConfig(){const t=super.getConfig(),e=o=>({className:o.getClassName(),config:o.getConfig()}),i={cells:this.cells.map(e)};return Object.assign(Object.assign({},t),i)}static fromConfig(t,e,s={}){const i=[];for(const o of e.cells)i.push(qn(o,s));return new t({cells:i})}get trainableWeights(){if(!this.trainable)return[];const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.cells)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const s of this.cells)e.push(...s.trainableWeights);return e.concat(t)}return t}getWeights(){const t=[];for(const e of this.cells)t.push(...e.weights);return su(t)}setWeights(t){const e=[];for(const s of this.cells){const i=s.weights.length,o=t.splice(i);for(let r=0;r<s.weights.length;++r)e.push([s.weights[r],o[r]])}Xl(e)}}nc.className="StackedRNNCells";q(nc);function bs(n){const{ones:t,rate:e,training:s=!1,count:i=1,dropoutFunc:o}=n,r=()=>o!=null?o(t(),e):cm(t(),e),a=()=>go(r,t,s);return!i||i<=1?Xn(a().clone()):Array(i).fill(void 0).map(a).map(l=>Xn(l.clone()))}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var dk=function(n,t){var e={};for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&t.indexOf(s)<0&&(e[s]=n[s]);if(n!=null&&typeof Object.getOwnPropertySymbols=="function")for(var i=0,s=Object.getOwnPropertySymbols(n);i<s.length;i++)t.indexOf(s[i])<0&&Object.prototype.propertyIsEnumerable.call(n,s[i])&&(e[s[i]]=n[s[i]]);return e};class wg extends vs{constructor(t){if(t.unroll)throw new At("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(t.cell))throw new At("It is not possible at the moment to stack convolutional cells.");super(t),this.inputSpec=[new ye({ndim:5})]}call(t,e){return B(()=>{if(this.cell.dropoutMask!=null&&(zt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(zt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),e&&e.constants)throw new M("ConvRNN2D cell does not support constants");const s=e==null?null:e.mask,i=e==null?null:e.training,o=e==null?null:e.initialState;return super.call(t,{mask:s,training:i,initialState:o})})}computeOutputShape(t){let e=this.computeSingleOutputShape(t);return this.returnSequences||(e=[e[0],...e.slice(2)]),this.returnState&&(e=[e,...Array(2).fill([t[0],...e.slice(-3)])]),e}getInitialState(t){return B(()=>{const{stateSize:e}=this.cell,s=t.shape,i=this.computeSingleOutputShape(s),o=[i[0],...i.slice(2)],r=Le(o);return Array.isArray(e)?Array(e.length).fill(r):[r]})}resetStates(t,e=!1){B(()=>{if(!this.stateful)throw new An("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape,i=this.computeSingleOutputShape(s),o=[i[0],...i.slice(2)];if(s[0]==null)throw new M("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Le(o)):this.states_=[Le(o)];else if(t==null)zt(this.states_),this.keptStates!=null&&(zt(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Le(o)):this.states_[0]=Le(o);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new M(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);e?this.keptStates.push(this.states_.slice()):zt(this.states_);for(let a=0;a<this.states_.length;++a){const u=t[a],l=o;if(!ke(u.shape,l))throw new M(`State ${a} is incompatible with layer ${this.name}: expected shape=${l}, received shape=${u.shape}`);this.states_[a]=u}}this.states_=this.states_.map(a=>Xn(a.clone()))})}computeSingleOutputShape(t){const{dataFormat:e,filters:s,kernelSize:i,padding:o,strides:r,dilationRate:a}=this.cell,u=e==="channelsFirst",l=t[u?3:2],c=t[u?4:3],h=gn(l,i[0],o,r[0],a[0]),p=gn(c,i[1],o,r[1],a[1]);return[...t.slice(0,2),...u?[s,h,p]:[h,p,s]]}}wg.className="ConvRNN2D";class sc extends ua{constructor(t){const{filters:e,kernelSize:s,strides:i,padding:o,dataFormat:r,dilationRate:a}=t;super(Object.assign(Object.assign({},t),{units:e})),this.filters=e,Ce(this.filters,"filters"),this.kernelSize=ai(s,2,"kernelSize"),this.kernelSize.forEach(u=>Ce(u,"kernelSize")),this.strides=ai(i||1,2,"strides"),this.strides.forEach(u=>Ce(u,"strides")),this.padding=o||"valid",Qe(this.padding),this.dataFormat=r||"channelsLast",pe(this.dataFormat),this.dilationRate=ai(a||1,2,"dilationRate"),this.dilationRate.forEach(u=>Ce(u,"dilationRate"))}build(t){var e;t=Wt(t);const s=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[s]==null)throw new M(`The channel dimension of the input should be defined. Found ${t[s]}`);const i=t[s],o=4,r=this.kernelSize.concat([i,this.filters*o]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const a=this.kernelSize.concat([this.filters,this.filters*o]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",a,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let u;if(this.unitForgetBias){const l=this.biasInitializer,c=this.filters;u=new(e=class extends cn{apply(p,f){const m=l.apply([c]),g=Bs([c]),b=l.apply([c*2]);return Bl([m,g,b])}},e.className="CustomInit",e)}else u=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*o],null,u,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(t,e){return B(()=>{if(t.length!==3)throw new M(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);const s=e.training||!1,i=t[0],o=t[1],r=t[2],a=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=bs({ones:()=>un(i),rate:this.dropout,training:s,count:a,dropoutFunc:this.dropoutFunc}));const u=this.dropoutMask,l=(Z,Y,it)=>!Y||!Y[it]?Z:O(Y[it],Z);let c=l(i,u,0),h=l(i,u,1),p=l(i,u,2),f=l(i,u,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=bs({ones:()=>un(o),rate:this.recurrentDropout,training:s,count:a,dropoutFunc:this.dropoutFunc}));const m=this.recurrentDropoutMask;let g=l(o,m,0),b=l(o,m,1),v=l(o,m,2),w=l(o,m,3);const k=3,[C,I,N,$]=Kn(this.kernel.read(),a,k),[A,z,F,E]=this.useBias?Kn(this.bias.read(),a):[null,null,null,null];c=this.inputConv(c,C,A,this.padding),h=this.inputConv(h,I,z,this.padding),p=this.inputConv(p,N,F,this.padding),f=this.inputConv(f,$,E,this.padding);const[U,L,W,_]=Kn(this.recurrentKernel.read(),a,k);g=this.recurrentConv(g,U),b=this.recurrentConv(b,L),v=this.recurrentConv(v,W),w=this.recurrentConv(w,_);const V=this.recurrentActivation.apply(ct(c,g)),X=this.recurrentActivation.apply(ct(h,b)),j=ct(O(X,r),O(V,this.activation.apply(ct(p,v)))),K=O(this.recurrentActivation.apply(ct(f,w)),this.activation.apply(j));return[K,K,j]})}getConfig(){const t=super.getConfig(),e=dk(t,["units"]),s={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},e),s)}inputConv(t,e,s,i){const o=Vo(t,e,this.strides,i||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return s?wn(o,s,this.dataFormat):o}recurrentConv(t,e){return Vo(t,e,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}sc.className="ConvLSTM2DCell";q(sc);class vg extends wg{constructor(t){const e=new sc(t);super(Object.assign(Object.assign({},t),{cell:e}))}static fromConfig(t,e){return new t(e)}}vg.className="ConvLSTM2D";q(vg);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class ic extends Ft{constructor(t){super(t),this.rate=Math.max(Math.min(t.rate,1),0),this.noiseShape=t.noiseShape,this.seed=t.seed,this.supportsMasking=!0}getNoiseShape(t){if(this.noiseShape==null)return this.noiseShape;const e=t.shape,s=[];for(let i=0;i<this.noiseShape.length;++i)s.push(this.noiseShape[i]==null?e[i]:this.noiseShape[i]);return s}call(t,e){return B(()=>{this.invokeCallHook(t,e);const s=kt(t);if(0<this.rate&&this.rate<1){const i=e.training==null?!1:e.training,o=this.getNoiseShape(s);return go(()=>cm(s,this.rate,o,this.seed),()=>s,i)}return t})}getConfig(){const t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},e=super.getConfig();return Object.assign(t,e),t}dispose(){return super.dispose()}}ic.className="Dropout";q(ic);class Cg extends ic{constructor(t){super(t),this.inputSpec=[{ndim:3}]}getNoiseShape(t){const e=t.shape;return[e[0],1,e[2]]}}Cg.className="SpatialDropout1D";q(Cg);class kg extends Ft{constructor(t){if(super(t),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.batchInputShape==null&&t.inputShape==null&&t.inputDim!=null){let e=null;t.batchSize!=null&&(e=t.batchSize),this.batchInputShape=[e,t.inputDim]}this.units=t.units,Ce(this.units,"units"),this.activation=ys(t.activation),t.useBias!=null&&(this.useBias=t.useBias),this.kernelInitializer=oe(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=oe(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=xe(t.kernelConstraint),this.biasConstraint=xe(t.biasConstraint),this.kernelRegularizer=re(t.kernelRegularizer),this.biasRegularizer=re(t.biasRegularizer),this.activityRegularizer=re(t.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(t){t=Wt(t);const e=t[t.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[e,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:e}}],this.built=!0}computeOutputShape(t){t=Wt(t);const e=t.slice();return e[e.length-1]=this.units,e}call(t,e){return B(()=>{this.invokeCallHook(t,e);const s=kt(t),i=sm(this.activation.getClassName());let o;return i!=null?o=En(s,this.kernel.read(),i,this.bias?this.bias.read():null):(o=En(s,this.kernel.read()),this.bias!=null&&(o=wn(o,this.bias.read())),this.activation!=null&&(o=this.activation.apply(o))),o})}getConfig(){const t={units:this.units,activation:gs(this.activation),useBias:this.useBias,kernelInitializer:ae(this.kernelInitializer),biasInitializer:ae(this.biasInitializer),kernelRegularizer:Yt(this.kernelRegularizer),biasRegularizer:Yt(this.biasRegularizer),activityRegularizer:Yt(this.activityRegularizer),kernelConstraint:be(this.kernelConstraint),biasConstraint:be(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}kg.className="Dense";q(kg);class Sg extends Ft{constructor(t){t=t||{},super(t),this.inputSpec=[{minNDim:3}],this.dataFormat=t.dataFormat}computeOutputShape(t){t=Wt(t);for(const e of t.slice(1))if(e==null)throw new M(`The shape of the input to "Flatten" is not fully defined (got ${t.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[t[0],ds(t,1)]}call(t,e){return B(()=>{this.invokeCallHook(t,e);let s=kt(t);if(this.dataFormat==="channelsFirst"&&s.rank>1){const i=[0];for(let o=2;o<s.rank;++o)i.push(o);i.push(1),s=Vt(s,i)}return jv(s)})}getConfig(){const t={};this.dataFormat!=null&&(t.dataFormat=this.dataFormat);const e=super.getConfig();return Object.assign(t,e),t}}Sg.className="Flatten";q(Sg);class Ig extends Ft{constructor(t){super(t),this.supportsMasking=!0,this.activation=ys(t.activation)}call(t,e){return B(()=>{this.invokeCallHook(t,e);const s=kt(t);return this.activation.apply(s)})}getConfig(){const t={activation:gs(this.activation)},e=super.getConfig();return Object.assign(t,e),t}}Ig.className="Activation";q(Ig);class Ng extends Ft{constructor(t){super(t),this.n=t.n,this.inputSpec=[{ndim:2}]}computeOutputShape(t){return[t[0],this.n,t[1]]}call(t,e){return B(()=>(t=kt(t),Gv(t,this.n)))}getConfig(){const t={n:this.n},e=super.getConfig();return Object.assign(t,e),t}}Ng.className="RepeatVector";q(Ng);class $g extends Ft{constructor(t){super(t),this.targetShape=t.targetShape;for(let e=0;e<this.targetShape.length;++e)this.isUnknown(this.targetShape[e])&&(this.targetShape[e]=null)}isUnknown(t){return t<0||t==null}fixUnknownDimension(t,e){const s="Total size of new array must be unchanged.",i=e.slice();let o=1,r=null;for(let u=0;u<i.length;++u){const l=i[u];if(this.isUnknown(l))if(r===null)r=u;else throw new M("Can only specifiy one unknown dimension.");else o*=l}const a=ds(t);if(r!==null){if(o===0||a%o!==0)throw new M(s);i[r]=a/o}else if(a!==o)throw new M(s);return i}computeOutputShape(t){let e=!1;for(let s=0;s<t.length;++s)if(this.isUnknown(t[s])){e=!0;break}return e?t.slice(0,1).concat(this.targetShape):t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape))}call(t,e){return B(()=>{this.invokeCallHook(t,e);const s=kt(t),i=s.shape,o=i.slice(0,1).concat(this.fixUnknownDimension(i.slice(1),this.targetShape));return Q(s,o)})}getConfig(){const t={targetShape:this.targetShape},e=super.getConfig();return Object.assign(t,e),t}}$g.className="Reshape";q($g);class Dg extends Ft{constructor(t){if(super(t),t.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(t.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${t.dims} instead.`);const e=bn(1,t.dims.length+1);if(!ke(t.dims.slice().sort(),e))throw new Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=t.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new ye({ndim:this.dims.length+1})]}computeOutputShape(t){t=Wt(t);const e=t.slice();return this.dims.forEach((s,i)=>{e[i+1]=t[s]}),e}call(t,e){return Vt(kt(t),this.dimsIncludingBatch)}getConfig(){const t={dims:this.dims},e=super.getConfig();return Object.assign(t,e),t}}Dg.className="Permute";q(Dg);class Rg extends Ft{constructor(t){super(t??{}),this.supportsMasking=!0,t!=null?this.maskValue=t.maskValue==null?0:t.maskValue:this.maskValue=0}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={maskValue:this.maskValue};return Object.assign(e,t),e}computeMask(t,e){const s=kt(t);return Qa(Ho(s,this.maskValue),-1)}call(t,e){return B(()=>{this.invokeCallHook(t,e);const s=kt(t),r=Qa(Ho(s,this.maskValue),-1,!0);return O(s,mt(r,s.dtype))})}}Rg.className="Masking";q(Rg);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Ag extends Ft{constructor(t){if(super(t),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",t.batchInputShape==null&&t.inputShape==null){let e=null;t.batchSize!=null&&(e=t.batchSize),t.inputLength==null?this.batchInputShape=[e,null]:this.batchInputShape=[e].concat(Kt(t.inputLength))}this.inputDim=t.inputDim,Ce(this.inputDim,"inputDim"),this.outputDim=t.outputDim,Ce(this.outputDim,"outputDim"),this.embeddingsInitializer=oe(t.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=re(t.embeddingsRegularizer),this.activityRegularizer=re(t.activityRegularizer),this.embeddingsConstraint=xe(t.embeddingsConstraint),this.maskZero=t.maskZero,this.supportsMasking=t.maskZero,this.inputLength=t.inputLength}build(t){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(t){}computeMask(t,e){return B(()=>this.maskZero?(t=kt(t),Ho(t,ce(t))):null)}computeOutputShape(t){if(t=Wt(t),this.inputLength==null)return[...t,this.outputDim];const e=Kt(this.inputLength);if(e.length!==t.length-1)throw new M(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);{let s=0;for(let i=0;i<e.length;++i){const o=e[i],r=t[i+1];if(o!=null&&r!=null&&o!==r)throw new M(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);o==null&&(e[s]=r),s++}}return[t[0],...e,this.outputDim]}call(t,e){return B(()=>{this.invokeCallHook(t,e);let s=kt(t);s.dtype!=="int32"&&(s=Pn(s,"int32"));const i=lm(this.embeddings.read(),Q(s,[s.size]));return Q(i,Wt(this.computeOutputShape(s.shape)))})}getConfig(){const t={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:ae(this.embeddingsInitializer),embeddingsRegularizer:Yt(this.embeddingsRegularizer),activityRegularizer:Yt(this.activityRegularizer),embeddingsConstraint:be(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},e=super.getConfig();return Object.assign(t,e),t}}Ag.className="Embedding";q(Ag);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class js extends Ft{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new At}computeElementwiseOpOutputShape(t,e){if(t==null||e==null)return null;if(t.length<e.length)return this.computeElementwiseOpOutputShape(e,t);if(e.length===0)return t;const s=t.slice(0,t.length-e.length);for(let i=0;i<e.length;++i){const o=t[t.length-e.length+i],r=e[i];if(o==null||r==null||o<0||r<0)s.push(null);else if(o===1)s.push(r);else if(r===1)s.push(o);else{if(o!==r)throw new M("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(e));s.push(o)}}return s}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[Wt(t)]),t=t,t.length<2)throw new M(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let e=[];for(const o of t)o!=null&&o[0]!==null&&e.push(o[0]);if(e=hs(e),e.length>1)throw new M(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let s=t[0]==null?null:t[0].slice(1);for(let o=1;o<t.length;++o){const r=t[o]==null?null:t[o].slice(1);s=this.computeElementwiseOpOutputShape(s,r)}const i=t.map(o=>o.length);t.indexOf(null)===-1&&hs(i).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(t,e){return B(()=>{if(t=t,this.reshapeRequired){const s=[],i=t.map(o=>o.rank);if(i.indexOf(null)===-1){const o=ms(i);for(let r of t){const a=r.rank;for(let u=0;u<o-a;++u)r=fo(r,1);s.push(r)}return this.mergeFunction(s)}else{let o=!1;for(const u of t){const l=u.rank;if(l==null){const c=u.shape,h=c[0],p=c.slice(1).concat([h]);let f=Q(u,[h].concat(ds(c.slice(1))));f=Vt(f,[1,0]),f=Q(f,p),s.push(f),o=!0}else if(l>1){const c=bn(1,l).concat([0]);s.push(Vt(u,c)),o=!0}else s.push(u)}let r=this.mergeFunction(s);const a=r.rank;if(o){if(a==null){const u=r.shape,l=u.length,c=u[l-1],h=[c].concat(u.slice(0,u.length-1));r=Q(Vt(Q(r,[-1,c]),[1,0]),h)}else if(a>1){const u=[a-1].concat(bn(0,a-1));r=Vt(r,u)}}return r}}else return this.mergeFunction(t)})}computeOutputShape(t){t=t;let e;t[0]==null?e=null:e=t[0].slice(1);for(let i=1;i<t.length;++i){const o=t[i]==null?null:t[i].slice(1);e=this.computeElementwiseOpOutputShape(e,o)}let s=[];for(const i of t)i!=null&&i[0]!==null&&s.push(i[0]);return s=hs(s),s.length===1?e=s.concat(e):e=[null].concat(e),e}computeMask(t,e){return B(()=>{if(e==null)return null;if(!Array.isArray(e))throw new M("`mask` should be an Array");if(!Array.isArray(t))throw new M("`inputs` should be an Array");if(e.length!==t.length)throw new M(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${e.length})`);if(e.every(i=>i==null))return null;e=e.map(i=>i==null?i:Ye(i,0));let s=e[0];for(let i=1;i<e.length-1;++i)s=vi(s,e[i]);return s})}}class Tg extends js{constructor(t){super(t)}mergeFunction(t){return B(()=>{let e=t[0].clone();for(let s=1;s<t.length;++s)e=ct(e,t[s]);return e})}}Tg.className="Add";q(Tg);class zg extends js{constructor(t){super(t)}mergeFunction(t){return B(()=>{let e=t[0].clone();for(let s=1;s<t.length;++s)e=O(e,t[s]);return e})}}zg.className="Multiply";q(zg);class Fg extends js{constructor(t){super(t)}mergeFunction(t){return B(()=>{let e=t[0].clone();for(let s=1;s<t.length;++s)e=ct(e,t[s]);return O(1/t.length,e)})}}Fg.className="Average";q(Fg);class Mg extends js{constructor(t){super(t)}mergeFunction(t){return B(()=>{let e=t[0];for(let s=1;s<t.length;++s)e=Vs(e,t[s]);return e})}}Mg.className="Maximum";q(Mg);class Pg extends js{constructor(t){super(t)}mergeFunction(t){return B(()=>{let e=t[0];for(let s=1;s<t.length;++s)e=jr(e,t[s]);return e})}}Pg.className="Minimum";q(Pg);class Eg extends js{constructor(t){super(t),this.DEFAULT_AXIS=-1,t==null&&(t={}),this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){if(!(Array.isArray(t)&&Array.isArray(t[0]))||t.length===1)throw new M("A `Concatenate` layer should be called on a list of at least 2 inputs");t=t;let e=!0;for(const i of t)if(i!=null){e=!1;break}if(e)return;const s=[];for(let i=0;i<t.length;++i){const o=t[i].slice();o.splice(this.axis,1);let r=!1;for(const a of s)if(ke(a,o)){r=!0;break}r||s.push(o)}if(s.length>1)throw new M("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(t))}mergeFunction(t){return B(()=>Bl(t,this.axis))}computeOutputShape(t){if(!(Array.isArray(t)&&Array.isArray(t[0])))throw new M("A `Concatenate` layer should be called on a list of inputs.");const e=t,s=e[0].slice(),i=this.axis<0?s.length+this.axis:this.axis;for(const o of e.slice(1)){if(s[i]==null||o[i]==null){s[i]=null;break}s[i]+=o[i]}return s}computeMask(t,e){if(e==null)return null;if(!Array.isArray(e))throw new M("`mask` should be an array for Concatenate");if(!Array.isArray(t))throw new M("`inputs` should be an array for Concatenate");if(e.length!==t.length)throw new M(`Mismatch in the length of mask (${e.length}) and the legnth of inputs (${t.length})`);return B(()=>{let s=!0;if(e.forEach(r=>{if(r!=null){s=!1;return}}),s)return null;const i=[];for(let r=0;r<t.length;++r)e[r]==null?i.push(mt(un(t[r]),"bool")):e[r].rank<t[r].rank?i.push(Ye(e[r],-1)):i.push(e[r]);const o=fs(i,this.axis);return rp(o,-1,!1)})}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}Eg.className="Concatenate";q(Eg);function Ui(n,t){for(;n<0;)n+=t;return n}function pk(n,t,e){if(n.shape.length>3||t.shape.length>3)throw new At("batchDot is not implemented for tensors of 4D or higher rank yet");if(tt(n.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${n.shape.length}`),tt(n.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),typeof e=="number"&&(e=[e,e]),n.dtype==="complex64"||t.dtype==="complex64")throw new At("batchDot is not implemented for complex64-type Tensors yet.");const s=n.shape.length,i=t.shape.length;e==null&&(e=[s-1,i-2]);const o=e;return B(()=>{let r;if(s>i){r=s-i;const u=[];for(let l=0;l<r;++l)u.push(1);t=Q(t,t.shape.concat(u))}else if(i>s){r=i-s;const u=[];for(let l=0;l<r;++l)u.push(1);n=Q(n,n.shape.concat(u))}else r=0;let a;if(n.shape.length===2&&t.shape.length===2)o[0]===o[1]?a=Et(O(n,t),o[0]):a=Et(O(Vt(n,[1,0]),t),o[1]);else{const u=o[0]!==n.shape.length-1,l=o[1]===t.shape.length-1;a=Dn(n,t,u,l)}if(r>0){let u;s>i?u=s+i-3:u=s-1;const l=[];for(let c=u;c<u+r;++c)l.push(c);a=Xt(a,l)}return a.shape.length===1&&(a=Ye(a,1)),a})}class Lg extends js{constructor(t){super(t),this.axes=t.axes,this.normalize=t.normalize==null?!1:t.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){tt(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const e=t[0],s=t[1];if(e.length>3||s.length>3)throw new At("Dot layer does not support tensors of 4D or higher rank yet.");const i=this.interpretAxes(e,s);if(e[i[0]]!==s[i[1]])throw new M(`Dimension incompatibility: ${e[i[0]]} !== ${s[i[1]]}`)}mergeFunction(t){if(t.length!==2)throw new M(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${t.length} input(s).`);let e=t[0],s=t[1],i;return Array.isArray(this.axes)?i=this.axes.map((o,r)=>Ui(o,t[r].shape.length)):i=[Ui(this.axes,e.shape.length),Ui(this.axes,s.shape.length)],this.normalize&&(e=Jo(e,i[0]),s=Jo(s,i[1])),pk(e,s,i)}interpretAxes(t,e){let s;return Array.isArray(this.axes)?s=this.axes:s=[Ui(this.axes,t.length),Ui(this.axes,e.length)],s}computeOutputShape(t){tt(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const e=t[0].slice(),s=t[1].slice();if(e.length>3||s.length>3)throw new At("Dot layer does not support tensors of 4D or higher rank yet.");const i=this.interpretAxes(e,s);e.splice(i[0],1),s.splice(i[1],1),s.splice(0,1);const o=e.concat(s);return o.length===1&&o.push(1),o}computeMask(t,e){return null}getConfig(){const t={axes:this.axes,normalize:this.normalize},e=super.getConfig();return Object.assign(t,e),t}}Lg.className="Dot";q(Lg);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Og extends Ft{constructor(t){super(t),this.supportsMasking=!0,this.stddev=t.stddev}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={stddev:this.stddev};return Object.assign(e,t),e}call(t,e){return B(()=>{this.invokeCallHook(t,e);const s=kt(t);return go(()=>ct(ea(s.shape,0,this.stddev),s),()=>s,e.training||!1)})}}Og.className="GaussianNoise";q(Og);class _g extends Ft{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return B(()=>{this.invokeCallHook(t,e);const s=kt(t);return this.rate>0&&this.rate<1?go(()=>{const o=Math.sqrt(this.rate/(1-this.rate));return O(s,ea(s.shape,1,o))},()=>s,e.training||!1):s})}}_g.className="GaussianDropout";q(_g);class Bg extends Ft{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate,this.noiseShape=t.noiseShape}_getNoiseShape(t){return this.noiseShape||kt(t).shape}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return B(()=>{if(this.rate<1&&this.rate>0){const s=this._getNoiseShape(t);return go(()=>{const o=kt(t),u=-1.6732632423543772*1.0507009873554805;let l=Ci(qr(s),this.rate);l=Pn(l,"float32");const c=((1-this.rate)*(1+this.rate*u**2))**-.5,h=-c*u*this.rate,p=ct(O(o,l),O(ct(l,-1),u));return ct(O(p,c),h)},()=>kt(t),e.training||!1)}return t})}}Bg.className="AlphaDropout";q(Bg);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function io(n,t,e,s,i,o=.001){let r;if(n.rank===2)r=Lw(n,t,e,s,i,o);else if(n.rank===3)r=Ow(n,t,e,s,i,o);else if(n.rank===4)r=_w(n,t,e,s,i,o);else throw new At(`batchNormalization is not implemented for array of rank ${n.rank} yet`);return r}function fk(n,t,e,s,i=.001){return B(()=>{const o=Dl(n,s),r=o.mean,a=o.variance;return[io(n,r,a,e,t,i),r,a]})}function mk(n,t,e,s,i=.001){return B(()=>{const o=Dl(n,s),r=o.mean,a=o.variance,u=[];for(const m of bn(0,n.rank))s.indexOf(m)!==-1?u.push(1):u.push(n.shape[m]);const l=Q(r,u),c=Q(a,u),h=t==null?null:Q(t,u),p=e==null?null:Q(e,u);return[io(n,l,c,p,h,i),r,a]})}function gk(n,t,e,s,i=.001){return ke(s.slice().sort(),bn(0,n.rank-1))?fk(n,t,e,s,i):mk(n,t,e,s,i)}class Wg extends Ft{constructor(t){t==null&&(t={}),super(t),this.supportsMasking=!0,this.axis=t.axis==null?-1:t.axis,this.momentum=t.momentum==null?.99:t.momentum,this.epsilon=t.epsilon==null?.001:t.epsilon,this.center=t.center==null?!0:t.center,this.scale=t.scale==null?!0:t.scale,this.betaInitializer=oe(t.betaInitializer||"zeros"),this.gammaInitializer=oe(t.gammaInitializer||"ones"),this.movingMeanInitializer=oe(t.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=oe(t.movingVarianceInitializer||"ones"),this.betaConstraint=xe(t.betaConstraint),this.gammaConstraint=xe(t.gammaConstraint),this.betaRegularizer=re(t.betaRegularizer),this.gammaRegularizer=re(t.gammaRegularizer)}build(t){t=Wt(t);const e=this.axis>=0?this.axis:this.axis+t.length,s=t[e];if(s==null)throw new M(`Axis ${e} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(t)}.`);this.inputSpec=[new ye({ndim:t.length,axes:{[e]:s}})];const i=[s];this.scale&&(this.gamma=this.addWeight("gamma",i,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",i,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",i,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",i,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(t,e){return B(()=>{const s=e.training==null?!1:e.training,i=kt(t),o=i.shape,r=o.length,a=bn(0,r),u=this.axis>=0?this.axis:this.axis+r;a.splice(u,1);const l=Os(1,r);l[u]=o[u];const c=a.slice();c.sort();const h=!ke(c,bn(0,r).slice(0,r-1)),p=()=>{if(h){const w=Q(this.movingMean.read(),l),k=Q(this.movingVariance.read(),l),C=this.center?Q(this.beta.read(),l):null,I=this.scale?Q(this.gamma.read(),l):null;return io(i,w,k,C,I,this.epsilon)}else return io(i,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!s)return p();const[f,m,g]=gk(i,this.gamma.read(),this.beta.read(),a,this.epsilon),b=(w,k,C)=>{B(()=>{const I=1-C,N=w.read(),$=O(Lt(N,k),I);w.write(Lt(N,$))})};return(()=>{b(this.movingMean,m,this.momentum),b(this.movingVariance,g,this.momentum)})(),f})}getConfig(){const t={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:ae(this.betaInitializer),gammaInitializer:ae(this.gammaInitializer),movingMeanInitializer:ae(this.movingMeanInitializer),movingVarianceInitializer:ae(this.movingVarianceInitializer),betaRegularizer:Yt(this.betaRegularizer),gammaRegularizer:Yt(this.gammaRegularizer),betaConstraint:be(this.betaConstraint),gammaConstraint:be(this.gammaConstraint)},e=super.getConfig();return Object.assign(t,e),t}}Wg.className="BatchNormalization";q(Wg);class Vg extends Ft{constructor(t){if(t==null&&(t={}),super(t),this.axis=t.axis==null?-1:t.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const e of this.axis)if(!Number.isInteger(e))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=t.epsilon==null?.001:t.epsilon,this.center=t.center==null?!0:t.center,this.scale=t.scale==null?!0:t.scale,this.betaInitializer=oe(t.betaInitializer||"zeros"),this.gammaInitializer=oe(t.gammaInitializer||"ones"),this.betaRegularizer=re(t.betaRegularizer),this.gammaRegularizer=re(t.gammaRegularizer),this.supportsMasking=!0}build(t){t=Wt(t);const e=t.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let o=0;o<this.axis.length;++o)this.axis[o]<0&&(this.axis[o]+=e);for(const o of this.axis)if(o<0||o>=e)throw new Error(`Invalid axis: ${o}`);if(this.axis.length!==hs(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const s=this.axis.map(o=>t[o]),i=!0;this.scale?this.gamma=this.addWeight("gamma",s,"float32",this.gammaInitializer,this.gammaRegularizer,i):this.gamma=null,this.center?this.beta=this.addWeight("beta",s,"float32",this.betaInitializer,this.betaRegularizer,i):this.beta=null,this.built=!0}call(t,e){const s=kt(t),i=s.shape,o=i.length;return B(()=>{let{mean:a,variance:u}=Dl(s,this.axis,!0);const l=Os(1,o);for(const g of this.axis)l[g]=i[g];const c=g=>g!=null&&g.shape.length!==o?Q(g,l):g;let h=this.scale?c(this.gamma.read()):null,p=this.center?c(this.beta.read()):null;const f=[],m=[];for(let g=0;g<o;++g)this.axis.indexOf(g)!==-1?(f.push(i[g]),m.push(1)):(f.push(1),m.push(i[g]));return a=As(a,f),u=As(u,f),h!=null&&(h=As(h,m)),p!=null&&(p=As(p,m)),io(s,a,u,p,h,this.epsilon)})}getConfig(){const t={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:ae(this.betaInitializer),gammaInitializer:ae(this.gammaInitializer),betaRegularizer:Yt(this.betaRegularizer),gammaRegularizer:Yt(this.gammaRegularizer)},e=super.getConfig();return Object.assign(t,e),t}}Vg.className="LayerNormalization";q(Vg);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function yk(n,t,e){return B(()=>{if(n.rank!==4)throw new M(`temporalPadding expects input tensor to be 4-D, but received a ${n.rank}-D tensor.`);if(t==null&&(t=[[1,1],[1,1]]),t.length!==2||t[0].length!==2||t[1].length!==2)throw new M("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(e==null&&(e=xn()),e!=="channelsLast"&&e!=="channelsFirst")throw new M(`Unknown data format: ${e}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let s;return e==="channelsFirst"?s=[[0,0],[0,0],t[0],t[1]]:s=[[0,0],t[0],t[1],[0,0]],ui(n,s)})}class Ug extends Ft{constructor(t){if(t==null&&(t={}),super(t),this.dataFormat=t.dataFormat==null?xn():t.dataFormat,t.padding==null)this.padding=[[1,1],[1,1]];else if(typeof t.padding=="number")this.padding=[[t.padding,t.padding],[t.padding,t.padding]];else{if(t.padding=t.padding,t.padding.length!==2)throw new M(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${t.padding.length} array.`);let e,s;if(typeof t.padding[0]=="number")e=[t.padding[0],t.padding[0]],s=[t.padding[1],t.padding[1]];else{if(t.padding=t.padding,t.padding[0].length!==2)throw new M(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${t.padding[0].length} array.`);if(e=t.padding[0],t.padding[1].length!==2)throw new M(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${t.padding[1].length} array.`);s=t.padding[1]}this.padding=[e,s]}this.inputSpec=[new ye({ndim:4})]}computeOutputShape(t){t=Wt(t);let e,s;return this.dataFormat==="channelsFirst"?(t[2]!=null&&t[2]>=0?e=t[2]+this.padding[0][0]+this.padding[0][1]:e=null,t[3]!=null&&t[3]>=0?s=t[3]+this.padding[1][0]+this.padding[1][1]:s=null,[t[0],t[1],e,s]):(t[1]!=null&&t[1]>=0?e=t[1]+this.padding[0][0]+this.padding[0][1]:e=null,t[2]!=null&&t[2]>=0?s=t[2]+this.padding[1][0]+this.padding[1][1]:s=null,[t[0],e,s,t[3]])}call(t,e){return B(()=>yk(kt(t),this.padding,this.dataFormat))}getConfig(){const t={padding:this.padding,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}Ug.className="ZeroPadding2D";q(Ug);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function la(n,t,e,s,i,o){return B(()=>{pe(i),om(o),Qe(s),e==null&&(e=[1,1]),s==null&&(s="valid"),i==null&&(i=xn()),o==null&&(o="max"),n=Jl(n,i);let r;const a=s==="same"?"same":"valid";return o==="max"?r=gp(n,t,e,a):r=ap(n,t,e,a),i==="channelsFirst"&&(r=Vt(r,[0,3,1,2])),r})}function Gg(n,t,e,s,i,o){return B(()=>{pe(i),om(o),Qe(s),e==null&&(e=[1,1,1]),s==null&&(s="valid"),i==null&&(i=xn()),o==null&&(o="max"),n=ag(n,i);let r;const a=s==="same"?"same":"valid";return o==="max"?r=Bw(n,t,e,a):r=Ww(n,t,e,a),i==="channelsFirst"&&(r=Vt(r,[0,4,1,2,3])),r})}class Hg extends Ft{constructor(t){if(t.poolSize==null&&(t.poolSize=2),super(t),typeof t.poolSize=="number")this.poolSize=[t.poolSize];else if(Array.isArray(t.poolSize)&&t.poolSize.length===1&&typeof t.poolSize[0]=="number")this.poolSize=t.poolSize;else throw new M(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);if(Ce(this.poolSize,"poolSize"),t.strides==null)this.strides=this.poolSize;else if(typeof t.strides=="number")this.strides=[t.strides];else if(Array.isArray(t.strides)&&t.strides.length===1&&typeof t.strides[0]=="number")this.strides=t.strides;else throw new M(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);Ce(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,Qe(this.padding),this.inputSpec=[new ye({ndim:3})]}computeOutputShape(t){t=Wt(t);const e=gn(t[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],e,t[2]]}call(t,e){return B(()=>{this.invokeCallHook(t,e),t=fo(kt(t),2);const s=this.poolingFunction(kt(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Xt(s,[2])})}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(t,e),t}}class jg extends Hg{constructor(t){super(t)}poolingFunction(t,e,s,i,o){return pe(o),Qe(i),la(t,e,s,i,o,"max")}}jg.className="MaxPooling1D";q(jg);class Kg extends Hg{constructor(t){super(t)}poolingFunction(t,e,s,i,o){return pe(o),Qe(i),la(t,e,s,i,o,"avg")}}Kg.className="AveragePooling1D";q(Kg);class Xg extends Ft{constructor(t){if(t.poolSize==null&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==2)throw new M(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides];Ce(this.poolSize,"poolSize"),Ce(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,pe(this.dataFormat),Qe(this.padding),this.inputSpec=[new ye({ndim:4})]}computeOutputShape(t){t=Wt(t);let e=this.dataFormat==="channelsFirst"?t[2]:t[1],s=this.dataFormat==="channelsFirst"?t[3]:t[2];return e=gn(e,this.poolSize[0],this.padding,this.strides[0]),s=gn(s,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[t[0],t[1],e,s]:[t[0],e,s,t[3]]}call(t,e){return B(()=>(this.invokeCallHook(t,e),this.poolingFunction(kt(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class qg extends Xg{constructor(t){super(t)}poolingFunction(t,e,s,i,o){return pe(o),Qe(i),la(t,e,s,i,o,"max")}}qg.className="MaxPooling2D";q(qg);class Yg extends Xg{constructor(t){super(t)}poolingFunction(t,e,s,i,o){return pe(o),Qe(i),la(t,e,s,i,o,"avg")}}Yg.className="AveragePooling2D";q(Yg);class Zg extends Ft{constructor(t){if(t.poolSize==null&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==3)throw new M(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];Ce(this.poolSize,"poolSize"),Ce(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,pe(this.dataFormat),Qe(this.padding),this.inputSpec=[new ye({ndim:5})]}computeOutputShape(t){t=Wt(t);let e=this.dataFormat==="channelsFirst"?t[2]:t[1],s=this.dataFormat==="channelsFirst"?t[3]:t[2],i=this.dataFormat==="channelsFirst"?t[4]:t[3];return e=gn(e,this.poolSize[0],this.padding,this.strides[0]),s=gn(s,this.poolSize[1],this.padding,this.strides[1]),i=gn(i,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[t[0],t[1],e,s,i]:[t[0],e,s,i,t[4]]}call(t,e){return B(()=>(this.invokeCallHook(t,e),this.poolingFunction(kt(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class Qg extends Zg{constructor(t){super(t)}poolingFunction(t,e,s,i,o){return pe(o),Qe(i),Gg(t,e,s,i,o,"max")}}Qg.className="MaxPooling3D";q(Qg);class Jg extends Zg{constructor(t){super(t)}poolingFunction(t,e,s,i,o){return pe(o),Qe(i),Gg(t,e,s,i,o,"avg")}}Jg.className="AveragePooling3D";q(Jg);class ty extends Ft{constructor(t){super(t),this.inputSpec=[new ye({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,e){throw new At}}class ey extends ty{constructor(t){super(t||{})}call(t,e){return B(()=>{const s=kt(t);return ve(s,1)})}}ey.className="GlobalAveragePooling1D";q(ey);class ny extends ty{constructor(t){super(t||{})}call(t,e){return B(()=>{const s=kt(t);return ci(s,1)})}}ny.className="GlobalMaxPooling1D";q(ny);class sy extends Ft{constructor(t){super(t),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,pe(this.dataFormat),this.inputSpec=[new ye({ndim:4})]}computeOutputShape(t){return t=t,this.dataFormat==="channelsLast"?[t[0],t[3]]:[t[0],t[1]]}call(t,e){throw new At}getConfig(){const t={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class iy extends sy{call(t,e){return B(()=>{const s=kt(t);return this.dataFormat==="channelsLast"?ve(s,[1,2]):ve(s,[2,3])})}}iy.className="GlobalAveragePooling2D";q(iy);class oy extends sy{call(t,e){return B(()=>{const s=kt(t);return this.dataFormat==="channelsLast"?ci(s,[1,2]):ci(s,[2,3])})}}oy.className="GlobalMaxPooling2D";q(oy);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class ry extends Ft{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(t){this.layer!=null&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){const t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(t,e),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,e,s={}){const i=e.layer,o=qn(i,s);delete e.layer;const r={layer:o};return Object.assign(r,e),new t(r)}}class ay extends ry{constructor(t){super(t),this.supportsMasking=!0}build(t){if(t=Wt(t),t.length<3)throw new M(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(t)}`);this.inputSpec=[{shape:t}];const e=[t[0]].concat(t.slice(2));this.layer.built||(this.layer.build(e),this.layer.built=!0),super.build(t)}computeOutputShape(t){t=Wt(t);const e=[t[0]].concat(t.slice(2)),s=this.layer.computeOutputShape(e),i=t[1];return[s[0],i].concat(s.slice(1))}call(t,e){return B(()=>(t=kt(t),gg((r,a)=>[kt(this.layer.call(r,e)),[]],t,[],!1,null,null,!1,!0)[1]))}}ay.className="TimeDistributed";q(ay);function bk(n){Hs(_v,"BidirectionalMergeMode",n)}const xk="concat";class uy extends ry{constructor(t){super(t);const e=t.layer.getConfig(),s={};s.className=t.layer.getClassName(),s.config=e,this.forwardLayer=qn(s),e.goBackwards=e.goBackwards!==!0;const i={};if(i.className=t.layer.getClassName(),i.config=e,this.backwardLayer=qn(i),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=t.mergeMode===void 0?xk:t.mergeMode,bk(this.mergeMode),t.weights)throw new At("weights support is not implemented for Bidirectional layer yet.");this._stateful=t.layer.stateful,this.returnSequences=t.layer.returnSequences,this.returnState=t.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=t.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(t){this._trainable=t,this.forwardLayer!=null&&(this.forwardLayer.trainable=t),this.backwardLayer!=null&&(this.backwardLayer.trainable=t)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(t){const e=t.length,s=Math.floor(e/2);this.forwardLayer.setWeights(t.slice(0,s)),this.backwardLayer.setWeights(t.slice(s))}computeOutputShape(t){let e=this.forwardLayer.computeOutputShape(t);Array.isArray(e)&&Array.isArray(e[0])||(e=[e]),e=e;let s,i,o;return this.returnState&&(o=e.slice(1)),s=e[0],s=s,this.mergeMode==="concat"?(s[s.length-1]*=2,i=[s]):this.mergeMode==null?i=[s,s.slice()]:i=[s],this.returnState?this.mergeMode==null?i.concat(o).concat(o.slice()):[s].concat(o).concat(o.slice()):Pe(i)}apply(t,e){let s=e==null?null:e.initialState,i=e==null?null:e.constants;e==null&&(e={});const o=mg(t,s,i,this.numConstants);if(t=o.inputs,s=o.initialState,i=o.constants,Array.isArray(t)&&(s=t.slice(1),t=t[0]),(s==null||s.length===0)&&i==null)return super.apply(t,e);const r=[],a=[];if(s!=null){const l=s.length;if(l%2>0)throw new M("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");e.initialState=s,r.push(...s);const c=s.map(h=>new ye({shape:h.shape}));this.forwardLayer.stateSpec=c.slice(0,l/2),this.backwardLayer.stateSpec=c.slice(l/2),a.push(...c)}if(i!=null)throw new At("Support for constants in Bidirectional layers is not implemented yet.");const u=r[0]instanceof On;for(const l of r)if(l instanceof On!==u)throw new M("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(u){const l=[t].concat(r),c=this.inputSpec.concat(a),h=this.inputSpec;this.inputSpec=c;const p=super.apply(l,e);return this.inputSpec=h,p}else return super.apply(t,e)}call(t,e){return B(()=>{const s=e.initialState;let i,o;if(s==null)i=this.forwardLayer.call(t,e),o=this.backwardLayer.call(t,e);else{const u=s.slice(0,s.length/2),l=s.slice(s.length/2);i=this.forwardLayer.call(t,Object.assign(e,{initialState:u})),o=this.backwardLayer.call(t,Object.assign(e,{initialState:l}))}let r;this.returnState&&(Array.isArray(i)&&(r=i.slice(1).concat(o.slice(1))),i=i[0],o=o[0]),this.returnSequences&&(o=Qi(o,1));let a;return this.mergeMode==="concat"?a=Bl([i,o]):this.mergeMode==="sum"?a=ct(i,o):this.mergeMode==="ave"?a=O(.5,ct(i,o)):this.mergeMode==="mul"?a=O(i,o):this.mergeMode==null&&(a=[i,o]),this.returnState?this.mergeMode==null?a.concat(r):[a].concat(r):a})}resetStates(t){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(t){Fs(this.forwardLayer.name,()=>{this.forwardLayer.build(t)}),Fs(this.backwardLayer.name,()=>{this.backwardLayer.build(t)}),this.built=!0}computeMask(t,e){Array.isArray(e)&&(e=e[0]);let s;if(this.returnSequences?this.mergeMode==null?s=[e,e]:s=e:this.mergeMode==null?s=[null,null]:s=null,this.returnState){const o=this.forwardLayer.states.map(r=>null);return Array.isArray(s)?s.concat(o).concat(o):[s].concat(o).concat(o)}else return s}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(t),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(t)}getConfig(){const t={mergeMode:this.mergeMode},e=super.getConfig();return Object.assign(t,e),t}static fromConfig(t,e){const s=qn(e.layer);if(delete e.layer,e.numConstants!=null)throw new At("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const i=e;return i.layer=s,new t(i)}}uy.className="Bidirectional";q(uy);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class ly extends Ft{constructor(t){super(t),this.scale=t.scale,t.offset?this.offset=t.offset:this.offset=0}getConfig(){const t={scale:this.scale,offset:this.offset},e=super.getConfig();return Object.assign(t,e),t}call(t,e){return B(()=>(t=kt(t),t.dtype!=="float32"&&(t=Pn(t,"float32")),ct(O(t,this.scale),this.offset)))}}ly.className="Rescaling";q(ly);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const{resizeBilinear:wk,cropAndResize:vk}=Oe;class cy extends Ft{constructor(t){super(t),this.height=t.height,this.width=t.width}centerCrop(t,e,s,i,o,r,a,u){return B(()=>{let l,c=!1;const h=e/r,p=s/a,f=(i+e)/r,m=(o+s)/a,g=[h,p,f,m],b=[];t.rank===3?(c=!0,l=uo([t])):l=t;for(let I=0;I<l.shape[0];I++)b.push(g);const v=Vw(b,[b.length,4]),w=Uw(0,b.length,1,"int32"),C=vk(l,v,w,[i,o],"nearest");return Pn(c?kt(Zi(C)):C,u)})}upsize(t,e,s,i){return B(()=>{const o=wk(t,[e,s]);return Pn(o,i)})}call(t,e){return B(()=>{const s=kt(t),i=s.dtype,o=s.shape,r=o[o.length-3],a=o[o.length-2];let u=0;r!==this.height&&(u=Math.floor((r-this.height)/2));let l=0;return a!==this.width&&(l=Math.floor((a-this.width)/2),l===0&&(l=1)),u>=0&&l>=0?this.centerCrop(s,u,l,this.height,this.width,r,a,i):this.upsize(t,this.height,this.width,i)})}getConfig(){const t={height:this.height,width:this.width},e=super.getConfig();return Object.assign(t,e),t}computeOutputShape(t){t=Wt(t);const e=t.length-3,s=t.length-2;return t[e]=this.height,t[s]=this.width,t}}cy.className="CenterCrop";q(cy);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Ck(n,t,e,s){let i=kt(n);if(i.dtype!=="int32"&&(i=Pn(i,"int32")),t==="int")return i;const o=i.shape;if(i.rank===0&&(i=Ye(i,-1)),t==="oneHot"&&i.shape[i.shape.length-1]!==1&&(i=Ye(i,-1)),i.rank>2)throw new M(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${o} which would result in output rank ${i.rank}.`);const r=["multiHot","oneHot"].includes(t),a=i;let u;if(typeof s<"u"&&t==="count"?u=Jc(a,s,e,r):u=Jc(a,[],e,r),t!=="tfIdf")return u;if(s)return O(u,s);throw new M("When outputMode is 'tfIdf', weights must be provided.")}/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class hy extends Ft{constructor(t){super(t),this.numTokens=t.numTokens,t.outputMode?this.outputMode=t.outputMode:this.outputMode="multiHot"}getConfig(){const t={numTokens:this.numTokens,outputMode:this.outputMode},e=super.getConfig();return Object.assign(t,e),t}computeOutputShape(t){return t=Wt(t),t==null?[this.numTokens]:this.outputMode==="oneHot"&&t[t.length-1]!==1?(t.push(this.numTokens),t):(t[t.length-1]=this.numTokens,t)}call(t,e){return B(()=>{t=kt(t),t.dtype!=="int32"&&(t=Pn(t,"int32"));let s;if(typeof e.countWeights<"u"){if(this.outputMode!=="count")throw new M(`countWeights is not used when outputMode !== count.
              Received countWeights=${e.countWeights}`);s=kt(e.countWeights)}const i=ci(t),o=yp(t),r=Wn(this.numTokens,i).bufferSync().get(0),a=Ci(o,0).bufferSync().get(0);if(!(r&&a))throw new M(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return Ck(t,this.outputMode,this.numTokens,s)})}}hy.className="CategoryEncoding";q(hy);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const kk=["bilinear","nearest"],Rh=new Set(kk);class dy extends Ft{constructor(t){if(super(t),this.height=t.height,this.width=t.width,t.interpolation)if(Rh.has(t.interpolation))this.interpolation=t.interpolation;else throw new M(`Invalid interpolation parameter: ${t.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!t.cropToAspectRatio}computeOutputShape(t){t=Wt(t);const e=t[2];return[this.height,this.width,e]}getConfig(){const t={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},e=super.getConfig();return Object.assign(t,e),t}call(t,e){return B(()=>{const s=[this.height,this.width];if(this.interpolation==="bilinear")return Oe.resizeBilinear(t,s,!this.cropToAspectRatio);if(this.interpolation==="nearest")return Oe.resizeNearestNeighbor(t,s,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...Rh]} are supported`)})}}dy.className="Resizing";q(dy);/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class py{constructor(t){this.seed=t}next(){if(this.seed!==void 0)return this.seed++}}py.className="RandomSeed";/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class fy extends Ft{constructor(t){super(t),this.randomGenerator=new py(t.seed)}getConfig(){const t={seed:this.randomGenerator.seed},e=super.getConfig();return Object.assign(t,e),t}}fy.className="BaseRandomLayer";/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Sk=["bilinear","nearest"],Ah=new Set(Sk);class my extends fy{constructor(t){super(t);const{factor:e,interpolation:s="bilinear"}=t;if(this.factor=e,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new M(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new M(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new M(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(s)if(Ah.has(s))this.interpolation=s;else throw new M(`Invalid interpolation parameter: ${s} is not implemented`)}getConfig(){const t={factor:this.factor,interpolation:this.interpolation},e=super.getConfig();return Object.assign(t,e),t}computeOutputShape(t){t=Wt(t);const e=t[2];return[this.imgHeight,-1,e]}call(t,e){return B(()=>{const s=kt(t);this.imgHeight=s.shape[s.shape.length-3];const i=s.shape[s.shape.length-2];this.widthFactor=qr([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let o=this.widthFactor.dataSync()[0]*i;o=Math.round(o);const r=[this.imgHeight,o];switch(this.interpolation){case"bilinear":return Oe.resizeBilinear(t,r);case"nearest":return Oe.resizeNearestNeighbor(t,r);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...Ah]} are supported`)}})}}my.className="RandomWidth";q(my);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var Th;(function(n){n[n.FAIL=0]="FAIL",n[n.SHORTEST=1]="SHORTEST",n[n.LONGEST=2]="LONGEST"})(Th||(Th={}));/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ik=Hw;class ca extends Ip{nextDataId(){return ca.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new Np(this,ls())}write(t,e,s){this.firstUse&&(this.firstUse=!1,he().get("IS_NODE")&&Gw(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const i={id:this.nextDataId()};return this.data.set(i,{values:t,dtype:s,refCount:1}),i}makeTensorInfo(t,e,s){let i;if(e==="string"&&s!=null&&s.length>0&&$p(s[0])){const o=s.map(r=>Dp(r));i=this.write(o,t,e)}else i=this.write(s,t,e);return{dataId:i,shape:t,dtype:e}}refCount(t){return this.data.has(t)?this.data.get(t).refCount:0}incRef(t){const e=this.data.get(t);e.refCount++}decRef(t){if(this.data.has(t)){const e=this.data.get(t);e.refCount--}}move(t,e,s,i,o){this.data.set(t,{values:e,dtype:i,refCount:o})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){const{dtype:e,complexTensorInfos:s}=this.data.get(t);if(e==="complex64"){const i=this.readSync(s.real.dataId),o=this.readSync(s.imag.dataId);return di(i,o)}return Bo(this.data.get(t).values,e)}bufferSync(t){const e=this.readSync(t.dataId);if(t.dtype==="string")try{const s=e.map(i=>ho(i));return ue(t.shape,t.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return ue(t.shape,t.dtype,e)}makeOutput(t,e,s){return ls().makeTensorFromTensorInfo(this.makeTensorInfo(e,s,t),this)}disposeData(t,e=!1){if(this.data.has(t)){if(this.data.get(t).refCount--,!e&&this.data.get(t).refCount>0)return!1;const{complexTensorInfos:s}=this.data.get(t);s!=null&&(this.disposeData(s.real.dataId,!0),this.disposeData(s.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}async time(t){const e=jo();return t(),{kernelMs:jo()-e}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){yt([t],"where");const e=this.readSync(t.dataId);return Ik(t.shape,e)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}ca.nextDataId=0;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Rp("cpu",()=>new ca,1);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gy=Qt(Sr,n=>n>=0?n:Math.exp(n)-1),Nk={kernelName:Sr,backendName:"cpu",kernelFunc:gy};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yy(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{alpha:o}=s;yt([i],"leakyRelu");const r=et(i.shape),a=e.data.get(i.dataId).values,u=Ln("float32",r);for(let l=0;l<a.length;l++)u[l]=a[l]<0?o*a[l]:a[l];return e.makeTensorInfo(i.shape,"float32",u)}const $k={kernelName:Wu,backendName:"cpu",kernelFunc:yy};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dk=Us((n,t)=>n<0?t*n:n);function by(n){const{inputs:t,backend:e}=n,{x:s,alpha:i}=t;yt([s,i],"prelu");const o=e.data.get(s.dataId).values,r=e.data.get(i.dataId).values,[a,u]=Dk(s.shape,i.shape,o,r,"float32");return e.makeTensorInfo(u,"float32",a)}const Rk={kernelName:sl,backendName:"cpu",kernelFunc:by};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xy=Qt(Er,n=>Math.max(0,n)),Ak={kernelName:Er,backendName:"cpu",kernelFunc:xy};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wy=Qt(Pr,n=>Math.min(Math.max(0,n),6)),Tk={kernelName:Pr,backendName:"cpu",kernelFunc:wy};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ir(n,t,e,s,i){if(e==="linear")return Gs({inputs:{x:t},backend:n});if(e==="relu")return xy({inputs:{x:t},backend:n});if(e==="elu")return gy({inputs:{x:t},backend:n});if(e==="relu6")return wy({inputs:{x:t},backend:n});if(e==="prelu")return by({inputs:{x:t,alpha:s},backend:n});if(e==="leakyrelu")return yy({inputs:{x:t},backend:n,attrs:{alpha:i}});if(e==="sigmoid")return jw({inputs:{x:t},backend:n});throw new Error(`Activation ${e} has not been implemented for the CPU backend.`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function te(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{shape:o}=s,r=et(i.shape),a=Ap(o,r),u=et(a);tt(r===u,()=>`The new shape (${a}) has ${u} elements and the old shape (${i.shape}) has ${r} elements. The new shape and old shape must have the same number of elements.`),e.incRef(i.dataId);const l=e.data.get(i.dataId);if(l.complexTensorInfos!=null){const c=l.complexTensorInfos.real,h=l.complexTensorInfos.imag;c.shape=a,h.shape=a}return{dataId:i.dataId,shape:a,dtype:i.dtype}}const zk={kernelName:il,backendName:"cpu",kernelFunc:te};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vy(n){const{inputs:t,backend:e,attrs:s}=n,{a:i,b:o}=t,{transposeA:r,transposeB:a}=s;yt([i,o],"matMul");const u=i.shape.length,l=o.shape.length,c=r?i.shape[u-2]:i.shape[u-1],h=a?o.shape[l-1]:o.shape[l-2],p=r?i.shape[u-1]:i.shape[u-2],f=a?o.shape[l-2]:o.shape[l-1],m=i.shape.slice(0,-2),g=o.shape.slice(0,-2),b=et(m),v=et(g),k=Ne(i.shape.slice(0,-2),o.shape.slice(0,-2)).concat([p,f]);tt(c===h,()=>`Error in matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${i.shape} and ${o.shape} and transposeA=${r} and transposeB=${a} must match.`);const C=r?[b,c,p]:[b,p,c],I=a?[v,f,h]:[v,h,f],N=te({inputs:{x:i},backend:e,attrs:{shape:C}}),$=te({inputs:{x:o},backend:e,attrs:{shape:I}}),A=r?N.shape[1]:N.shape[2],z=r?N.shape[2]:N.shape[1],F=a?$.shape[1]:$.shape[2],E=Math.max(b,v),U=e.data.get(N.dataId).values,L=e.data.get($.dataId).values,W=Tt(N.shape),_=Tt($.shape),[V,X,j]=r?[W[0],1,W[1]]:[W[0],W[1],1],[K,Z,Y]=a?[1,_[1],_[0]]:[_[1],1,_[0]],it=z*F,nt=ue([E,z,F],N.dtype),ut=nt.values,at=e.blockSize;for(let pt=0;pt<E;pt++){const gt=pt%b,wt=pt%v;for(let xt=0;xt<z;xt+=at){const Dt=Math.min(xt+at,z);for(let Nt=0;Nt<F;Nt+=at){const Ut=Math.min(Nt+at,F);for(let $t=0;$t<A;$t+=at){const Mt=Math.min($t+at,A);for(let jt=xt;jt<Dt;jt++)for(let Ht=Nt;Ht<Ut;Ht++){let Jt=0;for(let qt=$t;qt<Mt;qt++){const tn=U[gt*V+jt*X+qt*j],fe=L[qt*K+Ht*Z+wt*Y];Jt+=tn*fe}ut[pt*it+(jt*F+Ht)]+=Jt}}}}}return e.disposeIntermediateTensorInfo(N),e.disposeIntermediateTensorInfo($),e.makeTensorInfo(k,nt.dtype,nt.values)}const Fk={kernelName:Iu,backendName:"cpu",kernelFunc:vy};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mk(n){const{inputs:t,backend:e,attrs:s}=n,{a:i,b:o,bias:r,preluActivationWeights:a}=t,{transposeA:u,transposeB:l,activation:c,leakyreluAlpha:h}=s;let p,f,m;const g=[];p=vy({inputs:{a:i,b:o},attrs:{transposeA:u,transposeB:l},backend:e}),r&&(f=Ji({inputs:{a:p,b:r},backend:e}),g.push(p),p=f),c&&(m=ir(e,p,c,a,h),g.push(p),p=m);for(const v of g)e.disposeIntermediateTensorInfo(v);return p}const Pk={kernelName:Tp,backendName:"cpu",kernelFunc:Mk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ek=Qt(dr,n=>Math.acos(n)),Lk={kernelName:dr,backendName:"cpu",kernelFunc:Ek};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ok=Qt(pr,n=>Math.acosh(n)),_k={kernelName:pr,backendName:"cpu",kernelFunc:Ok};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bk(n){const{inputs:t,backend:e}=n,s=t;yt(t,"addN");const i=s.map(a=>e.data.get(a.dataId).values),o=ue(s[0].shape,s[0].dtype),r=o.values;for(let a=0;a<s.length;a++){const u=i[a];for(let l=0;l<r.length;l++)r[l]+=u[l]}return e.makeTensorInfo(o.shape,o.dtype,o.values)}const Wk={kernelName:bu,backendName:"cpu",kernelFunc:Bk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vk(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:o,keepDims:r}=s;yt(i,"all");const a=ee(o,i.shape);let u=a;const l=Me(u,i.shape.length);let c=i;l!=null&&(c=Ze({inputs:{x:i},backend:e,attrs:{perm:l}}),u=Ke(u.length,i.shape.length)),Vn("all",u,c.shape.length);const[h,p]=ln(c.shape,u),f=et(p),m=ss(et(h),c.dtype),g=e.data.get(c.dataId).values;for(let v=0;v<m.length;++v){const w=v*f;let k=g[w];for(let C=0;C<f;++C){const I=g[w+C];k=k&&I}m[v]=k}l!=null&&e.disposeIntermediateTensorInfo(c);const b=e.makeTensorInfo(h,c.dtype,m);if(r){const v=Jn(h,a),w=te({inputs:{x:b},backend:e,attrs:{shape:v}});return e.disposeIntermediateTensorInfo(b),w}return b}const Uk={kernelName:zp,backendName:"cpu",kernelFunc:Vk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gk(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:o,keepDims:r}=s;yt(i,"any");const a=ee(o,i.shape);let u=a;const l=Me(u,i.shape.length);let c=i;l!=null&&(c=Ze({inputs:{x:i},backend:e,attrs:{perm:l}}),u=Ke(u.length,i.shape.length)),Vn("any",u,c.shape.length);const[h,p]=ln(c.shape,u),f=et(p),m=ss(et(h),c.dtype),g=e.data.get(c.dataId).values;for(let v=0;v<m.length;++v){const w=v*f;let k=g[w];for(let C=0;C<f;++C){const I=g[w+C];k=k||I}m[v]=k}l!=null&&e.disposeIntermediateTensorInfo(c);const b=e.makeTensorInfo(h,c.dtype,m);if(r){const v=Jn(h,a),w=te({inputs:{x:b},backend:e,attrs:{shape:v}});return e.disposeIntermediateTensorInfo(b),w}return b}const Hk={kernelName:Fp,backendName:"cpu",kernelFunc:Gk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jk(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:o}=s;yt(i,"argMax");let r=ee(o,i.shape);const a=Me(r,i.shape.length);let u=i;const l=[];a!=null&&(u=Ze({inputs:{x:i},backend:e,attrs:{perm:a}}),l.push(u),r=Ke(r.length,u.shape.length)),r=[r[0]],Vn("argMax",r,u.shape.length);const[c,h]=ln(u.shape,r),p=et(c),f=ss(p,"int32"),m=et(h),g=e.data.get(u.dataId).values;for(let b=0;b<f.length;++b){const v=b*m;let w=g[v],k=0;for(let C=0;C<m;++C){const I=g[v+C];I>w&&(w=I,k=C)}f[b]=k}return l.forEach(b=>e.disposeIntermediateTensorInfo(b)),e.makeTensorInfo(c,"int32",f)}const Kk={kernelName:xu,backendName:"cpu",kernelFunc:jk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xk(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:o}=s;yt(i,"argMin");let r=ee(o,i.shape);const a=Me(r,i.shape.length);let u=i;const l=[];a!=null&&(u=Ze({inputs:{x:i},backend:e,attrs:{perm:a}}),l.push(u),r=Ke(r.length,u.shape.length)),r=[r[0]],Vn("argMin",r,u.shape.length);const[c,h]=ln(u.shape,r),p=et(c),f=ss(p,"int32"),m=et(h),g=e.data.get(u.dataId).values;for(let b=0;b<f.length;++b){const v=b*m;let w=g[v],k=0;for(let C=0;C<m;++C){const I=g[v+C];I<w&&(w=I,k=C)}f[b]=k}return l.forEach(b=>e.disposeIntermediateTensorInfo(b)),e.makeTensorInfo(c,"int32",f)}const qk={kernelName:wu,backendName:"cpu",kernelFunc:Xk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yk=Qt(fr,n=>Math.asin(n)),Zk={kernelName:fr,backendName:"cpu",kernelFunc:Yk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qk=Qt(mr,n=>Math.asinh(n)),Jk={kernelName:mr,backendName:"cpu",kernelFunc:Qk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tS=Qt(yr,n=>Math.atan(n)),eS={kernelName:yr,backendName:"cpu",kernelFunc:tS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nS=Us((n,t)=>Math.atan2(n,t)),sS=Ii(gr,nS),iS={kernelName:gr,backendName:"cpu",kernelFunc:sS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oS=Qt(br,n=>Math.atanh(n)),rS={kernelName:br,backendName:"cpu",kernelFunc:oS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oc(n,t,e,s,i,o){const r=i.strideHeight,a=i.strideWidth,u=i.dilationHeight,l=i.dilationWidth,c=i.effectiveFilterHeight,h=i.effectiveFilterWidth,p=i.padInfo.top,f=i.padInfo.left,m=o==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,g=ue(i.outShape,e),b=g.values,v=i.outShape[1]*i.outShape[2]*i.outShape[3],w=i.outShape[2]*i.outShape[3],k=i.outShape[3];for(let C=0;C<i.batchSize;++C){const I=C*v,N=C*s[0];for(let $=0;$<i.inChannels;++$)for(let A=0;A<i.outHeight;++A){const z=A*r-p,F=Math.max(0,z),E=Math.min(i.inHeight,c+z),U=I+A*w;for(let L=0;L<i.outWidth;++L){const W=L*a-f,_=Math.max(0,W),V=Math.min(i.inWidth,h+W);let X=m,j=0,K=0;for(let Y=F;Y<E;Y+=u){const it=N+Y*s[1];for(let nt=_;nt<V;nt+=l){const ut=it+nt*s[2],at=n[ut+$];o==="max"&&at>X?X=at:o==="avg"&&(j+=at,K++)}if(isNaN(X))break}const Z=U+L*k+$;b[Z]=o==="avg"?j/K:X}}}return g}function Cy(n,t,e,s,i=!1,o=!1){const r=ue(s.outShape,"int32"),a=s.strideHeight,u=s.strideWidth,l=s.dilationHeight,c=s.dilationWidth,h=s.effectiveFilterHeight,p=s.effectiveFilterWidth,f=s.padInfo.top,m=s.padInfo.left,g=ue(t,e,n);for(let b=0;b<s.batchSize;++b)for(let v=0;v<s.inChannels;++v)for(let w=0;w<s.outHeight;++w){const k=w*a-f;let C=k;for(;C<0;)C+=l;const I=Math.min(s.inHeight,h+k);for(let N=0;N<s.outWidth;++N){const $=N*u-m;let A=$;for(;A<0;)A+=c;const z=Math.min(s.inWidth,p+$);let F=Number.NEGATIVE_INFINITY,E=-1;for(let U=C;U<I;U+=l){const L=U-k;for(let W=A;W<z;W+=c){const _=W-$,V=g.get(b,U,W,v);V>F&&(F=V,i?E=o?((b*s.inHeight+U)*s.inWidth+W)*s.inChannels+v:(U*s.inWidth+W)*s.inChannels+v:E=L*p+_)}}r.set(E,b,w,N,v)}}return r}function ky(n,t,e,s,i,o){const r=i.strideDepth,a=i.strideHeight,u=i.strideWidth,l=i.dilationDepth,c=i.dilationHeight,h=i.dilationWidth,p=i.effectiveFilterDepth,f=i.effectiveFilterHeight,m=i.effectiveFilterWidth,g=i.padInfo.front,b=i.padInfo.top,v=i.padInfo.left,w=o==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,k=ue(i.outShape,e),C=k.values,I=i.outShape[1]*i.outShape[2]*i.outShape[3]*i.outShape[4],N=i.outShape[2]*i.outShape[3]*i.outShape[4],$=i.outShape[3]*i.outShape[4],A=i.outShape[4];for(let z=0;z<i.batchSize;++z){const F=z*I,E=z*s[0];for(let U=0;U<i.inChannels;++U)for(let L=0;L<i.outDepth;++L){const W=L*r-g;let _=W;for(;_<0;)_+=l;const V=Math.min(i.inDepth,p+W),X=F+L*N;for(let j=0;j<i.outHeight;++j){const K=j*a-b;let Z=K;for(;Z<0;)Z+=c;const Y=Math.min(i.inHeight,f+K),it=X+j*$;for(let nt=0;nt<i.outWidth;++nt){const ut=nt*u-v;let at=ut;for(;at<0;)at+=h;const pt=Math.min(i.inWidth,m+ut),gt=it+nt*A;let wt=w,xt=0,Dt=0;for(let Ut=_;Ut<V;Ut+=l){const $t=E+Ut*s[1];for(let Mt=Z;Mt<Y;Mt+=c){const jt=$t+Mt*s[2];for(let Ht=at;Ht<pt;Ht+=h){const Jt=jt+Ht*s[3],qt=n[Jt+U];if(o==="max"&&qt>wt?wt=qt:o==="avg"&&(xt+=qt,Dt++),isNaN(wt))break}if(isNaN(wt))break}if(isNaN(wt))break}const Nt=gt+U;C[Nt]=o==="avg"?xt/Math.max(Dt,1):wt}}}}return k}function aS(n,t){const e=ue(t.outShape,"int32"),s=t.strideDepth,i=t.strideHeight,o=t.strideWidth,r=t.dilationDepth,a=t.dilationHeight,u=t.dilationWidth,l=t.effectiveFilterDepth,c=t.effectiveFilterHeight,h=t.effectiveFilterWidth,p=t.padInfo.front,f=t.padInfo.top,m=t.padInfo.left;for(let g=0;g<t.batchSize;++g)for(let b=0;b<t.inChannels;++b)for(let v=0;v<t.outDepth;++v){const w=v*s-p;let k=w;for(;k<0;)k+=r;const C=Math.min(t.inDepth,l+w);for(let I=0;I<t.outHeight;++I){const N=I*i-f;let $=N;for(;$<0;)$+=a;const A=Math.min(t.inHeight,c+N);for(let z=0;z<t.outWidth;++z){const F=z*o-m;let E=F;for(;E<0;)E+=u;const U=Math.min(t.inWidth,h+F);let L=Number.NEGATIVE_INFINITY,W=-1;for(let _=k;_<C;_+=r){const V=_-w;for(let X=$;X<A;X+=a){const j=X-N;for(let K=E;K<U;K+=u){const Z=K-F,Y=n.get(g,_,X,K,b);Y>=L&&(L=Y,W=V*c*h+j*c+Z)}}}e.set(W,g,v,I,z,b)}}}return e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uS(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t;yt(i,"avgPool");const{filterSize:o,strides:r,pad:a,dimRoundingMode:u}=s,l=1;tt(ki(r,l),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${r} and dilations '${l}'`);const c=Un(i.shape,o,r,l,a,u);let h;if(c.filterWidth===1&&c.filterHeight===1&&ke(c.inShape,c.outShape))h=Gs({inputs:{x:i},backend:e});else{const p=e.data.get(i.dataId).values,f=Tt(i.shape),m=oc(p,i.shape,i.dtype,f,c,"avg");h=e.makeTensorInfo(c.outShape,i.dtype,m.values)}return h}const lS={kernelName:Su,backendName:"cpu",kernelFunc:uS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cS(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{filterSize:o,strides:r,pad:a,dimRoundingMode:u,dataFormat:l}=s;yt(i,"avgPool3d");const c=xs(i.shape,o,r,1,a,u,l),h=e.data.get(i.dataId).values,p=ky(h,i.shape,i.dtype,Tt(i.shape),c,"avg");return e.makeTensorInfo(p.shape,"float32",p.values)}const hS={kernelName:Cu,backendName:"cpu",kernelFunc:cS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dS(n){const{inputs:t,backend:e,attrs:s}=n,{dy:i,input:o}=t,{filterSize:r,strides:a,pad:u,dimRoundingMode:l}=s;yt([i,o],"avgPool3DGrad");const c=xs(o.shape,r,a,1,u,l),h=c.strideDepth,p=c.strideHeight,f=c.strideWidth,m=c.filterDepth,g=c.filterHeight,b=c.filterWidth,v=c.dilationDepth,w=c.dilationHeight,k=c.dilationWidth,C=c.effectiveFilterDepth,I=c.effectiveFilterHeight,N=c.effectiveFilterWidth,$=C-1-c.padInfo.front,A=N-1-c.padInfo.left,z=I-1-c.padInfo.top,F=ue(o.shape,"float32"),E=1/(m*g*b),U=e.bufferSync(i);for(let L=0;L<c.batchSize;++L)for(let W=0;W<c.inChannels;++W)for(let _=0;_<c.inDepth;++_)for(let V=0;V<c.inHeight;++V)for(let X=0;X<c.inWidth;++X){const j=_-$,K=V-z,Z=X-A;let Y=0;for(let it=0;it<C;it+=v){const nt=(j+it)/h;if(!(nt<0||nt>=c.outDepth||Math.floor(nt)!==nt))for(let ut=0;ut<I;ut+=w){const at=(K+ut)/p;if(!(at<0||at>=c.outHeight||Math.floor(at)!==at))for(let pt=0;pt<N;pt+=k){const gt=(Z+pt)/f;if(gt<0||gt>=c.outWidth||Math.floor(gt)!==gt)continue;const wt=U.get(L,nt,at,gt,W);Y+=wt}}}F.set(Y*E,L,_,V,X,W)}return e.makeTensorInfo(F.shape,F.dtype,F.values)}const pS={kernelName:vu,backendName:"cpu",kernelFunc:dS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fS(n){const{inputs:t,backend:e,attrs:s}=n,{dy:i,input:o}=t,r=o;yt([i,o],"avgPoolGrad");const{filterSize:a,strides:u,pad:l}=s,c=Un(r.shape,a,u,1,l),h=c.strideHeight,p=c.strideWidth,f=c.filterHeight,m=c.filterWidth,g=c.dilationHeight,b=c.dilationWidth,v=c.effectiveFilterHeight,w=c.effectiveFilterWidth,k=w-1-c.padInfo.left,C=v-1-c.padInfo.top,I=ue(r.shape,"float32"),N=1/(f*m),$=e.data.get(i.dataId).values,A=ue(i.shape,"float32",$);for(let z=0;z<c.batchSize;++z)for(let F=0;F<c.inChannels;++F)for(let E=0;E<c.inHeight;++E)for(let U=0;U<c.inWidth;++U){const L=E-C,W=U-k;let _=0;for(let V=0;V<v;V+=g){const X=(L+V)/h;if(!(X<0||X>=c.outHeight||Math.floor(X)!==X))for(let j=0;j<w;j+=b){const K=(W+j)/p;if(K<0||K>=c.outWidth||Math.floor(K)!==K)continue;const Z=A.get(z,X,K,F);_+=Z}}I.set(_*N,z,E,U,F)}return e.makeTensorInfo(I.shape,I.dtype,I.values)}const mS={kernelName:ku,backendName:"cpu",kernelFunc:fS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gS(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,scale:o,offset:r,mean:a,variance:u}=t;tt(a.shape.length===u.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),tt(r==null||a.shape.length===r.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),tt(o==null||a.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),yt([i,a,u,o,r],"batchNorm");let{varianceEpsilon:l}=s;l==null&&(l=.001);const c=e.data.get(i.dataId).values,h=e.data.get(a.dataId).values,p=e.data.get(u.dataId).values,f=o?e.data.get(o.dataId).values:new Float32Array([1]),m=r?e.data.get(r.dataId).values:new Float32Array([0]),g=new Float32Array(c.length),b=m.length,v=f.length,w=p.length,k=h.length;let C=0,I=0,N=0,$=0;for(let A=0;A<c.length;++A)g[A]=m[C++]+(c[A]-h[I++])*f[N++]/Math.sqrt(p[$++]+l),C>=b&&(C=0),I>=k&&(I=0),N>=v&&(N=0),$>=w&&($=0);return e.makeTensorInfo(i.shape,i.dtype,g)}const yS={kernelName:_u,backendName:"cpu",kernelFunc:gS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bS(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{blockShape:o,crops:r}=s;yt([i],"batchToSpaceND");const a=o.reduce((v,w)=>v*w),u=Yr(i.shape,o,a),l=Zr(u.length,o.length),c=Qr(i.shape,o,a),h=Mp(r,o.length),p=Pp(c,r,o.length),f=te({inputs:{x:i},backend:e,attrs:{shape:u}}),m=Ze({inputs:{x:f},backend:e,attrs:{perm:l}}),g=te({inputs:{x:m},backend:e,attrs:{shape:c}}),b=pi({inputs:{x:g},backend:e,attrs:{begin:h,size:p}});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(g),b}const xS={kernelName:Nu,backendName:"cpu",kernelFunc:bS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wS(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,weights:o}=t,{size:r}=s,a=e.data.get(i.dataId).values,u=e.data.get(o.dataId).values,l=Lp(a,u,o.dtype,o.shape,r);return e.makeTensorInfo([r],o.dtype,l)}const vS={kernelName:Ep,backendName:"cpu",kernelFunc:wS};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CS(n){const{inputs:t,backend:e}=n,{s0:s,s1:i}=t,o=e.data.get(s.dataId).values,r=e.data.get(i.dataId).values,a=Ne(Array.from(o),Array.from(r));return e.makeTensorInfo([a.length],"int32",Int32Array.from(a))}const kS={kernelName:Op,backendName:"cpu",kernelFunc:CS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SS=Qt(wr,(n,t)=>{const e=t;return n>e.clipValueMax?e.clipValueMax:n<e.clipValueMin?e.clipValueMin:n}),IS={kernelName:wr,backendName:"cpu",kernelFunc:SS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NS=n=>{const{x:t}=n.inputs,e=n.backend,s=new Float32Array(et(t.shape)),i=e.data.get(t.dataId),o=i.complexTensorInfos.real,r=i.complexTensorInfos.imag,a=e.data.get(o.dataId).values,u=e.data.get(r.dataId).values;for(let l=0;l<a.length;l++){const c=a[l],h=u[l];s[l]=Math.hypot(c,h)}return e.makeOutput(s,t.shape,"float32")},$S={kernelName:$u,backendName:"cpu",kernelFunc:NS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gi(n){const{inputs:t,backend:e}=n,{input:s}=t,i=e.data.get(s.dataId).complexTensorInfos.imag,o=e.data.get(i.dataId).values;return e.makeTensorInfo(i.shape,i.dtype,o)}const DS={kernelName:_p,backendName:"cpu",kernelFunc:gi};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yi(n){const{inputs:t,backend:e,attrs:s}=n,{axis:i}=s,o=ee(i,t[0].shape)[0],r=t.map(g=>g.shape);Bp(r,o);let a=cs(t.map(g=>g.shape),o);if(et(a)===0)return e.makeTensorInfo(a,t[0].dtype,[]);const u=t.filter(g=>et(g.shape)>0);if(u.length===1)return Gs({inputs:{x:u[0]},backend:e});if(u[0].dtype==="complex64"){const g=u.map(C=>to({inputs:{input:C},backend:e})),b=u.map(C=>gi({inputs:{input:C},backend:e})),v=yi({inputs:g,backend:e,attrs:{axis:o}}),w=yi({inputs:b,backend:e,attrs:{axis:o}}),k=Fn({inputs:{real:v,imag:w},backend:e});return g.forEach(C=>e.disposeIntermediateTensorInfo(C)),b.forEach(C=>e.disposeIntermediateTensorInfo(C)),e.disposeIntermediateTensorInfo(v),e.disposeIntermediateTensorInfo(w),k}const l=u.map(g=>{const v=[-1,et(g.shape.slice(o))];return te({inputs:{x:g},backend:e,attrs:{shape:v}})}),c=l.map(g=>({vals:e.data.get(g.dataId).values,shape:g.shape}));a=cs(l.map(g=>g.shape),1);const h=l[0].shape[0]===1,p=Kw(c,a,t[0].dtype,h),f=cs(u.map(g=>g.shape),o),m=e.makeTensorInfo(f,t[0].dtype,p);return l.forEach(g=>e.disposeIntermediateTensorInfo(g)),m}const RS={kernelName:Du,backendName:"cpu",kernelFunc:yi};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sy(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,filter:o}=t,{strides:r,pad:a,dataFormat:u,dilations:l,dimRoundingMode:c}=s;yt([i,o],"conv2d");const h=ws(u),p=Xe(i.shape,o.shape,r,l,a,c,!1,h),f=p.filterHeight,m=p.filterWidth,g=p.dilationHeight,b=p.dilationWidth,v=p.padInfo.left,w=p.padInfo.top,k=p.dataFormat==="channelsLast",C=new Ve(p.outShape,i.dtype),I=Tt(i.shape),N=Tt(o.shape),$=I[0],A=k?I[1]:I[2],z=k?I[2]:1,F=k?1:I[1],E=C.strides[0],U=k?C.strides[1]:C.strides[2],L=k?C.strides[2]:1,W=k?1:C.strides[1],_=e.data.get(i.dataId).values,V=e.data.get(o.dataId).values,X=C.values;for(let j=0;j<p.batchSize;++j){const K=j*$,Z=j*E;for(let Y=0;Y<p.outHeight;++Y){const it=Z+Y*U,nt=Y*p.strideHeight-w;for(let ut=0;ut<f;++ut){const at=nt+ut*g;if(at<0||at>=p.inHeight)continue;const pt=ut*N[0],gt=K+at*A;for(let wt=0;wt<p.outWidth;++wt){const xt=it+wt*L,Dt=wt*p.strideWidth-v;for(let Nt=0;Nt<m;++Nt){const Ut=Dt+Nt*b;if(Ut<0||Ut>=p.inWidth)continue;const $t=pt+Nt*N[1],Mt=gt+Ut*z;let jt=$t;for(let Ht=0;Ht<p.inChannels;++Ht){const Jt=_[Mt+Ht*F];for(let qt=0;qt<p.outChannels;++qt)X[xt+qt*W]+=Jt*V[jt+qt];jt+=p.outChannels}}}}}}return e.makeTensorInfo(C.shape,C.dtype,X)}const AS={kernelName:Ru,backendName:"cpu",kernelFunc:Sy};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TS(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,dy:o}=t,{strides:r,pad:a,dataFormat:u,dimRoundingMode:l,filterShape:c}=s;yt([i,o],"conv2dBackpropFilter");const h=ws(u),p=Xe(i.shape,c,r,1,a,l,!1,h),{strideHeight:f,strideWidth:m,filterHeight:g,filterWidth:b}=p,v=p.dataFormat==="channelsLast",w=new Ve(p.filterShape,"float32"),k=p.padInfo.left,C=p.padInfo.top,I=e.data.get(i.dataId).values,N=e.data.get(o.dataId).values,$=new Ve(i.shape,i.dtype,I),A=new Ve(o.shape,o.dtype,N);for(let z=0;z<g;++z){const F=Math.max(0,Math.ceil((C-z)/f)),E=Math.min(p.outHeight,(p.inHeight+C-z)/f);for(let U=0;U<b;++U){const L=Math.max(0,Math.ceil((k-U)/m)),W=Math.min(p.outWidth,(p.inWidth+k-U)/m);for(let _=0;_<p.inChannels;++_)for(let V=0;V<p.outChannels;++V){let X=0;for(let j=0;j<p.batchSize;++j)for(let K=F;K<E;++K){const Z=z+K*f-C;for(let Y=L;Y<W;++Y){const it=U+Y*m-k;v?X+=$.get(j,Z,it,_)*A.get(j,K,Y,V):X+=$.get(j,_,Z,it)*A.get(j,V,K,Y)}}w.set(X,z,U,_,V)}}}return e.makeTensorInfo(w.shape,w.dtype,w.values)}const zS={kernelName:Wp,backendName:"cpu",kernelFunc:TS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FS(n){const{inputs:t,backend:e,attrs:s}=n,{dy:i,filter:o}=t,{inputShape:r,strides:a,pad:u,dataFormat:l,dimRoundingMode:c}=s;yt([i,o],"conv2dBackpropInput");const h=Tt(o.shape),p=Tt(i.shape);let f=ws(l);const m=Xe(r,o.shape,a,1,u,c,!1,f),g=new Ve(m.inShape,"float32"),b=g.values,v=e.data.get(i.dataId).values,w=e.data.get(o.dataId).values,[k,C,I]=h,{batchSize:N,filterHeight:$,filterWidth:A,inChannels:z,inHeight:F,inWidth:E,outChannels:U,outHeight:L,outWidth:W,strideHeight:_,strideWidth:V}=m;f=m.dataFormat;const X=$-1-m.padInfo.top,j=A-1-m.padInfo.left,K=f==="channelsLast",Z=g.strides[0],Y=K?g.strides[1]:g.strides[2],it=K?g.strides[2]:1,nt=K?1:g.strides[1],ut=p[0],at=K?p[1]:p[2],pt=K?p[2]:1,gt=K?1:p[1];for(let wt=0;wt<N;++wt)for(let xt=0;xt<z;++xt)for(let Dt=0;Dt<F;++Dt){const Nt=Dt-X,Ut=Math.max(0,Math.ceil(Nt/_)),$t=Math.min(L,($+Nt)/_);for(let Mt=0;Mt<E;++Mt){const jt=Mt-j,Ht=Math.max(0,Math.ceil(jt/V)),Jt=Math.min(W,(A+jt)/V);let qt=0;for(let fe=Ut;fe<$t;++fe){const hn=fe*_-Nt;for(let De=Ht;De<Jt;++De){const vn=De*V-jt,we=ut*wt+at*fe+pt*De,en=k*($-1-hn)+C*(A-1-vn)+I*xt;for(let qe=0;qe<U;++qe){const nn=v[we+gt*qe],Cn=w[en+qe];qt+=nn*Cn}}}const tn=Z*wt+Y*Dt+it*Mt+nt*xt;b[tn]=qt}}return e.makeTensorInfo(g.shape,g.dtype,g.values)}const MS={kernelName:Tu,backendName:"cpu",kernelFunc:FS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PS(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,filter:o}=t,{strides:r,pad:a,dilations:u}=s;yt([i,o],"conv3d");const l=Ni(i.shape,o.shape,r,u,a),{filterDepth:c,filterHeight:h,filterWidth:p,dilationDepth:f,dilationHeight:m,dilationWidth:g,padInfo:b}=l,v=b.front,w=b.left,k=b.top,C=new Ve(l.outShape,i.dtype),I=e.data.get(i.dataId).values,N=e.data.get(o.dataId).values,$=C.values,A=Tt(i.shape),z=Tt(o.shape);for(let F=0;F<l.batchSize;++F){const E=F*A[0],U=F*C.strides[0];for(let L=0;L<l.outDepth;++L){const W=U+L*C.strides[1],_=L*l.strideDepth-v;for(let V=0;V<c;++V){const X=_+V*f;if(X<0||X>=l.inDepth)continue;const j=V*z[0],K=E+X*A[1];for(let Z=0;Z<l.outHeight;++Z){const Y=W+Z*C.strides[2],it=Z*l.strideHeight-k;for(let nt=0;nt<h;++nt){const ut=it+nt*m;if(ut<0||ut>=l.inHeight)continue;const at=j+nt*z[1],pt=K+ut*A[2];for(let gt=0;gt<l.outWidth;++gt){const wt=Y+gt*l.outChannels,xt=gt*l.strideWidth-w;for(let Dt=0;Dt<p;++Dt){const Nt=xt+Dt*g;if(Nt<0||Nt>=l.inWidth)continue;const Ut=at+Dt*z[2],$t=pt+Nt*l.inChannels;let Mt=Ut;for(let jt=0;jt<l.inChannels;++jt){const Ht=I[$t+jt];for(let Jt=0;Jt<l.outChannels;++Jt)$[wt+Jt]+=Ht*N[Mt+Jt];Mt+=l.outChannels}}}}}}}}return e.makeTensorInfo(C.shape,C.dtype,C.values)}const ES={kernelName:Fu,backendName:"cpu",kernelFunc:PS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LS(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,dy:o}=t,{strides:r,pad:a,filterShape:u}=s;yt([i,o],"conv3dBackpropFilterV2");const l=Tt(i.shape),c=Tt(o.shape),h=Ni(i.shape,u,r,1,a),p=h.strideDepth,f=h.strideHeight,m=h.strideWidth,g=h.filterDepth,b=h.filterHeight,v=h.filterWidth,w=new Ve(h.filterShape,"float32"),k=w.values,[C,I,N,$]=w.strides,A=e.data.get(o.dataId).values,[z,F,E,U]=c,L=e.data.get(i.dataId).values,[W,_,V,X]=l,j=h.padInfo.front,K=h.padInfo.left,Z=h.padInfo.top;for(let Y=0;Y<g;++Y){const it=Math.max(0,Math.ceil((j-Y)/p)),nt=Math.min(h.outDepth,(h.inDepth+j-Y)/p),ut=Y*C;for(let at=0;at<b;++at){const pt=Math.max(0,Math.ceil((Z-at)/f)),gt=Math.min(h.outHeight,(h.inHeight+Z-at)/f),wt=at*I+ut;for(let xt=0;xt<v;++xt){const Dt=Math.max(0,Math.ceil((K-xt)/m)),Nt=Math.min(h.outWidth,(h.inWidth+K-xt)/m),Ut=xt*N+wt;for(let $t=0;$t<h.inChannels;++$t){const Mt=$t*$+Ut;for(let jt=0;jt<h.outChannels;++jt){let Ht=0;for(let Jt=0;Jt<h.batchSize;++Jt){const qt=Jt*W,tn=Jt*z;for(let fe=it;fe<nt;++fe){const De=(Y+fe*p-j)*_+qt,vn=fe*F+tn;for(let we=pt;we<gt;++we){const qe=(at+we*f-Z)*V+De,nn=we*E+vn;for(let Cn=Dt;Cn<Nt;++Cn){const Fi=(xt+Cn*m-K)*X+qe,Ys=Cn*U+nn;Ht+=L[Fi+$t]*A[Ys+jt]}}}}k[Mt+jt]=Ht}}}}}return e.makeTensorInfo(w.shape,w.dtype,w.values)}const OS={kernelName:zu,backendName:"cpu",kernelFunc:LS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _S(n){const{inputs:t,backend:e,attrs:s}=n,{dy:i,filter:o}=t,{pad:r,strides:a,inputShape:u}=s;yt([i],"conv3dBackpropInputV2");const l=Tt(i.shape),c=Tt(o.shape),h=Ni(u,o.shape,a,1,r),p=new Ve(h.inShape,"float32"),f=p.values,[m,g,b,v]=p.strides,w=e.data.get(i.dataId).values,[k,C,I,N]=l,$=e.data.get(o.dataId).values,[A,z,F,E]=c,{batchSize:U,filterDepth:L,filterHeight:W,filterWidth:_,inChannels:V,inDepth:X,inHeight:j,inWidth:K,outChannels:Z,outDepth:Y,outHeight:it,outWidth:nt,strideDepth:ut,strideHeight:at,strideWidth:pt}=h,gt=L-1-h.padInfo.front,wt=W-1-h.padInfo.top,xt=_-1-h.padInfo.left;for(let Dt=0;Dt<U;++Dt)for(let Nt=0;Nt<V;++Nt)for(let Ut=0;Ut<X;++Ut){const $t=Ut-gt,Mt=Math.max(0,Math.ceil($t/ut)),jt=Math.min(Y,(L+$t)/ut);for(let Ht=0;Ht<j;++Ht){const Jt=Ht-wt,qt=Math.max(0,Math.ceil(Jt/at)),tn=Math.min(it,(W+Jt)/at);for(let fe=0;fe<K;++fe){const hn=fe-xt,De=Math.max(0,Math.ceil(hn/pt)),vn=Math.min(nt,(_+hn)/pt);let we=0;for(let en=Mt;en<jt;++en){const qe=en*ut-$t;for(let nn=qt;nn<tn;++nn){const Cn=nn*at-Jt;for(let os=De;os<vn;++os){const Fi=os*pt-hn,Ys=k*Dt+C*en+I*nn+N*os,ko=A*(L-1-qe)+z*(W-1-Cn)+F*(_-1-Fi)+E*Nt;for(let kn=0;kn<Z;++kn){const Mi=w[Ys+kn],So=$[ko+kn];we+=Mi*So}}}}f[m*Dt+g*Ut+b*Ht+v*fe+Nt]=we}}}return e.makeTensorInfo(p.shape,p.dtype,p.values)}const BS={kernelName:Vp,backendName:"cpu",kernelFunc:_S};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WS=Qt(Cr,n=>Math.cos(n)),VS={kernelName:Cr,backendName:"cpu",kernelFunc:WS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const US=Qt(kr,n=>Math.cosh(n)),GS={kernelName:kr,backendName:"cpu",kernelFunc:US};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HS(n){const{inputs:t,backend:e,attrs:s}=n,{image:i,boxes:o,boxInd:r}=t,{cropSize:a,method:u,extrapolationValue:l}=s,[c,h,p,f]=i.shape,m=o.shape[0],[g,b]=a,v=ue([m,g,b,f],"float32"),w=e.data.get(o.dataId).values,k=e.data.get(r.dataId).values,C=e.data.get(i.dataId).values,I=Tt(i.shape),N=Tt(v.shape);for(let $=0;$<m;$++){const A=$*4,z=w[A],F=w[A+1],E=w[A+2],U=w[A+3],L=k[$];if(L>=c)continue;const W=g>1?(E-z)*(h-1)/(g-1):0,_=b>1?(U-F)*(p-1)/(b-1):0;for(let V=0;V<g;V++){const X=g>1?z*(h-1)+V*W:.5*(z+E)*(h-1);if(X<0||X>h-1){for(let j=0;j<b;j++)for(let K=0;K<f;K++){const Z=K+j*N[2]+V*N[1]+$*N[0];v.values[Z]=l}continue}if(u==="bilinear"){const j=Math.floor(X),K=Math.ceil(X),Z=X-j;for(let Y=0;Y<b;Y++){const it=b>1?F*(p-1)+Y*_:.5*(F+U)*(p-1);if(it<0||it>p-1){for(let pt=0;pt<f;pt++){const gt=pt+Y*N[2]+V*N[1]+$*N[0];v.values[gt]=l}continue}const nt=Math.floor(it),ut=Math.ceil(it),at=it-nt;for(let pt=0;pt<f;pt++){let gt=pt+nt*I[2]+j*I[1]+L*I[0];const wt=C[gt];gt=pt+ut*I[2]+j*I[1]+L*I[0];const xt=C[gt];gt=pt+nt*I[2]+K*I[1]+L*I[0];const Dt=C[gt];gt=pt+ut*I[2]+K*I[1]+L*I[0];const Nt=C[gt],Ut=wt+(xt-wt)*at,$t=Dt+(Nt-Dt)*at;gt=pt+Y*N[2]+V*N[1]+$*N[0],v.values[gt]=Ut+($t-Ut)*Z}}}else for(let j=0;j<b;++j){const K=b>1?F*(p-1)+j*_:.5*(F+U)*(p-1);if(K<0||K>p-1){for(let it=0;it<f;it++){const nt=it+j*N[2]+V*N[1]+$*N[0];v.values[nt]=l}continue}const Z=Math.round(K),Y=Math.round(X);for(let it=0;it<f;it++){const nt=it+Z*I[2]+Y*I[1]+L*I[0],ut=it+j*N[2]+V*N[1]+$*N[0];v.values[ut]=C[nt]}}}}return e.makeTensorInfo(v.shape,v.dtype,v.values)}const jS={kernelName:Up,backendName:"cpu",kernelFunc:HS};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KS(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:o,exclusive:r,reverse:a}=s;yt(i,"cumprod");const u=Me([o],i.shape.length);let l=i;u!=null&&(l=Ze({inputs:{x:i},backend:e,attrs:{perm:u}}));const c=Ke(1,i.shape.length)[0];if(c!==l.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${l.shape.length-1} but got axis=${c}`);const h=es(l.dtype,"int32"),p=Xw(et(l.shape),h),f=e.data.get(l.dataId).values,m=l.shape[l.shape.length-1],g=a?(v,w)=>v+m-w-1:(v,w)=>v+w;for(let v=0;v<f.length;v+=m)for(let w=0;w<m;w++){const k=g(v,w);if(w===0)p[k]=r?1:f[k];else{const C=g(v,w-1);p[k]=r?f[C]*p[C]:f[k]*p[C]}}const b=e.makeTensorInfo(l.shape,h,p);if(u!=null){const v=_s(u),w=Ze({inputs:{x:b},backend:e,attrs:{perm:v}});return e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(l),w}return b}const XS={kernelName:Gp,backendName:"cpu",kernelFunc:KS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qS(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:o,exclusive:r,reverse:a}=s;yt(i,"cumsum");const u=Me([o],i.shape.length);let l=i;u!=null&&(l=Ze({inputs:{x:i},backend:e,attrs:{perm:u}}));const c=Ke(1,i.shape.length)[0];if(c!==l.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${l.shape.length-1} but got axis=${c}`);const h=es(l.dtype,"int32"),p=ss(et(l.shape),h),f=e.data.get(l.dataId).values,m=l.shape[l.shape.length-1],g=a?(v,w)=>v+m-w-1:(v,w)=>v+w;for(let v=0;v<f.length;v+=m)for(let w=0;w<m;w++){const k=g(v,w);if(w===0)p[k]=r?0:f[k];else{const C=g(v,w-1);p[k]=r?f[C]+p[C]:f[k]+p[C]}}const b=e.makeTensorInfo(l.shape,h,p);if(u!=null){const v=_s(u),w=Ze({inputs:{x:b},backend:e,attrs:{perm:v}});return e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(l),w}return b}const YS={kernelName:Mu,backendName:"cpu",kernelFunc:qS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZS(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,weights:o}=t,{size:r,binaryOutput:a}=s;if(i.shape.length===1){const u=e.data.get(i.dataId).values,l=e.data.get(o.dataId).values,c=Lp(u,l,o.dtype,o.shape,r);return e.makeTensorInfo([r],o.dtype,c)}else if(i.shape.length===2){const u=e.bufferSync(i),l=e.bufferSync(o),c=qw(u,l,r,a);return e.makeTensorInfo(c.shape,o.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${i.shape.length}.`)}const QS={kernelName:Hp,backendName:"cpu",kernelFunc:ZS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JS(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{blockSize:o,dataFormat:r}=s;tt(r==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${r}`);const a=i.shape[0],u=i.shape[1],l=i.shape[2],c=i.shape[3],h=u*o,p=l*o,f=c/(o*o),m=e.data.get(i.dataId).values,g=new Float32Array(a*h*p*f);let b=0;for(let v=0;v<a;++v)for(let w=0;w<h;++w){const k=Math.floor(w/o),C=w%o;for(let I=0;I<p;++I){const N=Math.floor(I/o),$=I%o,A=(C*o+$)*f;for(let z=0;z<f;++z){const E=z+A+c*(N+l*(k+u*v));g[b++]=m[E]}}}return e.makeTensorInfo([a,h,p,f],i.dtype,g)}const tI={kernelName:jp,backendName:"cpu",kernelFunc:JS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iy(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,filter:o}=t,{strides:r,pad:a,dilations:u,dimRoundingMode:l}=s;yt([i,o],"depthwiseConv2DNative");const c=Tt(i.shape),h=Tt(o.shape);let p=u;p==null&&(p=[1,1]),tt(ki(r,p),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${r} and dilations '${p}'`);const f=Xe(i.shape,o.shape,r,p,a,l,!0),{filterHeight:m,filterWidth:g,dilationHeight:b,dilationWidth:v,padInfo:w}=f,k=w.left,C=w.top,I=f.outChannels/f.inChannels,N=new Ve(f.outShape,i.dtype),$=e.data.get(i.dataId).values,A=e.data.get(o.dataId).values,z=N.values;for(let F=0;F<f.batchSize;++F){const E=F*c[0],U=F*N.strides[0];for(let L=0;L<f.outHeight;++L){const W=U+L*N.strides[1],_=L*f.strideHeight-C;for(let V=0;V<m;++V){const X=_+V*b;if(X<0||X>=f.inHeight)continue;const j=V*h[0],K=E+X*c[1];for(let Z=0;Z<f.outWidth;++Z){const Y=W+Z*N.strides[2],it=Z*f.strideWidth-k;for(let nt=0;nt<g;++nt){const ut=it+nt*v;if(ut<0||ut>=f.inWidth)continue;const at=j+nt*h[1],pt=K+ut*f.inChannels;let gt=Y,wt=at;for(let xt=0;xt<f.inChannels;++xt){const Dt=$[pt+xt];for(let Nt=0;Nt<I;++Nt)z[gt+Nt]+=Dt*A[wt+Nt];gt+=I,wt+=I}}}}}}return e.makeTensorInfo(N.shape,N.dtype,N.values)}const eI={kernelName:Pu,backendName:"cpu",kernelFunc:Iy};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nI(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,dy:o}=t,{strides:r,dilations:a,pad:u,dimRoundingMode:l,filterShape:c}=s;yt([i,o],"depthwiseConv2dNativeBackpropFilter");const h=Xe(i.shape,c,r,a,u,l,!0),{strideHeight:p,strideWidth:f,filterHeight:m,filterWidth:g}=h,b=new Ve(h.filterShape,"float32"),v=h.padInfo.left,w=h.padInfo.top,k=h.outChannels/h.inChannels,C=e.data.get(i.dataId).values,I=new Ve(i.shape,i.dtype,C),N=e.data.get(o.dataId).values,$=new Ve(o.shape,o.dtype,N);for(let A=0;A<m;++A){const z=Math.max(0,Math.ceil((w-A)/p)),F=Math.min(h.outHeight,(h.inHeight+w-A)/p);for(let E=0;E<g;++E){const U=Math.max(0,Math.ceil((v-E)/f)),L=Math.min(h.outWidth,(h.inWidth+v-E)/f);for(let W=0;W<h.outChannels;++W){const _=Math.trunc(W/k),V=W%k;let X=0;for(let j=0;j<h.batchSize;++j)for(let K=z;K<F;++K){const Z=A+K*p-w;for(let Y=U;Y<L;++Y){const it=E+Y*f-v;X+=I.get(j,Z,it,_)*$.get(j,K,Y,W)}}b.set(X,A,E,_,V)}}}return e.makeTensorInfo(b.shape,b.dtype,b.values)}const sI={kernelName:Kp,backendName:"cpu",kernelFunc:nI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iI(n){const{inputs:t,backend:e,attrs:s}=n,{dy:i,filter:o}=t,{strides:r,dilations:a,pad:u,dimRoundingMode:l,inputShape:c}=s;yt([i,o],"depthwiseConv2DNativeBackpropInput");const h=Tt(i.shape),p=Tt(o.shape),f=Xe(c,o.shape,r,a,u,l,!0),m=new Ve(f.inShape,"float32"),g=m.values,[b,v,w]=m.strides,k=e.data.get(i.dataId).values,[C,I,N]=h,$=e.data.get(o.dataId).values,[A,z,F]=p,{batchSize:E,filterHeight:U,filterWidth:L,inChannels:W,inHeight:_,inWidth:V,outChannels:X,outHeight:j,outWidth:K,strideHeight:Z,strideWidth:Y}=f,it=U-1-f.padInfo.top,nt=L-1-f.padInfo.left,ut=X/W;for(let at=0;at<E;++at)for(let pt=0;pt<W;++pt)for(let gt=0;gt<_;++gt){const wt=gt-it,xt=Math.max(0,Math.ceil(wt/Z)),Dt=Math.min(j,(U+wt)/Z);for(let Nt=0;Nt<V;++Nt){const Ut=Nt-nt,$t=Math.max(0,Math.ceil(Ut/Y)),Mt=Math.min(K,(L+Ut)/Y);let jt=0;for(let Ht=xt;Ht<Dt;++Ht){const Jt=Ht*Z-wt;for(let qt=$t;qt<Mt;++qt){const tn=qt*Y-Ut,fe=C*at+I*Ht+N*qt,hn=A*(U-1-Jt)+z*(L-1-tn)+F*pt;for(let De=0;De<ut;++De){const vn=pt*ut+De,we=k[fe+vn],en=$[hn+De];jt+=we*en}}}g[b*at+v*gt+w*Nt+pt]=jt}}return e.makeTensorInfo(m.shape,m.dtype,m.values)}const oI={kernelName:Xp,backendName:"cpu",kernelFunc:iI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rI(n){const{inputs:t,backend:e}=n,{x:s}=t,i=et(s.shape),o=e.data.get(s.dataId).values,r=ue([i,i],s.dtype),a=r.values;for(let l=0;l<o.length;l++)a[l*i+l]=o[l];const u=[...s.shape,...s.shape];return e.makeTensorInfo(u,r.dtype,r.values)}const aI={kernelName:qp,backendName:"cpu",kernelFunc:rI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uI={kernelName:Eu,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:s,filter:i}=n,{strides:o,pad:r,dilations:a}=e,u=t,l=u.data.get(s.dataId).values,c=s.shape.length,h=u.data.get(i.dataId).values,p=i.shape.length,{batchSize:f,inHeight:m,inWidth:g,inChannels:b,outHeight:v,outWidth:w,padInfo:k,strideHeight:C,strideWidth:I,filterHeight:N,filterWidth:$,dilationHeight:A,dilationWidth:z,outShape:F}=$i(s.shape,i.shape,o,r,"NHWC",a),E=et(F),U=F.length,L=Jr(s.dtype,E);for(let _=0;_<f;++_)for(let V=0;V<v;++V){const X=V*C-k.top;for(let j=0;j<w;++j){const K=j*I-k.left;for(let Z=0;Z<b;++Z){let Y=Number.MIN_SAFE_INTEGER;for(let nt=0;nt<N;++nt){const ut=X+nt*A;if(ut>=0&&ut<m)for(let at=0;at<$;++at){const pt=K+at*z;if(pt>=0&&pt<g){const gt=Xi([_,ut,pt,Z],c,Tt(s.shape)),wt=Xi([nt,at,Z],p,Tt(i.shape)),xt=l[gt]+h[wt];xt>Y&&(Y=xt)}}}const it=Xi([_,V,j,Z],U,Tt(F));L[it]=Y}}}return{dataId:u.write(Rl(L,s.dtype),F,s.dtype),shape:F,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lI={kernelName:Go,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:s,filter:i,dy:o}=n,{strides:r,pad:a,dilations:u}=e,l=t,c=oi(s.shape,l.data.get(s.dataId).values),h=oi(i.shape,l.data.get(i.dataId).values),{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:b,outWidth:v,padInfo:w,strideHeight:k,strideWidth:C,filterHeight:I,filterWidth:N,dilationHeight:$,dilationWidth:A,outShape:z}=$i(s.shape,i.shape,r,a,"NHWC",u);tt(o.rank===z.length,()=>`Error in ${Go}, dy must have the same rank as output ${z.length}, but got ${o.rank}`);const F=oi(z,l.data.get(o.dataId).values),E=Yp(i.shape,i.dtype);for(let L=0;L<p;++L)for(let W=0;W<b;++W){const _=W*k-w.top;for(let V=0;V<v;++V){const X=V*C-w.left;for(let j=0;j<g;++j){let K=Number.MIN_SAFE_INTEGER,Z=0,Y=0;for(let it=0;it<I;++it){const nt=_+it*$;if(nt>=0&&nt<f)for(let ut=0;ut<N;++ut){const at=X+ut*A;if(at>=0&&at<m){const pt=c[L][nt][at][j]+h[it][ut][j];pt>K&&(K=pt,Z=it,Y=ut)}}}E[Z][Y][j]+=F[L][W][V][j]}}}return{dataId:l.write(Rl(E,s.dtype),i.shape,i.dtype),shape:i.shape,dtype:i.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cI={kernelName:Uo,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:s,filter:i,dy:o}=n,{strides:r,pad:a,dilations:u}=e,l=t,c=oi(s.shape,l.data.get(s.dataId).values),h=oi(i.shape,l.data.get(i.dataId).values),{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:b,outWidth:v,padInfo:w,strideHeight:k,strideWidth:C,filterHeight:I,filterWidth:N,dilationHeight:$,dilationWidth:A,outShape:z}=$i(s.shape,i.shape,r,a,"NHWC",u);tt(o.rank===z.length,()=>`Error in ${Uo}, dy must have the same rank as output ${z.length}, but got ${o.rank}`);const F=oi(z,l.data.get(o.dataId).values),E=Yp(s.shape,s.dtype);for(let L=0;L<p;++L)for(let W=0;W<b;++W){const _=W*k-w.top;for(let V=0;V<v;++V){const X=V*C-w.left;for(let j=0;j<g;++j){let K=Number.MIN_SAFE_INTEGER,Z=_<0?0:_,Y=X<0?0:X;for(let it=0;it<I;++it){const nt=_+it*$;if(nt>=0&&nt<f)for(let ut=0;ut<N;++ut){const at=X+ut*A;if(at>=0&&at<m){const pt=c[L][nt][at][j]+h[it][ut][j];pt>K&&(K=pt,Z=nt,Y=at)}}}E[L][Z][Y][j]+=F[L][W][V][j]}}}return{dataId:l.write(Rl(E,s.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hI(n){const{inputs:t,backend:e,attrs:s}=n,{image:i}=t,{canvas:o,options:r}=s,{contextOptions:a,imageOptions:u}=r||{},l=(u==null?void 0:u.alpha)||1,c=(a==null?void 0:a.contextType)||"2d";if(c!=="2d")throw new Error(`Context type ${a.contextType} is not supported by the CPU backend.`);const h=o.getContext(c,(a==null?void 0:a.contextAttributes)||{});if(h==null)throw new Error(`Could not get the context with ${c} type.`);const[p,f]=i.shape.slice(0,2),m=i.shape.length===2?1:i.shape[2],g=e.data.get(i.dataId).values,b=i.dtype==="float32"?255:1,v=new Uint8ClampedArray(f*p*4);for(let k=0;k<p*f;++k){const C=[0,0,0,255*l];for(let N=0;N<m;N++){const $=g[k*m+N];if(i.dtype==="float32"){if($<0||$>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${$}.`)}else if(i.dtype==="int32"&&($<0||$>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${$}.`);m===1?(C[0]=$*b,C[1]=$*b,C[2]=$*b):C[N]=$*b}const I=k*4;v[I+0]=Math.round(C[0]),v[I+1]=Math.round(C[1]),v[I+2]=Math.round(C[2]),v[I+3]=Math.round(C[3])}o.width=f,o.height=p;const w=new ImageData(v,f,p);return h.putImageData(w,0,0),i}const dI={kernelName:Zp,backendName:"cpu",kernelFunc:hI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vo(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:o,keepDims:r}=s;yt(i,"sum");let a;i.dtype==="bool"?a=Al({inputs:{x:i},backend:e,attrs:{dtype:"int32"}}):a=Gs({inputs:{x:i},backend:e});const u=a.shape.length,l=ee(o,a.shape),c=Me(l,u);let h=l,p=a;c!=null&&(p=Ze({inputs:{x:a},backend:e,attrs:{perm:c}}),h=Ke(h.length,u)),Vn("sum",h,p.shape.length);const[f,m]=ln(p.shape,h),g=es(p.dtype,"int32");let b=Yw(e,f,g);const v=et(m),w=e.data.get(b.dataId).values,k=e.data.get(p.dataId).values;for(let C=0;C<w.length;++C){const I=C*v;let N=0;for(let $=0;$<v;++$)N+=k[I+$];w[C]=N}if(r){const C=Jn(b.shape,l),I=b;b=te({inputs:{x:b},backend:e,attrs:{shape:C}}),e.disposeIntermediateTensorInfo(I)}return e.disposeIntermediateTensorInfo(a),c!=null&&e.disposeIntermediateTensorInfo(p),b}const pI={kernelName:bl,backendName:"cpu",kernelFunc:vo};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fI(n){const{inputs:t,backend:e,attrs:s}=n,{equation:i}=s,o=t,{allDims:r,summedDims:a,idDims:u}=Jp(i,o.length);tf(r.length,u,o);const{path:l,steps:c}=ef(a,u),h=c.length;let p=null,f=r.length;const m=[];for(let g=0;g<h;++g){for(const b of c[g]){const{permutationIndices:v,expandDims:w}=nf(f,u[b]);let k;sf(v)?k=o[b]:(k=Ze({inputs:{x:o[b]},backend:e,attrs:{perm:v}}),m.push(k));const C=k.shape.slice();for(let I=0;I<w.length;++I)C.splice(w[I],0,1);ke(k.shape,C)||(k=te({inputs:{x:k},backend:e,attrs:{shape:C}}),m.push(k)),p===null?p=k:(p=Tl({inputs:{a:k,b:p},backend:e}),m.push(p))}g<h-1&&(l[g]>=0&&(p=vo({inputs:{x:p},backend:e,attrs:{axis:l[g]-(r.length-f),keepDims:!1}}),m.push(p)),f--)}for(const g of m)g!==p&&e.disposeIntermediateTensorInfo(g);return p}const mI={kernelName:Qp,backendName:"cpu",kernelFunc:fI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gI(n){const{inputs:t,backend:e}=n,{dy:s,y:i}=t;yt([s,i],"eluGrad");const o=new Float32Array(et(i.shape)),r=e.data.get(i.dataId).values,a=e.data.get(s.dataId).values;for(let u=0;u<r.length;++u){const l=r[u];l>=0?o[u]=a[u]:o[u]=a[u]*(l+1)}return e.makeTensorInfo(i.shape,"float32",o)}const yI={kernelName:Lu,backendName:"cpu",kernelFunc:gI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bI=cf,xI=of,wI=rf,vI=af,CI=uf,kI=lf,SI=Qt(Ir,n=>{const t=Math.sign(n),e=Math.abs(n),s=1/(1+bI*e);return t*(1-((((kI*s+CI)*s+vI)*s+wI)*s+xI)*s*Math.exp(-e*e))}),II={kernelName:Ir,backendName:"cpu",kernelFunc:SI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function or(n){const{inputs:t,backend:e,attrs:s}=n,{input:i}=t,{dim:o}=s,r=i.shape.length,a=i.shape.slice();let u=o;return o<0&&(tt(-(r+1)<=o,()=>`Axis must be in the interval [${-(r+1)}, ${r}]`),u=r+o+1),a.splice(u,0,1),te({inputs:{x:i},backend:e,attrs:{shape:a}})}const NI={kernelName:Ou,backendName:"cpu",kernelFunc:or};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $I=Us((n,t)=>n/t),rc=Ii(Fr,$I),lu={kernelName:Fr,backendName:"cpu",kernelFunc:rc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ny(n,t,e){const s=n.shape,i=s[0],o=s[1],r=e.data.get(n.dataId),a=r.complexTensorInfos.real,u=r.complexTensorInfos.imag,l=[i,o],c=et(l),h=Ln("float32",c),p=Ln("float32",c);for(let b=0;b<i;b++){const v=pi({inputs:{x:a},backend:e,attrs:{begin:[b,0],size:[1,o]}}),w=pi({inputs:{x:u},backend:e,attrs:{begin:[b,0],size:[1,o]}}),k=Fn({inputs:{real:v,imag:w},backend:e}),{real:C,imag:I}=DI(k,t,e),N=di(C,I);for(let $=0;$<o;$++){const A=hf(N,$);h[b*o+$]=A.real,p[b*o+$]=A.imag}e.disposeIntermediateTensorInfo(v),e.disposeIntermediateTensorInfo(w),e.disposeIntermediateTensorInfo(k)}const f=e.makeTensorInfo(l,"float32",h),m=e.makeTensorInfo(l,"float32",p),g=Fn({inputs:{real:f,imag:m},backend:e});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(m),g}function DI(n,t,e){const s=et(n.shape),i=e.data.get(n.dataId),o=e.data.get(i.complexTensorInfos.real.dataId).values,r=e.data.get(i.complexTensorInfos.imag.dataId).values;if(RI(s)){const a=cu(o,r,s,t,e),u=[n.shape[0],n.shape[1]];if(t){const l=e.makeTensorInfo(u,"float32",a.real),c=e.makeTensorInfo(u,"float32",a.imag),h=e.makeTensorInfo([],"float32",df(s,"float32")),p=Gs({inputs:{x:h},backend:e}),f=lu.kernelFunc({inputs:{a:l,b:h},backend:e}),m=lu.kernelFunc({inputs:{a:c,b:p},backend:e}),g=e.data.get(f.dataId).values,b=e.data.get(m.dataId).values;return e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(m),{real:g,imag:b}}return a}else{const a=di(o,r),u=AI(a,s,t);return Zw(u)}}function RI(n){return(n&n-1)===0}function cu(n,t,e,s,i){if(e===1)return{real:n,imag:t};const o=di(n,t),r=e/2,a=Qw(o),u=a.real,l=a.imag,c=[u.length],h=i.makeTensorInfo(c,"float32",u),p=i.makeTensorInfo(c,"float32",l),f=Fn({inputs:{real:h,imag:p},backend:i}),m=Jw(o),g=m.real,b=m.imag,v=[g.length],w=i.makeTensorInfo(v,"float32",g),k=i.makeTensorInfo(v,"float32",b),C=Fn({inputs:{real:w,imag:k},backend:i}),I=cu(u,l,r,s,i),N=I.real,$=I.imag,A=[N.length],z=i.makeTensorInfo(A,"float32",N),F=i.makeTensorInfo(A,"float32",$),E=Fn({inputs:{real:z,imag:F},backend:i}),U=cu(g,b,r,s,i),L=U.real,W=U.imag,_=[L.length],V=i.makeTensorInfo(_,"float32",L),X=i.makeTensorInfo(_,"float32",W),j=Fn({inputs:{real:V,imag:X},backend:i}),K=t0(e,s),Z=[K.real.length],Y=i.makeTensorInfo(Z,"float32",K.real),it=i.makeTensorInfo(Z,"float32",K.imag),nt=Fn({inputs:{real:Y,imag:it},backend:i}),ut=Tl({inputs:{a:nt,b:j},backend:i}),at=Ji({inputs:{a:E,b:ut},backend:i}),pt=pf({inputs:{a:E,b:ut},backend:i}),gt=to({inputs:{input:at},backend:i}),wt=to({inputs:{input:pt},backend:i}),xt=gi({inputs:{input:at},backend:i}),Dt=gi({inputs:{input:pt},backend:i}),Nt=yi({inputs:[gt,wt],backend:i,attrs:{axis:0}}),Ut=yi({inputs:[xt,Dt],backend:i,attrs:{axis:0}}),$t=i.data.get(Nt.dataId).values,Mt=i.data.get(Ut.dataId).values;return i.disposeIntermediateTensorInfo(h),i.disposeIntermediateTensorInfo(p),i.disposeIntermediateTensorInfo(f),i.disposeIntermediateTensorInfo(w),i.disposeIntermediateTensorInfo(k),i.disposeIntermediateTensorInfo(C),i.disposeIntermediateTensorInfo(z),i.disposeIntermediateTensorInfo(F),i.disposeIntermediateTensorInfo(E),i.disposeIntermediateTensorInfo(V),i.disposeIntermediateTensorInfo(X),i.disposeIntermediateTensorInfo(j),i.disposeIntermediateTensorInfo(Y),i.disposeIntermediateTensorInfo(it),i.disposeIntermediateTensorInfo(nt),i.disposeIntermediateTensorInfo(ut),i.disposeIntermediateTensorInfo(at),i.disposeIntermediateTensorInfo(pt),i.disposeIntermediateTensorInfo(gt),i.disposeIntermediateTensorInfo(xt),i.disposeIntermediateTensorInfo(wt),i.disposeIntermediateTensorInfo(Dt),i.disposeIntermediateTensorInfo(Nt),i.disposeIntermediateTensorInfo(Ut),{real:$t,imag:Mt}}function AI(n,t,e){const s=new Float32Array(t*2);for(let i=0;i<t;i++){let o=0,r=0;for(let a=0;a<t;a++){const u=n0(i*a,t,e),l=hf(n,a);o+=l.real*u.real-l.imag*u.imag,r+=l.real*u.imag+l.imag*u.real}e&&(o/=t,r/=t),e0(s,o,r,i)}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TI(n){const{inputs:t,backend:e}=n,{input:s}=t,i=et(s.shape),o=s.shape[s.shape.length-1],r=i/o,a=te({inputs:{x:s},backend:e,attrs:{shape:[r,o]}}),u=Ny(a,!1,e),l=te({inputs:{x:u},backend:e,attrs:{shape:s.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(u),l}const zI={kernelName:ff,backendName:"cpu",kernelFunc:TI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ac(n){const{backend:t,attrs:e}=n,{shape:s,value:i,dtype:o}=e,r=o||gf(i),a=Jr(r,et(s));return MI(a,i,r),t.makeTensorInfo(s,r,a)}const FI={kernelName:mf,backendName:"cpu",kernelFunc:ac};function MI(n,t,e){n.fill(t)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PI={kernelName:yf,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:s}=n,i=e,o=Ln(s.dtype,et(s.shape)),[r,a,u,l]=s.shape,c=i.data.get(s.dataId).values;for(let p=0;p<r;p++){const f=p*u*a*l;for(let m=0;m<a;m++){const g=m*(u*l);for(let b=0;b<u;b++){const v=b*l;for(let w=0;w<l;w++){const k=Math.round(u-b-1),C=f+g+v+w;let I=c[C];if(k>=0&&k<u){const N=k*l,$=f+g+N+w;I=c[$]}o[C]=I}}}}return{dataId:i.write(o,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EI(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,filter:o,bias:r,preluActivationWeights:a}=t,{strides:u,pad:l,dataFormat:c,dilations:h,dimRoundingMode:p,activation:f,leakyreluAlpha:m}=s;let g=Sy({inputs:{x:i,filter:o},backend:e,attrs:{strides:u,pad:l,dataFormat:c,dilations:h,dimRoundingMode:p}});if(r){const b=g;if(c==="NCHW"&&r.shape.length===1&&r.shape[0]!==1){const v=te({inputs:{x:r},backend:e,attrs:{shape:[r.shape[0],1,1]}});g=Ji({inputs:{a:g,b:v},backend:e}),e.disposeIntermediateTensorInfo(v)}else g=Ji({inputs:{a:g,b:r},backend:e});e.disposeIntermediateTensorInfo(b)}if(f){const b=g;if(c==="NCHW"&&f==="prelu"&&a.shape.length===1&&a.shape[0]!==1){const v=te({inputs:{x:a},backend:e,attrs:{shape:[a.shape[0],1,1]}});g=ir(e,g,f,v,m),e.disposeIntermediateTensorInfo(v)}else g=ir(e,g,f,a,m);e.disposeIntermediateTensorInfo(b)}return g}const LI={kernelName:bf,backendName:"cpu",kernelFunc:EI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OI(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,filter:o,bias:r,preluActivationWeights:a}=t,{strides:u,pad:l,dataFormat:c,dilations:h,dimRoundingMode:p,activation:f,leakyreluAlpha:m}=s;let g=Iy({inputs:{x:i,filter:o},backend:e,attrs:{strides:u,pad:l,dataFormat:c,dilations:h,dimRoundingMode:p}});if(r){const b=g;g=Ji({inputs:{a:g,b:r},backend:e}),e.disposeIntermediateTensorInfo(b)}if(f){const b=g;g=ir(e,g,f,a,m),e.disposeIntermediateTensorInfo(b)}return g}const _I={kernelName:xf,backendName:"cpu",kernelFunc:OI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BI(n){const{inputs:t,backend:e}=n,{params:s,indices:i}=t,o=et(s.shape),r=i.shape,a=r[r.length-1],[u,l,c,h]=vf(s,i);if(l===0)return e.makeTensorInfo(u,s.dtype,[]);const p=e.data.get(i.dataId).values,f=e.bufferSync(s),m=s0(p,f,s.dtype,l,a,c,h,s.shape,o);return e.makeTensorInfo(u,s.dtype,m.values)}const WI={kernelName:wf,backendName:"cpu",kernelFunc:BI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VI(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,indices:o}=t,{axis:r,batchDims:a}=s;yt([i,o],"gatherV2");const u=ee(r,i.shape)[0],l=e.data.get(o.dataId).values,c=i.shape[u];for(let C=0;C<l.length;++C){const I=l[C];tt(I<=c-1&&I>=0,()=>`GatherV2: the index value ${I} is not in [0, ${c-1}]`)}let h=a;a==null&&(h=0);const p=et(o.shape),f=Cf(i,o,u,h),m=te({inputs:{x:i},backend:e,attrs:{shape:[f.batchSize,f.outerSize,f.dimSize,f.sliceSize]}}),g=te({inputs:{x:o},backend:e,attrs:{shape:[f.batchSize,p/f.batchSize]}}),b=[f.batchSize,f.outerSize,p/f.batchSize,f.sliceSize],v=e.bufferSync(g),w=e.bufferSync(m),k=i0(w,v,b);return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(g),e.makeTensorInfo(f.outputShape,k.dtype,k.values)}const UI={kernelName:Bu,backendName:"cpu",kernelFunc:VI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GI(n){const{inputs:t,backend:e}=n,{input:s}=t,i=et(s.shape),o=s.shape[s.shape.length-1],r=i/o,a=te({inputs:{x:s},backend:e,attrs:{shape:[r,o]}}),u=Ny(a,!0,e),l=te({inputs:{x:u},backend:e,attrs:{shape:s.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(u),l}const HI={kernelName:kf,backendName:"cpu",kernelFunc:GI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jI=Qt(Nr,n=>Number.isFinite(n)?1:0,"bool"),KI={kernelName:Nr,backendName:"cpu",kernelFunc:jI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XI=Qt($r,n=>Math.abs(n)===1/0?1:0,"bool"),qI={kernelName:$r,backendName:"cpu",kernelFunc:XI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YI=Qt(Dr,n=>Number.isNaN(n)?1:0,"bool"),ZI={kernelName:Dr,backendName:"cpu",kernelFunc:YI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QI(n){const{backend:t,attrs:e}=n,{start:s,stop:i,num:o}=e,r=o0(s,i,o);return t.makeTensorInfo([r.length],"float32",r)}const JI={kernelName:Sf,backendName:"cpu",kernelFunc:QI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const t3=Qt(Rr,n=>Math.log1p(n)),e3={kernelName:Rr,backendName:"cpu",kernelFunc:t3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const n3=Us((n,t)=>n&&t),s3=Ii(zl,n3,null,"bool"),i3={kernelName:zl,backendName:"cpu",kernelFunc:s3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o3=Qt(Fl,n=>n?0:1,"bool"),r3={kernelName:Fl,backendName:"cpu",kernelFunc:o3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a3=Us((n,t)=>n||t),u3=Ii(Ml,a3,null,"bool"),l3={kernelName:Ml,backendName:"cpu",kernelFunc:u3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c3(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{depthRadius:o,bias:r,alpha:a,beta:u}=s;yt(i,"LRN");const l=i.shape[3],c=l-1,h=e.data.get(i.dataId).values,p=et(i.shape),f=new Float32Array(p);function m(g){const b=g%l;let v=g-b+Math.max(0,b-o);const w=g-b+Math.min(b+o,c);let k=0;for(;v<=w;v++){const C=h[v];k+=C*C}return k}for(let g=0;g<p;g++){const b=m(g),v=h[g]*Math.pow(r+a*b,-u);f[g]=v}return e.makeTensorInfo(i.shape,i.dtype,f)}const h3={kernelName:Uu,backendName:"cpu",kernelFunc:c3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d3(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,y:o,dy:r}=t,{depthRadius:a,bias:u,alpha:l,beta:c}=s;yt(r,"LRNGrad");const h=et(r.shape),p=r.shape[3],f=e.data.get(r.dataId).values,m=e.data.get(i.dataId).values,g=e.data.get(o.dataId).values,b=new Float32Array(h),v=h;for(let w=0;w<v;w++){const k=w%p,C=w-k+Math.max(0,k-a),I=w-k+Math.min(p,k+a+1);let N=0;for(let $=C;$<I;$++)N+=Math.pow(m[$],2);N=l*N+u;for(let $=C;$<I;$++){let A=-2*l*c*m[$]*g[w]/N;w===$&&(A+=Math.pow(N,-c)),A*=f[w],b[$]+=A}}return e.makeTensorInfo(r.shape,i.dtype,b)}const p3={kernelName:Vu,backendName:"cpu",kernelFunc:d3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $y(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{reductionIndices:o,keepDims:r}=s,a=e;let u=i.shape;const l=u.length,c=ee(o,u);let h=c;const p=Me(h,l);let f=a.data.get(i.dataId).values;if(p!=null){const C=new Array(l);for(let I=0;I<C.length;I++)C[I]=u[p[I]];f=r0(f,u,i.dtype,p,C),h=Ke(h.length,l),u=C}yt(i,"max"),Vn("max",h,l);const[m,g]=ln(u,h),b=et(g),v=a0(f,b,m,i.dtype),w=a.write(v,m,i.dtype);let k=m;return r&&(k=Jn(m,c)),{dataId:w,shape:k,dtype:i.dtype}}const f3={kernelName:Gu,backendName:"cpu",kernelFunc:$y};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m3(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t;yt(i,"maxPool");const{filterSize:o,strides:r,pad:a,dimRoundingMode:u}=s,l=1;tt(ki(r,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${r} and dilations '${l}'`);const c=Un(i.shape,o,r,l,a,u);let h;if(c.filterWidth===1&&c.filterHeight===1&&ke(c.inShape,c.outShape))h=Gs({inputs:{x:i},backend:e});else{const p=e.data.get(i.dataId).values,f=Tt(i.shape),m=oc(p,i.shape,i.dtype,f,c,"max");h=e.makeTensorInfo(c.outShape,i.dtype,m.values)}return h}const g3={kernelName:Xu,backendName:"cpu",kernelFunc:m3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y3(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{filterSize:o,strides:r,pad:a,dimRoundingMode:u,dataFormat:l}=s;yt(i,"maxPool3d");const c=xs(i.shape,o,r,1,a,u,l),h=e.data.get(i.dataId).values,p=ky(h,i.shape,i.dtype,Tt(i.shape),c,"max");return e.makeTensorInfo(p.shape,"float32",p.values)}const b3={kernelName:ju,backendName:"cpu",kernelFunc:y3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x3(n){const{inputs:t,backend:e,attrs:s}=n,{dy:i,input:o}=t,{filterSize:r,strides:a,pad:u,dimRoundingMode:l}=s;yt([i,o],"maxPool3DGrad");const c=xs(o.shape,r,a,1,u,l),h=e.bufferSync(o),p=aS(h,c),f=c.strideDepth,m=c.strideHeight,g=c.strideWidth,b=c.dilationDepth,v=c.dilationHeight,w=c.dilationWidth,k=c.effectiveFilterDepth,C=c.effectiveFilterHeight,I=c.effectiveFilterWidth,N=k-1-c.padInfo.front,$=I-1-c.padInfo.left,A=C-1-c.padInfo.top,z=ue(o.shape,"float32"),F=e.bufferSync(i);for(let E=0;E<c.batchSize;++E)for(let U=0;U<c.inChannels;++U)for(let L=0;L<c.inDepth;++L)for(let W=0;W<c.inHeight;++W)for(let _=0;_<c.inWidth;++_){const V=L-N,X=W-A,j=_-$;let K=0;for(let Z=0;Z<k;Z+=b){const Y=(V+Z)/f;if(!(Y<0||Y>=c.outDepth||Math.floor(Y)!==Y))for(let it=0;it<C;it+=v){const nt=(X+it)/m;if(!(nt<0||nt>=c.outHeight||Math.floor(nt)!==nt))for(let ut=0;ut<I;ut+=w){const at=(j+ut)/g;if(at<0||at>=c.outWidth||Math.floor(at)!==at)continue;const pt=k*C*I-1-p.get(E,Y,nt,at,U),gt=Z*C*I+it*I+ut,wt=pt===gt?1:0;if(wt===0)continue;const xt=F.get(E,Y,nt,at,U);K+=xt*wt}}}z.set(K,E,L,W,_,U)}return e.makeTensorInfo(z.shape,z.dtype,z.values)}const w3={kernelName:Hu,backendName:"cpu",kernelFunc:x3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v3(n){const{inputs:t,backend:e,attrs:s}=n,{dy:i,input:o,output:r}=t,a=o;yt([o,r],"maxPoolGrad");const{filterSize:u,strides:l,pad:c,dimRoundingMode:h}=s,p=Un(a.shape,u,l,1,c,h),f=e.data.get(a.dataId).values,m=ue(p.outShape,a.dtype,Cy(f,a.shape,a.dtype,p).values),g=p.strideHeight,b=p.strideWidth,v=p.dilationHeight,w=p.dilationWidth,k=p.effectiveFilterHeight,C=p.effectiveFilterWidth,I=C-1-p.padInfo.left,N=k-1-p.padInfo.top,$=ue(a.shape,"float32"),A=e.data.get(i.dataId).values,z=ue(i.shape,"float32",A);for(let F=0;F<p.batchSize;++F)for(let E=0;E<p.inChannels;++E)for(let U=0;U<p.inHeight;++U)for(let L=0;L<p.inWidth;++L){const W=U-N,_=L-I;let V=0;for(let X=0;X<k;X+=v){const j=(W+X)/g;if(!(j<0||j>=p.outHeight||Math.floor(j)!==j))for(let K=0;K<C;K+=w){const Z=(_+K)/b;if(Z<0||Z>=p.outWidth||Math.floor(Z)!==Z)continue;const Y=k*C-1-m.get(F,j,Z,E),it=X*C+K,nt=Y===it?1:0;if(nt===0)continue;const ut=z.get(F,j,Z,E);V+=ut*nt}}$.set(V,F,U,L,E)}return e.makeTensorInfo($.shape,$.dtype,$.values)}const C3={kernelName:Ku,backendName:"cpu",kernelFunc:v3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k3(n,t,e,s,i){const o=Tt(t),r=oc(n,t,e,o,i,"max"),a=Cy(n,t,e,i,!0,s);return[r.values,a.values]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const S3={kernelName:If,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:s}=n,{filterSize:i,strides:o,pad:r,includeBatchInIndex:a}=t,u=e;yt(s,"MaxPoolWithArgmax");const l=u.data.get(s.dataId).values,c=Un(s.shape,i,o,[1,1],r),[h,p]=k3(l,s.shape,s.dtype,a,c),f=u.write(h,c.outShape,s.dtype),m=u.write(p,c.outShape,s.dtype);return[{dataId:f,shape:c.outShape,dtype:s.dtype},{dataId:m,shape:c.outShape,dtype:"int32"}]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I3(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:o,keepDims:r}=s,a=ee(o,i.shape),l=ln(i.shape,a)[1],c=et(l),h=[],p=e.makeTensorInfo([],"float32",new Float32Array([c]));h.push(p);const f=Al({inputs:{x:i},backend:e,attrs:{dtype:"float32"}});h.push(f);const m=rc({inputs:{a:f,b:p},backend:e});h.push(m);const g=vo({inputs:{x:m},backend:e,attrs:{axis:o,keepDims:r}});return h.forEach(b=>e.disposeIntermediateTensorInfo(b)),g}const N3={kernelName:qu,backendName:"cpu",kernelFunc:I3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $3(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:o,keepDims:r}=s;yt(i,"min");const a=ee(o,i.shape);let u=a;const l=Me(u,i.shape.length);let c=i;l!=null&&(c=Ze({inputs:{x:i},backend:e,attrs:{perm:l}}),u=Ke(u.length,i.shape.length)),Vn("min",u,c.shape.length);const[h,p]=ln(c.shape,u),f=et(p),m=ss(et(h),c.dtype),g=e.data.get(c.dataId).values;for(let v=0;v<m.length;++v){const w=v*f;let k=g[w];for(let C=0;C<f;++C){const I=g[w+C];(Number.isNaN(I)||I<k)&&(k=I)}m[v]=k}l!=null&&e.disposeIntermediateTensorInfo(c);const b=e.makeTensorInfo(h,c.dtype,m);if(r){const v=Jn(h,a),w=te({inputs:{x:b},backend:e,attrs:{shape:v}});return e.disposeIntermediateTensorInfo(b),w}return b}const D3={kernelName:Yu,backendName:"cpu",kernelFunc:$3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R3(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{paddings:o,mode:r}=s;yt(i,"mirrorPad");const a=o.map((k,C)=>k[0]+i.shape[C]+k[1]),u=o.map(k=>k[0]),l=o.map((k,C)=>k[0]+i.shape[C]),c=r==="reflect"?0:1,h=e.data.get(i.dataId).values,p=i.shape.length,f=Tt(i.shape),m=et(a),g=a.length,b=Tt(a),v=Ln(i.dtype,m);for(let k=0;k<m;k++){let C=Nf(k,g,b);for(let N=0;N<g;N++)C[N]<u[N]?C[N]=u[N]*2-C[N]-c:C[N]>=l[N]&&(C[N]=(l[N]-1)*2-C[N]+c);C=C.map((N,$)=>N-u[$]);const I=Xi(C,p,f);v[k]=h[I]}return{dataId:e.write(v,a,i.dtype),shape:a,dtype:i.dtype}}const A3={kernelName:Zu,backendName:"cpu",kernelFunc:R3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const T3=Us((n,t)=>{const e=n%t;return n<0&&t<0||n>=0&&t>=0?e:(e+t)%t}),z3=Ii(Ar,T3),F3={kernelName:Ar,backendName:"cpu",kernelFunc:z3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dy(n){const{inputs:t,backend:e,attrs:s}=n,{logits:i}=t,{dim:o}=s,r=i.shape.length;let a=o;if(a===-1&&(a=r-1),a!==r-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${r} and dim was ${a}`);const u=ee([a],i.shape),l=$y({inputs:{x:i},backend:e,attrs:{reductionIndices:u,keepDims:!1}}),c=Jn(l.shape,u),h=te({inputs:{x:l},backend:e,attrs:{shape:c}}),p=pf({inputs:{a:i,b:h},backend:e}),f=u0({inputs:{x:p},backend:e}),m=vo({inputs:{x:f},backend:e,attrs:{axis:u,keepDims:!1}}),g=te({inputs:{x:m},backend:e,attrs:{shape:c}}),b=rc({inputs:{a:f,b:g},backend:e});return e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(g),b}const M3={kernelName:fl,backendName:"cpu",kernelFunc:Dy};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P3(n){const{inputs:t,backend:e,attrs:s}=n,{logits:i}=t,{numSamples:o,seed:r,normalized:a}=s;yt(i,"multinomial");const u=a?i:Dy({inputs:{logits:i},backend:e,attrs:{dim:-1}}),l=u.shape[0],c=u.shape[1],h=e.data.get(u.dataId).values,p=[l,o],f=ss(et(p),"int32");for(let m=0;m<l;++m){const g=m*c,b=new Float32Array(c-1);b[0]=h[g];for(let k=1;k<b.length;++k)b[k]=b[k-1]+h[g+k];const v=l0.alea(r.toString()),w=m*o;for(let k=0;k<o;++k){const C=v();f[w+k]=b.length;for(let I=0;I<b.length;I++)if(C<b[I]){f[w+k]=I;break}}}return a||e.disposeIntermediateTensorInfo(u),e.makeTensorInfo(p,"int32",f)}const E3={kernelName:$f,backendName:"cpu",kernelFunc:P3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const L3=Rf;function O3(n){const{inputs:t,backend:e,attrs:s}=n,{boxes:i,scores:o}=t,{maxOutputSize:r,iouThreshold:a,scoreThreshold:u}=s;yt(i,"NonMaxSuppression");const l=e.data.get(i.dataId).values,c=e.data.get(o.dataId).values,{selectedIndices:h}=L3(l,c,r,a,u);return e.makeTensorInfo([h.length],"int32",new Int32Array(h))}const _3={kernelName:Df,backendName:"cpu",kernelFunc:O3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const B3=h0;function W3(n){const{inputs:t,backend:e,attrs:s}=n,{boxes:i,scores:o}=t,{maxOutputSize:r,iouThreshold:a,scoreThreshold:u,padToMaxOutputSize:l}=s;yt(i,"NonMaxSuppressionPadded");const c=e.data.get(i.dataId).values,h=e.data.get(o.dataId).values,{selectedIndices:p,validOutputs:f}=B3(c,h,r,a,u,l);return[e.makeTensorInfo([p.length],"int32",new Int32Array(p)),e.makeTensorInfo([],"int32",new Int32Array([f]))]}const V3={kernelName:c0,backendName:"cpu",kernelFunc:W3};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const U3=Tf;function G3(n){const{inputs:t,backend:e,attrs:s}=n,{boxes:i,scores:o}=t,{maxOutputSize:r,iouThreshold:a,scoreThreshold:u,softNmsSigma:l}=s;yt(i,"NonMaxSuppressionWithScore");const c=e.data.get(i.dataId).values,h=e.data.get(o.dataId).values,p=r,f=a,m=u,g=l,{selectedIndices:b,selectedScores:v}=U3(c,h,p,f,m,g);return[e.makeTensorInfo([b.length],"int32",new Int32Array(b)),e.makeTensorInfo([v.length],"float32",new Float32Array(v))]}const H3={kernelName:Af,backendName:"cpu",kernelFunc:G3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j3(n){const{inputs:t,backend:e,attrs:s}=n,{indices:i}=t,{dtype:o,depth:r,onValue:a,offValue:u}=s;yt(i,"oneHot");const l=et(i.shape),c=new Float32Array(l*r);c.fill(u);const h=e.data.get(i.dataId).values;for(let p=0;p<l;++p)h[p]>=0&&h[p]<r&&(c[p*r+h[p]]=a);return e.makeTensorInfo([...i.shape,r],o,c)}const K3={kernelName:Ju,backendName:"cpu",kernelFunc:j3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rr(n){const{inputs:t,backend:e}=n,{x:s}=t;if(s.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(s.dtype==="complex64"){const i=to({inputs:{input:s},backend:e}),o=rr({inputs:{x:i},backend:e}),r=gi({inputs:{input:s},backend:e}),a=rr({inputs:{x:r},backend:e}),u=Fn({inputs:{real:o,imag:a},backend:e});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(r),e.disposeIntermediateTensorInfo(a),u}else return ac({backend:e,attrs:{shape:s.shape,value:0,dtype:s.dtype}})}const X3={kernelName:kl,backendName:"cpu",kernelFunc:rr};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ry(n){const{inputs:t,backend:e}=n,{x:s}=t;if(s.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(s.dtype==="complex64"){const i=to({inputs:{input:s},backend:e}),o=Ry({inputs:{x:i},backend:e}),r=gi({inputs:{input:s},backend:e}),a=rr({inputs:{x:r},backend:e}),u=Fn({inputs:{real:o,imag:a},backend:e});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(r),e.disposeIntermediateTensorInfo(a),u}else return ac({backend:e,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}const q3={kernelName:tl,backendName:"cpu",kernelFunc:Ry};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ay(n){const{inputs:t,backend:e,attrs:s}=n,{axis:i}=s;if(t.length===1)return or({inputs:{input:t[0]},backend:e,attrs:{dim:i}});const o=t[0].shape,r=t[0].dtype;t.forEach(c=>{zf(o,c.shape,"All tensors passed to stack must have matching shapes"),tt(r===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],u=t.map(c=>{const h=or({inputs:{input:c},backend:e,attrs:{dim:i}});return a.push(h),h}),l=yi({inputs:u,backend:e,attrs:{axis:i}});return a.forEach(c=>e.disposeIntermediateTensorInfo(c)),l}const Y3={kernelName:el,backendName:"cpu",kernelFunc:Ay};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z3(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{paddings:o,constantValue:r}=s;yt(i,"pad");const a=o.map((w,k)=>w[0]+i.shape[k]+w[1]),u=o.map(w=>w[0]),l=e.data.get(i.dataId).values,c=et(i.shape),h=i.shape.length,p=Tt(i.shape),f=et(a),m=a.length,g=Tt(a),b=Ln(i.dtype,f);r!==0&&b.fill(r);for(let w=0;w<c;w++){const C=Nf(w,h,p).map((N,$)=>N+u[$]),I=Xi(C,m,g);b[I]=l[w]}return{dataId:e.write(b,a,i.dtype),shape:a,dtype:i.dtype}}const Ty={kernelName:nl,backendName:"cpu",kernelFunc:Z3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Q3=Us((n,t)=>Math.pow(n,t)),J3=Ii(Tr,Q3),tN={kernelName:Tr,backendName:"cpu",kernelFunc:J3};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eN(n){const{inputs:t,backend:e,attrs:s}=n,{paramsNestedSplits:i,paramsDenseValues:o,indices:r}=t,a=i.map(b=>e.data.get(b.dataId).values),u=i.map(b=>b.shape),l=e.data.get(o.dataId).values,c=e.data.get(r.dataId).values,[h,p,f]=p0(a,u,l,o.shape,o.dtype,c,r.shape),m=h.map(b=>e.makeTensorInfo([b.length],"int32",b)),g=e.makeTensorInfo(f,o.dtype,p);return m.concat([g])}const nN={kernelName:d0,backendName:"cpu",kernelFunc:eN};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sN(n){const{inputs:t,backend:e}=n,{starts:s,limits:i,deltas:o}=t,r=e.data.get(s.dataId).values,a=e.data.get(i.dataId).values,u=e.data.get(o.dataId).values,[l,c]=m0(r,s.shape,s.dtype,a,i.shape,u,o.shape),h=e.makeTensorInfo([l.length],"int32",l),p=e.makeTensorInfo([c.length],s.dtype,c);return[h,p]}const iN={kernelName:f0,backendName:"cpu",kernelFunc:sN};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oN(n){const{inputs:t,backend:e,attrs:s}=n,{shape:i,values:o,defaultValue:r,rowPartitionTensors:a}=t,{rowPartitionTypes:u}=s,l=e.data.get(i.dataId).values,c=e.data.get(o.dataId).values,h=e.data.get(r.dataId).values,p=a.map(b=>e.data.get(b.dataId).values),f=a.map(b=>b.shape),[m,g]=y0(l,i.shape,c,o.shape,o.dtype,h,r.shape,p,f,u);return e.makeTensorInfo(m,o.dtype,g)}const rN={kernelName:g0,backendName:"cpu",kernelFunc:oN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aN(n){const{backend:t,attrs:e}=n,{start:s,stop:i,dtype:o,step:r}=e,a=b0(s,i,r,o);return t.makeTensorInfo([a.length],o,a)}const uN={kernelName:Ff,backendName:"cpu",kernelFunc:aN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lN=Qt(Mr,n=>1/n),cN={kernelName:Mr,backendName:"cpu",kernelFunc:lN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hN(n){const{inputs:t,backend:e,attrs:s}=n,{images:i}=t,{alignCorners:o,halfPixelCenters:r,size:a}=s;yt(i,"resizeBilinear");const u=Tt(i.shape),[l,c]=a,[h,p,f,m]=i.shape,g=e.data.get(i.dataId).values,b=new Float32Array(et([h,l,c,m])),v=[o&&l>1?p-1:p,o&&c>1?f-1:f],w=[o&&l>1?l-1:l,o&&c>1?c-1:c];let k=0;const C=v[0]/w[0],I=v[1]/w[1];for(let N=0;N<h;N++)for(let $=0;$<l;$++){let A;r?A=C*($+.5)-.5:A=C*$;const z=Math.max(0,Math.floor(A)),F=A-z,E=Math.min(p-1,Math.ceil(A)),U=N*u[0]+z*u[1],L=N*u[0]+E*u[1];for(let W=0;W<c;W++){let _;r?_=I*(W+.5)-.5:_=I*W;const V=Math.max(0,Math.floor(_)),X=_-V,j=Math.min(f-1,Math.ceil(_)),K=U+V*u[2],Z=L+V*u[2],Y=U+j*u[2],it=L+j*u[2];for(let nt=0;nt<m;nt++){const ut=g[K+nt],at=g[Z+nt],pt=g[Y+nt],gt=g[it+nt],wt=ut+(pt-ut)*X,xt=at+(gt-at)*X,Dt=wt+(xt-wt)*F;b[k++]=Dt}}}return e.makeTensorInfo([h,l,c,m],"float32",b)}const dN={kernelName:ol,backendName:"cpu",kernelFunc:hN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pN(n){const{inputs:t,backend:e,attrs:s}=n,{images:i,dy:o}=t,{alignCorners:r}=s;yt([o,i],"resizeBilinearGrad");const a=Tt(i.shape),[u,l,c,h]=i.shape,[,p,f]=o.shape,m=new Float32Array(u*l*c*h),g=[r&&p>1?l-1:l,r&&f>1?c-1:c],b=[r&&p>1?p-1:p,r&&f>1?f-1:f],v=g[0]/b[0],w=g[1]/b[1],k=e.data.get(o.dataId).values;let C=0;for(let I=0;I<u;I++){const N=I*a[0];for(let $=0;$<p;$++){const A=$*v,z=Math.floor(A),F=Math.min(Math.ceil(A),l-1),E=N+z*a[1],U=N+F*a[1],L=A-z,W=1-L;for(let _=0;_<f;_++){const V=_*w,X=Math.floor(V),j=Math.min(Math.ceil(V),c-1),K=V-X,Z=1-K,Y=E+X*a[2],it=E+j*a[2],nt=U+X*a[2],ut=U+j*a[2],at=W*Z,pt=W*K,gt=L*Z,wt=L*K;for(let xt=0;xt<h;xt++){const Dt=k[C++];m[Y+xt]+=Dt*at,m[it+xt]+=Dt*pt,m[nt+xt]+=Dt*gt,m[ut+xt]+=Dt*wt}}}}return e.makeTensorInfo([u,c,l,h],"float32",m)}const fN={kernelName:rl,backendName:"cpu",kernelFunc:pN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mN(n){const{inputs:t,backend:e,attrs:s}=n,{images:i}=t,{alignCorners:o,halfPixelCenters:r,size:a}=s;yt(i,"resizeNearestNeighbor");const u=Tt(i.shape),[l,c]=a,[h,p,f,m]=i.shape,g=e.data.get(i.dataId).values,b=new Float32Array(h*l*c*m),v=[o&&l>1?p-1:p,o&&c>1?f-1:f],w=[o&&l>1?l-1:l,o&&c>1?c-1:c],k=v[0]/w[0],C=v[1]/w[1];let I=0;for(let N=0;N<h;N++){const $=N*u[0];for(let A=0;A<l;A++){const z=r?k*(A+.5):k*A;let F=Math.min(p-1,o?Math.round(z):Math.floor(z));r&&(F=Math.max(0,F));const E=$+F*u[1];for(let U=0;U<c;U++){const L=r?C*(U+.5):C*U;let W=Math.min(f-1,o?Math.round(L):Math.floor(L));r&&(W=Math.max(0,W));const _=E+W*u[2];for(let V=0;V<m;V++){const X=g[_+V];b[I++]=X}}}}return e.makeTensorInfo([h,l,c,m],i.dtype,b)}const gN={kernelName:al,backendName:"cpu",kernelFunc:mN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yN(n){const{inputs:t,backend:e,attrs:s}=n,{images:i,dy:o}=t,{alignCorners:r}=s;yt([o,i],"resizeNearestNeighborGrad");const a=Tt(i.shape),u=Tt(o.shape),[l,c,h,p]=i.shape,[,f,m]=o.shape,g=new Float32Array(l*c*h*p),b=e.data.get(o.dataId).values,v=[r&&f>1?c-1:c,r&&m>1?h-1:h],w=[r&&f>1?f-1:f,r&&m>1?m-1:m],k=v[0]/w[0],C=v[1]/w[1],I=1/k,N=1/C,$=Math.ceil(I)*2+2,A=Math.ceil(N)*2+2;for(let z=0;z<l;z++){const F=z*a[0];for(let E=0;E<c;E++){const U=F+E*a[1],L=Math.floor(E*I),W=Math.floor(L-$/2);for(let _=0;_<h;_++){const V=U+_*a[2],X=Math.floor(_*N),j=Math.floor(X-A/2);for(let K=0;K<p;K++){let Z=0;for(let Y=0;Y<$;Y++){const it=Y+W;if(it<0||it>=f)continue;const nt=F+it*u[1],ut=it*k,at=Math.min(c-1,r?Math.round(ut):Math.floor(ut));if(E===at)for(let pt=0;pt<A;pt++){const gt=pt+j;if(gt<0||gt>=m)continue;const wt=nt+gt*u[2],xt=gt*C,Dt=Math.min(h-1,r?Math.round(xt):Math.floor(xt));_===Dt&&(Z+=b[wt+K])}}g[V+K]=Z}}}}return e.makeTensorInfo(i.shape,i.dtype,g)}const bN={kernelName:ul,backendName:"cpu",kernelFunc:yN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xN(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{dims:o}=s;yt(i,"reverse");const r=i.shape.length,a=ee(o,i.shape);if(r===0)return Gs({inputs:{x:i},backend:e});const u=new Ve(i.shape,i.dtype),l=e.bufferSync(i);for(let c=0;c<u.size;c++){const h=u.indexToLoc(c),p=h.slice();a.forEach(f=>p[f]=i.shape[f]-1-p[f]),u.set(l.get(...p),...h)}return e.makeTensorInfo(u.shape,u.dtype,u.values)}const wN={kernelName:ll,backendName:"cpu",kernelFunc:xN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vN={kernelName:Mf,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:s}=n,{radians:i,fillValue:o,center:r}=t,a=e,u=Ln(s.dtype,et(s.shape)),[l,c,h,p]=s.shape,[f,m]=Pf(r,c,h),g=255,b=Math.sin(i),v=Math.cos(i),w=a.data.get(s.dataId).values;for(let C=0;C<l;C++){const I=C*h*c*p;for(let N=0;N<c;N++){const $=N*(h*p);for(let A=0;A<h;A++){const z=A*p;for(let F=0;F<p;F++){const E=[l,N,A,F],U=E[2],L=E[1];let W=(U-f)*v-(L-m)*b,_=(U-f)*b+(L-m)*v;W=Math.round(W+f),_=Math.round(_+m);let V=o;if(typeof o!="number"&&(F===3?V=g:V=o[F]),W>=0&&W<h&&_>=0&&_<c){const j=_*(h*p),K=W*p,Z=I+j+K+F;V=w[Z]}const X=I+$+z+F;u[X]=V}}}}return{dataId:a.write(u,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CN=Qt(Lr,n=>{const t=Math.floor(n);return n-t<.5?Math.floor(n):n-t>.5?Math.ceil(n):t%2===0?t:t+1}),kN={kernelName:Lr,backendName:"cpu",kernelFunc:CN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SN(n){const{inputs:t,backend:e,attrs:s}=n,{indices:i,updates:o}=t,{shape:r}=s,{sliceRank:a,numUpdates:u,sliceSize:l,strides:c,outputSize:h}=Di(o,i,r),p=!0,f=e.bufferSync(i),m=e.bufferSync(o),g=ii(f,m,r,h,l,u,a,c,0,p);return e.makeTensorInfo(r,g.dtype,g.values)}const IN={kernelName:Ef,backendName:"cpu",kernelFunc:SN};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NN(n,t){let e=0,s=n.length,i=0;for(;e<s;)i=Math.floor((e+s)/2),n[i]<t?e=i+1:s=i;return s}function $N(n,t){let e=0,s=n.length,i=0;for(;e<s;)i=Math.floor((e+s)/2),n[i]<=t?e=i+1:s=i;return s}function DN(n,t,e,s,i,o){const r=Jr("int32",e*i);for(let a=0;a<e;++a){const u=n.slice(a*s,(a+1)*s),l=a*i;for(let c=0;c<i;++c)r[l+c]=o==="left"?NN(u,t[c+l]):$N(u,t[c+l])}return r}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RN(n){const{inputs:t,backend:e,attrs:s}=n,{sortedSequence:i,values:o}=t,{side:r}=s,a=e.data.get(i.dataId).values,u=e.data.get(o.dataId).values,l=DN(a,u,i.shape[0],i.shape[1],o.shape[1],r);return e.makeTensorInfo(o.shape,"int32",l)}const AN={kernelName:Lf,backendName:"cpu",kernelFunc:RN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TN(n){const{inputs:t,backend:e}=n,{condition:s,t:i,e:o}=t;yt([s,i,o],"select");const r=s.shape.length,a=e.data.get(s.dataId).values,u=e.data.get(i.dataId).values,l=e.data.get(o.dataId).values,c=es(i.dtype,o.dtype),h=ss(et(i.shape),c);let p=0;const f=r===0||r>1||i.shape.length===1?1:et(i.shape.slice(1));for(let m=0;m<a.length;m++)for(let g=0;g<f;g++)a[m]===1?h[p++]=u[m]:h[p++]=l[m];return e.makeTensorInfo(i.shape,c,h)}const zN={kernelName:cl,backendName:"cpu",kernelFunc:TN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FN=hl,MN=dl,PN=Qt(Or,n=>n>=0?MN*n:FN*(Math.exp(n)-1)),EN={kernelName:Or,backendName:"cpu",kernelFunc:PN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LN=Qt(_r,n=>n<0?-1:n>0?1:0),ON={kernelName:_r,backendName:"cpu",kernelFunc:LN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _N=Qt(Br,n=>Math.sin(n)),BN={kernelName:Br,backendName:"cpu",kernelFunc:_N};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WN=Qt(Wr,n=>Math.sinh(n)),VN={kernelName:Wr,backendName:"cpu",kernelFunc:WN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UN=11920928955078125e-23,zh=Math.log(UN)+2,GN=Qt(Vr,n=>{const t=n>-zh,e=n<zh,s=Math.exp(n);let i;return e?i=s:t?i=n:i=Math.log(1+s),i}),HN={kernelName:Vr,backendName:"cpu",kernelFunc:GN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jN(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{blockShape:o,paddings:r}=s;yt([i],"spaceToBatchND");const a=et(o),u=[[0,0]];u.push(...r);for(let N=1+o.length;N<i.shape.length;++N)u.push([0,0]);const l=Ty.kernelFunc({inputs:{x:i},backend:e,attrs:{paddings:u,constantValue:0}}),c=Yr(l.shape,o,a,!1),h=Zr(c.length,o.length,!1),p=Qr(l.shape,o,a,!1),g=te({inputs:{x:l},backend:e,attrs:{shape:c}}),w=Ze({inputs:{x:g},backend:e,attrs:{perm:h}}),I=te({inputs:{x:w},backend:e,attrs:{shape:p}});return e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(w),I}const KN={kernelName:ml,backendName:"cpu",kernelFunc:jN};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XN(n){const{inputs:t,backend:e}=n,{indices:s,values:i,denseShape:o,defaultValue:r}=t;if(o.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${o.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${s.shape}`);if(i.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${i.shape}`);if(r.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${r.shape}`);const a=e.data.get(s.dataId).values,u=e.data.get(i.dataId).values,l=e.data.get(o.dataId).values,c=e.data.get(r.dataId).values[0],[h,p,f,m,g]=w0(a,s.shape,s.dtype,u,i.dtype,l,c);return[e.makeTensorInfo(p,s.dtype,h),e.makeTensorInfo([p[0]],i.dtype,f),e.makeTensorInfo([m.length],"bool",new Uint8Array(m.map(b=>Number(b)))),e.makeTensorInfo([g.length],s.dtype,new Int32Array(g))]}const qN={kernelName:x0,backendName:"cpu",kernelFunc:XN};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YN(n){const{inputs:t,backend:e}=n,{inputIndices:s,inputShape:i,newShape:o}=t;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${s.shape}`);if(i.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${i.shape}`);if(o.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);const r=Array.from(e.data.get(i.dataId).values),a=e.data.get(s.dataId).values,u=Array.from(e.data.get(o.dataId).values),[l,c,h]=C0(a,s.shape,s.dtype,r,u);return[e.makeTensorInfo(c,s.dtype,l),e.makeTensorInfo([h.length],o.dtype,new Int32Array(h))]}const ZN={kernelName:v0,backendName:"cpu",kernelFunc:YN};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QN(n){const{inputs:t,backend:e}=n,{data:s,indices:i,segmentIds:o}=t;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${i.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${o.shape}`);if(i.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const r=e.data.get(s.dataId).values,a=e.data.get(i.dataId).values,u=e.data.get(o.dataId).values,[l,c]=_f(r,s.shape,s.dtype,a,u,!0);return e.makeTensorInfo(c,s.dtype,l)}const JN={kernelName:Of,backendName:"cpu",kernelFunc:QN};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t$(n){const{inputs:t,backend:e}=n,{data:s,indices:i,segmentIds:o}=t;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${i.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${o.shape}`);if(i.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const r=e.data.get(s.dataId).values,a=e.data.get(i.dataId).values,u=e.data.get(o.dataId).values,[l,c]=_f(r,s.shape,s.dtype,a,u);return e.makeTensorInfo(c,s.dtype,l)}const e$={kernelName:Bf,backendName:"cpu",kernelFunc:t$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n$(n){const{inputs:t,backend:e,attrs:s}=n,{sparseIndices:i,sparseValues:o,defaultValue:r}=t,{outputShape:a}=s,{sliceRank:u,numUpdates:l,sliceSize:c,strides:h,outputSize:p}=Di(o,i,a),f=!1,m=e.bufferSync(i);let g;switch(o.dtype){case"bool":{const b=e.bufferSync(o),v=!!e.data.get(r.dataId).values[0];g=ii(m,b,a,p,c,l,u,h,v,f);break}case"float32":{const b=e.bufferSync(o),v=e.data.get(r.dataId).values[0];g=ii(m,b,a,p,c,l,u,h,v,f);break}case"int32":{const b=e.bufferSync(o),v=e.data.get(r.dataId).values[0];g=ii(m,b,a,p,c,l,u,h,v,f);break}case"string":{const b=e.bufferSync(o),v=ho(e.data.get(r.dataId).values[0]);g=ii(m,b,a,p,c,l,u,h,v,f);break}default:throw new Error(`Unsupported type ${o.dtype}`)}return e.makeTensorInfo(a,g.dtype,g.values)}const s$={kernelName:Wf,backendName:"cpu",kernelFunc:n$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i$(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{numOrSizeSplits:o,axis:r}=s,a=ee(r,i.shape)[0],u=Vf(i,o,a),l=new Array(i.shape.length).fill(0),c=i.shape.slice();return u.map(h=>{const p=[...c];p[a]=h;const f=pi({inputs:{x:i},backend:e,attrs:{begin:l,size:p}});return l[a]+=h,f})}const o$={kernelName:gl,backendName:"cpu",kernelFunc:i$};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r$={kernelName:yl,backendName:"cpu",kernelFunc:({inputs:n,backend:t})=>{const{x:e}=n,s=t;yt(e,"square");const i=s.data.get(e.dataId).values,o=new Float32Array(i.length);for(let a=0;a<i.length;++a){const u=i[a];o[a]=u*u}return{dataId:s.write(o,e.shape,e.dtype),shape:e.shape,dtype:e.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a$=Qt(Ur,(n,t)=>{const e=t;return isNaN(n)?NaN:n>0?1:e.alpha}),u$={kernelName:Ur,backendName:"cpu",kernelFunc:a$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l$(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{begin:o,end:r,strides:a,beginMask:u,endMask:l,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:p}=s;yt(i,"stridedSlice");const{finalShapeSparse:f,finalShape:m,isIdentity:g,sliceDim0:b,isSimpleSlice:v,begin:w,end:k,strides:C}=Gf(i.shape,o,r,a,u,l,c,h,p);let I;if(g)I=te({inputs:{x:i},backend:e,attrs:{shape:m}});else if(b||v){tt(i.shape.length>=1,()=>`Input must have rank at least 1, got: ${i.shape.length}`);const N=Hf(w,k,C),$=pi({inputs:{x:i},backend:e,attrs:{begin:w,size:N}});I=te({inputs:{x:$},backend:e,attrs:{shape:m}}),e.disposeIntermediateTensorInfo($)}else{const N=e.bufferSync(i),$=k0(f,N,C,w);I=e.makeTensorInfo(m,$.dtype,$.values)}return I}const c$={kernelName:Uf,backendName:"cpu",kernelFunc:l$};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h$(n){const{inputs:t,backend:e,attrs:s}=n,{separator:i,nGramWidths:o,leftPad:r,rightPad:a,padWidth:u,preserveShortSequences:l}=s,{data:c,dataSplits:h}=t,p=e.data.get(c.dataId).values,f=e.data.get(h.dataId).values,[m,g]=S0(p,f,i,o,r,a,u,l);return[e.makeTensorInfo([m.length],"string",m),e.makeTensorInfo(h.shape,"int32",g)]}const d$={kernelName:jf,backendName:"cpu",kernelFunc:h$};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p$(n){const{inputs:t,backend:e,attrs:s}=n,{skipEmpty:i}=s,{input:o,delimiter:r}=t;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(o.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(r.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${r.shape}`);const a=e.data.get(o.dataId).values,u=e.data.get(r.dataId).values[0],[l,c,h]=N0(a,u,i),p=c.length;return[e.makeTensorInfo([p,2],"int32",l),e.makeTensorInfo([p],"string",c),e.makeTensorInfo([2],"int32",new Int32Array(h))]}const f$={kernelName:I0,backendName:"cpu",kernelFunc:p$};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m$(n){const{inputs:t,backend:e,attrs:s}=n,{numBuckets:i}=s,{input:o}=t;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(i<=0)throw new Error("Number of buckets must be at least 1");const r=e.data.get(o.dataId).values,a=D0(r,i);return e.makeTensorInfo(o.shape,"int32",a)}const g$={kernelName:$0,backendName:"cpu",kernelFunc:m$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const y$=Qt(Gr,n=>Math.tan(n)),b$={kernelName:Gr,backendName:"cpu",kernelFunc:y$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const x$=Qt(Hr,n=>Math.tanh(n)),w$={kernelName:Hr,backendName:"cpu",kernelFunc:x$};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v$(n){const{inputs:t,backend:e}=n,{tensor:s,indices:i,updates:o}=t,{sliceRank:r,numUpdates:a,sliceSize:u,strides:l,outputSize:c}=Di(o,i,s.shape),h=!1,p=e.bufferSync(i),f=e.bufferSync(o),m=e.bufferSync(s),g=ii(p,f,s.shape,c,u,a,r,l,m,h);return e.makeTensorInfo(s.shape,g.dtype,g.values)}const C$={kernelName:Kf,backendName:"cpu",kernelFunc:v$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k$(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{reps:o}=s;yt(i,"tile");const r=R0(e.bufferSync(i),o);return e.makeTensorInfo(r.shape,r.dtype,r.values)}const S$={kernelName:xl,backendName:"cpu",kernelFunc:k$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I$(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{k:o,sorted:r}=s;yt(i,"topk");const a=e.data.get(i.dataId).values,[u,l]=A0(a,i.shape,i.dtype,o,r);return[e.makeTensorInfo(u.shape,u.dtype,u.values),e.makeTensorInfo(l.shape,l.dtype,l.values)]}const N$={kernelName:Xf,backendName:"cpu",kernelFunc:I$};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $$(n){const{inputs:t,attrs:e,backend:s}=n,{image:i,transforms:o}=t,{interpolation:r,fillMode:a,fillValue:u,outputShape:l}=e,[c,h,p,f]=i.shape,[m,g]=l??[h,p],b=[c,m,g,f],v=Tt(i.shape),w=v[0],k=v[1],C=v[2],I=Tt(b),N=I[0],$=I[1],A=I[2],z=Ln(i.dtype,et(b));z.fill(u);const F=s.data.get(i.dataId).values,E=s.data.get(o.dataId).values;for(let L=0;L<c;++L){const W=o.shape[0]===1?E:E.subarray(L*8,L*8+8);for(let _=0;_<m;++_)for(let V=0;V<g;++V)for(let X=0;X<f;++X){let j;const K=W[6]*V+W[7]*_+1;if(K===0)continue;const Z=(W[0]*V+W[1]*_+W[2])/K,Y=(W[3]*V+W[4]*_+W[5])/K,it=Fh(Z,p,a),nt=Fh(Y,h,a);switch(r){case"nearest":j=F$(F,h,p,w,k,C,L,nt,it,X,u);break;case"bilinear":j=M$(F,h,p,w,k,C,L,nt,it,X,u);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${r}`)}const ut=L*N+_*$+V*A+X;z[ut]=j}return s.makeTensorInfo(b,i.dtype,z)}return{dataId:s.write(z,b,i.dtype),shape:i.shape,dtype:i.dtype}}const D$={kernelName:qf,backendName:"cpu",kernelFunc:$$};function Fh(n,t,e){switch(e){case"reflect":return R$(n,t);case"wrap":return A$(n,t);case"nearest":return z$(n,t);case"constant":default:return T$(n)}}function R$(n,t){let e=n;if(e<0)if(t<=1)e=0;else{const s=2*t;e<s&&(e=s*Math.trunc(-e/s)+e),e=e<-t?e+s:-e-1}else if(e>t-1)if(t<=1)e=0;else{const s=2*t;e-=s*Math.trunc(e/s),e>=t&&(e=s-e-1)}return Pl(0,e,t-1)}function A$(n,t){let e=n;if(e<0)if(t<=1)e=0;else{const s=t-1;e+=t*(Math.trunc(-e/s)+1)}else if(e>t-1)if(t<=1)e=0;else{const s=t-1;e-=t*Math.trunc(e/s)}return Pl(0,e,t-1)}function T$(n,t){return n}function z$(n,t){return Pl(0,n,t-1)}function ji(n,t,e,s,i,o,r,a,u,l,c){const h=r*s+a*i+u*o+l;return 0<=a&&a<t&&0<=u&&u<e?n[h]:c}function F$(n,t,e,s,i,o,r,a,u,l,c){const h=Math.round(a),p=Math.round(u);return ji(n,t,e,s,i,o,r,h,p,l,c)}function M$(n,t,e,s,i,o,r,a,u,l,c){const h=Math.floor(a),p=Math.floor(u),f=h+1,m=p+1,g=(m-u)*ji(n,t,e,s,i,o,r,h,p,l,c)+(u-p)*ji(n,t,e,s,i,o,r,h,m,l,c),b=(m-u)*ji(n,t,e,s,i,o,r,f,p,l,c)+(u-p)*ji(n,t,e,s,i,o,r,f,m,l,c);return(f-a)*g+(a-h)*b}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P$(n){const{inputs:t,attrs:e,backend:s}=n,{axis:i}=e,{x:o}=t;yt(o,"unique");const r=s.data.get(o.dataId).values,{outputValues:a,outputShape:u,indices:l}=z0(r,i,o.shape,o.dtype);return[s.makeTensorInfo(u,o.dtype,a),s.makeTensorInfo([l.length],"int32",l)]}const E$={kernelName:T0,backendName:"cpu",kernelFunc:P$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L$(n){const{inputs:t,backend:e,attrs:s}=n,{value:i}=t;let{axis:o}=s;o<0&&(o+=i.shape.length);const r=i.shape.length,a=i.shape[o],u=new Array(r-1);let l=0;for(let f=0;f<r;f++)f!==o&&(u[l++]=i.shape[f]);const c=new Array(r).fill(0),h=i.shape.slice();h[o]=1;const p=new Array(a);for(let f=0;f<p.length;f++){c[o]=f;const m=pi({inputs:{x:i},backend:e,attrs:{begin:c,size:h}});p[f]=te({inputs:{x:m},backend:e,attrs:{shape:u}}),e.disposeIntermediateTensorInfo(m)}return p}const O$={kernelName:wl,backendName:"cpu",kernelFunc:L$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _$(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,segmentIds:o}=t,{numSegments:r}=s;yt(i,"unsortedSegmentSum");const a=i.shape.length,u=o.shape.length,l=[],c=[],h=a-u;let p=o;for(let m=0;m<h;++m){const g=or({inputs:{input:p},backend:e,attrs:{dim:m+1}});p=g,c.push(g)}for(let m=0;m<r;++m){const g=df(m,"int32"),b=e.makeTensorInfo([],"int32",g),v=F0({inputs:{a:b,b:p},backend:e}),w=Al({inputs:{x:v},backend:e,attrs:{dtype:"float32"}}),k=Tl({inputs:{a:w,b:i},backend:e}),C=vo({inputs:{x:k},backend:e,attrs:{axis:0,keepDims:!1}});l.push(C),c.push(b),c.push(v),c.push(w),c.push(k),c.push(C)}const f=Ay({inputs:l,backend:e,attrs:{axis:0}});return c.forEach(m=>e.disposeIntermediateTensorInfo(m)),f}const B$={kernelName:vl,backendName:"cpu",kernelFunc:_$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const W$=[Pk,M0,Lk,_k,P0,Wk,Uk,Hk,Kk,qk,Zk,Jk,eS,iS,rS,lS,hS,pS,mS,Fk,yS,xS,vS,E0,kS,L0,O0,IS,_0,$S,RS,AS,zS,MS,ES,OS,BS,VS,GS,jS,XS,YS,QS,tI,eI,sI,oI,aI,uI,lI,cI,dI,mI,Nk,yI,B0,II,W0,NI,V0,zI,FI,PI,U0,G0,LI,_I,WI,UI,H0,j0,K0,HI,DS,KI,qI,ZI,$k,X0,q0,JI,Y0,e3,i3,r3,l3,h3,p3,f3,Z0,g3,b3,w3,C3,S3,N3,D3,Q0,A3,F3,E3,J0,t1,_3,V3,H3,e1,K3,q3,Y3,Ty,tN,Rk,n1,nN,iN,rN,uN,s1,lu,cN,Ak,Tk,zk,dN,fN,gN,bN,wN,vN,kN,i1,IN,AN,zN,EN,o1,ON,BN,VN,r1,M3,HN,KN,qN,ZN,JN,e$,s$,o$,a1,r$,u1,l1,u$,c$,d$,f$,g$,c1,pI,b$,w$,C$,S$,N$,D$,h1,E$,O$,B$,X3];for(const n of W$)Yf(n);var V$={};(function(){var n;function t(d){var y=0;return function(){return y<d.length?{done:!1,value:d[y++]}:{done:!0}}}var e=typeof Object.defineProperties=="function"?Object.defineProperty:function(d,y,x){return d==Array.prototype||d==Object.prototype||(d[y]=x.value),d};function s(d){d=[typeof globalThis=="object"&&globalThis,d,typeof window=="object"&&window,typeof self=="object"&&self,typeof Ma=="object"&&Ma];for(var y=0;y<d.length;++y){var x=d[y];if(x&&x.Math==Math)return x}throw Error("Cannot find global object")}var i=s(this);function o(d,y){if(y)t:{var x=i;d=d.split(".");for(var S=0;S<d.length-1;S++){var D=d[S];if(!(D in x))break t;x=x[D]}d=d[d.length-1],S=x[d],y=y(S),y!=S&&y!=null&&e(x,d,{configurable:!0,writable:!0,value:y})}}o("Symbol",function(d){function y(T){if(this instanceof y)throw new TypeError("Symbol is not a constructor");return new x(S+(T||"")+"_"+D++,T)}function x(T,R){this.h=T,e(this,"description",{configurable:!0,writable:!0,value:R})}if(d)return d;x.prototype.toString=function(){return this.h};var S="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",D=0;return y}),o("Symbol.iterator",function(d){if(d)return d;d=Symbol("Symbol.iterator");for(var y="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),x=0;x<y.length;x++){var S=i[y[x]];typeof S=="function"&&typeof S.prototype[d]!="function"&&e(S.prototype,d,{configurable:!0,writable:!0,value:function(){return r(t(this))}})}return d});function r(d){return d={next:d},d[Symbol.iterator]=function(){return this},d}function a(d){var y=typeof Symbol<"u"&&Symbol.iterator&&d[Symbol.iterator];return y?y.call(d):{next:t(d)}}function u(d){if(!(d instanceof Array)){d=a(d);for(var y,x=[];!(y=d.next()).done;)x.push(y.value);d=x}return d}var l=typeof Object.assign=="function"?Object.assign:function(d,y){for(var x=1;x<arguments.length;x++){var S=arguments[x];if(S)for(var D in S)Object.prototype.hasOwnProperty.call(S,D)&&(d[D]=S[D])}return d};o("Object.assign",function(d){return d||l});var c=typeof Object.create=="function"?Object.create:function(d){function y(){}return y.prototype=d,new y},h;if(typeof Object.setPrototypeOf=="function")h=Object.setPrototypeOf;else{var p;t:{var f={a:!0},m={};try{m.__proto__=f,p=m.a;break t}catch{}p=!1}h=p?function(d,y){if(d.__proto__=y,d.__proto__!==y)throw new TypeError(d+" is not extensible");return d}:null}var g=h;function b(d,y){if(d.prototype=c(y.prototype),d.prototype.constructor=d,g)g(d,y);else for(var x in y)if(x!="prototype")if(Object.defineProperties){var S=Object.getOwnPropertyDescriptor(y,x);S&&Object.defineProperty(d,x,S)}else d[x]=y[x];d.za=y.prototype}function v(){this.m=!1,this.j=null,this.i=void 0,this.h=1,this.v=this.s=0,this.l=null}function w(d){if(d.m)throw new TypeError("Generator is already running");d.m=!0}v.prototype.u=function(d){this.i=d};function k(d,y){d.l={ma:y,na:!0},d.h=d.s||d.v}v.prototype.return=function(d){this.l={return:d},this.h=this.v};function C(d,y,x){return d.h=x,{value:y}}function I(d){this.h=new v,this.i=d}function N(d,y){w(d.h);var x=d.h.j;return x?$(d,"return"in x?x.return:function(S){return{value:S,done:!0}},y,d.h.return):(d.h.return(y),A(d))}function $(d,y,x,S){try{var D=y.call(d.h.j,x);if(!(D instanceof Object))throw new TypeError("Iterator result "+D+" is not an object");if(!D.done)return d.h.m=!1,D;var T=D.value}catch(R){return d.h.j=null,k(d.h,R),A(d)}return d.h.j=null,S.call(d.h,T),A(d)}function A(d){for(;d.h.h;)try{var y=d.i(d.h);if(y)return d.h.m=!1,{value:y.value,done:!1}}catch(x){d.h.i=void 0,k(d.h,x)}if(d.h.m=!1,d.h.l){if(y=d.h.l,d.h.l=null,y.na)throw y.ma;return{value:y.return,done:!0}}return{value:void 0,done:!0}}function z(d){this.next=function(y){return w(d.h),d.h.j?y=$(d,d.h.j.next,y,d.h.u):(d.h.u(y),y=A(d)),y},this.throw=function(y){return w(d.h),d.h.j?y=$(d,d.h.j.throw,y,d.h.u):(k(d.h,y),y=A(d)),y},this.return=function(y){return N(d,y)},this[Symbol.iterator]=function(){return this}}function F(d){function y(S){return d.next(S)}function x(S){return d.throw(S)}return new Promise(function(S,D){function T(R){R.done?S(R.value):Promise.resolve(R.value).then(y,x).then(T,D)}T(d.next())})}function E(d){return F(new z(new I(d)))}o("Promise",function(d){function y(R){this.i=0,this.j=void 0,this.h=[],this.u=!1;var P=this.l();try{R(P.resolve,P.reject)}catch(G){P.reject(G)}}function x(){this.h=null}function S(R){return R instanceof y?R:new y(function(P){P(R)})}if(d)return d;x.prototype.i=function(R){if(this.h==null){this.h=[];var P=this;this.j(function(){P.m()})}this.h.push(R)};var D=i.setTimeout;x.prototype.j=function(R){D(R,0)},x.prototype.m=function(){for(;this.h&&this.h.length;){var R=this.h;this.h=[];for(var P=0;P<R.length;++P){var G=R[P];R[P]=null;try{G()}catch(J){this.l(J)}}}this.h=null},x.prototype.l=function(R){this.j(function(){throw R})},y.prototype.l=function(){function R(J){return function(lt){G||(G=!0,J.call(P,lt))}}var P=this,G=!1;return{resolve:R(this.I),reject:R(this.m)}},y.prototype.I=function(R){if(R===this)this.m(new TypeError("A Promise cannot resolve to itself"));else if(R instanceof y)this.L(R);else{t:switch(typeof R){case"object":var P=R!=null;break t;case"function":P=!0;break t;default:P=!1}P?this.F(R):this.s(R)}},y.prototype.F=function(R){var P=void 0;try{P=R.then}catch(G){this.m(G);return}typeof P=="function"?this.M(P,R):this.s(R)},y.prototype.m=function(R){this.v(2,R)},y.prototype.s=function(R){this.v(1,R)},y.prototype.v=function(R,P){if(this.i!=0)throw Error("Cannot settle("+R+", "+P+"): Promise already settled in state"+this.i);this.i=R,this.j=P,this.i===2&&this.K(),this.H()},y.prototype.K=function(){var R=this;D(function(){if(R.D()){var P=i.console;typeof P<"u"&&P.error(R.j)}},1)},y.prototype.D=function(){if(this.u)return!1;var R=i.CustomEvent,P=i.Event,G=i.dispatchEvent;return typeof G>"u"?!0:(typeof R=="function"?R=new R("unhandledrejection",{cancelable:!0}):typeof P=="function"?R=new P("unhandledrejection",{cancelable:!0}):(R=i.document.createEvent("CustomEvent"),R.initCustomEvent("unhandledrejection",!1,!0,R)),R.promise=this,R.reason=this.j,G(R))},y.prototype.H=function(){if(this.h!=null){for(var R=0;R<this.h.length;++R)T.i(this.h[R]);this.h=null}};var T=new x;return y.prototype.L=function(R){var P=this.l();R.T(P.resolve,P.reject)},y.prototype.M=function(R,P){var G=this.l();try{R.call(P,G.resolve,G.reject)}catch(J){G.reject(J)}},y.prototype.then=function(R,P){function G(bt,dt){return typeof bt=="function"?function(It){try{J(bt(It))}catch(Pt){lt(Pt)}}:dt}var J,lt,St=new y(function(bt,dt){J=bt,lt=dt});return this.T(G(R,J),G(P,lt)),St},y.prototype.catch=function(R){return this.then(void 0,R)},y.prototype.T=function(R,P){function G(){switch(J.i){case 1:R(J.j);break;case 2:P(J.j);break;default:throw Error("Unexpected state: "+J.i)}}var J=this;this.h==null?T.i(G):this.h.push(G),this.u=!0},y.resolve=S,y.reject=function(R){return new y(function(P,G){G(R)})},y.race=function(R){return new y(function(P,G){for(var J=a(R),lt=J.next();!lt.done;lt=J.next())S(lt.value).T(P,G)})},y.all=function(R){var P=a(R),G=P.next();return G.done?S([]):new y(function(J,lt){function St(It){return function(Pt){bt[It]=Pt,dt--,dt==0&&J(bt)}}var bt=[],dt=0;do bt.push(void 0),dt++,S(G.value).T(St(bt.length-1),lt),G=P.next();while(!G.done)})},y});function U(d,y){d instanceof String&&(d+="");var x=0,S=!1,D={next:function(){if(!S&&x<d.length){var T=x++;return{value:y(T,d[T]),done:!1}}return S=!0,{done:!0,value:void 0}}};return D[Symbol.iterator]=function(){return D},D}o("Array.prototype.keys",function(d){return d||function(){return U(this,function(y){return y})}}),o("Array.prototype.fill",function(d){return d||function(y,x,S){var D=this.length||0;for(0>x&&(x=Math.max(0,D+x)),(S==null||S>D)&&(S=D),S=Number(S),0>S&&(S=Math.max(0,D+S)),x=Number(x||0);x<S;x++)this[x]=y;return this}});function L(d){return d||Array.prototype.fill}o("Int8Array.prototype.fill",L),o("Uint8Array.prototype.fill",L),o("Uint8ClampedArray.prototype.fill",L),o("Int16Array.prototype.fill",L),o("Uint16Array.prototype.fill",L),o("Int32Array.prototype.fill",L),o("Uint32Array.prototype.fill",L),o("Float32Array.prototype.fill",L),o("Float64Array.prototype.fill",L),o("Object.is",function(d){return d||function(y,x){return y===x?y!==0||1/y===1/x:y!==y&&x!==x}}),o("Array.prototype.includes",function(d){return d||function(y,x){var S=this;S instanceof String&&(S=String(S));var D=S.length;for(x=x||0,0>x&&(x=Math.max(x+D,0));x<D;x++){var T=S[x];if(T===y||Object.is(T,y))return!0}return!1}}),o("String.prototype.includes",function(d){return d||function(y,x){if(this==null)throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");if(y instanceof RegExp)throw new TypeError("First argument to String.prototype.includes must not be a regular expression");return this.indexOf(y,x||0)!==-1}});var W=this||self;function _(d,y){d=d.split(".");var x=W;d[0]in x||typeof x.execScript>"u"||x.execScript("var "+d[0]);for(var S;d.length&&(S=d.shift());)d.length||y===void 0?x[S]&&x[S]!==Object.prototype[S]?x=x[S]:x=x[S]={}:x[S]=y}function V(d){var y;t:{if((y=W.navigator)&&(y=y.userAgent))break t;y=""}return y.indexOf(d)!=-1}var X=Array.prototype.map?function(d,y){return Array.prototype.map.call(d,y,void 0)}:function(d,y){for(var x=d.length,S=Array(x),D=typeof d=="string"?d.split(""):d,T=0;T<x;T++)T in D&&(S[T]=y.call(void 0,D[T],T,d));return S},j={},K=null;function Z(d){var y=d.length,x=3*y/4;x%3?x=Math.floor(x):"=.".indexOf(d[y-1])!=-1&&(x="=.".indexOf(d[y-2])!=-1?x-2:x-1);var S=new Uint8Array(x),D=0;return Y(d,function(T){S[D++]=T}),D!==x?S.subarray(0,D):S}function Y(d,y){function x(G){for(;S<d.length;){var J=d.charAt(S++),lt=K[J];if(lt!=null)return lt;if(!/^[\s\xa0]*$/.test(J))throw Error("Unknown base64 encoding at char: "+J)}return G}it();for(var S=0;;){var D=x(-1),T=x(0),R=x(64),P=x(64);if(P===64&&D===-1)break;y(D<<2|T>>4),R!=64&&(y(T<<4&240|R>>2),P!=64&&y(R<<6&192|P))}}function it(){if(!K){K={};for(var d="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""),y=["+/=","+/","-_=","-_.","-_"],x=0;5>x;x++){var S=d.concat(y[x].split(""));j[x]=S;for(var D=0;D<S.length;D++){var T=S[D];K[T]===void 0&&(K[T]=D)}}}}var nt=typeof Uint8Array<"u",ut=!(V("Trident")||V("MSIE"))&&typeof W.btoa=="function";function at(d){if(!ut){var y;y===void 0&&(y=0),it(),y=j[y];for(var x=Array(Math.floor(d.length/3)),S=y[64]||"",D=0,T=0;D<d.length-2;D+=3){var R=d[D],P=d[D+1],G=d[D+2],J=y[R>>2];R=y[(R&3)<<4|P>>4],P=y[(P&15)<<2|G>>6],G=y[G&63],x[T++]=J+R+P+G}switch(J=0,G=S,d.length-D){case 2:J=d[D+1],G=y[(J&15)<<2]||S;case 1:d=d[D],x[T]=y[d>>2]+y[(d&3)<<4|J>>4]+G+S}return x.join("")}for(y="";10240<d.length;)y+=String.fromCharCode.apply(null,d.subarray(0,10240)),d=d.subarray(10240);return y+=String.fromCharCode.apply(null,d),btoa(y)}var pt=RegExp("[-_.]","g");function gt(d){switch(d){case"-":return"+";case"_":return"/";case".":return"=";default:return""}}function wt(d){if(!ut)return Z(d);pt.test(d)&&(d=d.replace(pt,gt)),d=atob(d);for(var y=new Uint8Array(d.length),x=0;x<d.length;x++)y[x]=d.charCodeAt(x);return y}var xt;function Dt(){return xt||(xt=new Uint8Array(0))}var Nt={},Ut=typeof Uint8Array.prototype.slice=="function",$t=0,Mt=0;function jt(d){var y=0>d;d=Math.abs(d);var x=d>>>0;d=Math.floor((d-x)/4294967296),y&&(x=a(Jt(x,d)),y=x.next().value,d=x.next().value,x=y),$t=x>>>0,Mt=d>>>0}var Ht=typeof BigInt=="function";function Jt(d,y){return y=~y,d?d=~d+1:y+=1,[d,y]}function qt(d,y){this.i=d>>>0,this.h=y>>>0}function tn(d){if(!d)return fe||(fe=new qt(0,0));if(!/^-?\d+$/.test(d))return null;if(16>d.length)jt(Number(d));else if(Ht)d=BigInt(d),$t=Number(d&BigInt(4294967295))>>>0,Mt=Number(d>>BigInt(32)&BigInt(4294967295));else{var y=+(d[0]==="-");Mt=$t=0;for(var x=d.length,S=y,D=(x-y)%6+y;D<=x;S=D,D+=6)S=Number(d.slice(S,D)),Mt*=1e6,$t=1e6*$t+S,4294967296<=$t&&(Mt+=$t/4294967296|0,$t%=4294967296);y&&(y=a(Jt($t,Mt)),d=y.next().value,y=y.next().value,$t=d,Mt=y)}return new qt($t,Mt)}var fe;function hn(d,y){return Error("Invalid wire type: "+d+" (at position "+y+")")}function De(){return Error("Failed to read varint, encoding is invalid.")}function vn(d,y){return Error("Tried to read past the end of the data "+y+" > "+d)}function we(){throw Error("Invalid UTF8")}function en(d,y){return y=String.fromCharCode.apply(null,y),d==null?y:d+y}var qe=void 0,nn,Cn=typeof TextDecoder<"u",os,Fi=typeof TextEncoder<"u",Ys;function ko(d){if(d!==Nt)throw Error("illegal external caller")}function kn(d,y){if(ko(y),this.V=d,d!=null&&d.length===0)throw Error("ByteString should be constructed with non-empty values")}function Mi(){return Ys||(Ys=new kn(null,Nt))}function So(d){ko(Nt);var y=d.V;return y=y==null||nt&&y!=null&&y instanceof Uint8Array?y:typeof y=="string"?wt(y):null,y==null?y:d.V=y}function Ib(d){if(typeof d=="string")return{buffer:wt(d),C:!1};if(Array.isArray(d))return{buffer:new Uint8Array(d),C:!1};if(d.constructor===Uint8Array)return{buffer:d,C:!1};if(d.constructor===ArrayBuffer)return{buffer:new Uint8Array(d),C:!1};if(d.constructor===kn)return{buffer:So(d)||Dt(),C:!0};if(d instanceof Uint8Array)return{buffer:new Uint8Array(d.buffer,d.byteOffset,d.byteLength),C:!1};throw Error("Type not convertible to a Uint8Array, expected a Uint8Array, an ArrayBuffer, a base64 encoded string, a ByteString or an Array of numbers")}function pc(d,y){this.i=null,this.m=!1,this.h=this.j=this.l=0,ma(this,d,y)}function ma(d,y,x){x=x===void 0?{}:x,d.S=x.S===void 0?!1:x.S,y&&(y=Ib(y),d.i=y.buffer,d.m=y.C,d.l=0,d.j=d.i.length,d.h=d.l)}pc.prototype.reset=function(){this.h=this.l};function ks(d,y){if(d.h=y,y>d.j)throw vn(d.j,y)}function Pi(d){var y=d.i,x=d.h,S=y[x++],D=S&127;if(S&128&&(S=y[x++],D|=(S&127)<<7,S&128&&(S=y[x++],D|=(S&127)<<14,S&128&&(S=y[x++],D|=(S&127)<<21,S&128&&(S=y[x++],D|=S<<28,S&128&&y[x++]&128&&y[x++]&128&&y[x++]&128&&y[x++]&128&&y[x++]&128)))))throw De();return ks(d,x),D}function fc(d,y){if(0>y)throw Error("Tried to read a negative byte length: "+y);var x=d.h,S=x+y;if(S>d.j)throw vn(y,d.j-x);return d.h=S,x}var mc=[];function ga(){this.h=[]}ga.prototype.length=function(){return this.h.length},ga.prototype.end=function(){var d=this.h;return this.h=[],d};function gc(d,y,x){for(;0<x||127<y;)d.h.push(y&127|128),y=(y>>>7|x<<25)>>>0,x>>>=7;d.h.push(y)}function Ss(d,y){for(;127<y;)d.h.push(y&127|128),y>>>=7;d.h.push(y)}function ya(d,y){if(mc.length){var x=mc.pop();ma(x,d,y),d=x}else d=new pc(d,y);this.h=d,this.j=this.h.h,this.i=this.l=-1,this.setOptions(y)}ya.prototype.setOptions=function(d){d=d===void 0?{}:d,this.ca=d.ca===void 0?!1:d.ca},ya.prototype.reset=function(){this.h.reset(),this.j=this.h.h,this.i=this.l=-1};function yc(d){var y=d.h;if(y.h==y.j)return!1;d.j=d.h.h;var x=Pi(d.h)>>>0;if(y=x>>>3,x&=7,!(0<=x&&5>=x))throw hn(x,d.j);if(1>y)throw Error("Invalid field number: "+y+" (at position "+d.j+")");return d.l=y,d.i=x,!0}function Io(d){switch(d.i){case 0:if(d.i!=0)Io(d);else t:{d=d.h;for(var y=d.h,x=y+10,S=d.i;y<x;)if(!(S[y++]&128)){ks(d,y);break t}throw De()}break;case 1:d=d.h,ks(d,d.h+8);break;case 2:d.i!=2?Io(d):(y=Pi(d.h)>>>0,d=d.h,ks(d,d.h+y));break;case 5:d=d.h,ks(d,d.h+4);break;case 3:y=d.l;do{if(!yc(d))throw Error("Unmatched start-group tag: stream EOF");if(d.i==4){if(d.l!=y)throw Error("Unmatched end-group tag");break}Io(d)}while(!0);break;default:throw hn(d.i,d.j)}}var No=[];function Nb(){this.j=[],this.i=0,this.h=new ga}function Zs(d,y){y.length!==0&&(d.j.push(y),d.i+=y.length)}function $b(d,y){if(y=y.R){Zs(d,d.h.end());for(var x=0;x<y.length;x++)Zs(d,So(y[x])||Dt())}}var Gn=typeof Symbol=="function"&&typeof Symbol()=="symbol"?Symbol():void 0;function Is(d,y){return Gn?d[Gn]|=y:d.A!==void 0?d.A|=y:(Object.defineProperties(d,{A:{value:y,configurable:!0,writable:!0,enumerable:!1}}),y)}function bc(d,y){Gn?d[Gn]&&(d[Gn]&=~y):d.A!==void 0&&(d.A&=~y)}function me(d){var y;return Gn?y=d[Gn]:y=d.A,y??0}function Sn(d,y){Gn?d[Gn]=y:d.A!==void 0?d.A=y:Object.defineProperties(d,{A:{value:y,configurable:!0,writable:!0,enumerable:!1}})}function ba(d){return Is(d,1),d}function Db(d,y){Sn(y,(d|0)&-51)}function $o(d,y){Sn(y,(d|18)&-41)}var xa={};function Do(d){return d!==null&&typeof d=="object"&&!Array.isArray(d)&&d.constructor===Object}var Ei,xc=[];Sn(xc,23),Ei=Object.freeze(xc);function wa(d){if(me(d.o)&2)throw Error("Cannot mutate an immutable Message")}function va(d){var y=d.length;(y=y?d[y-1]:void 0)&&Do(y)?y.g=1:(y={},d.push((y.g=1,y)))}function wc(d){var y=d.i+d.G;return d.B||(d.B=d.o[y]={})}function dn(d,y){return y===-1?null:y>=d.i?d.B?d.B[y]:void 0:d.o[y+d.G]}function In(d,y,x,S){wa(d),Li(d,y,x,S)}function Li(d,y,x,S){d.j&&(d.j=void 0),y>=d.i||S?wc(d)[y]=x:(d.o[y+d.G]=x,(d=d.B)&&y in d&&delete d[y])}function Ca(d,y,x,S){var D=dn(d,y);Array.isArray(D)||(D=Ei);var T=me(D);if(T&1||ba(D),S)T&2||Is(D,2),x&1||Object.freeze(D);else{S=!(x&2);var R=T&2;x&1||!R?S&&T&16&&!R&&bc(D,16):(D=ba(Array.prototype.slice.call(D)),Li(d,y,D))}return D}function ka(d,y){var x=dn(d,y),S=x==null?x:typeof x=="number"||x==="NaN"||x==="Infinity"||x==="-Infinity"?Number(x):void 0;return S!=null&&S!==x&&Li(d,y,S),S}function vc(d,y,x,S,D){d.h||(d.h={});var T=d.h[x],R=Ca(d,x,3,D);if(!T){var P=R;T=[];var G=!!(me(d.o)&16);R=!!(me(P)&2);var J=P;!D&&R&&(P=Array.prototype.slice.call(P));for(var lt=R,St=0;St<P.length;St++){var bt=P[St],dt=y,It=!1;if(It=It===void 0?!1:It,bt=Array.isArray(bt)?new dt(bt):It?new dt:void 0,bt!==void 0){dt=bt.o;var Pt=It=me(dt);R&&(Pt|=2),G&&(Pt|=16),Pt!=It&&Sn(dt,Pt),dt=Pt,lt=lt||!!(2&dt),T.push(bt)}}return d.h[x]=T,G=me(P),y=G|33,y=lt?y&-9:y|8,G!=y&&(lt=P,Object.isFrozen(lt)&&(lt=Array.prototype.slice.call(lt)),Sn(lt,y),P=lt),J!==P&&Li(d,x,P),(D||S&&R)&&Is(T,2),S&&Object.freeze(T),T}return D||(D=Object.isFrozen(T),S&&!D?Object.freeze(T):!S&&D&&(T=Array.prototype.slice.call(T),d.h[x]=T)),T}function Sa(d,y,x){var S=!!(me(d.o)&2);if(y=vc(d,y,x,S,S),d=Ca(d,x,3,S),!(S||me(d)&8)){for(S=0;S<y.length;S++){if(x=y[S],me(x.o)&2){var D=$c(x,!1);D.j=x}else D=x;x!==D&&(y[S]=D,d[S]=D.o)}Is(d,8)}return y}function Nn(d,y,x){if(x!=null&&typeof x!="number")throw Error("Value of float/double field must be a number|null|undefined, found "+typeof x+": "+x);In(d,y,x)}function Cc(d,y,x,S,D){wa(d);var T=vc(d,x,y,!1,!1);return x=S??new x,d=Ca(d,y,2,!1),D!=null?(T.splice(D,0,x),d.splice(D,0,x.o)):(T.push(x),d.push(x.o)),x.C()&&bc(d,8),x}function Ro(d,y){return d??y}function $n(d,y,x){return x=x===void 0?0:x,Ro(ka(d,y),x)}var Ao;function Rb(d){switch(typeof d){case"number":return isFinite(d)?d:String(d);case"object":if(d)if(Array.isArray(d)){if(me(d)&128)return d=Array.prototype.slice.call(d),va(d),d}else{if(nt&&d!=null&&d instanceof Uint8Array)return at(d);if(d instanceof kn){var y=d.V;return y==null?"":typeof y=="string"?y:d.V=at(y)}}}return d}function kc(d,y,x,S){if(d!=null){if(Array.isArray(d))d=Ia(d,y,x,S!==void 0);else if(Do(d)){var D={},T;for(T in d)D[T]=kc(d[T],y,x,S);d=D}else d=y(d,S);return d}}function Ia(d,y,x,S){var D=me(d);S=S?!!(D&16):void 0,d=Array.prototype.slice.call(d);for(var T=0;T<d.length;T++)d[T]=kc(d[T],y,x,S);return x(D,d),d}function Ab(d){return d.ja===xa?d.toJSON():Rb(d)}function Tb(d,y){d&128&&va(y)}function Sc(d,y,x){if(x=x===void 0?$o:x,d!=null){if(nt&&d instanceof Uint8Array)return d.length?new kn(new Uint8Array(d),Nt):Mi();if(Array.isArray(d)){var S=me(d);return S&2?d:y&&!(S&32)&&(S&16||S===0)?(Sn(d,S|2),d):(d=Ia(d,Sc,S&4?$o:x,!0),y=me(d),y&4&&y&2&&Object.freeze(d),d)}return d.ja===xa?Nc(d):d}}function Ic(d,y,x,S,D,T,R){if(d=d.h&&d.h[x]){if(S=me(d),S&2?S=d:(T=X(d,Nc),$o(S,T),Object.freeze(T),S=T),wa(y),R=S==null?Ei:ba([]),S!=null){for(T=!!S.length,d=0;d<S.length;d++){var P=S[d];T=T&&!(me(P.o)&2),R[d]=P.o}T=(T?8:0)|1,d=me(R),(d&T)!==T&&(Object.isFrozen(R)&&(R=Array.prototype.slice.call(R)),Sn(R,d|T)),y.h||(y.h={}),y.h[x]=S}else y.h&&(y.h[x]=void 0);Li(y,x,R,D)}else In(y,x,Sc(S,T,R),D)}function Nc(d){return me(d.o)&2||(d=$c(d,!0),Is(d.o,2)),d}function $c(d,y){var x=d.o,S=[];Is(S,16);var D=d.constructor.h;if(D&&S.push(D),D=d.B,D){S.length=x.length,S.fill(void 0,S.length,x.length);var T={};S[S.length-1]=T}me(x)&128&&va(S),y=y||d.C()?$o:Db,T=d.constructor,Ao=S,S=new T(S),Ao=void 0,d.R&&(S.R=d.R.slice()),T=!!(me(x)&16);for(var R=D?x.length-1:x.length,P=0;P<R;P++)Ic(d,S,P-d.G,x[P],!1,T,y);if(D)for(var G in D)Ic(d,S,+G,D[G],!0,T,y);return S}function Be(d,y,x){d==null&&(d=Ao),Ao=void 0;var S=this.constructor.i||0,D=0<S,T=this.constructor.h,R=!1;if(d==null){d=T?[T]:[];var P=48,G=!0;D&&(S=0,P|=128),Sn(d,P)}else{if(!Array.isArray(d)||T&&T!==d[0])throw Error();var J=P=Is(d,0);if((G=(16&J)!==0)&&((R=(32&J)!==0)||(J|=32)),D){if(128&J)S=0;else if(0<d.length){var lt=d[d.length-1];if(Do(lt)&&"g"in lt){S=0,J|=128,delete lt.g;var St=!0,bt;for(bt in lt){St=!1;break}St&&d.pop()}}}else if(128&J)throw Error();P!==J&&Sn(d,J)}this.G=(T?0:-1)-S,this.h=void 0,this.o=d;t:{if(T=this.o.length,S=T-1,T&&(T=this.o[S],Do(T))){this.B=T,this.i=S-this.G;break t}y!==void 0&&-1<y?(this.i=Math.max(y,S+1-this.G),this.B=void 0):this.i=Number.MAX_VALUE}if(!D&&this.B&&"g"in this.B)throw Error('Unexpected "g" flag in sparse object of message that is not a group type.');if(x){y=G&&!R&&!0,D=this.i;var dt;for(G=0;G<x.length;G++)R=x[G],R<D?(R+=this.G,(S=d[R])?Dc(S,y):d[R]=Ei):(dt||(dt=wc(this)),(S=dt[R])?Dc(S,y):dt[R]=Ei)}}Be.prototype.toJSON=function(){return Ia(this.o,Ab,Tb)},Be.prototype.C=function(){return!!(me(this.o)&2)};function Dc(d,y){if(Array.isArray(d)){var x=me(d),S=1;!y||x&2||(S|=16),(x&S)!==S&&Sn(d,x|S)}}Be.prototype.ja=xa,Be.prototype.toString=function(){return this.o.toString()};function Rc(d,y,x){if(x){var S={},D;for(D in x){var T=x[D],R=T.ra;R||(S.J=T.xa||T.oa.W,T.ia?(S.aa=Mc(T.ia),R=function(P){return function(G,J,lt){return P.J(G,J,lt,P.aa)}}(S)):T.ka?(S.Z=Pc(T.da.P,T.ka),R=function(P){return function(G,J,lt){return P.J(G,J,lt,P.Z)}}(S)):R=S.J,T.ra=R),R(y,d,T.da),S={J:S.J,aa:S.aa,Z:S.Z}}}$b(y,d)}var To=Symbol();function Ac(d,y,x){return d[To]||(d[To]=function(S,D){return y(S,D,x)})}function Tc(d){var y=d[To];if(!y){var x=$a(d);y=function(S,D){return Ec(S,D,x)},d[To]=y}return y}function zb(d){var y=d.ia;if(y)return Tc(y);if(y=d.wa)return Ac(d.da.P,y,d.ka)}function Fb(d){var y=zb(d),x=d.da,S=d.oa.U;return y?function(D,T){return S(D,T,x,y)}:function(D,T){return S(D,T,x)}}function zc(d,y){var x=d[y];return typeof x=="function"&&x.length===0&&(x=x(),d[y]=x),Array.isArray(x)&&(_i in x||Oi in x||0<x.length&&typeof x[0]=="function")?x:void 0}function Fc(d,y,x,S,D,T){y.P=d[0];var R=1;if(d.length>R&&typeof d[R]!="number"){var P=d[R++];x(y,P)}for(;R<d.length;){x=d[R++];for(var G=R+1;G<d.length&&typeof d[G]!="number";)G++;switch(P=d[R++],G-=R,G){case 0:S(y,x,P);break;case 1:(G=zc(d,R))?(R++,D(y,x,P,G)):S(y,x,P,d[R++]);break;case 2:G=R++,G=zc(d,G),D(y,x,P,G,d[R++]);break;case 3:T(y,x,P,d[R++],d[R++],d[R++]);break;case 4:T(y,x,P,d[R++],d[R++],d[R++],d[R++]);break;default:throw Error("unexpected number of binary field arguments: "+G)}}return y}var zo=Symbol();function Mc(d){var y=d[zo];if(!y){var x=Na(d);y=function(S,D){return Lc(S,D,x)},d[zo]=y}return y}function Pc(d,y){var x=d[zo];return x||(x=function(S,D){return Rc(S,D,y)},d[zo]=x),x}var Oi=Symbol();function Mb(d,y){d.push(y)}function Pb(d,y,x){d.push(y,x.W)}function Eb(d,y,x,S){var D=Mc(S),T=Na(S).P,R=x.W;d.push(y,function(P,G,J){return R(P,G,J,T,D)})}function Lb(d,y,x,S,D,T){var R=Pc(S,T),P=x.W;d.push(y,function(G,J,lt){return P(G,J,lt,S,R)})}function Na(d){var y=d[Oi];return y||(y=Fc(d,d[Oi]=[],Mb,Pb,Eb,Lb),_i in d&&Oi in d&&(d.length=0),y)}var _i=Symbol();function Ob(d,y){d[0]=y}function _b(d,y,x,S){var D=x.U;d[y]=S?function(T,R,P){return D(T,R,P,S)}:D}function Bb(d,y,x,S,D){var T=x.U,R=Tc(S),P=$a(S).P;d[y]=function(G,J,lt){return T(G,J,lt,P,R,D)}}function Wb(d,y,x,S,D,T,R){var P=x.U,G=Ac(S,D,T);d[y]=function(J,lt,St){return P(J,lt,St,S,G,R)}}function $a(d){var y=d[_i];return y||(y=Fc(d,d[_i]={},Ob,_b,Bb,Wb),_i in d&&Oi in d&&(d.length=0),y)}function Ec(d,y,x){for(;yc(y)&&y.i!=4;){var S=y.l,D=x[S];if(!D){var T=x[0];T&&(T=T[S])&&(D=x[S]=Fb(T))}if(!D||!D(y,d,S)){D=y,S=d,T=D.j,Io(D);var R=D;if(!R.ca){if(D=R.h.h-T,R.h.h=T,R=R.h,D==0)D=Mi();else{if(T=fc(R,D),R.S&&R.m)D=R.i.subarray(T,T+D);else{R=R.i;var P=T;D=T+D,D=P===D?Dt():Ut?R.slice(P,D):new Uint8Array(R.subarray(P,D))}D=D.length==0?Mi():new kn(D,Nt)}(T=S.R)?T.push(D):S.R=[D]}}}return d}function Lc(d,y,x){for(var S=x.length,D=S%2==1,T=D?1:0;T<S;T+=2)(0,x[T+1])(y,d,x[T]);Rc(d,y,D?x[0]:void 0)}function Bi(d,y){return{U:d,W:y}}var pn=Bi(function(d,y,x){if(d.i!==5)return!1;d=d.h;var S=d.i,D=d.h,T=S[D],R=S[D+1],P=S[D+2];return S=S[D+3],ks(d,d.h+4),R=(T<<0|R<<8|P<<16|S<<24)>>>0,d=2*(R>>31)+1,T=R>>>23&255,R&=8388607,In(y,x,T==255?R?NaN:1/0*d:T==0?d*Math.pow(2,-149)*R:d*Math.pow(2,T-150)*(R+Math.pow(2,23))),!0},function(d,y,x){if(y=ka(y,x),y!=null){Ss(d.h,8*x+5),d=d.h;var S=+y;S===0?0<1/S?$t=Mt=0:(Mt=0,$t=2147483648):isNaN(S)?(Mt=0,$t=2147483647):(S=(x=0>S?-2147483648:0)?-S:S,34028234663852886e22<S?(Mt=0,$t=(x|2139095040)>>>0):11754943508222875e-54>S?(S=Math.round(S/Math.pow(2,-149)),Mt=0,$t=(x|S)>>>0):(y=Math.floor(Math.log(S)/Math.LN2),S*=Math.pow(2,-y),S=Math.round(8388608*S),16777216<=S&&++y,Mt=0,$t=(x|y+127<<23|S&8388607)>>>0)),x=$t,d.h.push(x>>>0&255),d.h.push(x>>>8&255),d.h.push(x>>>16&255),d.h.push(x>>>24&255)}}),Vb=Bi(function(d,y,x){if(d.i!==0)return!1;var S=d.h,D=0,T=d=0,R=S.i,P=S.h;do{var G=R[P++];D|=(G&127)<<T,T+=7}while(32>T&&G&128);for(32<T&&(d|=(G&127)>>4),T=3;32>T&&G&128;T+=7)G=R[P++],d|=(G&127)<<T;if(ks(S,P),128>G)S=D>>>0,G=d>>>0,(d=G&2147483648)&&(S=~S+1>>>0,G=~G>>>0,S==0&&(G=G+1>>>0)),S=4294967296*G+(S>>>0);else throw De();return In(y,x,d?-S:S),!0},function(d,y,x){y=dn(y,x),y!=null&&(typeof y=="string"&&tn(y),y!=null&&(Ss(d.h,8*x),typeof y=="number"?(d=d.h,jt(y),gc(d,$t,Mt)):(x=tn(y),gc(d.h,x.i,x.h))))}),Ub=Bi(function(d,y,x){return d.i!==0?!1:(In(y,x,Pi(d.h)),!0)},function(d,y,x){if(y=dn(y,x),y!=null&&y!=null)if(Ss(d.h,8*x),d=d.h,x=y,0<=x)Ss(d,x);else{for(y=0;9>y;y++)d.h.push(x&127|128),x>>=7;d.h.push(1)}}),Oc=Bi(function(d,y,x){if(d.i!==2)return!1;var S=Pi(d.h)>>>0;d=d.h;var D=fc(d,S);if(d=d.i,Cn){var T=d,R;(R=nn)||(R=nn=new TextDecoder("utf-8",{fatal:!0})),d=D+S,T=D===0&&d===T.length?T:T.subarray(D,d);try{var P=R.decode(T)}catch(St){if(qe===void 0){try{R.decode(new Uint8Array([128]))}catch{}try{R.decode(new Uint8Array([97])),qe=!0}catch{qe=!1}}throw!qe&&(nn=void 0),St}}else{P=D,S=P+S,D=[];for(var G=null,J,lt;P<S;)J=d[P++],128>J?D.push(J):224>J?P>=S?we():(lt=d[P++],194>J||(lt&192)!==128?(P--,we()):D.push((J&31)<<6|lt&63)):240>J?P>=S-1?we():(lt=d[P++],(lt&192)!==128||J===224&&160>lt||J===237&&160<=lt||((T=d[P++])&192)!==128?(P--,we()):D.push((J&15)<<12|(lt&63)<<6|T&63)):244>=J?P>=S-2?we():(lt=d[P++],(lt&192)!==128||(J<<28)+(lt-144)>>30||((T=d[P++])&192)!==128||((R=d[P++])&192)!==128?(P--,we()):(J=(J&7)<<18|(lt&63)<<12|(T&63)<<6|R&63,J-=65536,D.push((J>>10&1023)+55296,(J&1023)+56320))):we(),8192<=D.length&&(G=en(G,D),D.length=0);P=en(G,D)}return In(y,x,P),!0},function(d,y,x){if(y=dn(y,x),y!=null){var S=!1;if(S=S===void 0?!1:S,Fi){if(S&&/(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])/.test(y))throw Error("Found an unpaired surrogate");y=(os||(os=new TextEncoder)).encode(y)}else{for(var D=0,T=new Uint8Array(3*y.length),R=0;R<y.length;R++){var P=y.charCodeAt(R);if(128>P)T[D++]=P;else{if(2048>P)T[D++]=P>>6|192;else{if(55296<=P&&57343>=P){if(56319>=P&&R<y.length){var G=y.charCodeAt(++R);if(56320<=G&&57343>=G){P=1024*(P-55296)+G-56320+65536,T[D++]=P>>18|240,T[D++]=P>>12&63|128,T[D++]=P>>6&63|128,T[D++]=P&63|128;continue}else R--}if(S)throw Error("Found an unpaired surrogate");P=65533}T[D++]=P>>12|224,T[D++]=P>>6&63|128}T[D++]=P&63|128}}y=D===T.length?T:T.subarray(0,D)}Ss(d.h,8*x+2),Ss(d.h,y.length),Zs(d,d.h.end()),Zs(d,y)}}),_c=Bi(function(d,y,x,S,D){if(d.i!==2)return!1;y=Cc(y,x,S),x=d.h.j,S=Pi(d.h)>>>0;var T=d.h.h+S,R=T-x;if(0>=R&&(d.h.j=T,D(y,d,void 0,void 0,void 0),R=T-d.h.h),R)throw Error("Message parsing ended unexpectedly. Expected to read "+(S+" bytes, instead read "+(S-R)+" bytes, either the data ended unexpectedly or the message misreported its own length"));return d.h.h=T,d.h.j=x,!0},function(d,y,x,S,D){if(y=Sa(y,S,x),y!=null)for(S=0;S<y.length;S++){var T=d;Ss(T.h,8*x+2);var R=T.h.end();Zs(T,R),R.push(T.i),T=R,D(y[S],d),R=d;var P=T.pop();for(P=R.i+R.h.length()-P;127<P;)T.push(P&127|128),P>>>=7,R.i++;T.push(P),R.i++}});function Da(d){return function(y,x){t:{if(No.length){var S=No.pop();S.setOptions(x),ma(S.h,y,x),y=S}else y=new ya(y,x);try{var D=$a(d),T=Ec(new D.P,y,D);break t}finally{D=y.h,D.i=null,D.m=!1,D.l=0,D.j=0,D.h=0,D.S=!1,y.l=-1,y.i=-1,100>No.length&&No.push(y)}T=void 0}return T}}function Ra(d){return function(){var y=new Nb;Lc(this,y,Na(d)),Zs(y,y.h.end());for(var x=new Uint8Array(y.i),S=y.j,D=S.length,T=0,R=0;R<D;R++){var P=S[R];x.set(P,T),T+=P.length}return y.j=[x],x}}function Qs(d){Be.call(this,d)}b(Qs,Be);var Bc=[Qs,1,Ub,2,pn,3,Oc,4,Oc];Qs.prototype.l=Ra(Bc);function Aa(d){Be.call(this,d,-1,Gb)}b(Aa,Be),Aa.prototype.addClassification=function(d,y){return Cc(this,1,Qs,d,y),this};var Gb=[1],Hb=Da([Aa,1,_c,Bc]);function Wi(d){Be.call(this,d)}b(Wi,Be);var Wc=[Wi,1,pn,2,pn,3,pn,4,pn,5,pn];Wi.prototype.l=Ra(Wc);function Vc(d){Be.call(this,d,-1,jb)}b(Vc,Be);var jb=[1],Kb=Da([Vc,1,_c,Wc]);function Fo(d){Be.call(this,d)}b(Fo,Be);var Uc=[Fo,1,pn,2,pn,3,pn,4,pn,5,pn,6,Vb],Xb=Da(Uc);Fo.prototype.l=Ra(Uc);function Gc(d,y,x){if(x=d.createShader(x===0?d.VERTEX_SHADER:d.FRAGMENT_SHADER),d.shaderSource(x,y),d.compileShader(x),!d.getShaderParameter(x,d.COMPILE_STATUS))throw Error(`Could not compile WebGL shader.

`+d.getShaderInfoLog(x));return x}function qb(d){return Sa(d,Qs,1).map(function(y){var x=dn(y,1);return{index:x??0,qa:$n(y,2),label:dn(y,3)!=null?Ro(dn(y,3),""):void 0,displayName:dn(y,4)!=null?Ro(dn(y,4),""):void 0}})}function Yb(d){return{x:$n(d,1),y:$n(d,2),z:$n(d,3),visibility:ka(d,4)!=null?$n(d,4):void 0}}function Ta(d){return Sa(Kb(d),Wi,1).map(Yb)}function za(d,y){this.i=d,this.h=y,this.m=0}function Hc(d,y,x){return Zb(d,y),typeof d.h.canvas.transferToImageBitmap=="function"?Promise.resolve(d.h.canvas.transferToImageBitmap()):x?Promise.resolve(d.h.canvas):typeof createImageBitmap=="function"?createImageBitmap(d.h.canvas):(d.j===void 0&&(d.j=document.createElement("canvas")),new Promise(function(S){d.j.height=d.h.canvas.height,d.j.width=d.h.canvas.width,d.j.getContext("2d",{}).drawImage(d.h.canvas,0,0,d.h.canvas.width,d.h.canvas.height),S(d.j)}))}function Zb(d,y){var x=d.h;if(d.s===void 0){var S=Gc(x,`
  attribute vec2 aVertex;
  attribute vec2 aTex;
  varying vec2 vTex;
  void main(void) {
    gl_Position = vec4(aVertex, 0.0, 1.0);
    vTex = aTex;
  }`,0),D=Gc(x,`
  precision mediump float;
  varying vec2 vTex;
  uniform sampler2D sampler0;
  void main(){
    gl_FragColor = texture2D(sampler0, vTex);
  }`,1),T=x.createProgram();if(x.attachShader(T,S),x.attachShader(T,D),x.linkProgram(T),!x.getProgramParameter(T,x.LINK_STATUS))throw Error(`Could not compile WebGL program.

`+x.getProgramInfoLog(T));S=d.s=T,x.useProgram(S),D=x.getUniformLocation(S,"sampler0"),d.l={O:x.getAttribLocation(S,"aVertex"),N:x.getAttribLocation(S,"aTex"),ya:D},d.v=x.createBuffer(),x.bindBuffer(x.ARRAY_BUFFER,d.v),x.enableVertexAttribArray(d.l.O),x.vertexAttribPointer(d.l.O,2,x.FLOAT,!1,0,0),x.bufferData(x.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),x.STATIC_DRAW),x.bindBuffer(x.ARRAY_BUFFER,null),d.u=x.createBuffer(),x.bindBuffer(x.ARRAY_BUFFER,d.u),x.enableVertexAttribArray(d.l.N),x.vertexAttribPointer(d.l.N,2,x.FLOAT,!1,0,0),x.bufferData(x.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),x.STATIC_DRAW),x.bindBuffer(x.ARRAY_BUFFER,null),x.uniform1i(D,0)}S=d.l,x.useProgram(d.s),x.canvas.width=y.width,x.canvas.height=y.height,x.viewport(0,0,y.width,y.height),x.activeTexture(x.TEXTURE0),d.i.bindTexture2d(y.glName),x.enableVertexAttribArray(S.O),x.bindBuffer(x.ARRAY_BUFFER,d.v),x.vertexAttribPointer(S.O,2,x.FLOAT,!1,0,0),x.enableVertexAttribArray(S.N),x.bindBuffer(x.ARRAY_BUFFER,d.u),x.vertexAttribPointer(S.N,2,x.FLOAT,!1,0,0),x.bindFramebuffer(x.DRAW_FRAMEBUFFER?x.DRAW_FRAMEBUFFER:x.FRAMEBUFFER,null),x.clearColor(0,0,0,0),x.clear(x.COLOR_BUFFER_BIT),x.colorMask(!0,!0,!0,!0),x.drawArrays(x.TRIANGLE_FAN,0,4),x.disableVertexAttribArray(S.O),x.disableVertexAttribArray(S.N),x.bindBuffer(x.ARRAY_BUFFER,null),d.i.bindTexture2d(0)}function Qb(d){this.h=d}var Jb=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]);function tx(d,y){return y+d}function jc(d,y){window[d]=y}function ex(d){var y=document.createElement("script");return y.setAttribute("src",d),y.setAttribute("crossorigin","anonymous"),new Promise(function(x){y.addEventListener("load",function(){x()},!1),y.addEventListener("error",function(){x()},!1),document.body.appendChild(y)})}function nx(){return E(function(d){switch(d.h){case 1:return d.s=2,C(d,WebAssembly.instantiate(Jb),4);case 4:d.h=3,d.s=0;break;case 2:return d.s=0,d.l=null,d.return(!1);case 3:return d.return(!0)}})}function Fa(d){if(this.h=d,this.listeners={},this.l={},this.L={},this.s={},this.v={},this.M=this.u=this.ga=!0,this.I=Promise.resolve(),this.fa="",this.D={},this.locateFile=d&&d.locateFile||tx,typeof window=="object")var y=window.location.pathname.toString().substring(0,window.location.pathname.toString().lastIndexOf("/"))+"/";else if(typeof location<"u")y=location.pathname.toString().substring(0,location.pathname.toString().lastIndexOf("/"))+"/";else throw Error("solutions can only be loaded on a web page or in a web worker");if(this.ha=y,d.options){y=a(Object.keys(d.options));for(var x=y.next();!x.done;x=y.next()){x=x.value;var S=d.options[x].default;S!==void 0&&(this.l[x]=typeof S=="function"?S():S)}}}n=Fa.prototype,n.close=function(){return this.j&&this.j.delete(),Promise.resolve()};function sx(d){var y,x,S,D,T,R,P,G,J,lt,St;return E(function(bt){switch(bt.h){case 1:return d.ga?(y=d.h.files===void 0?[]:typeof d.h.files=="function"?d.h.files(d.l):d.h.files,C(bt,nx(),2)):bt.return();case 2:if(x=bt.i,typeof window=="object")return jc("createMediapipeSolutionsWasm",{locateFile:d.locateFile}),jc("createMediapipeSolutionsPackedAssets",{locateFile:d.locateFile}),R=y.filter(function(dt){return dt.data!==void 0}),P=y.filter(function(dt){return dt.data===void 0}),G=Promise.all(R.map(function(dt){var It=Mo(d,dt.url);if(dt.path!==void 0){var Pt=dt.path;It=It.then(function(ie){return d.overrideFile(Pt,ie),Promise.resolve(ie)})}return It})),J=Promise.all(P.map(function(dt){return dt.simd===void 0||dt.simd&&x||!dt.simd&&!x?ex(d.locateFile(dt.url,d.ha)):Promise.resolve()})).then(function(){var dt,It,Pt;return E(function(ie){if(ie.h==1)return dt=window.createMediapipeSolutionsWasm,It=window.createMediapipeSolutionsPackedAssets,Pt=d,C(ie,dt(It),2);Pt.i=ie.i,ie.h=0})}),lt=function(){return E(function(dt){return d.h.graph&&d.h.graph.url?dt=C(dt,Mo(d,d.h.graph.url),0):(dt.h=0,dt=void 0),dt})}(),C(bt,Promise.all([J,G,lt]),7);if(typeof importScripts!="function")throw Error("solutions can only be loaded on a web page or in a web worker");return S=y.filter(function(dt){return dt.simd===void 0||dt.simd&&x||!dt.simd&&!x}).map(function(dt){return d.locateFile(dt.url,d.ha)}),importScripts.apply(null,u(S)),D=d,C(bt,createMediapipeSolutionsWasm(Module),6);case 6:D.i=bt.i,d.m=new OffscreenCanvas(1,1),d.i.canvas=d.m,T=d.i.GL.createContext(d.m,{antialias:!1,alpha:!1,va:typeof WebGL2RenderingContext<"u"?2:1}),d.i.GL.makeContextCurrent(T),bt.h=4;break;case 7:if(d.m=document.createElement("canvas"),St=d.m.getContext("webgl2",{}),!St&&(St=d.m.getContext("webgl",{}),!St))return alert("Failed to create WebGL canvas context when passing video frame."),bt.return();d.K=St,d.i.canvas=d.m,d.i.createContext(d.m,!0,!0,{});case 4:d.j=new d.i.SolutionWasm,d.ga=!1,bt.h=0}})}function ix(d){var y,x,S,D,T,R,P,G;return E(function(J){if(J.h==1){if(d.h.graph&&d.h.graph.url&&d.fa===d.h.graph.url)return J.return();if(d.u=!0,!d.h.graph||!d.h.graph.url){J.h=2;return}return d.fa=d.h.graph.url,C(J,Mo(d,d.h.graph.url),3)}for(J.h!=2&&(y=J.i,d.j.loadGraph(y)),x=a(Object.keys(d.D)),S=x.next();!S.done;S=x.next())D=S.value,d.j.overrideFile(D,d.D[D]);if(d.D={},d.h.listeners)for(T=a(d.h.listeners),R=T.next();!R.done;R=T.next())P=R.value,ux(d,P);G=d.l,d.l={},d.setOptions(G),J.h=0})}n.reset=function(){var d=this;return E(function(y){d.j&&(d.j.reset(),d.s={},d.v={}),y.h=0})},n.setOptions=function(d,y){var x=this;if(y=y||this.h.options){for(var S=[],D=[],T={},R=a(Object.keys(d)),P=R.next();!P.done;T={X:T.X,Y:T.Y},P=R.next())if(P=P.value,!(P in this.l&&this.l[P]===d[P])){this.l[P]=d[P];var G=y[P];G!==void 0&&(G.onChange&&(T.X=G.onChange,T.Y=d[P],S.push(function(J){return function(){var lt;return E(function(St){if(St.h==1)return C(St,J.X(J.Y),2);lt=St.i,lt===!0&&(x.u=!0),St.h=0})}}(T))),G.graphOptionXref&&(P=Object.assign({},{calculatorName:"",calculatorIndex:0},G.graphOptionXref,{valueNumber:G.type===1?d[P]:0,valueBoolean:G.type===0?d[P]:!1,valueString:G.type===2?d[P]:""}),D.push(P)))}(S.length!==0||D.length!==0)&&(this.u=!0,this.H=(this.H===void 0?[]:this.H).concat(D),this.F=(this.F===void 0?[]:this.F).concat(S))}};function ox(d){var y,x,S,D,T,R,P;return E(function(G){switch(G.h){case 1:if(!d.u)return G.return();if(!d.F){G.h=2;break}y=a(d.F),x=y.next();case 3:if(x.done){G.h=5;break}return S=x.value,C(G,S(),4);case 4:x=y.next(),G.h=3;break;case 5:d.F=void 0;case 2:if(d.H){for(D=new d.i.GraphOptionChangeRequestList,T=a(d.H),R=T.next();!R.done;R=T.next())P=R.value,D.push_back(P);d.j.changeOptions(D),D.delete(),d.H=void 0}d.u=!1,G.h=0}})}n.initialize=function(){var d=this;return E(function(y){return y.h==1?C(y,sx(d),2):y.h!=3?C(y,ix(d),3):C(y,ox(d),0)})};function Mo(d,y){var x,S;return E(function(D){return y in d.L?D.return(d.L[y]):(x=d.locateFile(y,""),S=fetch(x).then(function(T){return T.arrayBuffer()}),d.L[y]=S,D.return(S))})}n.overrideFile=function(d,y){this.j?this.j.overrideFile(d,y):this.D[d]=y},n.clearOverriddenFiles=function(){this.D={},this.j&&this.j.clearOverriddenFiles()},n.send=function(d,y){var x=this,S,D,T,R,P,G,J,lt,St;return E(function(bt){switch(bt.h){case 1:return x.h.inputs?(S=1e3*(y??performance.now()),C(bt,x.I,2)):bt.return();case 2:return C(bt,x.initialize(),3);case 3:for(D=new x.i.PacketDataList,T=a(Object.keys(d)),R=T.next();!R.done;R=T.next())if(P=R.value,G=x.h.inputs[P]){t:{var dt=d[P];switch(G.type){case"video":var It=x.s[G.stream];if(It||(It=new za(x.i,x.K),x.s[G.stream]=It),It.m===0&&(It.m=It.i.createTexture()),typeof HTMLVideoElement<"u"&&dt instanceof HTMLVideoElement)var Pt=dt.videoWidth,ie=dt.videoHeight;else typeof HTMLImageElement<"u"&&dt instanceof HTMLImageElement?(Pt=dt.naturalWidth,ie=dt.naturalHeight):(Pt=dt.width,ie=dt.height);ie={glName:It.m,width:Pt,height:ie},Pt=It.h,Pt.canvas.width=ie.width,Pt.canvas.height=ie.height,Pt.activeTexture(Pt.TEXTURE0),It.i.bindTexture2d(It.m),Pt.texImage2D(Pt.TEXTURE_2D,0,Pt.RGBA,Pt.RGBA,Pt.UNSIGNED_BYTE,dt),It.i.bindTexture2d(0),It=ie;break t;case"detections":for(It=x.s[G.stream],It||(It=new Qb(x.i),x.s[G.stream]=It),It.data||(It.data=new It.h.DetectionListData),It.data.reset(dt.length),ie=0;ie<dt.length;++ie){Pt=dt[ie];var ne=It.data,Re=ne.setBoundingBox,sn=ie,We=Pt.la,Gt=new Fo;if(Nn(Gt,1,We.sa),Nn(Gt,2,We.ta),Nn(Gt,3,We.height),Nn(Gt,4,We.width),Nn(Gt,5,We.rotation),In(Gt,6,We.pa),We=Gt.l(),Re.call(ne,sn,We),Pt.ea)for(ne=0;ne<Pt.ea.length;++ne){Gt=Pt.ea[ne],Re=It.data,sn=Re.addNormalizedLandmark,We=ie,Gt=Object.assign({},Gt,{visibility:Gt.visibility?Gt.visibility:0});var Ae=new Wi;Nn(Ae,1,Gt.x),Nn(Ae,2,Gt.y),Nn(Ae,3,Gt.z),Gt.visibility&&Nn(Ae,4,Gt.visibility),Gt=Ae.l(),sn.call(Re,We,Gt)}if(Pt.ba)for(ne=0;ne<Pt.ba.length;++ne)Re=It.data,sn=Re.addClassification,We=ie,Gt=Pt.ba[ne],Ae=new Qs,Nn(Ae,2,Gt.qa),Gt.index&&In(Ae,1,Gt.index),Gt.label&&In(Ae,3,Gt.label),Gt.displayName&&In(Ae,4,Gt.displayName),Gt=Ae.l(),sn.call(Re,We,Gt)}It=It.data;break t;default:It={}}}switch(J=It,lt=G.stream,G.type){case"video":D.pushTexture2d(Object.assign({},J,{stream:lt,timestamp:S}));break;case"detections":St=J,St.stream=lt,St.timestamp=S,D.pushDetectionList(St);break;default:throw Error("Unknown input config type: '"+G.type+"'")}}return x.j.send(D),C(bt,x.I,4);case 4:D.delete(),bt.h=0}})};function rx(d,y,x){var S,D,T,R,P,G,J,lt,St,bt,dt,It,Pt,ie;return E(function(ne){switch(ne.h){case 1:if(!x)return ne.return(y);for(S={},D=0,T=a(Object.keys(x)),R=T.next();!R.done;R=T.next())P=R.value,G=x[P],typeof G!="string"&&G.type==="texture"&&y[G.stream]!==void 0&&++D;1<D&&(d.M=!1),J=a(Object.keys(x)),R=J.next();case 2:if(R.done){ne.h=4;break}if(lt=R.value,St=x[lt],typeof St=="string")return Pt=S,ie=lt,C(ne,ax(d,lt,y[St]),14);if(bt=y[St.stream],St.type==="detection_list"){if(bt){for(var Re=bt.getRectList(),sn=bt.getLandmarksList(),We=bt.getClassificationsList(),Gt=[],Ae=0;Ae<Re.size();++Ae){var rs=Xb(Re.get(Ae)),lx=$n(rs,1),cx=$n(rs,2),hx=$n(rs,3),dx=$n(rs,4),px=$n(rs,5,0),Po=void 0;Po=Po===void 0?0:Po,rs={la:{sa:lx,ta:cx,height:hx,width:dx,rotation:px,pa:Ro(dn(rs,6),Po)},ea:Ta(sn.get(Ae)),ba:qb(Hb(We.get(Ae)))},Gt.push(rs)}Re=Gt}else Re=[];S[lt]=Re,ne.h=7;break}if(St.type==="proto_list"){if(bt){for(Re=Array(bt.size()),sn=0;sn<bt.size();sn++)Re[sn]=bt.get(sn);bt.delete()}else Re=[];S[lt]=Re,ne.h=7;break}if(bt===void 0){ne.h=3;break}if(St.type==="float_list"){S[lt]=bt,ne.h=7;break}if(St.type==="proto"){S[lt]=bt,ne.h=7;break}if(St.type!=="texture")throw Error("Unknown output config type: '"+St.type+"'");return dt=d.v[lt],dt||(dt=new za(d.i,d.K),d.v[lt]=dt),C(ne,Hc(dt,bt,d.M),13);case 13:It=ne.i,S[lt]=It;case 7:St.transform&&S[lt]&&(S[lt]=St.transform(S[lt])),ne.h=3;break;case 14:Pt[ie]=ne.i;case 3:R=J.next(),ne.h=2;break;case 4:return ne.return(S)}})}function ax(d,y,x){var S;return E(function(D){return typeof x=="number"||x instanceof Uint8Array||x instanceof d.i.Uint8BlobList?D.return(x):x instanceof d.i.Texture2dDataOut?(S=d.v[y],S||(S=new za(d.i,d.K),d.v[y]=S),D.return(Hc(S,x,d.M))):D.return(void 0)})}function ux(d,y){for(var x=y.name||"$",S=[].concat(u(y.wants)),D=new d.i.StringList,T=a(y.wants),R=T.next();!R.done;R=T.next())D.push_back(R.value);T=d.i.PacketListener.implement({onResults:function(P){for(var G={},J=0;J<y.wants.length;++J)G[S[J]]=P.get(J);var lt=d.listeners[x];lt&&(d.I=rx(d,G,y.outs).then(function(St){St=lt(St);for(var bt=0;bt<y.wants.length;++bt){var dt=G[S[bt]];typeof dt=="object"&&dt.hasOwnProperty&&dt.hasOwnProperty("delete")&&dt.delete()}St&&(d.I=St)}))}}),d.j.attachMultiListener(D,T),D.delete()}n.onResults=function(d,y){this.listeners[y||"$"]=d},_("Solution",Fa),_("OptionType",{BOOL:0,NUMBER:1,ua:2,0:"BOOL",1:"NUMBER",2:"STRING"});function Kc(d){switch(d===void 0&&(d=0),d){case 1:return"pose_landmark_full.tflite";case 2:return"pose_landmark_heavy.tflite";default:return"pose_landmark_lite.tflite"}}function Xc(d){var y=this;d=d||{},this.h=new Fa({locateFile:d.locateFile,files:function(x){return[{url:"pose_solution_packed_assets_loader.js"},{simd:!1,url:"pose_solution_wasm_bin.js"},{simd:!0,url:"pose_solution_simd_wasm_bin.js"},{data:!0,url:Kc(x.modelComplexity)}]},graph:{url:"pose_web.binarypb"},listeners:[{wants:["pose_landmarks","world_landmarks","segmentation_mask","image_transformed"],outs:{image:{type:"texture",stream:"image_transformed"},poseLandmarks:{type:"proto",stream:"pose_landmarks",transform:Ta},poseWorldLandmarks:{type:"proto",stream:"world_landmarks",transform:Ta},segmentationMask:{type:"texture",stream:"segmentation_mask"}}}],inputs:{image:{type:"video",stream:"input_frames_gpu"}},options:{useCpuInference:{type:0,graphOptionXref:{calculatorType:"InferenceCalculator",fieldName:"use_cpu_inference"},default:typeof window!="object"||window.navigator===void 0?!1:"iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document},selfieMode:{type:0,graphOptionXref:{calculatorType:"GlScalerCalculator",calculatorIndex:1,fieldName:"flip_horizontal"}},modelComplexity:{type:1,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorModelComplexity",fieldName:"int_value"},onChange:function(x){var S,D,T;return E(function(R){return R.h==1?(S=Kc(x),D="third_party/mediapipe/modules/pose_landmark/"+S,C(R,Mo(y.h,S),2)):(T=R.i,y.h.overrideFile(D,T),R.return(!0))})}},smoothLandmarks:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothLandmarks",fieldName:"bool_value"}},enableSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorEnableSegmentation",fieldName:"bool_value"}},smoothSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothSegmentation",fieldName:"bool_value"}},minDetectionConfidence:{type:1,graphOptionXref:{calculatorType:"TensorsToDetectionsCalculator",calculatorName:"poselandmarkgpu__posedetectiongpu__TensorsToDetectionsCalculator",fieldName:"min_score_thresh"}},minTrackingConfidence:{type:1,graphOptionXref:{calculatorType:"ThresholdingCalculator",calculatorName:"poselandmarkgpu__poselandmarkbyroigpu__tensorstoposelandmarksandsegmentation__ThresholdingCalculator",fieldName:"threshold"}}}})}n=Xc.prototype,n.reset=function(){this.h.reset()},n.close=function(){return this.h.close(),Promise.resolve()},n.onResults=function(d){this.h.onResults(d)},n.initialize=function(){var d=this;return E(function(y){return C(y,d.h.initialize(),0)})},n.send=function(d,y){var x=this;return E(function(S){return C(S,x.h.send(d,y),0)})},n.setOptions=function(d){this.h.setOptions(d)},_("Pose",Xc),_("POSE_CONNECTIONS",[[0,1],[1,2],[2,3],[3,7],[0,4],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[13,15],[15,17],[15,19],[15,21],[17,19],[12,14],[14,16],[16,18],[16,20],[16,22],[18,20],[11,23],[12,24],[23,24],[23,25],[24,26],[25,27],[26,28],[27,29],[28,30],[29,31],[30,32],[27,31],[28,32]]),_("POSE_LANDMARKS",{NOSE:0,LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,LEFT_EAR:7,RIGHT_EAR:8,LEFT_RIGHT:9,RIGHT_LEFT:10,LEFT_SHOULDER:11,RIGHT_SHOULDER:12,LEFT_ELBOW:13,RIGHT_ELBOW:14,LEFT_WRIST:15,RIGHT_WRIST:16,LEFT_PINKY:17,RIGHT_PINKY:18,LEFT_INDEX:19,RIGHT_INDEX:20,LEFT_THUMB:21,RIGHT_THUMB:22,LEFT_HIP:23,RIGHT_HIP:24,LEFT_KNEE:25,RIGHT_KNEE:26,LEFT_ANKLE:27,RIGHT_ANKLE:28,LEFT_HEEL:29,RIGHT_HEEL:30,LEFT_FOOT_INDEX:31,RIGHT_FOOT_INDEX:32}),_("POSE_LANDMARKS_LEFT",{LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,LEFT_EAR:7,LEFT_RIGHT:9,LEFT_SHOULDER:11,LEFT_ELBOW:13,LEFT_WRIST:15,LEFT_PINKY:17,LEFT_INDEX:19,LEFT_THUMB:21,LEFT_HIP:23,LEFT_KNEE:25,LEFT_ANKLE:27,LEFT_HEEL:29,LEFT_FOOT_INDEX:31}),_("POSE_LANDMARKS_RIGHT",{RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,RIGHT_EAR:8,RIGHT_LEFT:10,RIGHT_SHOULDER:12,RIGHT_ELBOW:14,RIGHT_WRIST:16,RIGHT_PINKY:18,RIGHT_INDEX:20,RIGHT_THUMB:22,RIGHT_HIP:24,RIGHT_KNEE:26,RIGHT_ANKLE:28,RIGHT_HEEL:30,RIGHT_FOOT_INDEX:32}),_("POSE_LANDMARKS_NEUTRAL",{NOSE:0}),_("VERSION","0.5.1675469404")}).call(Ma);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Je=he();Je.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE",()=>15);Je.registerFlag("WEBGPU_CPU_FORWARD",()=>!0);Je.registerFlag("WEBGPU_MATMUL_PROGRAM_TYPE",()=>-1);Je.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE",()=>!0);Je.registerFlag("WEBGPU_USE_LOW_POWER_GPU",()=>!1);Je.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e3);Je.registerFlag("WEBGPU_USE_PROFILE_TOOL",()=>!1);Je.registerFlag("WEBGPU_IMPORT_EXTERNAL_TEXTURE",()=>!0);Je.registerFlag("WEBGPU_USE_NAIVE_CONV2D_DEBUG",()=>!1);Je.registerFlag("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL",()=>-1);Je.registerFlag("WEBGPU_CONV_SEPARATE_IM2COL_SHADER",()=>!1);Je.registerFlag("WEBGPU_PRINT_SHADER",()=>"");Je.registerFlag("WEBGPU_ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class U${constructor(t){t&&(this.vendor=t.vendor,this.architecture=t.architecture,this.intelGPUGeneration=this.getIntelGPUGeneration())}getIntelGPUGeneration(){if(this.isIntel()){if(this.architecture.startsWith("gen"))return Number(this.architecture.match(/\d+/));if(this.architecture.startsWith("xe"))return 12}return 0}isIntel(){return this.vendor==="intel"}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class G${constructor(t){this.device=t,this.numUsedBuffers=0,this.numFreeBuffers=0,this.freeBuffers=new Map,this.usedBuffers=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireBuffer(t,e,s=!1,i=!0){let o;const r=Mh(t,e);return i?(this.freeBuffers.has(r)||this.freeBuffers.set(r,[]),this.freeBuffers.get(r).length>0?(o=this.freeBuffers.get(r).pop(),this.numFreeBuffers--):(o=this.device.createBuffer({size:t,usage:e,mappedAtCreation:s}),this.numBytesAllocated+=t)):(o=this.device.createBuffer({size:t,usage:e,mappedAtCreation:s}),this.numBytesAllocated+=t),this.usedBuffers.has(r)||this.usedBuffers.set(r,[]),this.usedBuffers.get(r).push(o),this.numUsedBuffers++,this.numBytesUsed+=t,o}releaseBuffer(t,e=!0){if(this.freeBuffers.size===0)return;const s=t.size,i=t.usage,o=Mh(s,i),r=this.usedBuffers.get(o),a=r.indexOf(t);if(a<0)throw new Error("Cannot find the buffer in buffer manager");r[a]=r[r.length-1],r.pop(),this.numUsedBuffers--,this.numBytesUsed-=s,e?(this.freeBuffers.get(o).push(t),this.numFreeBuffers++):(t.destroy(),this.numBytesAllocated-=s)}getNumUsedBuffers(){return this.numUsedBuffers}getNumFreeBuffers(){return this.numFreeBuffers}dispose(){this.freeBuffers.forEach((t,e)=>{t.forEach(s=>{s.destroy()})}),this.usedBuffers.forEach((t,e)=>{t.forEach(s=>{s.destroy()})}),this.freeBuffers=new Map,this.usedBuffers=new Map,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function Mh(n,t){return`${n}_${t}`}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class H${constructor(t){this.device=t,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures=new Map,this.usedTextures=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireTexture(t,e,s,i){const o=Eh(s),r=t*e*o,a=Ph(t,e,s,i);if(this.freeTextures.has(a)||this.freeTextures.set(a,[]),this.usedTextures.has(a)||this.usedTextures.set(a,[]),this.numBytesUsed+=r,this.numUsedTextures++,this.freeTextures.get(a).length>0){this.numFreeTextures--;const l=this.freeTextures.get(a).shift();return this.usedTextures.get(a).push(l),l}this.numBytesAllocated+=r;const u=this.device.createTexture({size:[t,e],format:s,usage:i});return this.usedTextures.get(a).push(u),u}releaseTexture(t){if(this.freeTextures.size===0)return;const e=t.width,s=t.height,i=t.format,o=t.usage,r=Ph(e,s,i,o);this.freeTextures.has(r)||this.freeTextures.set(r,[]),this.freeTextures.get(r).push(t),this.numFreeTextures++,this.numUsedTextures--;const a=this.usedTextures.get(r),u=a.indexOf(t);if(u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");a.splice(u,1);const l=Eh(i),c=e*s*l;this.numBytesUsed-=c}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){this.freeTextures.forEach((t,e)=>{t.forEach(s=>{s.destroy()})}),this.usedTextures.forEach((t,e)=>{t.forEach(s=>{s.destroy()})}),this.freeTextures=new Map,this.usedTextures=new Map,this.numUsedTextures=0,this.numFreeTextures=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function Ph(n,t,e,s){return`${n}_${t}_${e}_${s}`}function Eh(n){if(n==="rgba8unorm")return 16;throw new Error(`${n} is not supported!`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j$(n,t){if(Math.max(...n)>5)throw new Error("Cannot symbolically compute strides for rank > 6 tensor.");const e=n.length,s="xyzwuv",i=n.map(r=>`${t}.${s[r]}`),o=new Array(e-1);o[e-2]=i[e-1];for(let r=e-3;r>=0;--r)o[r]=`(${o[r+1]} * ${i[r+1]})`;return o}const Cs=(n,t,e)=>e==="int32"?`atomicAdd(${n}, bitcast<i32>(${t}));`:`
          {
            var oldValue = 0;
            loop {
              let newValueF32 = bitcast<f32>(oldValue) + (${t});
              let newValue = bitcast<i32>(newValueF32);
              let res = atomicCompareExchangeWeak(${n}, oldValue, newValue);
              if res.exchanged {
                break;
              }
              oldValue = res.old_value;
            }
          }`;/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var bi;(function(n){n[n.FROM_PIXELS=0]="FROM_PIXELS",n[n.DRAW=1]="DRAW"})(bi||(bi={}));const K$=(n,t,e,s,i)=>{const o={dtype:s.dtype,shape:s.shape},r=q$(e,o,t),a=n.createShaderModule({code:r,label:t.constructor.name});let u=he().get("WEBGPU_PRINT_SHADER");if(u!==""){u=u.toLowerCase();const l=u.split(",");(u==="all"||l.some(c=>t.shaderKey.toLowerCase().includes(c)))&&(console.group(t.shaderKey),console.debug(r),console.groupEnd())}return i?n.createComputePipelineAsync({compute:{module:a,entryPoint:"_start"},label:t.constructor.name,layout:"auto"}):n.createComputePipeline({compute:{module:a,entryPoint:"_start"},label:t.constructor.name,layout:"auto"})},Rt=(n,t="f32")=>{switch(n){case 1:return`${t}`;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw new Error(`${n}-component ${t} is not supported.`)}};function de(n){if(n<=1)return"i32";if(n===2)return"vec2<i32>";if(n===3)return"vec3<i32>";if(n===4)return"vec4<i32>";if(n===5)return"vec5";if(n===6)return"vec6";throw Error(`GPU for rank ${n} is not yet supported`)}function Yn(n){if(n===0)return"x";if(n===1)return"y";if(n===2)return"z";if(n===3)return"w";if(n===4)return"u";if(n===5)return"v";throw Error(`Index ${n} is not yet supported`)}function ot(...n){let t;switch(n.length){case 0:t=`
        fn main()
      `;break;case 1:t=`
        fn main(${n[0]} : i32)
      `;break;default:throw Error("Unreachable")}return t}function Lh(n,t){let e;return e=`
     ${X$(t)}
      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
                @builtin(global_invocation_id) GlobalId : vec3<u32>,
                @builtin(local_invocation_index) LocalIndex: u32,
                @builtin(workgroup_id) WorkgroupId : vec3<u32>,
                @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {
        localId = LocalId;
        localIndex = LocalIndex;
        globalId = GlobalId;
        numWorkgroups = NumWorkgroups;
        workgroupId = WorkgroupId;
        ${n?"main(getGlobalIndex());":"main();"};
      }
    `,e}function X$(n){return`
  @compute @workgroup_size(${n.workgroupSize[0]}, ${n.workgroupSize[1]}, ${n.workgroupSize[2]})
`}function q$(n,t,e){const s=[],i=e.workgroupSize[0]*e.workgroupSize[1]*e.workgroupSize[2];if(e.outputComponent=e.outputComponent?e.outputComponent:1,s.push(`

      var<private> localId: vec3<u32>;
      var<private> localIndex: u32;
      var<private> globalId: vec3<u32>;
      var<private> numWorkgroups: vec3<u32>;
      var<private> workgroupId: vec3<u32>;

      // Only used when the y/z dimension of workgroup size is 1.
      fn getGlobalIndex() -> i32 {
        ${zy(e)?"  return i32(globalId.x);":`  return i32((workgroupId.z * numWorkgroups.x * numWorkgroups.y +
                workgroupId.y * numWorkgroups.x + workgroupId.x) * ${i}u +
                localIndex);
        `}
      }
    `),e.pixelsOpType!=null){const m=e.pixelsOpType===bi.FROM_PIXELS?`@group(0) @binding(0) var<storage, read_write> result: array<${Rs(t.dtype,e.outputComponent)}>;`:`@group(0) @binding(1) var<storage, read> inBuf : array<${Rs(n[0].dtype,e.outputComponent)}>;`,g=t.shape.length===3?"vec2<i32>":"i32";s.push(`
        struct Uniform {
          outShapeStrides : ${g},
          size            : i32,
          numChannels     : i32,
          alpha           : f32,
        };

        ${m}
        @group(0) @binding(2) var<uniform> uniforms: Uniform;
      `);const b=_h(e);return[Oh,s.join(`
`),Wo(t.shape),e.getUserCode(),Lh(b,e)].join(`
`)}let o,r,a="struct Uniforms { NAN : f32, INFINITY : f32, ";e.variableNames.forEach((m,g)=>{const b=de(n[g].shape.length);a+=`${m.charAt(0).toLowerCase()+m.slice(1)}Shape : ${b}, `,o=n[g].shape.length-1,r=de(o),a+=`${m.charAt(0).toLowerCase()+m.slice(1)}ShapeStrides: ${r}, `});const u=de(t.shape.length);a+=`outShape : ${u}, `,o=t.shape.length-1,r=de(o),a+=`
         outShapeStrides: ${r}, `,e.size&&(a+="size : i32, "),e.uniforms&&(a+=e.uniforms),a+="};",a=iD(a),s.push(a),e.atomic?s.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;
    `):s.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<${Rs(t.dtype,e.outputComponent)}>;
    `),e.variableNames.forEach((m,g)=>{s.push(`
      @group(0) @binding(${1+g}) var<storage, read> ${m}: array<${e.variableComponents?Rs(n[g].dtype,e.variableComponents[g]):Rs(n[g].dtype,e.outputComponent)}>;
        `)}),a!==""&&s.push(`
      @group(0) @binding(${1+e.variableNames.length}) var<uniform> uniforms: Uniforms;
      `);const l=eD(t.shape,e.dispatchLayout),c=[Oh,s.join(`
`)+Z$,Wo(t.shape),l,nD(t.shape.length)];e.atomic||c.push(sD(t.shape,t.dtype,e.outputComponent)),e.variableNames.forEach((m,g)=>{c.push(`${Wo(n[g].shape,m)}`)});const h=n.map((m,g)=>tD(m,t.shape,e.variableComponents?e.variableComponents[g]:e.outputComponent,e.dispatchLayout.x.length===t.shape.length)).join(`
`);c.push(h),c.push(e.getUserCode());const p=_h(e);return c.push(Lh(p,e)),c.join(`
`)}function Y$(n,t,e){let s=n.shaderKey;if(n.pixelsOpType!=null)return s;const i=[],o=[];t.forEach(c=>{i.push(c.shape),o.push(c.dtype)}),i.push(e.shape),o.push(e.dtype);const r=t.map(c=>Zf(c.shape,e.shape)),a=t.map(c=>ke(c.shape,e.shape)).join("_"),u=r.map(c=>c.join("_")).join(";"),l=zy(n)?"flatDispatch":"";return s+="_"+(n.workgroupSize?n.workgroupSize.join(","):"")+i.map(c=>c.length).join(",")+o.join(",")+n.variableNames.join(",")+u+a+l,s}const Oh=`
  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};
  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};

  // Checks whether coordinates lie within the bounds of the shape.
  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {
    return all(coord >= vec2<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {
    return all(coord >= vec3<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {
    return all(coord >= vec4<i32>(0)) && all(coord < shape);
  }

  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {
    return coord;
  }
  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {
    return dot(coords, vec2<i32>(shape.y, 1));
  }
  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {
    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));
  }
  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
    return dot(coords, vec4<i32>(
        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
  }
  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {
    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;
  }
  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {
    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;
  }

  // NaN defination in IEEE 754-1985 is :
  //   - sign = either 0 or 1.
  //   - biased exponent = all 1 bits.
  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).
  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers
  fn isnan(val: f32) -> bool {
    let floatToUint: u32 = bitcast<u32>(val);
    return (floatToUint & 0x7fffffffu) > 0x7f800000u;
  }
  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {
    let floatToUint: vec4<u32> = bitcast<vec4<u32>>(val);
    return (floatToUint & vec4<u32>(0x7fffffffu)) > vec4<u32>(0x7f800000u);
  }
`,Z$=`
  fn isinf(val: f32) -> bool {
    return abs(val) == uniforms.INFINITY;
  }
`;function Wo(n,t=""){const e=n.length,s=t!==""?`get${t.charAt(0).toUpperCase()+t.slice(1)}CoordsFromIndex`:"getCoordsFromIndex",i=t!==""?`${t.charAt(0).toLowerCase()+t.slice(1)}ShapeStrides`:"outShapeStrides";if(e<=1)return`fn ${s}(index : i32) -> i32 { return index; }`;const o=Tt(n),r=de(e),a=[];for(let l=0;l<e;l++)a.push(`d${l}`);if(o.length===1)return`    fn ${s}(index : i32) -> vec2<i32> {
      let d0 = index / uniforms.${i}; let d1 = index - d0 * uniforms.${i};
      return vec2<i32>(d0, d1);
    }`;let u;return u="var index2 = index;"+o.map((l,c)=>{const h=`let ${a[c]} = index2 / uniforms.${i}.${Yn(c)}`,p=c===o.length-1?`let ${a[c+1]} = index2 - ${a[c]} * uniforms.${i}.${Yn(c)}`:`index2 = index2 - ${a[c]} * uniforms.${i}.${Yn(c)}`;return`${h}; ${p};`}).join(""),`
    fn ${s}(index : i32) -> ${r} {
      ${u}
      return ${r}(${a.join(",")});
    }
  `}function Q$(n,t){const e=n.name,s=n.shape.length,i=de(s),o="get"+e.charAt(0).toUpperCase()+e.slice(1),r=["d0","d1","d2","d3","d4","d5"].slice(0,s),a=r.map(c=>`${c} : i32`).join(", ");if(s<1)return`
      fn ${o}() -> ${Rt(t)} {
        return ${Rt(t)}(${e}[0]);
      }
    `;const u=`uniforms.${e.charAt(0).toLowerCase()+e.slice(1)}Shape`;let l=`${s}D`;return s===0&&(l="1D"),`
    fn ${o}(${a}) -> ${Rt(t)} {
      return ${Rt(t)}(${e}[getIndexFromCoords${l}(${i}(${r.join(",")}),
        ${u})${t===1?"":` / ${t}`}]);
    }
   `}function J$(n,t,e,s){const i=n.name,o=i.charAt(0).toUpperCase()+i.slice(1),r="get"+o+"ByOutput",a=n.shape.length,u=t.length,l=de(u);if(ke(n.shape,t)&&s)return`
    fn ${r}Index(globalIndex : i32) -> ${Rt(e)} {
      return ${Rt(e)}(${i}[globalIndex]);
    }

    fn ${r}Coords(coords : ${l}) -> ${Rt(e)} {
      return ${Rt(e)}(${i}[${u>1?"getOutputIndexFromCoords(coords)":"coords"}${e===1?"":` / ${e}`}]);
    }
    `;const c=Zf(n.shape,t),h=u-a;let p="";if(a===0)return`
    fn ${r}Index(globalIndex : i32) -> ${Rt(e)}{
      return get${o}();
    }

    fn ${r}Coords(coords : ${l}) -> ${Rt(e)}{
      return get${o}();
    }
  `;u<2&&c.length>=1?p="coords = 0;":p=c.map(b=>`coords.${Yn(b+h)} = 0;`).join(`
`);let f="";if(u<2&&a>0)f="coords";else if(u>1){const b=de(a),v=n.shape.map((w,k)=>`coords.${Yn(k+h)}`).join(", ");f=`${b}(${v})`}else f="coords";const m=`uniforms.${i.charAt(0).toLowerCase()+i.slice(1)}Shape`,g=`${a}D`;return`
  fn ${r}Index(globalIndex : i32) -> ${Rt(e)} {
    var coords = getCoordsFromIndex(globalIndex);
    ${p}
    return ${Rt(e)}(${i}[getIndexFromCoords${g}(${f}, ${m})${e===1?"":` / ${e}`}]);
  }

  fn ${r}Coords(coordsIn : ${l}) -> ${Rt(e)} {
    var coords = coordsIn;
    ${p}
    return ${Rt(e)}(${i}[getIndexFromCoords${g}(${f}, ${m})${e===1?"":` / ${e}`}]);
  }
`}function tD(n,t,e,s){let i=Q$(n,e);return n.shape.length<=t.length&&(i+=J$(n,t,e,s)),i}function eD(n,t){const{x:e,y:s=[],z:i=[]}=t,o=n.length,r=e.length+s.length+i.length;if(r!==o)return"";if(e.length===o)return`fn getOutputCoords() -> ${de(o)}{
    let globalIndex = getGlobalIndex();
    return getCoordsFromIndex(globalIndex);
  }
  `;let a="";const u=[e,s,i];for(let p=0;p<u.length;p++){const f=u[p];if(f.length!==0)if(f.length===1)a+=`let d${f[0]} = i32(globalId[${p}]);`;else{const m=j$(f,"uniforms.outShape");a+=`var index${p} = i32(globalId[${p}]);`;for(let g=0;g<m.length;g++)a+=`let d${f[g]} = index${p} / ${m[g]};`,g===m.length-1?a+=`let d${f[g+1]} = index${p} - d${f[g]} * ${m[g]};`:a+=`index${p} = index${p} - d${f[g]} * ${m[g]};`}}const l=[];for(let p=0;p<r;p++)l.push(`d${p}`);const c=de(r);let h=`fn getOutputCoords() -> ${c} {
  ${a}
`;return l.length===0?h+=`return ${c}(0); }`:h+=`return ${c}(${l.join(",")}); }`,h}function nD(n){let t="";switch(n){case 0:case 1:t+=`
        fn getOutputIndexFromCoords(coords : i32) -> i32 {
          return coords;
        }
        `;break;case 2:t+=`
        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {
          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));
        }
        `;break;case 3:t+=`
        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {
          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));
        }
        `;break;case 4:t+=`
        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
          return dot(coords, vec4<i32>(
            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));
        }
        `;break;case 5:t+=`
        fn getOutputIndexFromCoords(coords : vec5) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u;
        }
        `;break;case 6:t+=`
        fn getOutputIndexFromCoords(coords : vec6) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u * uniforms.outShapeStrides.u +
              coords.v;
        }
        `;break;default:tt(!1,()=>`Unsupported ${n}D shape`);break}return t}function zy(n){return n.dispatch[1]===1&&n.dispatch[2]===1}function Rs(n,t=1){if(n==="float32")return Rt(t,"f32");if(n==="int32"||n==="bool")return Rt(t,"i32");throw new Error(`type ${n} is not supported.`)}function sD(n,t,e){const s=n.length,i=Rs(t,e);let o=`fn setOutputAtIndex(flatIndex : i32, value : ${Rt(e)}) {
      result[flatIndex] = ${i}(value);
    }

    fn setOutputAtIndexI32(flatIndex : i32, value : ${Rt(e,"i32")}) {
      result[flatIndex] = ${i}(value);
    }
    `;if(s>=2){const r=["d0","d1","d2","d3","d4","d5"].slice(0,s),a=de(s);o+=`
      fn setOutputAtCoords(${r.map(u=>`${u} : i32`).join(", ")}, value : ${Rt(e)}) {
        let flatIndex = getOutputIndexFromCoords(${a}(${r.join(", ")}));
        setOutputAtIndex(flatIndex${e===1?"":` / ${e}`}, value);
      }
      fn setOutputAtCoordsI32(${r.map(u=>`${u} : i32`).join(", ")}, value : ${Rt(e,"i32")}) {
        let flatIndex = getOutputIndexFromCoords(${a}(${r.join(", ")}));
        setOutputAtIndexI32(flatIndex${e===1?"":` / ${e}`}, value);
      }
    `}return o}function iD(n){const t=/(\w+)\s*:\s*vec(5|6)/g;n=n.replace(t,s=>"@align(16) "+s);const e=/vec(5|6)\s*,\s*(\w+)/g;return n=n.replace(e,(s,i,o)=>`vec${i}, @align(16) ${o}`),n}function _h(n){return!(n.dispatchLayout.hasOwnProperty("y")&&n.dispatchLayout.y.length!==0||n.dispatchLayout.hasOwnProperty("z")&&n.dispatchLayout.z.length!==0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ps=n=>{let t=1;for(let e=0;e<n.length;e++)t*=n[e];return t};function rt(n,t,e=[1,1,1],s=[1,1,1]){const[i,o,r]=[Math.ceil(Ps(n.x.map(a=>t[a]))/(e[0]*s[0])),n.y?Math.ceil(Ps(n.y.map(a=>t[a]))/(e[1]*s[1])):1,n.z?Math.ceil(Ps(n.z.map(a=>t[a]))/(e[2]*s[2])):1];return[i,o,r]}function oD(n,t,e,s=!1){const i=[8,8,1],o=[4,4,1];return s||(n<=8&&(o[1]=1),t<=16&&e<=16&&(i[0]=4)),{workgroupSize:i,elementsPerThread:o}}function Fy(n,t,e=!1){if(e)return[8,8,1];const s=Ps(n.x.map(o=>t[o])),i=Ps(n.y.map(o=>t[o]));return s<=4?[4,16,1]:i<=4?[16,4,1]:[16,16,1]}function My(n,t,e=!1){if(e)return[4,4,1];const s=Ps(n.x.map(o=>t[o])),i=Ps(n.y.map(o=>t[o]));return s<=4?[1,2,1]:i<=4?[2,1,1]:[2,2,1]}function ht(n){return{x:n.map((t,e)=>e)}}function Bh(n){if(n==="float32"||n==="int32"||n==="bool"||n==="string")return 4;if(n==="complex64")return 8;throw new Error(`Unknown dtype ${n}`)}function Py(){return!!(typeof globalThis<"u"&&globalThis.navigator&&globalThis.navigator.gpu)}function Ey(n,t){Array.isArray(n)||(n=[n]),n.forEach(e=>{e!=null&&tt(e.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the WebGPU backend.`)})}var Rn;(function(n){n[n.MatMulReduceProgram=0]="MatMulReduceProgram",n[n.MatMulSplitKProgram=1]="MatMulSplitKProgram",n[n.MatMulSmallOutputSizeProgram=2]="MatMulSmallOutputSizeProgram",n[n.MatMulPackedProgram=3]="MatMulPackedProgram",n[n.MatMulMax=4]="MatMulMax"})(Rn||(Rn={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rD=he().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD"),aD=(n,t)=>{const e=n.limits.maxComputeWorkgroupsPerDimension,s=t.dispatchLayout,i=t.dispatch;if(i.every(r=>r<=e))return i;tt(i[0]>e&&s.y===void 0&&s.z===void 0,()=>"Dispatch size exceeds WebGPU limits in Y or Z dimension.");let o=Math.ceil(Math.sqrt(i[0]));return o>e?(o=Math.ceil(Math.cbrt(i[0])),tt(o<=e,()=>"Total dispatch size exceeds WebGPU maximum."),[o,o,o]):[o,o,1]};class Ai extends Ip{nextDataId(){return Ai.nextDataId++}constructor(t,e){if(super(),this.commandQueueOwnedIds=new WeakSet,this.dispatchCountInPass=0,this.disposed=!1,this.downloadWaitMs=0,this.tensorDataPendingDisposal=[],this.queryResolveBuffer=null,this.querySet=null,this.querySetCount=2,this.stagingPendingDisposal=[],this.uniformPendingDisposal=[],this.uploadWaitMs=0,this.hasReadSyncWarned=!1,this.hasTimestampQueryWarned=!1,!Py())throw new Error("WebGPU is not supported on this device");this.pipelineCache={},this.device=t,this.queue=t.queue,this.commandEncoder=null,this.computePassEncoder=null,this.adapterInfo=new U$(e),this.supportTimestampQuery=this.device.features.has("timestamp-query"),this.thresholdToIncreaseWorkgroups=this.adapterInfo.intelGPUGeneration>=12?16:8,this.bufferManager=new G$(this.device),this.textureManager=new H$(this.device),this.tensorMap=new Np(this,ls()),he().getBool("WEBGPU_USE_PROFILE_TOOL")&&(this.dummyCanvas=document.createElement("canvas"),this.dummyCanvas.width=1,this.dummyCanvas.height=1,this.dummyContext=this.dummyCanvas.getContext("webgpu"),this.dummyContext.configure({device:t,format:"bgra8unorm"}),document.body.appendChild(this.dummyCanvas))}floatPrecision(){return 32}disposeData(t,e=!1){if(!this.tensorMap.has(t))return!0;const s=this.tensorMap.get(t);return e?s.refCount=0:s.refCount--,s.refCount>0?!1:(s.complexTensorInfos!=null&&(this.disposeData(s.complexTensorInfos.real.dataId),this.disposeData(s.complexTensorInfos.imag.dataId)),this.commandQueueOwnedIds.has(t)?(this.tensorDataPendingDisposal.push(t),!0):(this.releaseResource(t),this.tensorMap.delete(t),!0))}memory(){return{numBytesInGPU:this.bufferManager.numBytesUsed,numBytesAllocatedInGPU:this.bufferManager.numBytesAllocated,unreliable:!1}}releaseResource(t){const e=this.tensorMap.get(t);if(!(!e||!e.resource)){if(e.external){e.resource=null;return}e.resource instanceof GPUBuffer?this.bufferManager.releaseBuffer(e.resource):e.resource instanceof GPUTexture&&this.textureManager.releaseTexture(e.resource),e.resource=null}}refCount(t){return this.tensorMap.has(t)?this.tensorMap.get(t).refCount:0}incRef(t){const e=this.tensorMap.get(t);e.refCount++}decRef(t){if(this.tensorMap.has(t)){const e=this.tensorMap.get(t);e.refCount--}}write(t,e,s){if(s==="complex64"&&t!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const i={id:this.nextDataId()};return this.tensorMap.set(i,{dtype:s,shape:e,values:t,refCount:1}),i}move(t,e,s,i,o){if(i==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.tensorMap.set(t,{dtype:i,shape:s,values:e,refCount:o})}submitQueue(){this.queue.submit([this.commandEncoder.finish()]),this.commandEncoder=null,this.dispatchCountInPass=0,this.commandQueueOwnedIds=new WeakSet,this.tensorDataPendingDisposal.forEach(t=>{this.releaseResource(t),this.tensorMap.delete(t)}),this.uniformPendingDisposal.forEach(t=>this.bufferManager.releaseBuffer(t)),this.stagingPendingDisposal.forEach(t=>this.bufferManager.releaseBuffer(t,!1)),this.tensorDataPendingDisposal=[],this.uniformPendingDisposal=[],this.stagingPendingDisposal=[]}ensureCommandEncoderReady(){this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder())}endComputePassEncoder(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}async checkCompileCompletionAsync(){let t;try{t=await Promise.all(Object.values(this.pipelineCache))}catch(e){throw new Error(e.message)}Object.keys(this.pipelineCache).map((e,s)=>{this.pipelineCache[e]=t[s]})}async getBufferData(t){if(he().getBool("WEBGPU_ENGINE_COMPILE_ONLY"))return console.warn("The data may be invalid since WEBGPU_ENGINE_COMPILE_ONLY is true, this can only be called when WEBGPU_ENGINE_COMPILE_ONLY is false"),null;const e=t.size,s=this.bufferManager.acquireBuffer(e,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(t,0,s,0,e),this.submitQueue(),await s.mapAsync(GPUMapMode.READ);const i=s.getMappedRange().slice(0);return s.unmap(),s!=null&&this.bufferManager.releaseBuffer(s),he().getBool("WEBGPU_USE_PROFILE_TOOL")&&(tt(this.dummyContext!==void 0,()=>"Fail to get context for profiling tool"),this.dummyContext.getCurrentTexture()),i}convertAndCacheOnCPU(t,e){const s=this.tensorMap.get(t);return s.values=e,s.values}readSync(t){const e=this.tensorMap.get(t),{values:s,complexTensorInfos:i}=e;if(s!=null||e.dtype==="string")return s;if(e.dtype==="complex64"){const g=this.readSync(i.real.dataId),b=this.readSync(i.imag.dataId),v=Bo(di(g,b).buffer,"float32");return this.convertAndCacheOnCPU(t,v),v}this.hasReadSyncWarned||(this.hasReadSyncWarned=!0,console.warn("The performance of synchronously reading data from GPU to CPU is poor on the webgpu backend, please use asynchronous APIs instead."));const o=["opaque","premultiplied"],r=e.resource,a=r.size;tt(a%4===0,()=>"Because there is 4 bytes for one pixel, buffer size must be multiple of 4.");const u=a/4,l=new ArrayBuffer(a),c=256,h=256,p=o.map(g=>new OffscreenCanvas(c,h)),f=new OffscreenCanvas(c,h);this.endComputePassEncoder(),p.map((g,b)=>{const v=g.getContext("webgpu");return v.configure({device:this.device,format:"bgra8unorm",usage:GPUTextureUsage.COPY_DST,alphaMode:o[b]}),v.getCurrentTexture()}).map((g,b)=>{const v=c*4,w=(A,z,F)=>{this.ensureCommandEncoderReady(),this.commandEncoder.copyBufferToTexture({buffer:r,bytesPerRow:v,offset:F},{texture:g},{width:A,height:z}),this.submitQueue();const E=f.getContext("2d",{willReadFrequently:!0});E.clearRect(0,0,A,z),E.drawImage(p[b],0,0);const U=E.getImageData(0,0,A,z).data,L=o[b],W=new Uint8ClampedArray(l,F,A*z*4);for(let _=0;_<W.length;_+=4)if(L==="premultiplied")W[_+3]=U[_+3];else{const V=U[_];W[_]=U[_+2],W[_+1]=U[_+1],W[_+2]=V}},k=Math.floor(u/(c*h));let C=c,I=h,N=0;for(let A=0;A<k;A++)w(C,I,N),N+=c*h*4;const $=u%(c*h);I=Math.floor($/c),I>0&&(w(C,I,N),N+=I*(c*4)),C=$%c,C>0&&w(C,1,N)});const m=Bo(l,e.dtype);return this.convertAndCacheOnCPU(t,m),m}async read(t){if(!this.tensorMap.has(t))throw new Error(`Tensor ${t} was not registered!`);const e=this.tensorMap.get(t),{values:s}=e;if(s!=null)return s;let i;if(e.dtype==="complex64"){const o=await Promise.all([this.read(e.complexTensorInfos.real.dataId),this.read(e.complexTensorInfos.imag.dataId)]),r=o[0],a=o[1];i=di(r,a)}else{const o=await this.getBufferData(e.resource);i=Bo(o,e.dtype)}return this.convertAndCacheOnCPU(t,i),i}copyBuffer(t){const e=t.size,s=t.usage,i=this.bufferManager.acquireBuffer(e,s);return this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(t,0,i,0,e),this.submitQueue(),i}createTensorFromGPUData(t,e,s){let i=t.buffer;if(s==="complex64")throw new Error("Cannot write to a complex64 dtype. ");const o={id:this.nextDataId()};this.tensorMap.set(o,{dtype:s,shape:e,values:null,refCount:1,external:t.zeroCopy});const r=this.tensorMap.get(o),a=Bh(r.dtype)*et(r.shape);if(t.buffer.size<a)throw new Error(`GPUBuffer size(${t.buffer.size}) is smaller than tensor size(${a})!`);if((t.buffer.usage&(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))!==(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))throw new Error("GPUBuffer.usage should include GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC!");return t.zeroCopy!==!0&&(i=this.copyBuffer(i)),r.resource=i,ls().makeTensorFromDataId(o,e,s,this)}readToGPU(t){const e=this.tensorMap.get(t),{values:s,dtype:i,shape:o,resource:r}=e;if(i==="complex64")throw new Error("Does not support reading buffer for complex64 dtype.");if(r==null)throw s!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const a=r,u=a.size,l=a.usage,c=this.bufferManager.acquireBuffer(u,l);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(r,0,c,0,u),this.submitQueue();const h=this.makeTensorInfo(o,i),p=ls().makeTensorFromTensorInfo(h),f=this.tensorMap.get(h.dataId);return f.resource=c,{tensorRef:p,buffer:c}}bufferSync(t){const e=this.readSync(t.dataId);if(t.dtype==="string")try{const s=e.map(i=>ho(i));return ue(t.shape,t.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return ue(t.shape,t.dtype,e)}async time(t){!this.supportTimestampQuery&&!this.hasTimestampQueryWarned&&(console.warn("This device doesn't support timestamp-query extension. Start Chrome browser with flag --enable-dawn-features=allow_unsafe_apis to try it again. Otherwise, zero will be shown for the kernel time when profiling mode is enabled."),this.hasTimestampQueryWarned=!0);const e=this.activeTimers,s=[];let i=!1;this.programTimersStack==null?(this.programTimersStack=s,i=!0):this.activeTimers.push(s),this.activeTimers=s,t();const o=th(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),r=th(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=e,i&&(this.programTimersStack=null);const a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},u=await Promise.all(o);return a.kernelMs=d1(u),a.getExtraProfileInfo=()=>u.map((l,c)=>({name:r[c],ms:l})).map(l=>`${l.name}: ${l.ms}`).join(", "),this.uploadWaitMs=0,this.downloadWaitMs=0,a}makeTensorInfo(t,e,s){return e==="string"&&s!=null&&s.length>0&&$p(s[0])&&(s=s.map(o=>Dp(o))),{dataId:this.write(s,t,e),shape:t,dtype:e}}tensorToBinding(t){if(!t)return null;const s=this.tensorMap.get(t.dataId).resource;return s instanceof GPUBuffer?{buffer:s}:s instanceof GPUTexture?s.createView():s}uploadToGPU(t){const e=this.tensorMap.get(t);if(e.resource!=null)return;const s=Bh(e.dtype)*et(e.shape);let i;const o=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST;if(e.values){if(i=this.bufferManager.acquireBuffer(s,o,!0),i.mapState==="unmapped"){const r=this.bufferManager.acquireBuffer(s,GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,!0,!1),a=r.getMappedRange();e.dtype==="int32"||e.dtype==="bool"?new Int32Array(a).set(e.values):new Float32Array(a).set(e.values),r.unmap(),this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(r,0,i,0,s),this.stagingPendingDisposal.push(r)}else{const r=i.getMappedRange();e.dtype==="int32"||e.dtype==="bool"?new Int32Array(r).set(e.values):new Float32Array(r).set(e.values),i.unmap()}e.values=null}else i=this.bufferManager.acquireBuffer(s,o);e.resource=i}makeUniforms(t){let e=0,s=0;const i=[];let o=1;t.forEach(u=>{u.data.length===0&&(u.data=[1]);let l;switch(u.data.length){case 1:l=4;break;case 2:l=8;break;case 3:l=16;break;case 4:l=16;break;case 5:l=16;break;case 6:l=16;break;default:tt(!1,()=>`Unsupported ${u.data.length}D shape`)}(s===5||s===6)&&(l=16),l>o&&(o=l),e=Math.ceil(e/l)*l,s=u.data.length,i.push(e),e+=u.data.length*4}),e=Math.ceil(e/o)*o;const r=new ArrayBuffer(e);t.forEach((u,l)=>{const c=i[l];u.type==="int32"?new Int32Array(r,c,u.data.length).set(u.data):u.type==="uint32"?new Uint32Array(r,c,u.data.length).set(u.data):new Float32Array(r,c,u.data.length).set(u.data)});const a=this.bufferManager.acquireBuffer(e,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);return this.queue.writeBuffer(a,0,r,0,e),this.uniformPendingDisposal.push(a),{offset:0,size:e,buffer:a}}runWebGPUProgram(t,e,s,i,o){if(o||(o=this.makeTensorInfo(t.outputShape,s)),et(o.shape)===0)return this.tensorMap.get(o.dataId).values=Ln(o.dtype,0),o;this.uploadToGPU(o.dataId),t.dispatch=aD(this.device,t);const r=e.map((u,l)=>{if(u.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");return this.uploadToGPU(u.dataId),{dtype:this.tensorMap.get(u.dataId).dtype,shape:u.shape,name:t.variableNames[l]}});t.shaderKey=Y$(t,r,o);const a=he().getBool("WEBGPU_ENGINE_COMPILE_ONLY");return t.shaderKey in this.pipelineCache||(this.pipelineCache[t.shaderKey]=K$(this.device,t,r,o,a)),t.pipeline=this.pipelineCache[t.shaderKey],a||this.recordAndSubmit(t,o,e,i),o}recordAndSubmit(t,e,s,i){if(t.pipeline instanceof Promise)throw new Error("Please call checkCompileCompletionAsync to ensure parallel compilation is done!");let o=[],r=[];const a="int32";if(t.pixelsOpType==null){o.push({type:"float32",data:[NaN]},{type:"float32",data:[1/0]}),r=s.concat(e).map(f=>f.shape);const p="int32";r.map(f=>{o.push({type:p,data:f});const m=Tt(f);o.push({type:p,data:m})})}else{const p=Tt(e.shape);o.push({type:a,data:p})}if(t.size){const p=et(t.outputShape);o.push({type:a,data:[t.outputComponent?p/t.outputComponent:p]})}i&&(o=[...o,...i]);const u=[this.tensorToBinding(e),...s.map(p=>this.tensorToBinding(p)),this.makeUniforms(o)];s.forEach(p=>{this.commandQueueOwnedIds.add(p.dataId)}),this.commandQueueOwnedIds.add(e.dataId);const l=this.device.createBindGroup({layout:t.pipeline.getBindGroupLayout(0),entries:u.map((p,f)=>({binding:f,resource:p}))}),c=this.activeTimers!=null;this.ensureCommandEncoderReady();const h={};c&&this.supportTimestampQuery?(this.endComputePassEncoder(),this.querySet==null&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.querySetCount})),h.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:0,endOfPassWriteIndex:1},this.computePassEncoder=this.commandEncoder.beginComputePass(h)):this.computePassEncoder||(this.computePassEncoder=this.commandEncoder.beginComputePass(h)),this.computePassEncoder.setPipeline(t.pipeline),this.computePassEncoder.setBindGroup(0,l),this.computePassEncoder.dispatchWorkgroups(t.dispatch[0],t.dispatch[1],t.dispatch[2]),this.dispatchCountInPass++,(c||he().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE")<=this.dispatchCountInPass||t.pixelsOpType===bi.DRAW)&&(this.endComputePassEncoder(),c?this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime()}):this.submitQueue())}async getQueryTime(){if(!this.supportTimestampQuery)return 0;this.queryResolveBuffer==null&&(this.queryResolveBuffer=this.bufferManager.acquireBuffer(this.querySetCount*8,GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST|GPUBufferUsage.QUERY_RESOLVE)),this.commandEncoder.resolveQuerySet(this.querySet,0,this.querySetCount,this.queryResolveBuffer,0);const t=this.bufferManager.acquireBuffer(this.querySetCount*8,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,t,0,this.querySetCount*8),this.submitQueue(),await t.mapAsync(GPUMapMode.READ);const e=new BigUint64Array(t.getMappedRange()),s=Number(e[1]-e[0])/1e6;return t.unmap(),this.bufferManager.releaseBuffer(t),s}shouldExecuteOnCPU(t,e=rD){return he().getBool("WEBGPU_CPU_FORWARD")&&t.every(s=>this.tensorMap.get(s.dataId).resource==null&&et(s.shape)<e)}numDataIds(){return this.tensorMap.numDataIds()-this.tensorDataPendingDisposal.length}dispose(){this.disposed||(this.querySet!=null&&this.querySet.destroy(),this.bufferManager.dispose(),this.textureManager.dispose(),this.disposed=!0)}}Ai.nextDataId=0;/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Py()&&Rp("webgpu",async()=>{const n={powerPreference:he().get("WEBGPU_USE_LOW_POWER_GPU")?"low-power":"high-performance"},t=await navigator.gpu.requestAdapter(n),e={},s=[];t.features.has("timestamp-query")&&s.push("timestamp-query"),t.features.has("bgra8unorm-storage")&&s.push(["bgra8unorm-storage"]),e.requiredFeatures=s;const i=t.limits;e.requiredLimits={maxComputeWorkgroupStorageSize:i.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:i.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:i.maxStorageBufferBindingSize,maxBufferSize:i.maxBufferSize,maxComputeWorkgroupSizeX:i.maxComputeWorkgroupSizeX,maxComputeInvocationsPerWorkgroup:i.maxComputeInvocationsPerWorkgroup};const o=await t.requestDevice(e),r=await t.requestAdapterInfo();return new Ai(o,r)},3);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var vt;(function(n){n[n.ADD=0]="ADD",n[n.ATAN2=1]="ATAN2",n[n.COMPLEX_MULTIPLY_IMAG=2]="COMPLEX_MULTIPLY_IMAG",n[n.COMPLEX_MULTIPLY_REAL=3]="COMPLEX_MULTIPLY_REAL",n[n.DIV=4]="DIV",n[n.ELU_DER=5]="ELU_DER",n[n.EQUAL=6]="EQUAL",n[n.FLOOR_DIV=7]="FLOOR_DIV",n[n.GREATER=8]="GREATER",n[n.GREATER_EQUAL=9]="GREATER_EQUAL",n[n.LESS=10]="LESS",n[n.LESS_EQUAL=11]="LESS_EQUAL",n[n.LOGICAL_AND=12]="LOGICAL_AND",n[n.LOGICAL_OR=13]="LOGICAL_OR",n[n.MAX=14]="MAX",n[n.MIN=15]="MIN",n[n.MOD=16]="MOD",n[n.MUL=17]="MUL",n[n.NOT_EQUAL=18]="NOT_EQUAL",n[n.POW=19]="POW",n[n.PRELU=20]="PRELU",n[n.SQUARED_DIFFERENCE=21]="SQUARED_DIFFERENCE",n[n.SUB=22]="SUB"})(vt||(vt={}));const uD="let resultTemp = a + b;",lD="let resultTemp = atan2(a, b);",cD="let resultTemp = areal * breal - aimag * bimag;",hD="let resultTemp = areal * bimag + aimag * breal;",dD="let resultTemp = a / b;",pD="let resultTemp = select(a * (b + 1.0), a, b >= b - b);",fD=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a == b);
`,mD=`
  let remainder =
      select(a % b, round(a % b), (round(a) == a) & (round(b) == b));
  let quotient = (a - remainder) / b;
  let resultTemp =
      round(select(quotient, quotient - 1, sign(remainder) == -sign(b)));
`,gD=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a > b);
`,yD=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a >= b);
`,bD=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a < b);
`,xD=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a <= b);
`,wD="return f32(a >= 1.0 && b >= 1.0);",vD=`return (vec4<f32>(a >= vec4<f32>(1.0)) *
  vec4<f32>(b >= vec4<f32>(1.0)));`,CD="return f32(a >= 1.0 || b >= 1.0);",kD=`return min(vec4<f32>(a >= vec4<f32>(1.0)) +
  vec4<f32>(b >= vec4<f32>(1.0)), vec4<f32>(1.0));`,SD="let resultTemp = max(a, b);",ID="let resultTemp = min(a, b);",ND=`
  let isNaN = b == 0.;
  var resultTemp = a % b;
  resultTemp = select((resultTemp + b) % b, resultTemp,
      (a < 0. && b < 0.) || (a >= 0. && b > 0.));
`,$D=`
  let isNaN = !vec4<bool>(b);
  var resultTemp = vec4<f32>(a % b);
  if (!((a[0] < 0. && b[0] < 0.) || (a[0] >= 0. && b[0] > 0.))) {
    resultTemp[0] = (resultTemp[0] + b[0]) % b[0];
  }
  if (!((a[1] < 0. && b[1] < 0.) || (a[1] >= 0. && b[1] > 0.))) {
    resultTemp[1] = (resultTemp[1] + b[1]) % b[1];
  }
  if (!((a[2] < 0. && b[2] < 0.) || (a[2] >= 0. && b[2] > 0.))) {
    resultTemp[2] = (resultTemp[2] + b[2]) % b[2];
  }
  if (!((a[3] < 0. && b[3] < 0.) || (a[3] >= 0. && b[3] > 0.))) {
    resultTemp[3] = (resultTemp[3] + b[3]) % b[3];
  }
`,DD="let resultTemp = a * b;",RD=`
  var resultTemp = f32(a != b);
  let valueForNaN = 1.0;
`,AD=`
  var resultTemp = vec4<f32>(a != b);
  let valueForNaN = 1.0;
`,TD=`
  let isNaN = a < 0.0 && floor(b) < b;
  if (b == 0.0) {
    return 1.0;
  }
  var resultTemp = select(sign(a) * pow(abs(a), b), pow(abs(a), b),
      round(abs(b) % 2.0) != 1.0);
`,zD=`
  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);
  let isModRound1 = vec4<f32>(isModRound1Bool);
  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);
  var resultTemp = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  let isExpZero = b == vec4<f32>(0.0);
  if (isExpZero.r) {
    resultTemp.r = 1.0;
  }
  if (isExpZero.g) {
    resultTemp.g = 1.0;
  }
  if (isExpZero.b) {
    resultTemp.b = 1.0;
  }
  if (isExpZero.a) {
    resultTemp.a = 1.0;
  }
  let isNaN = (a < vec4<f32>(0.0)) & (floor(b) < b);
`,FD="if (a < 0.0) { return b * a; }  return a;",MD=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`,PD="let resultTemp = (a - b) * (a - b);",ED="let resultTemp = a - b;";function uc(n,t){let e;do{switch(n){case vt.ATAN2:e=lD;break;case vt.MAX:e=SD;break;case vt.MIN:e=ID;break;case vt.MOD:e=t?$D:ND;break;case vt.NOT_EQUAL:e=t?AD:RD;break;case vt.POW:e=t?zD:TD;break;default:continue}let s,i,o;return t?(s="isnanVec4",i="vec4<f32>",o="vec4<bool>"):(s="isnan",i="f32",o="bool"),`
      let aIsNaN = ${s}(a);
      let aPostLegalization = select(a, ${i}(42), aIsNaN);
      let bIsNaN = ${s}(b);
      let bPostLegalization = select(b, ${i}(42), bIsNaN);
      let isNaN = false;
      let valueForNaN = uniforms.NAN;
      {
        let a = aPostLegalization;
        let b = bPostLegalization;
        ${e}
        return select(
            resultTemp, ${i}(valueForNaN),
            ${o}(isNaN) | aIsNaN | bIsNaN);
      }
    `}while(!1);switch(n){case vt.ADD:e=uD;break;case vt.COMPLEX_MULTIPLY_IMAG:e=hD;break;case vt.COMPLEX_MULTIPLY_REAL:e=cD;break;case vt.DIV:e=dD;break;case vt.ELU_DER:e=pD;break;case vt.EQUAL:e=fD;break;case vt.FLOOR_DIV:e=mD;break;case vt.GREATER:e=gD;break;case vt.GREATER_EQUAL:e=yD;break;case vt.LESS:e=bD;break;case vt.LESS_EQUAL:e=xD;break;case vt.LOGICAL_AND:return t?vD:wD;case vt.LOGICAL_OR:return t?kD:CD;case vt.MUL:e=DD;break;case vt.PRELU:return t?MD:FD;case vt.SQUARED_DIFFERENCE:e=PD;break;case vt.SUB:e=ED;break}return`
    ${e}
    return resultTemp;
  `}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var st;(function(n){n[n.ABS=0]="ABS",n[n.ACOS=1]="ACOS",n[n.ACOSH=2]="ACOSH",n[n.ASIN=3]="ASIN",n[n.ASINH=4]="ASINH",n[n.ATAN=5]="ATAN",n[n.ATANH=6]="ATANH",n[n.CEIL=7]="CEIL",n[n.COS=8]="COS",n[n.COSH=9]="COSH",n[n.ELU=10]="ELU",n[n.ERF=11]="ERF",n[n.EXP=12]="EXP",n[n.EXPM1=13]="EXPM1",n[n.FLOOR=14]="FLOOR",n[n.IS_FINITE=15]="IS_FINITE",n[n.IS_INF=16]="IS_INF",n[n.IS_NAN=17]="IS_NAN",n[n.LINEAR=18]="LINEAR",n[n.LOG=19]="LOG",n[n.LOG1P=20]="LOG1P",n[n.LOGICAL_NOT=21]="LOGICAL_NOT",n[n.NEG=22]="NEG",n[n.RELU=23]="RELU",n[n.RELU6=24]="RELU6",n[n.LEAKYRELU=25]="LEAKYRELU",n[n.RECIPROCAL=26]="RECIPROCAL",n[n.ROUND=27]="ROUND",n[n.RSQRT=28]="RSQRT",n[n.SELU=29]="SELU",n[n.SIGMOID=30]="SIGMOID",n[n.SIGN=31]="SIGN",n[n.SIN=32]="SIN",n[n.SINH=33]="SINH",n[n.SOFTPLUS=34]="SOFTPLUS",n[n.SQRT=35]="SQRT",n[n.SQUARE=36]="SQUARE",n[n.STEP=37]="STEP",n[n.TAN=38]="TAN",n[n.TANH=39]="TANH",n[n.TO_INT=40]="TO_INT"})(st||(st={}));const LD="return abs(a);",OD=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return acos(a);
`,_D=`
  if (a < 1.) {
    return uniforms.NAN;
  }
  return acosh(a);
`,BD=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return asin(a);
`,WD="return asinh(a);",VD=`
  if (isnan(a)) {
    return uniforms.NAN;
  }
  return atan(a);
`,UD=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  if (a == 1.) {
    return uniforms.INFINITY;
  }
  if (a == -1.) {
    return -uniforms.INFINITY;
  }
  return atanh(a);
`,GD="return ceil(a);",HD="return cos(a);",jD=`
  let e2x = exp(-a);
  return (e2x + 1.0 / e2x) / 2.0;
`,KD="return exp(a) - 1.0;",XD="if (a >= 0.0) { return a; }  return (exp(a) - 1.0);",qD=`
  var resFloat = exp(a) - vec4<f32>(1.0);
  if (a.r >= 0.0) {
    resFloat.r = a.r;
  }
  if (a.g >= 0.0) {
    resFloat.g = a.g;
  }
  if (a.b >= 0.0) {
    resFloat.b = a.b;
  }
  if (a.a >= 0.0) {
    resFloat.a = a.a;
  }
  return resFloat;
`,YD=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  let p = ${cf};
  let a1 = ${of};
  let a2 = ${rf};
  let a3 = ${af};
  let a4 = ${uf};
  let a5 = ${lf};

  let sign = sign(a);
  let absA = abs(a);
  let t = 1.0 / (1.0 + p * absA);
  return sign * (1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-absA * absA));
`,ZD="return exp(a);",QD="return floor(a);",JD="return f32(!isnan(a) && !isinf(a));",tR="return f32(isinf(a));",eR="return f32(isnan(a));",nR="return a;",sR=`if (a < 0.0) { return uniforms.NAN; }
  return log(a);`,iR=`
  if (isnan(a)) { return a; }
  return log(1.0 + a);
`,oR="return f32(!(a >= 1.0));",rR="return -a;",aR="if (a < 0.0) { return uniforms.alpha * a; } return a;",uR=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`,lR="return 1.0 / a;",cR="return select(a, 0.0, a < 0.0);",hR="return clamp(a, 0.0, 6.0);",dR="return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));",pR=`
  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));
`,fR="return round(a);",mR="return inverseSqrt(a);",gR=`
  if (a >= 0.0) {
    return ${dl} * a;
  } else {
    return ${hl} * (exp(a) - 1.0);
  }
`,yR="return 1.0 / (1.0 + exp(-1.0 * a));",bR="return sign(a);",xR="return sin(a);",wR=`
  let e2x = exp(a);
  return (e2x - 1.0 / e2x) / 2.0;
`,vR=`
  let epsilon = 1.1920928955078125e-7;
  let threshold = log(epsilon) + 2.0;

  let too_large = a > -threshold;
  let too_small = a < threshold;
  let exp_a = exp(a);

  if (too_large) {
    return a;
  } else if (too_small) {
    return exp_a;
  } else {
    return log(exp_a + 1.0);
  }
`,CR="return sqrt(a);",kR="return a * a;",SR=`
  if (isnan(a)) {
    return a;
  }

  return select(uniforms.stepAlpha, 1.0, a > 0.0);
`,IR="return tan(a);",NR=`
  let e2x = exp(-2.0 * abs(a));
  return sign(a) * (1.0 - e2x) / (1.0 + e2x);
`,$R="return f32(i32((a)));";function $s(n,t){switch(n){case st.ABS:return LD;case st.ACOS:return OD;case st.ACOSH:return _D;case st.ASIN:return BD;case st.ASINH:return WD;case st.ATAN:return VD;case st.ATANH:return UD;case st.COS:return HD;case st.COSH:return jD;case st.CEIL:return GD;case st.ELU:return t?qD:XD;case st.ERF:return YD;case st.EXP:return ZD;case st.EXPM1:return KD;case st.FLOOR:return QD;case st.IS_FINITE:return JD;case st.IS_INF:return tR;case st.IS_NAN:return eR;case st.LINEAR:return nR;case st.LOG:return sR;case st.LOG1P:return iR;case st.LOGICAL_NOT:return oR;case st.NEG:return rR;case st.LEAKYRELU:return t?uR:aR;case st.RECIPROCAL:return lR;case st.RELU:return t?pR:cR;case st.RELU6:return t?dR:hR;case st.ROUND:return fR;case st.RSQRT:return mR;case st.SELU:return gR;case st.SIGMOID:return yR;case st.SIGN:return bR;case st.SIN:return xR;case st.SINH:return wR;case st.SOFTPLUS:return vR;case st.SQRT:return CR;case st.SQUARE:return kR;case st.STEP:return SR;case st.TAN:return IR;case st.TANH:return NR;case st.TO_INT:return $R;default:throw new Error(`BinaryType ${n} is not implemented!`)}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function is(n,t=!1,e=!1,s=3){if(n===null)return"";let i="";if(n==="linear")i=$s(st.LINEAR);else if(n==="relu")i=$s(st.RELU,e);else if(n==="elu")i=$s(st.ELU,e);else if(n==="relu6")i=$s(st.RELU6,e);else if(n==="prelu")i=uc(vt.PRELU,e);else if(n==="sigmoid")i=$s(st.SIGMOID,e);else if(n==="leakyrelu")i=$s(st.LEAKYRELU,e);else throw new Error(`Activation ${n} has not been implemented for the WebGPU backend.`);const r=Rt(e?4:1);let a="";return t?a=`
      fn activation(a : ${r}, coords : vec${s}<i32>) -> ${r} {
        let b = getPreluActivationWeightsByOutputCoords(coords);
        ${i}
      }`:a=`
      fn activation(a : ${r}, coords : vec${s}<i32>) -> ${r} {
        ${i}
      }`,a}function Ks(n,t){return`
      ${n?"value = value + getBiasByOutputCoords(coords);":""}
      ${t?"value = activation(value, coords);":""}
      `}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ly(n,t,e=!1,s=!1,i=!1,o=1){tt(n&&o===1||!n,()=>`transposeA ${n} is not compatible with component size ${o}`);const r=`
      ${n?"value = getA(batch, col, row);":"value = getA(batch, row, col);"}

    `,a=t?"value = getB(batch, col, row);":"value = getB(batch, row, col);";return`
  fn mm_readA(batch: i32, row: i32, col: i32) -> ${Rt(o)} {
    var value = ${Rt(o)}(0.0);
    ${e&&i?r:`
    ${n?"if(row < uniforms.dimAOuter && col < uniforms.dimInner)":"if(row < uniforms.aShape[1] && col < uniforms.aShape[2])"}
    {
      ${r}
    }
    `}
    return value;
  }

  fn mm_readB(batch: i32, row: i32, col: i32) -> ${Rt(o)} {
    var value = ${Rt(o)}(0.0);
    ${a}
    return value;
  }
  `}function lc(n,t,e,s,i=!1,o=!1,r=!1,a=1){return`
  ${Ly(e,s,i,o,r,a)}
  fn mm_write(batch: i32, row: i32, col: i32, valueIn: ${Rt(a)}) {
    ${i&&o?"":"if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)"}
    {
      var value = valueIn;
      let coords = vec3<i32>(batch, row, col);
      ${Ks(n,t)}
      setOutputAtCoords(coords[0], coords[1], coords[2], value);
    }
  }
  `}const DR=(n,t)=>n?`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol * ${t});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRow + innerRow,
          kStart + inputCol * ${t});
        `,RR=(n,t,e,s)=>{if(n)return`
      for (var k = 0; k < ${s}; k++) {
        let BCached0 = mm_Bsub[k][tileCol];
        let ACached0 = mm_Asub[k][localRow];
        for (var i = 0; i < ${e}; i++) {
          acc[i] = fma(BCached0, vec4<f32>(ACached0[i]), acc[i]);
        }
      }`;{let i="",o="";for(let r=0;r<t;r++)i+=`let BCached${r} = mm_Bsub[k * ${t} + ${r}][tileCol];`,o+=`acc[i] = fma(BCached${r}, vec4<f32>(ACached[${r}]), acc[i]);`;return`
      for (var k = 0; k < ${s/t}; k++) {
        ${i}
        for (var i = 0; i < ${e}; i++) {
          let ACached = mm_Asub[tileRow + i][k];
          ${o}
        }
      }`}};function ha(n,t,e=!1,s=32,i=!1,o=32,r=!1){const a=t[1]*n[1],u=t[0]*n[0],l=e?a:s,c=e?s:a,h=l/t[0],p=s/t[1],f=n[1],m=n[0];return tt((e&&h===4&&n[1]===4||!e&&(h===3||h===4))&&l%t[0]===0&&s%t[1]===0&&n[0]===4,()=>`If transposeA ${e} is true, innerElementSize ${h} and workPerThread[1] ${n[1]} must be 4.
          Otherwise, innerElementSize ${h} must be 3 or 4.
      tileAWidth ${l} must be divisible by workgroupSize[0]${t[0]}. tileInner ${s} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${n[0]} must be 4.`),`
  var<workgroup> mm_Asub : array<array<vec${h}<f32>, ${l/h}>, ${c}>;
  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${u/n[0]}>, ${s}>;

  ${ot()} {
    let localRow = i32(localId.y);
    let tileRow = localRow * ${f};
    let tileCol = i32(localId.x);

    let globalRow = i32(globalId.y) * ${f};
    let globalCol = i32(globalId.x) * ${m};
    let batch = ${i?"0":"i32(globalId.z)"};
    let batchA = ${i||!r?"batch":"batch % uniforms.aShape[0]"};
    let batchB = ${i||!r?"batch":"batch % uniforms.bShape[0]"};
    let globalRowStart = i32(workgroupId.y) * ${a};

    let numTiles = ${i?`${Math.ceil(o/s)}`:`(uniforms.dimInner - 1) / ${s} + 1`};
    var kStart = ${i?`i32(globalId.z) * ${o}`:"0"};

    var acc: array<vec4<f32>, ${f}>;

    // Loop over shared dimension.
    let tileRowB = localRow * ${p};
    for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var innerRow = 0; innerRow < ${f}; innerRow++) {
            let inputRow = tileRow + innerRow;
            let inputCol = tileCol;
            ${DR(e,h)}
        }

        // Load one tile of B into local memory.
        for (var innerRow = 0; innerRow < ${p}; innerRow++) {
            let inputRow = tileRowB + innerRow;
            let inputCol = tileCol;
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB, kStart + inputRow, globalCol);
        }
        kStart = kStart + ${s};
        workgroupBarrier();

        // Compute acc values for a single thread.
        ${RR(e,h,f,s)}
        workgroupBarrier();
    }

    for (var innerRow = 0; innerRow < ${f}; innerRow++) {
        mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
    }
  }`}const Wh=n=>n?`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol);
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRowStart + inputRow,
          kStart + inputCol);
        `,AR=n=>n?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];";function da(n,t,e=!1,s=32,i=!1,o=32,r=!1,a=!1){const u=n[1]*t[1],l=n[0]*t[0],c=e?u:s,h=e?s:u;tt(h%t[1]===0&&c%t[0]===0&&s%t[1]===0,()=>`tileAHight ${h} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${c} must be divisible by workgroupSize[0]${t[0]}, tileInner ${s} must be divisible by workgroupSize[1]${t[1]}`);const p=h/t[1],f=c/t[0],m=s/t[1],g=n[1],b=n[0],v=r?`
      let localRow = i32(localId.y);
      let localCol = i32(localId.x);
      let globalRowStart = i32(workgroupId.y) * ${u};
      let globalColStart = i32(workgroupId.x) * ${l};

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var inputRow = localRow; inputRow < ${h}; inputRow = inputRow + ${t[1]}) {
          for (var inputCol = localCol; inputCol < ${c}; inputCol = inputCol + ${t[0]}) {
            ${Wh(e)}
          }
        }
        // Load one tile of B into local memory.
        for (var inputRow = localRow; inputRow < ${s}; inputRow = inputRow + ${t[1]}) {
              for (var inputCol = localCol; inputCol < ${l}; inputCol = inputCol + ${t[0]}) {
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
              kStart + inputRow,
              globalColStart + inputCol);
          }
        }
        kStart = kStart + ${s};
        workgroupBarrier();

        // Compute acc values for a single thread.
        var BCached : array<f32, ${b}>;
        for (var k = 0; k < ${s}; k++) {
          for (var inner = 0; inner < ${b}; inner++) {
            BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];
          }
          for (var innerRow = 0; innerRow < ${g}; innerRow++) {
            let ACached = ${e?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}
            for (var innerCol = 0; innerCol < ${b}; innerCol++) {
              acc[innerRow][innerCol] =
                  fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
            }
          }
        }
        workgroupBarrier();
      }
      for (var innerRow = 0; innerRow < ${g}; innerRow++) {
        let gRow = globalRowStart + localRow + innerRow * ${t[1]};
        for (var innerCol = 0; innerCol < ${b}; innerCol++) {
          let gCol = globalColStart + localCol + innerCol * ${t[0]};
          mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
        }
      }
      `:`
  let tileRow = i32(localId.y) * ${g};
  let tileCol = i32(localId.x) * ${b};

  let globalRow = i32(globalId.y) * ${g};
  let globalCol = i32(globalId.x) * ${b};
  let globalRowStart = i32(workgroupId.y) * ${u};

  let tileRowA = i32(localId.y) * ${p};
  let tileColA = i32(localId.x) * ${f};
  let tileRowB = i32(localId.y) * ${m};
  // Loop over shared dimension.
  for (var t = 0; t < numTiles; t++) {
    // Load one tile of A into local memory.
    for (var innerRow = 0; innerRow < ${p}; innerRow++) {
      for (var innerCol = 0; innerCol < ${f}; innerCol++) {
        let inputRow = tileRowA + innerRow;
        let inputCol = tileColA + innerCol;
        ${Wh(e)}
      }
    }

    // Load one tile of B into local memory.
    for (var innerRow = 0; innerRow < ${m}; innerRow++) {
      for (var innerCol = 0; innerCol < ${b}; innerCol++) {
        let inputRow = tileRowB + innerRow;
        let inputCol = tileCol + innerCol;
        mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
          kStart + inputRow,
          globalCol + innerCol);
      }
    }
    kStart = kStart + ${s};
    workgroupBarrier();

    // Compute acc values for a single thread.
    var BCached : array<f32, ${b}>;
    for (var k = 0; k < ${s}; k++) {
      for (var inner = 0; inner < ${b}; inner++) {
        BCached[inner] = mm_Bsub[k][tileCol + inner];
      }

      for (var innerRow = 0; innerRow < ${g}; innerRow++) {
        ${AR(e)}
        for (var innerCol = 0; innerCol < ${b}; innerCol++) {
          acc[innerRow][innerCol] =
              fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
        }
      }
    }

    workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < ${g}; innerRow++) {
    for (var innerCol = 0; innerCol < ${b}; innerCol++) {
      mm_write(batch, globalRow + innerRow, globalCol + innerCol,
          acc[innerRow][innerCol]);
    }
  }
  `;return`
    var<workgroup> mm_Asub : array<array<f32, ${c}>, ${h}>;
    var<workgroup> mm_Bsub : array<array<f32, ${l}>, ${s}>;

    ${ot()} {
      let batch = ${i?"0":"i32(globalId.z)"};
      let batchA = ${i||!a?"batch":"batch % uniforms.aShape[0]"};
      let batchB = ${i||!a?"batch":"batch % uniforms.bShape[0]"};
      let numTiles = ${i?`${Math.ceil(o/s)}`:`(uniforms.dimInner - 1) / ${s} + 1`};
      var kStart = ${i?`i32(globalId.z) * ${o}`:"0"};

      var acc : array<array<f32, ${b}>, ${g}>;

      // Without this initialization strange values show up in acc.
      for (var innerRow = 0; innerRow < ${g}; innerRow++) {
        for (var innerCol = 0; innerCol < ${b}; innerCol++) {
          acc[innerRow][innerCol] = 0.0;
        }
      }
      ${v}
    }
  `}const TR=n=>n?`
      mm_readA(batchA, colA, globalRow),
      mm_readA(batchA, colA + 1, globalRow),
      mm_readA(batchA, colA + 2, globalRow),
      mm_readA(batchA, colA + 3, globalRow)
  `:`
      mm_readA(batchA, globalRow, colA),
      mm_readA(batchA, globalRow, colA + 1),
      mm_readA(batchA, globalRow, colA + 2),
      mm_readA(batchA, globalRow, colA + 3)
  `;function zR(n,t=!1){tt(n[1]===1&&n[2]===1,()=>`A linear work group size is required. But got ${n}.`);const e=n[0]*4;return`
    var<workgroup> mm_Asub : array<vec4<f32>, ${n[0]}>;

    ${ot()} {
      let tileCol = i32(localId.x);
      let globalCol = i32(globalId.x);
      let globalRow = i32(globalId.y);

      let numTiles = (uniforms.dimInner - 1) / ${e} + 1;
      let batch = i32(globalId.z);
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      // Without this initialization strange values show up in acc.
      var acc = 0.0;

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        let colA = t * ${e} + tileCol * 4;
        mm_Asub[tileCol] = vec4<f32>(${TR(t)});
        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < ${e/4}; k++) {
          let rowB = t * ${e} + k * 4;
          let BCached = vec4<f32>(mm_readB(batchB, rowB, globalCol),
                              mm_readB(batchB, rowB + 1, globalCol),
                              mm_readB(batchB, rowB + 2, globalCol),
                              mm_readB(batchB, rowB + 3, globalCol));

          let ACached = mm_Asub[k];
          acc = acc + dot(ACached, BCached);
        }

        workgroupBarrier();
      }

      mm_write(batch, globalRow, globalCol, acc);
    }
  `}class FR{constructor(t,e,s=!1,i=!1,o=null,r=null,a=null,u=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e,this.dispatchLayout={x:[2],y:[1],z:[0]};const l=s?t[1]:t[2];if(this.isVec4=(l%4===0&&!s||e[1]%4===0&&s)&&e[2]%4===0&&!i,this.outputComponent=this.isVec4?4:1,this.isVectorA=e[1]===1&&!s,!this.isVec4&&this.isVectorA)this.elementsPerThread=[1,1,1],this.workgroupSize=[32,1,1];else{const p=oD(e[1],l,e[2],s);this.workgroupSize=p.workgroupSize,this.elementsPerThread=p.elementsPerThread}this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread);const c=o!=null,h=a!=null;c&&this.variableNames.push("bias"),h&&this.variableNames.push("preluActivationWeights"),this.sequentialAccessByThreads=u,this.transposeA=s,this.transposeB=i,this.addBias=c,this.activation=r,this.hasPreluActivationWeights=h,[this.fitAOuter,this.fitBOuter,this.fitInner]=this.getShapeFit(e[1],e[2],l),this.shaderKey=`matMulPacked_${this.elementsPerThread}_${s}_${i}_${this.activation}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.isVectorA}_${this.sequentialAccessByThreads}`}getShapeFit(t,e,s){const i=this.workgroupSize[1]*this.elementsPerThread[1],o=this.workgroupSize[0]*this.elementsPerThread[0];!this.isVec4&&this.isVectorA?this.tileInner=this.workgroupSize[0]*4:this.tileInner=o;const r=t%i===0,a=e%o===0,u=s%this.tileInner===0;return[r,a,u]}getUserCode(){return`
      ${is(this.activation,this.hasPreluActivationWeights,this.isVec4)}
      ${lc(this.addBias,this.activation,!1,this.transposeB,this.fitAOuter,this.fitBOuter,this.fitInner,this.isVec4?4:1)}
      ${this.isVec4?ha(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,!0):this.isVectorA?zR(this.workgroupSize,this.transposeA):da(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,this.sequentialAccessByThreads,!0)}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MR(n){return`
    var<workgroup> sumValues : array<f32, ${n}>;
    ${ot()} {
      let coords = getOutputCoords();
      let batch = coords[0];
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      let row = coords[1];
      let col = coords[2];
      var sum = 0.0;
      let Length = uniforms.dimInner;
      for (var k = i32(localId.x); k < Length; k = k + ${n}) {
        let dataA = mm_readA(batchA, row, k);
        let dataB = mm_readB(batchB, k, col);
        sum = sum + dataA * dataB;
      }
      sumValues[localId.x] = sum;
      workgroupBarrier();

      for(var currentSize = ${n/2}u; currentSize > 1u;
          currentSize = currentSize / 2u) {
        if (localId.x < currentSize)
        {
          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];
        }
        workgroupBarrier();
      }

      if (localId.x == 0u) {
        sum = sumValues[0] + sumValues[1];
        mm_write(batch, row, col, sum);
      }
    }
  `}class PR{constructor(t,e=!1,s=!1,i=null,o=null,r=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[256,1,1],this.outputShape=t,this.dispatchLayout={x:[],y:[1,2],z:[0]},this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize);const a=i!=null,u=r!=null;a&&this.variableNames.push("bias"),u&&this.variableNames.push("preluActivationWeights"),this.transposeA=e,this.transposeB=s,this.addBias=a,this.activation=o,this.hasPreluActivationWeights=u,this.shaderKey=`matMulReduce_${this.activation}_${e}_${s}`}getUserCode(){return`
      ${is(this.activation,this.hasPreluActivationWeights)}
      ${lc(this.addBias,this.activation,this.transposeA,this.transposeB)}
      ${MR(this.workgroupSize[0])}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ER(n){const t=n[1],e=n[0],s=t>e?t:e;return`
  var<workgroup> mm_Asub : array<array<f32, ${s}>, ${t}>;
  var<workgroup> mm_Bsub : array<array<f32, ${e}>, ${s}>;

  // If the output size is small for matrix multiplication, avoid to use vec4
  // and handle some elements per thread to optimally utilize the ALU.
  // Read data from global memory to registers firstly, then store them into
  // shared memory, so it is instruction-Level parallelism for arithmetic
  // operations and others handle IO operations between barrier api, makes ALU
  // and load/store units work simultaneously, could improves the performance.
  ${ot()} {
    let tileRow = i32(localId.y);
    let tileCol = i32(localId.x);
    let globalRow = i32(globalId.y);
    let globalCol = i32(globalId.x);
    let batch = i32(globalId.z);
    let batchA = batch % uniforms.aShape[0];
    let batchB = batch % uniforms.bShape[0];

    // uniforms.dimInner should be greater than 0.
    let numTiles = (uniforms.dimInner - 1) / ${s} + 1;
    var acc = 0.0;

    var globalColA = tileCol;
    var globalRowB = 0;
    var regA = mm_readA(batchA, globalRow, globalColA);
    var regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
    var regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
    globalColA = globalColA + ${s};
    globalRowB = globalRowB + ${s};

    for (var t = 0; t < numTiles; t = t + 1) {
      mm_Asub[tileRow][tileCol] = regA;
      mm_Bsub[2 * tileRow][tileCol] = regB0;
      mm_Bsub[2 * tileRow + 1][tileCol] = regB1;

      workgroupBarrier();

      regA = mm_readA(batchA, globalRow, globalColA);
      regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
      regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
      globalColA = globalColA + ${s};
      globalRowB = globalRowB + ${s};

      for (var k = 0; k < ${s}; k = k + 1) {
        acc = acc + mm_Asub[tileRow][k] * mm_Bsub[k][tileCol];
      }
      workgroupBarrier();
    }

    mm_write(batch, globalRow, globalCol, acc);
  }
  `}class LR{constructor(t,e,s,i=!1,o=!1,r=null,a=null,u=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[16,8,1],this.outputShape=s,this.dispatchLayout={x:[2],y:[1],z:[0]},this.dispatch=[Math.ceil(s[2]/this.workgroupSize[0]),Math.ceil(s[1]/this.workgroupSize[1]),s[0]];const l=r!=null;l&&this.variableNames.push("bias");const c=u!=null;c&&this.variableNames.push("preluActivationWeights"),this.transposeA=i,this.transposeB=o,this.addBias=l,this.activation=a,this.hasPreluActivationWeights=c,this.shaderKey=`matMulSmallOutputSize_${this.activation}_${i}_${o}`}getUserCode(){return`
      ${is(this.activation,this.hasPreluActivationWeights)}
      ${lc(this.addBias,this.activation,this.transposeA,this.transposeB)}
      ${ER(this.workgroupSize)}
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class OR{constructor(t,e,s=!1,i=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[8,8,1],this.atomic=!0,this.splitedDimInner=128,tt(t[0]===1,()=>"MatMulSplitKProgram only supports batch = 1."),this.outputShape=t,this.dispatchLayout={x:[2],y:[1],z:[0,3]};const o=(s&&this.outputShape[1]%4===0||!s&&e%4===0)&&this.outputShape[2]%4===0;this.elementsPerThread=[4,4,this.splitedDimInner],this.outputComponent=o?4:1,o||(this.outputShape[1]<16&&(this.elementsPerThread[1]=1),this.outputShape[2]<16&&(this.elementsPerThread[0]=1)),this.dispatch=rt(this.dispatchLayout,[this.outputShape[0],this.outputShape[1],this.outputShape[2],e],this.workgroupSize,this.elementsPerThread),this.transposeA=s,this.transposeB=i,this.shaderKey=`matMulSplitK_${s}_${i}_${this.elementsPerThread}_${this.outputComponent}`}getUserCode(){const t=this.outputComponent;return`
      ${Ly(!1,this.transposeB,!1,!1,!1,t)}
      fn mm_write(batch: i32, row : i32, col : i32, value : ${Rt(t)}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
          let coords = vec3<i32>(batch, row, col);
          let flatIndex = getOutputIndexFromCoords(coords);
          // The problem is that we should initialize output to zero before using.
          // Otherwise, the original value will be added to the result.
          for (var i = 0; i < ${t}; i = i + 1) {
            ${Cs("&result[flatIndex + i]",`${t>1?"value[i]":"value"}`,"float32")}
          }
        }
      }
      ${t===4?ha(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner):da(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner)}
    `}}class _R{constructor(t,e=null,s=null,i=null){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=e!=null,this.hasPreluActivationWeights=i!=null,this.activation=s,this.addBias&&this.variableNames.push("bias"),this.hasPreluActivationWeights&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`biasActivation_${s}`}getUserCode(){return`
    ${is(this.activation,this.hasPreluActivationWeights)}
    ${ot("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        var value = getXByOutputIndex(index);
        ${Ks(this.addBias,this.activation)}
        setOutputAtIndex(index, value);
      }
    }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class BR{constructor(t){this.variableNames=[],this.outputShape=[],this.uniforms="value : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="fill"}getUserCode(){return`
    ${ot("index")} {
      if (index < uniforms.size) {
        setOutputAtIndex(index, uniforms.value);
      }
    }
  `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _e(n){const{backend:t,attrs:e}=n,{shape:s,value:i}=e;let{dtype:o}=e;if(o=o||gf(i),o==="string"){const r=Jr(o,et(s));return r.fill(i),t.makeTensorInfo(s,o,r)}else{const r=new BR(s),a=[{type:"float32",data:[i]}];return t.runWebGPUProgram(r,[],o,a)}}const WR={kernelName:mf,backendName:"webgpu",kernelFunc:_e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ft(n){const{inputs:t,attrs:e}=n,{x:s}=t,{shape:i}=e,o=et(s.shape),r=Ap(i,o),a=et(r);return tt(o===a,()=>`The new shape (${r}) has ${a} elements and the old shape (${s.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`),n.backend.incRef(s.dataId),{dataId:s.dataId,shape:r,dtype:s.dtype}}const VR={kernelName:il,backendName:"webgpu",kernelFunc:ft};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pa({a:n,b:t,transposeA:e,transposeB:s,backend:i,bias:o=null,preluActivationWeights:r=null,leakyreluAlpha:a=0,activation:u=null}){const l=n.shape.length,c=t.shape.length,h=e?n.shape[l-2]:n.shape[l-1],p=s?t.shape[c-1]:t.shape[c-2],f=e?n.shape[l-1]:n.shape[l-2],m=s?t.shape[c-2]:t.shape[c-1],g=n.shape.slice(0,-2),b=t.shape.slice(0,-2),v=et(g),w=et(b),C=Ne(n.shape.slice(0,-2),t.shape.slice(0,-2)).concat([f,m]);tt(h===p,()=>`Error in matMul: inner shapes (${h}) and (${p}) of Tensors with shapes ${n.shape} and ${t.shape} and transposeA=${e} and transposeB=${s} must match.`);const I=e?[v,h,f]:[v,f,h],N=s?[w,m,p]:[w,p,m],$=ft({inputs:{x:n},backend:i,attrs:{shape:I}}),A=ft({inputs:{x:t},backend:i,attrs:{shape:N}}),z=[$,A],F=Math.max(v,w),E=[$,A],U=[{type:"int32",data:[f]},{type:"int32",data:[m]},{type:"int32",data:[h]}];let L,W;const _=[F,f,m];let V=he().get("WEBGPU_MATMUL_PROGRAM_TYPE");if(V<0){const j=he().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),K=j>0?j:i.thresholdToIncreaseWorkgroups,Z=F*Math.ceil(f/32)*Math.ceil(m/32);Z<=K||f<=8&&Z<=K*2?F*f*m<=128?V=Rn.MatMulReduceProgram:F===1&&p>=2e3?V=Rn.MatMulSplitKProgram:V=Rn.MatMulSmallOutputSizeProgram:V=Rn.MatMulPackedProgram}switch(V){case Rn.MatMulReduceProgram:L=new PR(_,e,s,o,u,r);break;case Rn.MatMulSplitKProgram:{if(W=_e({backend:i,attrs:{shape:_,value:0,dtype:n.dtype}}),L=new OR(_,p,e,s),o||u){W=i.runWebGPUProgram(L,E,n.dtype,U,W);const K=new _R(W.shape,o,u,r);let Z=null;const Y=[W];o&&Y.push(o),r&&Y.push(r),u==="leakyrelu"&&(Z=[{type:"float32",data:[a]}],K.uniforms+=" alpha : f32,");const it=i.runWebGPUProgram(K,Y,W.dtype,Z);z.push(W);const nt=ft({inputs:{x:it},backend:i,attrs:{shape:C}});z.push(it);for(const ut of z)i.disposeData(ut.dataId);return nt}break}case Rn.MatMulSmallOutputSizeProgram:L=new LR(I,N,_,e,s,o,u,r);break;case Rn.MatMulPackedProgram:const j=i.adapterInfo.isIntel();L=new FR(I,_,e,s,o,u,r,j);break;default:throw new Error(`Unsupported MatMulProgramType ${V}.`)}o&&E.push(o),r&&E.push(r),u==="leakyrelu"&&(U.push({type:"float32",data:[a]}),L.uniforms+=" alpha : f32,"),W=i.runWebGPUProgram(L,E,n.dtype,U,W);const X=ft({inputs:{x:W},backend:i,attrs:{shape:C}});z.push(W);for(const j of z)i.disposeData(j.dataId);return X}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UR(n){const{inputs:t,backend:e,attrs:s}=n,{a:i,b:o,bias:r,preluActivationWeights:a}=t,{transposeA:u,transposeB:l,activation:c,leakyreluAlpha:h}=s;return pa({a:i,b:o,transposeA:u,transposeB:l,backend:e,bias:r,preluActivationWeights:a,leakyreluAlpha:h,activation:c})}const GR={kernelName:Tp,backendName:"webgpu",kernelFunc:UR};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Vh{constructor(t,e,s){this.variableNames=["AReal","AImag","BReal","BImag"],this.workgroupSize=[128,1,1],this.size=!0,this.outputShape=Ne(e,s),this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`binaryOpComplex_${t}`,this.op=t}getUserCode(){return`
      fn binaryOpComplex(
          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {
        ${uc(this.op,!1)}
      }

      ${ot("index")} {
        if(index < uniforms.size) {
          let areal = getARealByOutputIndex(index);
          let aimag = getAImagByOutputIndex(index);
          let breal = getBRealByOutputIndex(index);
          let bimag = getBImagByOutputIndex(index);
          setOutputAtIndex(index, binaryOpComplex(areal, aimag, breal, bimag));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ar{constructor(t,e,s){if(this.size=!0,this.variableNames=["A","B"],this.outputShape=Ne(e,s),this.dispatchLayout=ht(this.outputShape),this.op=t,this.useSharedMemoryWithA=e.length<=1&&s.length>1&&e[0]<128,this.useSharedMemoryWithB=s.length<=1&&e.length>1&&s[0]<128,this.useSharedMemoryWithA||this.useSharedMemoryWithB)this.outputComponent=1,this.variableComponents=[1,1],this.lastDimensionSize=this.useSharedMemoryWithB?s[0]:e[0],this.shaderKey=`binary_${t}_${this.lastDimensionSize}`,this.type="shared",this.workgroupSize=[256,1,1];else{const i=e.length>0&&e[e.length-1]%4===0,o=s.length>0&&s[s.length-1]%4===0;i&&o?(this.outputComponent=4,this.variableComponents=[4,4]):i&&(eh(s)||s[s.length-1]===1)||o&&(eh(e)||e[e.length-1]===1)?(this.outputComponent=4,this.variableComponents=i?[4,1]:[1,4]):(this.outputComponent=1,this.variableComponents=[1,1]),this.type="nonshared",this.shaderKey=`binary_${t}_${this.variableComponents}`,this.workgroupSize=[128,1,1]}this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.outputComponent,1,1])}getUserCode(){let t;const e=this.outputComponent===4?"vec4<f32>":"f32",s=`
    fn binaryOperation(a : ${e}, b : ${e}) -> ${e} {
      ${uc(this.op,this.outputComponent===4)}
    };
    `;if(this.type==="shared"){const i=this.lastDimensionSize>1?`coords[${this.outputShape.length-1}]`:"0",o=this.useSharedMemoryWithB?`let a = getAByOutputIndex(index);
          let b = sharedBuf[${i}];`:`let a = sharedBuf[${i}];
          let b = getBByOutputIndex(index);`;t=`
        ${s}
        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;
        ${ot("index")} {
          // Fill in the shared memory buffer.
          let localIndex = i32(localId.x);
          if(localIndex < ${this.lastDimensionSize}) {
            sharedBuf[localIndex] = f32(${this.useSharedMemoryWithB?"B":"A"}[localIndex]);
          }
          workgroupBarrier();

          if(index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            ${o}
            setOutputAtIndex(index, binaryOperation(a, b));
          }
        }
        `}else t=`
       ${s}
       ${ot("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index * ${this.outputComponent});
           let a = ${e}(getAByOutputCoords(coords));
           let b = ${e}(getBByOutputCoords(coords));
           setOutputAtIndex(index, binaryOperation(a, b));
         }
       }
       `;return t}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function je(n){const{inputs:t}=n,{x:e}=t;return n.backend.incRef(e.dataId),{dataId:e.dataId,shape:e.shape,dtype:e.dtype}}const HR={kernelName:Wd,backendName:"webgpu",kernelFunc:je};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xs(n){const{inputs:t,backend:e}=n,{real:s,imag:i}=t,o=e.makeTensorInfo(s.shape,"complex64"),r=e.tensorMap.get(o.dataId),a=je({inputs:{x:s},backend:e}),u=je({inputs:{x:i},backend:e});return r.complexTensorInfos={real:a,imag:u},o}const jR={kernelName:p1,backendName:"webgpu",kernelFunc:Xs};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ti{constructor(t,e,s=""){this.variableNames=["A"],this.size=!0;const i=128;this.workgroupSize=[i,1,1],this.outputShape=t,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.op=e,s!==""&&(this.uniforms=s),this.shaderKey=`unary_${e}`}getUserCode(){return`
      fn unaryOperation(a : f32) -> f32 {
        ${$s(this.op,!1)}
      }
      ${ot("index")} {
        if (index < uniforms.size) {
          let a = getAByOutputIndex(index);
          setOutputAtIndex(index, unaryOperation(a));
        }
      }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bt({opType:n,cpuKernelImpl:t,dtype:e}){return({inputs:s,backend:i})=>{const{x:o}=s,r=i,a=e||o.dtype;if(r.shouldExecuteOnCPU([o])&&t!=null){const l=r.tensorMap.get(o.dataId),c=t(l.values,a);return r.makeTensorInfo(o.shape,a,c)}const u=new Ti(o.shape,n);return r.runWebGPUProgram(u,[o],a)}}function Se({opType:n,cpuKernelImpl:t,supportsComplex:e=!1,dtype:s}){return({inputs:i,backend:o})=>{const{a:r,b:a}=i,u=o;if(e&&r.dtype==="complex64"){const h=u.tensorMap.get(r.dataId),p=u.tensorMap.get(a.dataId);let f,m;if(n!==vt.MUL)[f,m]=[[h.complexTensorInfos.real,p.complexTensorInfos.real],[h.complexTensorInfos.imag,p.complexTensorInfos.imag]].map(b=>{const[v,w]=b,k={dataId:v.dataId,dtype:v.dtype,shape:r.shape},C={dataId:w.dataId,dtype:w.dtype,shape:a.shape},I=new ar(n,r.shape,a.shape);return u.runWebGPUProgram(I,[k,C],es(v.dtype,w.dtype))});else{const b=new Vh(vt.COMPLEX_MULTIPLY_REAL,r.shape,a.shape),v=new Vh(vt.COMPLEX_MULTIPLY_IMAG,r.shape,a.shape),w=[{dataId:h.complexTensorInfos.real.dataId,dtype:h.complexTensorInfos.real.dtype,shape:r.shape},{dataId:h.complexTensorInfos.imag.dataId,dtype:h.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:p.complexTensorInfos.real.dataId,dtype:p.complexTensorInfos.real.dtype,shape:a.shape},{dataId:p.complexTensorInfos.imag.dataId,dtype:p.complexTensorInfos.imag.dtype,shape:a.shape}];f=u.runWebGPUProgram(b,w,"float32"),m=u.runWebGPUProgram(v,w,"float32")}const g=Xs({inputs:{real:f,imag:m},backend:u});return u.disposeData(f.dataId),u.disposeData(m.dataId),g}const l=s||es(r.dtype,a.dtype);if((r.dtype==="string"||a.dtype==="string"||u.shouldExecuteOnCPU([r,a]))&&t!=null){const h=u.tensorMap.get(r.dataId).values,p=u.tensorMap.get(a.dataId).values,f=r.dtype==="string"?nh(h):h,m=r.dtype==="string"?nh(p):p,[g,b]=t(r.shape,a.shape,f,m,l);return u.makeTensorInfo(b,l,g)}const c=new ar(n,r.shape,a.shape);return u.runWebGPUProgram(c,[r,a],l)}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:KR,castImpl:XR,ceilImpl:qR,concatImpl:YR,equalImpl:ZR,expImpl:QR,expm1Impl:JR,floorImpl:tA,floorDivImpl:eA,gatherNdImpl:nA,gatherV2Impl:sA,greaterEqualImpl:iA,greaterImpl:oA,lessEqualImpl:rA,lessImpl:aA,logImpl:uA,maxImpl:lA,maximumImpl:cA,minimumImpl:hA,multiplyImpl:dA,negImpl:pA,notEqualImpl:fA,prodImpl:mA,rangeImpl:gA,rsqrtImpl:yA,scatterImpl:bA,simpleAbsImpl:xA,sliceImpl:wA,stridedSliceImpl:vA,stringNGramsImpl:CA,subImpl:kA,tileImpl:SA,topKImpl:IA,transposeImpl:NA,uniqueImpl:FO}=f1;/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $A=Bt({opType:st.ABS,cpuKernelImpl:xA}),DA={kernelName:Id,backendName:"webgpu",kernelFunc:$A};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RA=Bt({opType:st.ACOS}),AA={kernelName:dr,backendName:"webgpu",kernelFunc:RA};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TA=Bt({opType:st.ACOSH}),zA={kernelName:pr,backendName:"webgpu",kernelFunc:TA};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FA=Se({opType:vt.ADD,cpuKernelImpl:KR,supportsComplex:!0}),MA={kernelName:Nd,backendName:"webgpu",kernelFunc:FA};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class PA{constructor(t){this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t[0],this.variableNames=t.map((e,s)=>`T${s}`),this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="addN"}getUserCode(){const t=[];this.variableNames.forEach(i=>{t.push(`let v${i} = get${i}ByOutputCoords(coords);`)});const e=this.variableNames.map(i=>`v${i}`).join(" + ");return`
      ${ot("index")} {
        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if (flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            ${t.join(`
        `)}
            setOutputAtIndex(flatIndex, ${e});
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EA(n){const{inputs:t,backend:e}=n,s=t;if(s.length===1)return je({inputs:{x:s[0]},backend:e});const i=s.map(a=>a.dtype).reduce((a,u)=>es(a,u)),o=s.map(a=>a.shape),r=new PA(o);return e.runWebGPUProgram(r,s,i)}const LA={kernelName:bu,backendName:"webgpu",kernelFunc:EA};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class OA{constructor(t,e){this.variableNames=["A"],this.workgroupSize=[16,16,1];const s=new Array(t.length);for(let i=0;i<s.length;i++)s[i]=t[e[i]];this.outputShape=s,this.dispatchLayout={x:[0],y:[1]},this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize,[1,1,1]),this.shaderKey="transposeShared"}getUserCode(){tt(this.workgroupSize[0]===this.workgroupSize[1],()=>`Must be a square tile, current tile shape is ${this.workgroupSize[0]} x ${this.workgroupSize[1]}`);const t=this.workgroupSize[0];return`
      var<workgroup> tile : array<array<f32, ${this.workgroupSize[0]+1}>, ${this.workgroupSize[0]}>;
      ${ot()} {
        var x = i32(workgroupId.x) * ${t} + i32(localId.x);
        var y = i32(workgroupId.y) * ${t} + i32(localId.y);
        let width = uniforms.outShape[0];
        let height = uniforms.outShape[1];
        if (x < width && y < height) {
          tile[localId.y][localId.x] = f32(A[y * width + x]);
        }
        workgroupBarrier();

        x = i32(workgroupId.y) * ${t} + i32(localId.x);
        y = i32(workgroupId.x) * ${t} + i32(localId.y);
        if (x < height && y < width) {
          setOutputAtIndex((y * height + x), tile[localId.x]
            [localId.y]);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _A{constructor(t,e){this.variableNames=["A"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0;const s=new Array(t.length);for(let i=0;i<s.length;i++)s[i]=t[e[i]];this.outputShape=s,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.newDim=e,this.shaderKey=`transpose_${e}`}getUserCode(){const t=de(this.outputShape.length),e=Oy(this.newDim);return`
      ${ot("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            setOutputAtIndex(flatIndex, A[getIndexFromCoords${this.outputShape.length}D(
              ${t}(${e}), uniforms.aShape)]);
          }
        }
      }
    `}}function Oy(n){const t=n.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const e=new Array(t);for(let s=0;s<n.length;s++)e[n[s]]=`coords.${Yn(s)}`;return e.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _n(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{perm:o}=s,r=e,a=i.shape.length,u=new Array(a);for(let c=0;c<u.length;c++)u[c]=i.shape[o[c]];if(e.shouldExecuteOnCPU([i])){const h=r.tensorMap.get(i.dataId).values,p=NA(h,i.shape,i.dtype,o,u);return e.makeTensorInfo(u,i.dtype,p)}if(i.shape.length===2&&ke(o,[1,0])){const c=new OA(i.shape,o);return r.runWebGPUProgram(c,[i],i.dtype)}const l=new _A(i.shape,o);return r.runWebGPUProgram(l,[i],i.dtype)}const BA={kernelName:op,backendName:"webgpu",kernelFunc:_n};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class WA{constructor(t,e,s){this.variableNames=["x"],this.uniforms="reduceSize : i32,",this.size=!0,this.inputShape=[t.batchSize,t.inSize];const[i]=ln(this.inputShape,[1]);this.outputShape=i.length===0?[1]:i,t.inSize>=32768&&s>=512?this.workgroupSize=[512,1,1]:t.inSize>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,[1,1,1]),this.reduceType=e,this.shaderKey=`reduce_${e}`}getUserCode(){let t="",e="0.0";const s=this.workgroupSize[0];this.reduceType==="min"||this.reduceType==="max"?(t=`
         if (isnan(candidate)) {
          bestValue = uniforms.NAN;
         } else if (!isnan(bestValue) && candidate ${this.reduceType==="min"?"<":">"} bestValue)
           {  bestValue = candidate; }`,e="f32(x[offset])"):this.reduceType==="sum"||this.reduceType==="mean"?t=" bestValue = bestValue + candidate; ":this.reduceType==="prod"?(t=" bestValue = bestValue * candidate; ",e="1.0"):this.reduceType==="all"?(t=" bestValue = f32(bestValue >= 1.0 && candidate >= 1.0); ",e="1.0"):this.reduceType==="any"&&(t=" bestValue = f32(bestValue >= 1.0 || candidate >= 1.0); ",e="0.0");const i=this.reduceType==="mean"?"setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));":"setOutputAtIndex(outputIndex, bestValue);";return`
       fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
       }

       ${`
         var<workgroup> xBestValues : array<f32, ${s}>;
       `}
       fn getOffset(outputIndex : i32) -> i32 {
         let outputCoords = getCoordsFromIndex(outputIndex);
         let offset = ${this.outputShape.length===1?"outputCoords":"outputCoords[0]"} * uniforms.reduceSize;
          return offset;
       }
       ${ot("index")} {
         let outputIndex = index / ${s};
         let offset = getOffset(outputIndex);
         var bestValue = ${e};
         let Length = uniforms.reduceSize;
         let WorkPerThread = DIV_CEIL(u32(Length), ${s}u);
         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;
             k = k + ${s}) {
           let candidate = f32(x[offset + k]);
           ${t}
         }
         xBestValues[localId.x] = bestValue;
         workgroupBarrier();

         var reduceSize = min(u32(Length), ${s}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            ${t}
            xBestValues[localId.x] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (localId.x == 0u && outputIndex < uniforms.size) {
          ${i}
        }
       }
     `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VA={mean:"float32",all:"bool",any:"bool"};function qs(n,t,e,s,i){const o=n.shape.length,r=[],a=ee(t,n.shape);let u=a;const l=Me(u,o);let c=n;l!=null&&(c=_n({inputs:{x:n},attrs:{perm:l},backend:i}),u=Ke(u.length,o),r.push(c)),Vn(s,u,o);const[h,p]=ln(c.shape,u);let f=h;e&&(f=Jn(h,a));let m;if((s==="max"||s==="prod")&&i.shouldExecuteOnCPU([c])){const g=i.tensorMap.get(c.dataId).values;switch(s){case"max":const b=lA(g,et(p),f,n.dtype);m=i.makeTensorInfo(f,n.dtype,b);break;case"prod":const{outVals:v,outShape:w,outDtype:k}=mA(c.shape,c.dtype,g,u);m=i.makeTensorInfo(w,k,v);break;default:throw new Error(`${s} CPU implementation is not yet supported.`)}}else{const g=et(p),v=et(c.shape)/g,w={windowSize:g,inSize:g,batchSize:v,outSize:1},k=VA[s]||m1(n.dtype),C=[{type:"int32",data:[g]}],I=new WA(w,s,i.device.limits.maxComputeWorkgroupSizeX),N=i.runWebGPUProgram(I,[c],k,C);r.push(N),m=ft({inputs:{x:N},attrs:{shape:f},backend:i})}return r.forEach(g=>i.disposeData(g.dataId)),m}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UA(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{keepDims:o,axis:r}=s;return qs(i,r,o,"all",e)}const GA={kernelName:zp,backendName:"webgpu",kernelFunc:UA};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HA(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{keepDims:o,axis:r}=s;return qs(i,r,o,"any",e)}const jA={kernelName:Fp,backendName:"webgpu",kernelFunc:HA};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _y{constructor(t,e,s){this.workgroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="infinityValue : f32,",this.size=!0;const i=[e];this.op=s==="min"?"<":">";const[o,r]=ln(t,i);this.outputShape=o.length===0?[1]:o,this.dispatchLayout=ht(this.outputShape),et(r)<32?(this.type="plain",this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize)):(this.type="shared",this.dispatch=rt(this.dispatchLayout,this.outputShape,[1,1,1])),this.inputShape=t,this.shaderKey=`argMinMax_${this.op}_${this.type}`}getUserCode(){const t=this.workgroupSize[0],e=()=>this.inputShape.length===1?"uniforms.xShape":`uniforms.xShape.${Yn(this.inputShape.length-1)}`,s=()=>{let i="";if(this.outputShape.length===1)this.inputShape.length!==1&&(i+="outputCoords,");else for(let o=0;o<this.outputShape.length;o++)i+=`outputCoords.${Yn(o)},`;return i};return this.type==="shared"?`
      fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
      }

      ${`
      var<workgroup> xBestIndices : array<i32, ${t}>;
      var<workgroup> xBestValues : array<f32, ${t}>;
    `}

      ${ot("index")} {
        let outputIndex = index / ${t};
        let reduceLength = ${e()};

        var bestIndex = i32(localId.x);
        var bestValue = uniforms.infinityValue;
        let outputCoords = getCoordsFromIndex(outputIndex);
        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;
            k = k + ${t}) {
          let candidate = getX(${s()} k);
          if (!isnan(candidate) && candidate ${this.op} bestValue) {
            bestValue = candidate;
            bestIndex = k;
          }
        }
        xBestValues[localId.x] = bestValue;
        xBestIndices[localId.x] = bestIndex;
        workgroupBarrier();

        var reduceSize = min(u32(reduceLength), ${t}u);
        for (var currentSize = reduceSize / 2u; reduceSize > 1u;
            currentSize = reduceSize / 2u) {
          let interval = DIV_CEIL(reduceSize, 2u);
          if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              xBestValues[localId.x] = bestValue;
              xBestIndices[localId.x] = xBestIndices[localId.x + interval];
            }
          }
          reduceSize = interval;
          workgroupBarrier();
        }

        if (localId.x == 0u && outputIndex < uniforms.size) {
          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);
        }
      }
    `:`
      ${ot("index")} {
        if (index < uniforms.size) {
          let outputCoords = getCoordsFromIndex(index);
          var bestIndex = 0;
          var bestValue = getX(${s()} 0);
          let reduceLength = ${e()};
          for (var i = 1; i < reduceLength; i++) {
            let candidate = getX(${s()} i);
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              bestIndex = i;
            }
          }
          setOutputAtIndexI32(index, bestIndex);
        }
      }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KA(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:o}=s;let r=ee(o,i.shape);const a=Me(r,i.shape.length);let u=i;const l=[];a!=null&&(u=_n({inputs:{x:i},backend:e,attrs:{perm:a}}),l.push(u),r=Ke(r.length,u.shape.length)),Vn("argMax",[r[0]],u.shape.length);const c=new _y(u.shape,r[0],"max"),h=[{type:"float32",data:[Number.NEGATIVE_INFINITY]}],p=e.runWebGPUProgram(c,[u],"int32",h);return l.forEach(f=>e.disposeData(f.dataId)),p}const XA={kernelName:xu,backendName:"webgpu",kernelFunc:KA};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qA(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:o}=s;let r=ee(o,i.shape);const a=Me(r,i.shape.length);let u=i;const l=[];a!=null&&(u=_n({inputs:{x:i},backend:e,attrs:{perm:a}}),l.push(u),r=Ke(r.length,u.shape.length)),Vn("argMin",[r[0]],u.shape.length);const c=new _y(u.shape,r[0],"min"),h=[{type:"float32",data:[Number.POSITIVE_INFINITY]}],p=e.runWebGPUProgram(c,[u],"int32",h);return l.forEach(f=>e.disposeData(f.dataId)),p}const YA={kernelName:wu,backendName:"webgpu",kernelFunc:qA};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZA=Bt({opType:st.ASIN}),QA={kernelName:fr,backendName:"webgpu",kernelFunc:ZA};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JA=Bt({opType:st.ASINH}),tT={kernelName:mr,backendName:"webgpu",kernelFunc:JA};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eT=Bt({opType:st.ATAN}),nT={kernelName:yr,backendName:"webgpu",kernelFunc:eT};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sT=Se({opType:vt.ATAN2}),iT={kernelName:gr,backendName:"webgpu",kernelFunc:sT};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oT=Bt({opType:st.ATANH}),rT={kernelName:br,backendName:"webgpu",kernelFunc:oT};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aT{constructor(t){this.variableNames=["x"],this.uniforms="strides : vec2<i32>,",this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=t.outShape,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="poolWithFilterSizeEqualsOne"}getUserCode(){return`
      ${ot("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];

          let xRCCorner = coords.yz * uniforms.strides;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          let value = getX(batch, xRCorner, xCCorner, d);
          setOutputAtIndex(index, value);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oo{constructor(t,e,s=!1,i=!1,o=!1){if(this.variableNames=["x"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,",this.workgroupSize=[128,1,1],this.size=!0,e==="avg"&&s)throw new Error("Cannot compute positions for average pool.");this.outputShape=t.outShape,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=e,this.computePositions=s,this.flattenPositions=i,this.includeBatchIndex=o,this.shaderKey=`pool2D_${e}_${s}_${i}_${o}`}getUserCode(){let t;this.poolType==="avg"?t="resultValue = resultValue + value; count = count + 1.0;":this.computePositions?t=`let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"((batch * uniforms.xShape[1] + xR) * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"(xR * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"wR * uniforms.filterDims.y + wC"};
      }`:t="resultValue = max(value, resultValue);";let e="resultValue";return this.poolType==="avg"&&(e="resultValue / max(count, 1.0)"),`
      ${ot("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];
          let xRCCorner = vec2<i32>(coords.yz) * uniforms.strides - uniforms.pads;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          ${this.computePositions?`var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;`:`var resultValue = ${this.poolType==="avg"?"0.0":"-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilations.x) {
            let xR = xRCorner + wR;

            if (xR < 0 || xR >= uniforms.convDims.x) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilations.y) {
              let xC = xCCorner + wC;
              if (xC < 0 || xC >= uniforms.convDims.y) {
                continue;
              }

              let value = getX(batch, xR, xC, d);
              ${t}
            }
          }

          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${e});`}
        }
      }
    `}}class cc{constructor(t,e,s=!1,i=!1,o=!1){if(this.variableNames=["x"],this.uniforms="strides : vec3<i32>, pads : vec3<i32>, convDims : vec3<i32>, filterDims : vec3<i32>,",this.workgroupSize=[128,1,1],this.size=!0,e==="avg"&&s)throw new Error("Cannot compute positions for average pool.");this.outputShape=t.outShape,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=e,this.computePositions=s,this.flattenPositions=i,this.includeBatchIndex=o,this.shaderKey=`pool3D_${e}_${s}_${i}_${o}`}getUserCode(){let t;this.poolType==="avg"?t="resultValue += value; count += 1.0;":this.computePositions?t=`let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"(((batch * uniforms.xShape.y + xD) * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"((xD * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"wD * uniforms.filterDims.y * uniforms.filterDims.y + wR * uniforms.filterDims.z + wC"};
      }`:t="resultValue = max(value, resultValue);";let e="resultValue";return this.poolType==="avg"&&(e="resultValue / max(count, 1.0)"),`
      ${ot("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords.x;
          let ch = coords.u;

          let xCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
          let xDCorner = xCorner.x;
          let xRCorner = xCorner.y;
          let xCCorner = xCorner.z;

          ${this.computePositions?`var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;`:`var resultValue = ${this.poolType==="avg"?"0.0":"-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wD = 0; wD < uniforms.filterDims.x; wD++) {
            let xD = xDCorner + wD;
            if (xD < 0 || xD >= uniforms.convDims.x) {
              continue;
            }

            for (var wR = 0; wR < uniforms.filterDims.y; wR++) {
              let xR = xRCorner + wR;
              if (xR < 0 || xR >= uniforms.convDims.y) {
                continue;
              }

              for (var wC = 0; wC < uniforms.filterDims.z; wC++) {
                let xC = xCCorner + wC;
                if (xC < 0 || xC >= uniforms.convDims.z) {
                  continue;
                }

                let value = getX(batch, xD, xR, xC, ch);
                ${t}
              }
            }
          }

          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${e});`}
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function By(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{reductionIndices:o,keepDims:r}=s;return qs(i,o,r,"max",e)}const uT={kernelName:Gu,backendName:"webgpu",kernelFunc:By};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wy(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{keepDims:o,axis:r}=s;return qs(i,r,o,"mean",e)}const lT={kernelName:qu,backendName:"webgpu",kernelFunc:Wy};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vy(n,t,e,s){if(t.filterWidth===1&&t.filterHeight===1&&ke(t.inShape,t.outShape))return je({inputs:{x:n},backend:s});if(t.filterWidth===t.inWidth&&t.filterHeight===t.inHeight&&t.batchSize===1&&t.padInfo.type==="VALID"){const r=n.shape.length,a=ft({inputs:{x:n},backend:s,attrs:{shape:[n.shape[r-3]*n.shape[r-2],n.shape[r-1]]}});let u;e==="avg"?u=Wy({inputs:{x:a},backend:s,attrs:{axis:0,keepDims:!1}}):(tt(e==="max",()=>`Invalid pool type ${e}`),u=By({inputs:{x:a},backend:s,attrs:{reductionIndices:0,keepDims:!1}}));const l=ft({inputs:{x:u},backend:s,attrs:{shape:t.outShape}});return s.disposeData(a.dataId),s.disposeData(u.dataId),l}let i;const o=[{type:"int32",data:[t.strideHeight,t.strideWidth]}];return t.filterHeight===1&&t.filterWidth===1?i=new aT(t):(e==="avg"?i=new oo(t,"avg"):(tt(e==="max",()=>`Invalid pool type ${e}`),i=new oo(t,"max")),o.push({type:"int32",data:[t.padInfo.top,t.padInfo.left]},{type:"int32",data:[t.dilationHeight,t.dilationWidth]},{type:"int32",data:[t.inHeight,t.inWidth]},{type:"int32",data:[t.effectiveFilterHeight,t.effectiveFilterWidth]})),s.runWebGPUProgram(i,[n],n.dtype,o)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cT(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{filterSize:o,strides:r,pad:a,dimRoundingMode:u}=s,c=Un(i.shape,o,r,1,a,u);return Vy(i,c,"avg",e)}const hT={kernelName:Su,backendName:"webgpu",kernelFunc:cT};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dT(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{filterSize:o,strides:r,pad:a,dataFormat:u,dimRoundingMode:l}=s,c=[1,1,1],h=xs(i.shape,o,r,c,a,l,u),p=new cc(h,"avg"),f=[{type:"int32",data:[h.strideDepth,h.strideHeight,h.strideWidth]},{type:"int32",data:[h.padInfo.front,h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.inDepth,h.inHeight,h.inWidth]},{type:"int32",data:[h.effectiveFilterDepth,h.effectiveFilterHeight,h.effectiveFilterWidth]}];return e.runWebGPUProgram(p,[i],i.dtype,f)}const pT={kernelName:Cu,backendName:"webgpu",kernelFunc:dT};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fT{constructor(t){this.variableNames=["dy"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, avgMultiplier : f32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.inShape,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool2DBackprop"}getUserCode(){return`
      ${ot("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR = wR + uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC = wC + uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);

            dotProd = dotProd + dyValue * uniforms.avgMultiplier;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}class mT{constructor(t){this.variableNames=["dy"],this.uniforms=`strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
       outDepth : i32, outHeight : i32, outWidth : i32, avgMultiplier : f32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.inShape,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool3DBackprop"}getUserCode(){return`
      ${ot("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              dotProd += dyValue * uniforms.avgMultiplier;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gT(n){const{inputs:t,backend:e,attrs:s}=n,{dy:i,input:o}=t,r=o,{filterSize:a,strides:u,pad:l,dimRoundingMode:c}=s,h=xs(r.shape,a,u,1,l,c),p=new mT(h),f=1/(h.filterDepth*h.filterHeight*h.filterWidth),m=[{type:"int32",data:[h.strideDepth,h.strideHeight,h.strideWidth]},{type:"int32",data:[h.effectiveFilterDepth-1-h.padInfo.front,h.effectiveFilterHeight-1-h.padInfo.top,h.effectiveFilterWidth-1-h.padInfo.left]},{type:"int32",data:[h.effectiveFilterDepth,h.effectiveFilterHeight,h.effectiveFilterWidth]},{type:"int32",data:[h.outDepth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]},{type:"float32",data:[f]}];return e.runWebGPUProgram(p,[i],r.dtype,m)}const yT={kernelName:vu,backendName:"webgpu",kernelFunc:gT};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bT(n){const{inputs:t,backend:e,attrs:s}=n,{dy:i,input:o}=t,r=o;Ey([i,o],"avgPoolGrad");const{filterSize:a,strides:u,pad:l}=s,c=Un(r.shape,a,u,1,l),h=new fT(c),p=1/(c.filterHeight*c.filterWidth),f=[{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.effectiveFilterHeight-1-c.padInfo.top,c.effectiveFilterWidth-1-c.padInfo.left]},{type:"int32",data:[c.dilationHeight,c.dilationWidth]},{type:"int32",data:[c.effectiveFilterHeight,c.effectiveFilterWidth]},{type:"int32",data:[c.outHeight]},{type:"int32",data:[c.outWidth]},{type:"float32",data:[p]}];return e.runWebGPUProgram(h,[i],r.dtype,f)}const xT={kernelName:ku,backendName:"webgpu",kernelFunc:bT};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wT(n){const{inputs:t,backend:e,attrs:s}=n,{a:i,b:o}=t,{transposeA:r,transposeB:a}=s;return pa({a:i,b:o,transposeA:r,transposeB:a,backend:e})}const vT={kernelName:Iu,backendName:"webgpu",kernelFunc:wT};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class CT{constructor(t,e){this.variableNames=["source"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.rank=e.length,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.start=t,this.uniforms=`start : ${de(t.length)}, `,this.shaderKey="slice"}getUserCode(){const t=de(this.rank),e=kT(this.rank);let s;return this.start.length===1?s=this.outputShape.map((o,r)=>"sourceLoc = uniforms.start + coords;"):s=this.outputShape.map((o,r)=>`sourceLoc.${hu[r]} = uniforms.start.${Yn(r)} + coords.${hu[r]};`),`
      ${ot("index")} {
        if (index < uniforms.size) {
          var sourceLoc : ${t};
          let coords = getCoordsFromIndex(index);
          ${s.join(`
`)}
          setOutputAtIndex(index, getSource(${e}));
        }
      }
    `}}const hu=["x","y","z","w","u","v"];function kT(n){if(n===1)return"sourceLoc";if(n<=6)return hu.slice(0,n).map(t=>`sourceLoc.${t}`).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zi(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{begin:o,size:r}=s,[a,u]=tp(i,o,r);if(g1(i,a,u),e.shouldExecuteOnCPU([i])||i.dtype==="string"){const h=e.tensorMap.get(i.dataId),p=wA(h.values,a,u,i.shape,i.dtype);return e.makeTensorInfo(u,i.dtype,p)}if(et(u)===0)return e.makeTensorInfo(u,i.dtype,[]);const l=new CT(a,u),c=[{type:"int32",data:a}];return e.runWebGPUProgram(l,[i],i.dtype,c)}const ST={kernelName:Jd,backendName:"webgpu",kernelFunc:zi};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IT=n=>{const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{blockShape:o,crops:r}=s;tt(i.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet");const a=o.reduce((w,k)=>w*k),u=Yr(i.shape,o,a),l=Zr(u.length,o.length),c=Qr(i.shape,o,a),h=Mp(r,o.length),p=Pp(c,r,o.length),f=[],m=ft({inputs:{x:i},backend:e,attrs:{shape:u}}),g=_n({inputs:{x:m},backend:e,attrs:{perm:l}}),b=ft({inputs:{x:g},backend:e,attrs:{shape:c}}),v=zi({inputs:{x:b},backend:e,attrs:{begin:h,size:p}});return f.push(m),f.push(g),f.push(b),f.forEach(w=>e.disposeData(w.dataId)),v},NT={kernelName:Nu,backendName:"webgpu",kernelFunc:IT};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $T=`
  fn bincount_write(index: i32, value: f32) {
    ${Cs("&result[index]","value","float32")}
  }
`,DT=`
  fn bincount_write(index: i32, value: f32) {
    atomicStore(&result[index], bitcast<i32>(value));
  }
`;class Uy{constructor(t,e,s=!1){this.outputShape=[],this.variableNames=["x"],this.uniforms="binCountSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.hasWeights=!0,this.binaryOutput=!1,this.outputShape=t,this.rank=t.length,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.binaryOutput=s,s&&(this.atomic=!1),this.hasWeights=e,this.hasWeights&&this.variableNames.push("w"),this.shaderKey=`bincount_${this.hasWeights}_${this.binaryOutput}_${this.rank}`}getUserCode(){return`
    ${this.binaryOutput?DT:$T}
  ${ot("index")} {
    ${this.rank===1?`if (index < uniforms.xShape) {
      let indexVal = i32(getX(index));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput?1:this.hasWeights?"getW(index)":"1."};
        bincount_write(indexVal, value);
      }
    }`:`let coord = getCoordsFromIndex(index);
    if (coordsInBounds2D(coord, uniforms.xShape)) {
      let indexVal = i32(getX(coord[0], coord[1]));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput?1:this.hasWeights?"getW(coord[0], coord[1])":"1."};
        bincount_write(coord.x * uniforms.binCountSize + indexVal, value);
      }
    }`}
  }
  `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RT(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,weights:o}=t,{size:r}=s,a=et(i.shape),l=et(o.shape)>0,c=[r],h=o.dtype,p=_e({backend:e,attrs:{shape:c,value:0,dtype:h}}),f=new Uy([a],l),m=[{type:"int32",data:[r]}],g=l?[i,o]:[i];return e.runWebGPUProgram(f,g,h,m,p)}const AT={kernelName:Ep,backendName:"webgpu",kernelFunc:RT};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class TT{constructor(t){this.outputShape=[],this.variableNames=["s0","s1"],this.uniforms="s0Size : i32, s1Size : i32, ",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[t],this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="broadcastArgs"}getUserCode(){return`
  ${ot("index")} {
    if (index < uniforms.size) {
      var s0 = 1.0;
      var s1 = 1.0;
      let indexS0 = index - uniforms.size + uniforms.s0Size;
      let indexS1 = index - uniforms.size + uniforms.s1Size;
      if (indexS0 >= 0) {
        s0 = getS0(indexS0);
      }
      if (indexS1 >= 0) {
        s1 = getS1(indexS1);
      }

      if (s0 == 1.0) {
        setOutputAtIndex(index, s1);
      } else if (s1 == 1.0) {
        setOutputAtIndex(index, s0);
      } else if (s0 != s1) {
        setOutputAtIndex(index, uniforms.NAN);
      } else {
        setOutputAtIndex(index, s0);
      }
    }
  }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zT(n){const{inputs:t,backend:e}=n,{s0:s,s1:i}=t;if(e.shouldExecuteOnCPU([s,i])){const c=e.tensorMap.get(s.dataId),h=e.tensorMap.get(i.dataId),p=c.values,f=h.values,m=Ne(Array.from(p),Array.from(f));return e.makeTensorInfo([m.length],"int32",Int32Array.from(m))}const o=et(s.shape),r=et(i.shape),a=Math.max(o,r),u=new TT(a),l=[{type:"int32",data:[o]},{type:"int32",data:[r]}];return e.runWebGPUProgram(u,[s,i],"int32",l)}const FT={kernelName:Op,backendName:"webgpu",kernelFunc:zT};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gy=Se({opType:vt.NOT_EQUAL,dtype:"bool",cpuKernelImpl:fA}),MT={kernelName:y1,backendName:"webgpu",kernelFunc:Gy};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Co(n){const{inputs:t,backend:e}=n,{input:s}=t,i=e.tensorMap.get(s.dataId);return je({inputs:{x:i.complexTensorInfos.real},backend:e})}const PT={kernelName:b1,backendName:"webgpu",kernelFunc:Co};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ET(n,t){const e=new Ti(n.shape,st.TO_INT),s=t.runWebGPUProgram(e,[n],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function du(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{dtype:o}=s;if(o==="complex64"){if(i.dtype==="complex64")return je({inputs:{x:i},backend:e});const r=Le(i.shape),a=du({inputs:{x:i},backend:e,attrs:{dtype:"float32"}}),u=Xs({inputs:{real:a,imag:r},backend:e});return r.dispose(),e.disposeData(a.dataId),u}if(i.dtype==="complex64"){const r=Co({inputs:{input:i},backend:e}),a=du({inputs:{x:r},backend:e,attrs:{dtype:o}});return e.disposeData(r.dataId),a}if(!x1(i.dtype,o)){const r=je({inputs:{x:i},backend:e});return{dataId:r.dataId,shape:r.shape,dtype:o}}if(e.shouldExecuteOnCPU([i])){const r=e.tensorMap.get(i.dataId).values,[a,u,l]=XR(r,i.shape,i.dtype,o);return e.makeTensorInfo(a,u,l)}if(o==="int32")return ET(i,e);if(o==="bool"){const r=e.makeTensorInfo([],"bool",Ln("bool",1)),u=Gy({inputs:{a:i,b:r},backend:e});return e.disposeData(r.dataId),u}throw new Error(`Error in Cast: failed to cast ${i.dtype} to ${o}`)}const LT={kernelName:Dd,backendName:"webgpu",kernelFunc:du};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OT=Bt({opType:st.CEIL,cpuKernelImpl:qR}),_T={kernelName:Rd,backendName:"webgpu",kernelFunc:OT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class BT{constructor(t){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workPerThread=4,this.workgroupSize=[64,1,1],this.outputComponent=4,this.size=!0,this.outputShape=t,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="clipVec4"}getUserCode(){return`
      ${ot("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          var clampedValue = clamp(
              value, vec4<f32>(uniforms.minVal), vec4<f32>(uniforms.maxVal));
          clampedValue = select(clampedValue, value, isnanVec4(value));
          setOutputAtIndex(index, clampedValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class WT{constructor(t){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="clip"}getUserCode(){return`
      ${ot("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          if (isnan(value)) {
            setOutputAtIndex(index, value);
            return;
          }
          setOutputAtIndex(index, clamp(value, uniforms.minVal, uniforms.maxVal));
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VT(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{clipValueMin:o,clipValueMax:r}=s;let a;const u=[{type:"float32",data:[o]},{type:"float32",data:[r]}];return et(i.shape)%4===0?a=new BT(i.shape):a=new WT(i.shape),e.runWebGPUProgram(a,[i],i.dtype,u)}const UT={kernelName:wr,backendName:"webgpu",kernelFunc:VT};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class GT{constructor(t){this.outputShape=[],this.variableNames=["real","imag"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="complexAbs"}getUserCode(){return`
    ${ot("index")} {
      if (index < uniforms.size) {
        let re = abs(getRealByOutputIndex(index));
        let im = abs(getImagByOutputIndex(index));
        let mx = max(re, im);

        // The length function in wgsl may be not underflow-safe on some GPUs.
        // So the safe solution is to ensure underflow-safety in all cases.
        setOutputAtIndex(index, select(mx * length(vec2<f32>(1, min(re, im)/mx)), 0.0, mx == 0.0));
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uh(n,t){return{dataId:t.dataId,dtype:t.dtype,shape:n.shape}}function HT(n){const{inputs:t,backend:e}=n,{x:s}=t,i=e.tensorMap.get(s.dataId),o=new GT(s.shape),r=[Uh(s,i.complexTensorInfos.real),Uh(s,i.complexTensorInfos.imag)];return e.runWebGPUProgram(o,r,r[0].dtype)}const jT={kernelName:$u,backendName:"webgpu",kernelFunc:HT};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class KT{constructor(t){this.uniforms="",this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=cs(t,1),this.variableNames=t.map((e,s)=>`T${s}`),this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.offsetLength=t.length-1;for(let e=0;e<this.offsetLength;e++)this.uniforms+=`offset${e} : i32,`;this.shaderKey="concat"}getUserCode(){const t=[];if(this.offsetLength>0){t.push("if (yC < uniforms.offset0){ setOutputAtCoords(coords.x, coords.y, getT0(yR, yC)); }");for(let o=1;o<this.offsetLength;o++)t.push(`else if (yC < uniforms.offset${[o]}){ setOutputAtCoords(coords.x, coords.y, getT${o}(yR, yC - uniforms.offset${o-1})); }`);const s=this.offsetLength,i=this.offsetLength-1;t.push(`else { setOutputAtCoords(coords.x, coords.y, getT${s}(yR, yC - uniforms.offset${i})); }`)}else t.push("setOutputAtCoords(coords.x, coords.y, getT0(yR, yC));");return`
      ${ot("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            let yR = coords.x;
            let yC = coords.y;

            ${t.join(`
        `)}
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fa(n){const{inputs:t,backend:e}=n,{input:s}=t,i=e.tensorMap.get(s.dataId);return je({inputs:{x:i.complexTensorInfos.imag},backend:e})}const XT={kernelName:_p,backendName:"webgpu",kernelFunc:fa};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ki(n,t,e){const s=n[0].dtype;if(s==="complex64"){const m=n.map(k=>Co({inputs:{input:k},backend:e})),g=n.map(k=>fa({inputs:{input:k},backend:e})),b=Ki(m,t,e),v=Ki(g,t,e),w=Xs({inputs:{real:b,imag:v},backend:e});return m.forEach(k=>e.disposeData(k.dataId)),g.forEach(k=>e.disposeData(k.dataId)),e.disposeData(b.dataId),e.disposeData(v.dataId),w}let i=e.shouldExecuteOnCPU(n);if(s==="string"&&(i=!0),i){const m=n.map(I=>{const $=[-1,et(I.shape.slice(t))];return ft({inputs:{x:I},backend:e,attrs:{shape:$}})}),g=m.map(I=>({vals:e.readSync(I.dataId),shape:I.shape})),b=cs(m.map(I=>I.shape),1),v=m[0].shape[0]===1,w=YR(g,b,s,v),k=cs(n.map(I=>I.shape),t),C=e.makeTensorInfo(k,s,w);return m.forEach(I=>e.disposeData(I.dataId)),C}const o=e.device.limits.maxStorageBuffersPerShaderStage-1;if(n.length>o){const m=[];for(let b=0;b<n.length;b+=o){const v=n.slice(b,b+o);m.push(Ki(v,t,e))}const g=Ki(m,t,e);for(const b of m)e.disposeData(b.dataId);return g}const{tensors2D:r,outShape:a}=qT(n,t,e),u=r.map(m=>m.shape),l=new KT(u),c=[],h=new Array(u.length-1);if(h.length>0){h[0]=u[0][1],c.push({type:"int32",data:[h[0]]});for(let m=1;m<h.length;m++)h[m]=h[m-1]+u[m][1],c.push({type:"int32",data:[h[m]]})}const p=e.runWebGPUProgram(l,r,r[0].dtype,c);r.forEach(m=>e.disposeData(m.dataId));const f=ft({inputs:{x:p},backend:e,attrs:{shape:a}});return e.disposeData(p.dataId),f}function qT(n,t,e){const s=cs(n.map(o=>o.shape),t);return{tensors2D:n.map(o=>ft({inputs:{x:o},backend:e,attrs:{shape:[et(o.shape.slice(0,t)),et(o.shape.slice(t))]}})),outShape:s}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hy(n){const{inputs:t,backend:e,attrs:s}=n,{axis:i}=s,o=ee(i,t[0].shape)[0],r=t.map(l=>l.shape);Bp(r,o);const a=cs(t.map(l=>l.shape),o);if(et(a)===0)return e.makeTensorInfo(a,t[0].dtype,[]);const u=t.filter(l=>et(l.shape)>0);return u.length===1?je({inputs:{x:u[0]},backend:e}):Ki(u,o,e)}const YT={kernelName:Du,backendName:"webgpu",kernelFunc:Hy};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZT(n,t,e,s,i=!1,o=null,r=!1,a=4,u=4,l=4){const c=z=>{switch(z){case 1:return"resData = f32(x[xIndex]);";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = vec4<f32>(x[xIndex / 4]);";default:throw new Error(`innerElementSize ${z} is not supported.`)}},h=z=>{switch(z){case 1:return"return f32(W[row * uniforms.wShape[3] + col]);";case 4:return"return vec4<f32>(W[(row * uniforms.wShape[3] + col) / 4]);";default:throw new Error(`innerElementSize ${z} is not supported.`)}},p=n?`
      let coord = vec4<i32>(batch, xRow, xCol, xCh);
      `:`
      let coord = vec4<i32>(batch, xCh, xRow, xCol);
      `,f=n?`
      let coords = vec4<i32>(
        batch,
        row / outWidth,
        row % outWidth,
        col);
      `:`
      let coords = vec4<i32>(
        batch,
        row,
        col / outWidth,
        col % outWidth);
      `,m=n?"uniforms.xShape[1]":"uniforms.xShape[2]",g=n?"uniforms.xShape[2]":"uniforms.xShape[3]",b=n?"row":"col",v=n?"col":"row",w=`
      let inChannels = uniforms.wShape[2];
      let outWidth = ${n?"uniforms.outShape[2]":"uniforms.outShape[3]"};
      let outRow = ${b} / outWidth;
      let outCol = ${b} % outWidth;

      let WRow = ${v} / (uniforms.filterDims[1] * inChannels);
      let WCol = ${v} / inChannels % uniforms.filterDims[1];
      let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * WRow - uniforms.pads[0];
      let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * WCol - uniforms.pads[1];
      let xCh = ${v} % inChannels;
      var resData = ${Rt(a)}(0.0);
      // The bounds checking is always needed since we use it to pad zero for
      // the 'same' padding type.
      if (xRow >= 0 && xRow < ${m} && xCol >= 0 && xCol < ${g}) {
        ${p}
        let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);
        ${c(a)}
      }
      return resData;`,k=n?t&&s?`
      ${w}`:`
      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${w}
      }
      return ${Rt(a)}(0.0);`:s&&e?`
      ${w}`:`
      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {
        ${w}
      }
      return ${Rt(a)}(0.0);`,C=`${h(u)}`,I=Rt(l),N=Rt(n?a:u),$=Rt(n?u:a);return`
      ${is(o,r,l===4,4)}
      fn mm_readA(batch: i32, row : i32, col : i32) -> ${N} {
        ${n?k:C}
      }

      fn mm_readB(batch: i32, row : i32, col : i32) -> ${$} {
        ${n?C:k}
      }

      fn mm_write(batch: i32, row : i32, col : i32, valueIn : ${I}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)
        {
        var value = valueIn;
        let outWidth = ${n?"uniforms.outShape[2]":"uniforms.outShape[3]"};
        ${f}
        ${Ks(i,o)}
        setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }`}class QT{constructor(t,e,s,i,o=!1,r=null,a=!1,u=!1){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=t.outShape,this.isChannelsLast=t.dataFormat==="channelsLast",this.isVec4=((t.inChannels%4===0||t.inChannels%3===0)&&this.isChannelsLast||t.outWidth%4===0&&!this.isChannelsLast)&&t.outChannels%4===0,this.dispatchLayout=this.isChannelsLast?{x:[3],y:[1,2],z:[0]}:{x:[2,3],y:[1],z:[0]},this.workgroupSize=Fy(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=My(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4?(this.outputComponent=4,this.isChannelsLast&&t.inChannels%4!==0?(this.innerElementSize=3,this.variableComponents=[1,4]):(this.innerElementSize=4,this.variableComponents=[4,4]),o&&(this.variableNames.push("bias"),this.variableComponents.push(4)),a&&(this.variableNames.push("preluActivationWeights"),this.variableComponents.push(4))):(this.innerElementSize=this.elementsPerThread[0],o&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights")),this.sequentialAccessByThreads=u,this.addBias=o,this.activation=r,this.hasPreluActivationWeights=a,this.tileAOuter=this.workgroupSize[1]*this.elementsPerThread[1],this.tileBOuter=this.workgroupSize[0]*this.elementsPerThread[0],this.tileInner=Math.max(this.workgroupSize[0]*this.innerElementSize,this.workgroupSize[1]),this.fitAOuter=e%this.tileAOuter===0,this.fitBOuter=s%this.tileBOuter===0,this.fitInner=i%this.tileInner===0,this.shaderKey=`conv2DMM_${this.elementsPerThread}_${this.activation}}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.innerElementSize}_${this.isChannelsLast}_${this.sequentialAccessByThreads}`}getUserCode(){const t=this.isVec4?ha(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner):da(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner,!1,null,this.sequentialAccessByThreads),e=this.isVec4?[this.innerElementSize,4,4]:[1,1,1];return`
    ${ZT(this.isChannelsLast,this.fitAOuter,this.fitBOuter,this.fitInner,this.addBias,this.activation,this.hasPreluActivationWeights,e[0],e[1],e[2])}
    ${t}
  `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JT{constructor(t,e=!1,s=null,i=!1){this.variableNames=["x","W"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>,",this.workgroupSize=[4,4,8],this.outputShape=t.outShape,this.isChannelsLast=t.dataFormat==="channelsLast",this.dispatchLayout=this.isChannelsLast?{x:[2],y:[1],z:[0,3]}:{x:[3],y:[2],z:[0,1]},this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=e,this.activation=s,this.hasPreluActivationWeights=i,e&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`conv2dnaive_${this.activation}_${this.isChannelsLast}`}getUserCode(){return`
       ${is(this.activation,this.hasPreluActivationWeights,!1,4)}
       fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32{
         let coords = vec4<i32>(batch, row, col, chan);
         if (coordsInBounds4D(coords, uniforms.xShape)) {
           return  getX(batch, row, col, chan);
         } else {
          return 0.0;
         }
       }
       fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{
         let coords = vec4<i32>(row, col, xChannel, outChannel);
         if(coordsInBounds4D(coords, uniforms.wShape)) {
           return getW(row, col, xChannel, outChannel);
          } else {
            return 0.0;
          }
       }
       fn writeResult(batch : i32, row : i32, col : i32, chan : i32, valueIn : f32) {
         let coords = ${this.isChannelsLast?"vec4<i32>(batch, row, col, chan);":"vec4<i32>(batch, chan, row, col);"}
         if (coordsInBounds4D(coords, uniforms.outShape)) {
           var value = valueIn;
           ${Ks(this.addBias,this.activation)}
           setOutputAtCoords(coords.x, coords.y, coords.z, coords.w, value);
         }
       }
       ${ot("index")} {
         let coords = getOutputCoords();
         let batch = coords[0];
         let outChannel = ${this.isChannelsLast?"coords[3];":"coords[1];"}
         let outRow = ${this.isChannelsLast?"coords[1];":"coords[2];"}
         let outCol = ${this.isChannelsLast?"coords[2];":"coords[3];"}
         var acc : f32 = 0.0;
         for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {
           for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {
             let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * row - uniforms.pads[0];
             let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * col - uniforms.pads[1];
             for (var xChannel = 0; xChannel < ${this.isChannelsLast?"uniforms.xShape[3];":"uniforms.xShape[1];"} xChannel = xChannel + 1) {
               ${this.isChannelsLast?"let v = readInp(batch, xRow, xCol, xChannel);":"let v = readInp(batch, xChannel, xRow, xCol);"}
               let f = readFilt(row, col, xChannel, outChannel);
               acc = acc + v * f;
             }
           }
         }
         writeResult(batch, outRow, outCol, outChannel, acc);
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tz{constructor(t,e){this.variableNames=["x"],this.uniforms=`pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, outWidth : i32, itemsPerBlockRow : i32,
       inChannels : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=e,this.shaderKey=`im2col_${this.isChannelsLast}`}getUserCode(){const t=this.isChannelsLast?1:2,e=this.isChannelsLast?2:3,s=this.isChannelsLast?"coords[1]":"coords[2]",i=this.isChannelsLast?"coords[2]":"coords[1]",o=this.isChannelsLast?"getX(batch, xRow, xCol, ch)":"getX(batch, ch, xRow, xCol)";return`
    ${ot("index")} {
      let coords = getCoordsFromIndex(index);
      if(index < uniforms.size) {
        let batch = coords[0];
        let row = ${s};
        let col = ${i};
        let offsetY = (row / uniforms.outWidth) * uniforms.strides[0] - uniforms.pads[0];
        let xRow = offsetY + uniforms.dilations[0] * (col / uniforms.itemsPerBlockRow);
        var value = 0.0;
        if(xRow < uniforms.xShape[${t}] && xRow >= 0) {
          let offsetX = (row % uniforms.outWidth) * uniforms.strides[1] -
              uniforms.pads[1];
          let xCol = offsetX + uniforms.dilations[1] * ((col %
              uniforms.itemsPerBlockRow) / uniforms.inChannels);
          let ch = col % uniforms.inChannels;
          if(xCol < uniforms.xShape[${e}] && xCol >= 0) {
            value = ${o};
          }
        }
        setOutputAtIndex(index, value);
      }
    }
   `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ur(n,t){const e=n.length;return e>=3?t?[...n.slice(0,-3),n[e-3]*n[e-2],n[e-1]]:[...n.slice(0,-3),n[e-3],n[e-2]*n[e-1]]:!t&&e===1&&n[0]>1?[n[0],1]:null}function ez({x:n,filter:t,convInfo:e,backend:s,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:r=0,activation:a=null}){const u=e.dataFormat==="channelsLast",l=!u,c=!1,h=u&&e.filterHeight===e.inHeight&&e.filterWidth===e.inWidth&&e.padInfo.type==="VALID",p=[];let f,m;if(h){const v=e.inHeight*e.inWidth*e.inChannels;f=ft({inputs:{x:n},backend:s,attrs:{shape:[1,e.batchSize,v]}}),m=ft({inputs:{x:t},backend:s,attrs:{shape:[1,v,e.outChannels]}})}else f=ft({inputs:{x:n},backend:s,attrs:{shape:u?[e.batchSize,e.inHeight*e.inWidth,e.inChannels]:[e.batchSize,e.inChannels,e.inHeight*e.inWidth]}}),m=ft({inputs:{x:t},backend:s,attrs:{shape:[1,e.inChannels,e.outChannels]}});if(p.push(f),p.push(m),o!=null){const v=ur(o.shape,u);v!=null&&(o=ft({inputs:{x:o},backend:s,attrs:{shape:v}}),p.push(o))}if(i!=null){const v=ur(i.shape,u);v!=null&&(i=ft({inputs:{x:i},backend:s,attrs:{shape:v}}),p.push(i))}const g=pa({a:u?f:m,b:u?m:f,transposeA:l,transposeB:c,backend:s,bias:i,activation:a,preluActivationWeights:o,leakyreluAlpha:r}),b=ft({inputs:{x:g},backend:s,attrs:{shape:e.outShape}});p.push(g);for(const v of p)s.disposeData(v.dataId);return b}function nz({x:n,filter:t,convInfo:e,backend:s,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:r=0,activation:a=null}){const{filterWidth:u,filterHeight:l,inChannels:c,strideWidth:h,strideHeight:p,padInfo:f,outWidth:m,outHeight:g,dilationWidth:b,dilationHeight:v,dataFormat:w}=e,k=w==="channelsLast",C=u*l*c,I=g*m,N=k?[e.batchSize,I,C]:[e.batchSize,C,I],$=new tz(N,k),A=[{type:"int32",data:[f.top,f.left]},{type:"int32",data:[p,h]},{type:"int32",data:[v,b]},{type:"int32",data:[m]},{type:"int32",data:[c*u]},{type:"int32",data:[c]}],z=s.runWebGPUProgram($,[n],n.dtype,A),F=[];F.push(z);const E=ft({inputs:{x:t},backend:s,attrs:{shape:[1,C,-1]}});if(F.push(E),o!=null){const V=ur(o.shape,k);V!=null&&(o=ft({inputs:{x:o},backend:s,attrs:{shape:V}}),F.push(o))}if(i!=null){const V=ur(i.shape,k);V!=null&&(i=ft({inputs:{x:i},backend:s,attrs:{shape:V}}),F.push(i))}const W=pa({a:k?z:E,b:k?E:z,transposeA:!k,transposeB:!1,backend:s,bias:i,activation:a,preluActivationWeights:o,leakyreluAlpha:r}),_=ft({inputs:{x:W},backend:s,attrs:{shape:e.outShape}});F.push(W);for(const V of F)s.disposeData(V.dataId);return _}function jy({x:n,filter:t,convInfo:e,backend:s,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:r=0,activation:a=null}){const u=i!=null,l=o!=null,c=e.dataFormat==="channelsLast",h=c&&e.filterHeight===e.inHeight&&e.filterWidth===e.inWidth&&e.padInfo.type==="VALID",p=he().getBool("WEBGPU_USE_NAIVE_CONV2D_DEBUG");if(!p&&(h||e.filterHeight===1&&e.filterWidth===1&&e.dilationHeight===1&&e.dilationWidth===1&&e.strideHeight===1&&e.strideWidth===1&&(e.padInfo.type==="SAME"||e.padInfo.type==="VALID")))return ez({x:n,filter:t,convInfo:e,backend:s,bias:i,activation:a,preluActivationWeights:o,leakyreluAlpha:r});const f=he().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),m=f>-1?f:s.thresholdToIncreaseWorkgroups,g=e.batchSize*Math.ceil(e.outHeight*e.outWidth/32)*Math.ceil(e.outChannels/32);if(he().getBool("WEBGPU_CONV_SEPARATE_IM2COL_SHADER")||g<=m)return nz({x:n,filter:t,convInfo:e,backend:s,bias:i,preluActivationWeights:o,leakyreluAlpha:r,activation:a});let b;const v=[e.padInfo.top,e.padInfo.left],w=[{type:"int32",data:[e.filterHeight,e.filterWidth]},{type:"int32",data:[...v]},{type:"int32",data:[e.strideHeight,e.strideWidth]},{type:"int32",data:[e.dilationHeight,e.dilationWidth]}];if(p)b=new JT(e,u,a,l);else{const N=c?e.outHeight*e.outWidth:e.outChannels,$=c?e.outChannels:e.outHeight*e.outWidth,A=e.filterHeight*e.filterWidth*e.inChannels;w.push({type:"int32",data:[N]},{type:"int32",data:[$]},{type:"int32",data:[A]});const z=s.adapterInfo.isIntel();b=new QT(e,N,$,A,u,a,l,z)}const k=[],C=[n,t];u&&(!c&&i.shape.length===1&&(i=ft({inputs:{x:i},backend:s,attrs:{shape:[i.shape[0],1,1]}}),k.push(i)),C.push(i)),l&&(!c&&o.shape.length===1&&(o=ft({inputs:{x:o},backend:s,attrs:{shape:[o.shape[0],1,1]}}),k.push(o)),C.push(o)),a==="leakyrelu"&&(w.push({type:"float32",data:[r]}),b.uniforms+=" alpha : f32,");const I=s.runWebGPUProgram(b,C,n.dtype,w);for(const N of k)s.disposeData(N.dataId);return I}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sz(n){const{inputs:t,attrs:e,backend:s}=n,{x:i,filter:o}=t,{strides:r,pad:a,dataFormat:u,dilations:l,dimRoundingMode:c}=e,h=ws(u),p=Xe(i.shape,o.shape,r,l,a,c,!1,h);return jy({x:i,filter:o,convInfo:p,backend:s})}const iz={kernelName:Ru,backendName:"webgpu",kernelFunc:sz};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oz{constructor(t){this.variableNames=["dy","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>,",this.workgroupSize=[64,1,1],this.size=!1,this.isVec4=!1,this.workPerThread=1,this.outputShape=t.inShape,this.isChannelsLast=t.dataFormat==="channelsLast",this.isVec4=this.isChannelsLast&&t.outChannels%4===0&&t.inChannels%4===0,this.isVec4?(this.workPerThread=2,this.outputComponent=4,this.workgroupSize=[4,4,4],this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize,[4,this.workPerThread,1])):(this.size=!0,this.workPerThread=1,this.workgroupSize=[64,1,1],this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize)),this.shaderKey=`conv2DDerInput_${this.isChannelsLast}_${this.isVec4}_${this.workPerThread}`}getUserCode(){const t=this.isChannelsLast?1:2,e=this.isChannelsLast?2:3,s=this.isChannelsLast?3:1,i=`
    ${ot()} {
      let batch = i32(globalId.z) / uniforms.outShape[1];
      let r = i32(globalId.z) % uniforms.outShape[1];
      let c = i32(globalId.y) * ${this.workPerThread};
      let d1 = i32(globalId.x) * 4;

      let dyCorner = vec2<i32>(r, c) - uniforms.pads;

      // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
      // ? = to be determined. : = across all values in that axis.
      var dotProd: array<vec4<f32>, ${this.workPerThread}>;
      for (var i = 0; i < ${this.workPerThread}; i++) {
        dotProd[i] = vec4<f32>(0.0);
      }
      for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
        let dyR = f32(dyCorner.x + wR) / f32(uniforms.strides.x);
        let wRPerm = uniforms.filterDims.x - 1 - wR;
        if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) ||
            fract(dyR) > 0.0) {
          continue;
        }
        let idyR = i32(dyR);

        for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
          let dyC = f32(dyCorner.y + wC) / f32(uniforms.strides.y);
          let dyC2 = f32(dyCorner.y + 1 + wC) / f32(uniforms.strides.y);
          let wCPerm = uniforms.filterDims.y - 1 - wC;
          var bDyCVal = true;
          var bDyCVal2 = true;
          if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
              fract(dyC) > 0.0) {
            bDyCVal = false;
          }
          if (dyC2 < 0.0 || dyC2 >= f32(uniforms.outBackprop[2]) ||
              fract(dyC2) > 0.0) {
            bDyCVal2 = false;
          }

          let idyC = i32(dyC);
          let idyC2 = i32(dyC2);
          if (bDyCVal && bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
              xValue = getDy(batch, idyR, idyC2, d2);
              dotProd[1] = dotProd[1] + vec4<f32>(dot(xValue, wValue0),
                                                  dot(xValue, wValue1),
                                                  dot(xValue, wValue2),
                                                  dot(xValue, wValue3));
            }
          } else if (bDyCVal) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
            }
          } else if (bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC2, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[1] = dotProd[1] + tmpval;
            }
          }
        }
      }

      for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
        let coords = vec4<i32>(batch, r, c + i, d1);
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], dotProd[i]);
        }
      }
    }
    `;return this.isVec4?`
    ${i}
    `:`
    ${ot("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[${s}];

        let dyCorner = vec2<i32>(coords[${t}], coords[${e}]) - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.strides.x);
          let wRPerm = uniforms.filterDims.x - 1 - wR;
          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||
              wRPerm < 0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.strides.y);
            let wCPerm = uniforms.filterDims.y - 1 - wC;
            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
                fract(dyC) > 0.0 || wCPerm < 0) {
              continue;
            }
            let idyC = i32(dyC);

            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {
              let xValue = ${this.isChannelsLast?"getDy(batch, idyR, idyC, d2)":"getDy(batch, d2, idyR, idyC)"};
              let wValue = getW(wRPerm, wCPerm, d1, d2);
              dotProd = dotProd + xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}class rz{constructor(t){this.variableNames=["x","dy"],this.uniforms="pads : vec2<i32>, strides : vec2<i32>, batchSize : i32, outHeight : i32, outWidth : i32, inHeight : i32, inWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.filterShape,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=t.dataFormat==="channelsLast",this.shaderKey=`conv2DDerFilter_${this.isChannelsLast}`}getUserCode(){return`
    ${ot("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let d2 = coords[3];

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b = b + 1) {
          for (var yR = 0; yR < uniforms.outHeight; yR = yR + 1) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];
            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC = yC + 1) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              if (${this.isChannelsLast}) {
                let dyValue = getDy(b, yR, yC, d2);
                let xValue = getX(b, xR, xC, d1);
                dotProd = dotProd + xValue * dyValue;
              } else {
                let dyValue = getDy(b, d2, yR, yC);
                let xValue = getX(b, d1, xR, xC);
                dotProd = dotProd + xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}class az{constructor(t){this.variableNames=["x","dy"],this.uniforms=`pads : vec3<i32>, strides : vec3<i32>, batchSize : i32, outDepth : i32,
       outHeight : i32, outWidth : i32, inDepth : i32, inHeight : i32, inWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.filterShape,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerFilter"}getUserCode(){return`
    ${ot("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wF = coords.x;
        let wR = coords.y;
        let wC = coords.z;
        let d1 = coords.w;
        let d2 = coords.u;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yF = 0; yF < uniforms.outDepth; yF++) {
            let xF = wF + yF * uniforms.strides[0] - uniforms.pads[0];
            if (xF < 0 || xF >= uniforms.inDepth) {
              continue;
            }

            for (var yR = 0; yR < uniforms.outHeight; yR++) {
              let xR = wR + yR * uniforms.strides[1] - uniforms.pads[1];
              if (xR < 0 || xR >= uniforms.inHeight) {
                continue;
              }

              for (var yC = 0; yC < uniforms.outWidth; yC++) {
                let xC = wC + yC * uniforms.strides[2] - uniforms.pads[2];
                if (xC < 0 || xC >= uniforms.inWidth) {
                  continue;
                }

                let dyValue = getDy(b, yF, yR, yC, d2);
                let xValue = getX(b, xF, xR, xC, d1);
                dotProd += xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}class uz{constructor(t){this.variableNames=["dy","W"],this.uniforms=`filterDims : vec3<i32>, pads : vec3<i32>, strides : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32, outChannels : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.inShape,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerInput"}getUserCode(){return`
    ${ot("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let d1 = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyFCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let dyF = f32(dyFCorner + wF) / f32(uniforms.strides[0]);
          if (dyF < 0.0 || dyF >= f32(uniforms.outDepth) || fract(dyF) > 0.0) {
            continue;
          }
          let idyF = i32(dyF);

          let wFPerm = uniforms.filterDims[0] - 1 - wF;

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            let wRPerm = uniforms.filterDims[1] - 1 - wR;

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let wCPerm = uniforms.filterDims[2] - 1 - wC;

              for (var d2 = 0; d2 < uniforms.outChannels; d2++) {
                let xValue = getDy(batch, idyF, idyR, idyC, d2);
                let wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lz(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,dy:o}=t,{strides:r,pad:a,dataFormat:u,dimRoundingMode:l,filterShape:c}=s,h=ws(u),p=Xe(i.shape,c,r,1,a,l,!1,h),f=new rz(p),m=[{type:"int32",data:[p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.batchSize]},{type:"int32",data:[p.outHeight]},{type:"int32",data:[p.outWidth]},{type:"int32",data:[p.inHeight]},{type:"int32",data:[p.inWidth]}];return e.runWebGPUProgram(f,[i,o],i.dtype,m)}const cz={kernelName:Wp,backendName:"webgpu",kernelFunc:lz};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hz(n=4){const t=o=>{switch(o){case 1:return"return W[getIndexFromCoords4D(coord, uniforms.wShape)];";case 4:return`
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];
            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];
            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];
            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];
            return vec4<f32>(v0, v1, v2, v3);
            `;default:throw new Error(`innerElementSize ${o} is not supported.`)}},s=`if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${`
      let outRow = row / uniforms.outShape[2];
      let outCol = row % uniforms.outShape[2];

      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];
      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.strides[0]);
      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.strides[1]);
      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {
        return ${Rt(n)}(0.0);
      }
      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {
        return ${Rt(n)}(0.0);
      }
      let coord = vec4<i32>(
          batch,
          i32(xR),
          i32(xC),
          col % uniforms.outBackprop[3]);
      return x[getIndexFromCoords4D(coord, uniforms.xShape)/${n}];`}
      }
      return ${Rt(n)}(0.0);`;return`
  fn mm_readA(batch: i32, row : i32, col : i32) -> ${Rt(n)} {
    ${s}
  }

  fn mm_readB(batch: i32, row : i32, col : i32) -> ${Rt(n)} {
    let coordX = uniforms.filterDims.x - 1 -
        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
    let coordY = uniforms.filterDims.y - 1 -
        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];
    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&
        coordX >= 0 && coordY >= 0) {
      let rowInner = row % uniforms.outBackprop[3];
      let coord = vec4<i32>(coordX, coordY, col, rowInner);
      ${t(n)}
    }
    return ${Rt(n)}(0.0);
  }

  fn mm_write(batch: i32, row : i32, col : i32, valueInput : ${Rt(n)}) {
    if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
      var value = valueInput;
      let outCoord = vec4<i32>(
          batch,
          row / uniforms.outShape[2],
          row % uniforms.outShape[2],
          col);
      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/${n}] = value;
    }
  }`}class dz{constructor(t){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=t.inShape,tt(t.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),this.isVec4=t.inChannels%4===0&&t.outChannels%4===0,this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workgroupSize=Fy(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=My(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4&&(this.outputComponent=4,this.variableComponents=[4,1]),this.shaderKey=`conv2DDerInputMM_${this.isVec4}_${this.elementsPerThread}`}getUserCode(){const t=this.isVec4?ha(this.elementsPerThread,this.workgroupSize):da(this.elementsPerThread,this.workgroupSize);return`
    ${hz(this.isVec4?4:1)}
    ${t}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pz(n){const{inputs:t,backend:e,attrs:s}=n,{dy:i,filter:o}=t,{inputShape:r,strides:a,pad:u,dataFormat:l,dimRoundingMode:c}=s,h=ws(l),p=Xe(r,o.shape,a,1,u,c,!1,h),f=[{type:"int32",data:[p.filterHeight,p.filterWidth]},{type:"int32",data:[p.filterHeight-1-p.padInfo.top,p.filterWidth-1-p.padInfo.left]},{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.batchSize,p.outHeight,p.outWidth,p.outChannels]}];let m;if(he().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE")||p.dataFormat!=="channelsLast")m=new oz(p);else{m=new dz(p);const g=p.inHeight*p.inWidth,b=p.inChannels,v=p.filterHeight*p.filterWidth*p.outChannels;f.push({type:"uint32",data:[g]},{type:"uint32",data:[b]},{type:"uint32",data:[v]})}return e.runWebGPUProgram(m,[i,o],"float32",f)}const fz={kernelName:Tu,backendName:"webgpu",kernelFunc:pz};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mz{constructor(t){this.variableNames=["x","W"],this.uniforms="filterDims: vec3<i32>, pads: vec3<i32>, strides: vec3<i32>, dilations: vec3<i32>,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.outShape,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3dnaive"}getUserCode(){return`
    ${ot("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords.x;
        let d2 = coords.u;

        let xFRCCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
        let xFCorner = xFRCCorner.x;
        let xRCorner = xFRCCorner.y;
        let xCCorner = xFRCCorner.z;

        let inputDepthNearestVec4 = (uniforms.xShape.u / 4) * 4;
        let inputDepthVec4Remainder = uniforms.xShape.u % 4;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let xF = xFCorner + wF * uniforms.dilations[0];
          if (xF < 0 || xF >= uniforms.xShape.y) {
            continue;
          }

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let xR = xRCorner + wR * uniforms.dilations[1];
            if (xR < 0 || xR >= uniforms.xShape.z) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let xC = xCCorner + wC * uniforms.dilations[2];
              if (xC < 0 || xC >= uniforms.xShape.w) {
                continue;
              }

              for (var d1 = 0; d1 < inputDepthNearestVec4; d1 += 4) {
                let xValues = vec4<f32>(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                let wValues = vec4<f32>(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (inputDepthVec4Remainder == 1) {
                dotProd += getX(batch, xF, xR, xC, inputDepthNearestVec4) *
                  getW(wF, wR, wC, inputDepthNearestVec4, d2);
              } else if (inputDepthVec4Remainder == 2) {
                let xValues = vec2<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1)
                );
                let wValues = vec2<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (inputDepthVec4Remainder == 3) {
                let xValues = vec3<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2)
                );
                let wValues = vec3<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }`}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gz(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,filter:o}=t,{strides:r,pad:a,dilations:u}=s,l=Ni(i.shape,o.shape,r,u,a),c=[l.padInfo.front,l.padInfo.top,l.padInfo.left],h=[{type:"int32",data:[l.filterDepth,l.filterHeight,l.filterWidth]},{type:"int32",data:[...c]},{type:"int32",data:[l.strideDepth,l.strideHeight,l.strideWidth]},{type:"int32",data:[l.dilationDepth,l.dilationHeight,l.dilationWidth]}],p=new mz(l),f=es(i.dtype,o.dtype);return e.runWebGPUProgram(p,[i,o],f,h)}const yz={kernelName:Fu,backendName:"webgpu",kernelFunc:gz};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bz(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,dy:o}=t,{strides:r,pad:a,filterShape:u}=s,l=Ni(i.shape,u,r,1,a),c=new az(l),h=[{type:"int32",data:[l.padInfo.front,l.padInfo.top,l.padInfo.left]},{type:"int32",data:[l.strideDepth,l.strideHeight,l.strideWidth]},{type:"int32",data:[l.batchSize]},{type:"int32",data:[l.outDepth]},{type:"int32",data:[l.outHeight]},{type:"int32",data:[l.outWidth]},{type:"int32",data:[l.inDepth]},{type:"int32",data:[l.inHeight]},{type:"int32",data:[l.inWidth]}];return e.runWebGPUProgram(c,[i,o],o.dtype,h)}const xz={kernelName:zu,backendName:"webgpu",kernelFunc:bz};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wz(n){const{inputs:t,backend:e,attrs:s}=n,{dy:i,filter:o}=t,{strides:r,pad:a,inputShape:u}=s,l=Ni(u,o.shape,r,1,a),c=new uz(l),h=[{type:"int32",data:[l.filterDepth,l.filterHeight,l.filterWidth]},{type:"int32",data:[l.filterDepth-1-l.padInfo.front,l.filterHeight-1-l.padInfo.top,l.filterWidth-1-l.padInfo.left]},{type:"int32",data:[l.strideDepth,l.strideHeight,l.strideWidth]},{type:"int32",data:[l.outDepth]},{type:"int32",data:[l.outHeight]},{type:"int32",data:[l.outWidth]},{type:"int32",data:[l.outChannels]}];return e.runWebGPUProgram(c,[i,o],i.dtype,h)}const vz={kernelName:Vp,backendName:"webgpu",kernelFunc:wz};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cz=Bt({opType:st.COS}),kz={kernelName:Cr,backendName:"webgpu",kernelFunc:Cz};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sz=Bt({opType:st.COSH}),Iz={kernelName:kr,backendName:"webgpu",kernelFunc:Sz};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Nz{constructor(t,e,s,i){this.variableNames=["Image","Boxes","BoxInd"],this.uniforms="extrapolationValue : f32,",this.workgroupSize=[64,1,1],this.size=!0;const[o]=e;this.outputShape=[o,s[0],s[1],t],this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.methodId=i==="bilinear"?1:0,this.cropHeightBiggerThan1=this.outputShape[1]>1,this.cropWidthBiggerThan1=this.outputShape[2]>1,this.shaderKey=`cropAndResize_${this.methodId}_${this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`}getUserCode(){const[t,e]=["f32(uniforms.imageShape[1] - 1)","f32(uniforms.imageShape[2] - 1)"],[s,i,o]=this.cropHeightBiggerThan1?[`(${t} / f32(uniforms.outShape[1] - 1))`,"(y2-y1) * height_ratio",`y1*${t} + f32(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${t}`],[r,a,u]=this.cropWidthBiggerThan1?[`(${e} / f32(uniforms.outShape[2] - 1))`,"(x2-x1) * width_ratio",`x1*${e} + f32(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${e}`];return`
    ${ot("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let height_ratio = f32(${s});
        let width_ratio = f32(${r});
        let b = coords[0];
        let y = coords[1];
        let x = coords[2];
        let d = coords[3];
        // get box vals
        let y1 = getBoxes(b, 0);
        let x1 = getBoxes(b, 1);
        let y2 = getBoxes(b, 2);
        let x2 = getBoxes(b, 3);
        // get image in batch index
        let bInd = i32(round(getBoxInd(b)));
        if(bInd < 0 || bInd >= uniforms.outShape[0]) {
          return;
        }
        let height_scale = ${i};
        let width_scale = ${a};
        let in_y = ${o};
        if( in_y < 0.0 || in_y > ${t} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let in_x = ${u};
        if( in_x < 0.0 || in_x > ${e} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let sourceFracIndexCR = vec2<f32>(in_x,in_y);
        if(${this.methodId} == 1) {
          // Compute the four integer indices.
          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);
          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));
          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);
          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);
          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);
          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);
          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);
          let top = topLeft + (topRight - topLeft) * fracCR.x;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          let newValue = top + (bottom - top) * fracCR.y;
          setOutputAtIndex(index, newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          let sourceNearestCR = vec2<i32>(floor(
            sourceFracIndexCR + vec2<f32>(0.5,0.5)));
          let newValue = getImage(
            bInd, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutputAtIndex(index, newValue);
        }
      }
    }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $z=n=>{const{inputs:t,backend:e,attrs:s}=n,{image:i,boxes:o,boxInd:r}=t,{cropSize:a,method:u,extrapolationValue:l}=s,c=new Nz(i.shape[3],o.shape,a,u),h=[{type:"float32",data:[l]}];return e.runWebGPUProgram(c,[i,o,r],"float32",h)},Dz={kernelName:Up,backendName:"webgpu",kernelFunc:$z};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var ro;(function(n){n.Prod="*",n.Sum="+"})(ro||(ro={}));class Gh{constructor(t,e,s,i){this.variableNames=["x"],this.uniforms="index : f32,",this.size=!0,this.workgroupSize=[128,1,1],this.outputShape=e,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.exclusive=s,this.reverse=i,this.op=t,this.shaderKey=`cum_${this.op}_${this.exclusive}_${this.reverse}`}getUserCode(){const t=this.outputShape.length,e=this.op===ro.Prod?"1.0":"0.0",s=this.exclusive?e:`getX(${Hh(t,"coords",this.op)})`,i=this.outputShape[this.outputShape.length-1];let o="",r="";return this.exclusive?(o=this.reverse?`end != ${i-1}`:"end != 0",r=this.reverse?"end + 1":"end - 1"):(o=this.reverse?`end + pow2 < ${i}`:"end >= pow2",r=this.reverse?"end + pow2":"end - pow2"),`
      ${ot("index")} {
       if (index < uniforms.size) {
         var coords = getCoordsFromIndex(index);

         let end = ${jh(t,"coords",this.op)};
         var val = ${s};
         let pow2 = i32(pow(2.0, uniforms.index));
         if (${o}) {
           let idx = ${r};
           ${jh(t,"coords",this.op)} = idx;
           val ${this.op}= getX(${Hh(t,"coords",this.op)});
         }
         setOutputAtIndex(index, val);
       }
      }
    `}}function Hh(n,t,e){if(n===1)return`${t}`;if(n===2)return`${t}.x, ${t}.y`;if(n===3)return`${t}.x, ${t}.y, ${t}.z`;if(n===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw Error(`Cumulative ${e} for rank ${n} is not yet supported`)}function jh(n,t,e){if(n===1)return`${t}`;if(n===2)return`${t}.y`;if(n===3)return`${t}.z`;if(n===4)return`${t}.w`;throw Error(`Cumulative ${e} for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ky(n,t,e,s,i,o){const r=t.shape.length,a=Me([s],r);let u=t;a!=null&&(u=_n({inputs:{x:t},backend:e,attrs:{perm:a}}));const l=Ke(1,r)[0];if(l!==r-1)throw new Error(`WebGPU cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${s}`);const c=u.shape[l];let h=je({inputs:{x:u},backend:e});for(let p=0;p<=Math.ceil(Math.log2(c))-1;p++){const f=new Gh(n,u.shape,!1,o),m=h,g=[{type:"float32",data:[p]}];h=e.runWebGPUProgram(f,[h],h.dtype,g),e.disposeData(m.dataId)}if(i){const p=new Gh(n,u.shape,i,o),f=h,m=[{type:"float32",data:[0]}];h=e.runWebGPUProgram(p,[h],h.dtype,m),e.disposeData(f.dataId)}if(a!=null){const p=_s(a),f=_n({inputs:{x:h},backend:e,attrs:{perm:p}});return e.disposeData(h.dataId),e.disposeData(u.dataId),f}return h}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rz(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:o,exclusive:r,reverse:a}=s;return Ky(ro.Prod,i,e,o,r,a)}const Az={kernelName:Gp,backendName:"webgpu",kernelFunc:Rz};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tz(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:o,exclusive:r,reverse:a}=s;return Ky(ro.Sum,i,e,o,r,a)}const zz={kernelName:Mu,backendName:"webgpu",kernelFunc:Tz};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fz(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,weights:o}=t,{size:r,binaryOutput:a}=s,u=i.shape.length===1,c=et(o.shape)>0,h=o.dtype,p=u?[i.shape[0]]:[i.shape[0],i.shape[1]],f=u?[r]:[i.shape[0],r],m=_e({backend:e,attrs:{shape:f,value:0,dtype:h}}),g=new Uy(p,c,a),b=[{type:"int32",data:[r]}],v=c?[i,o]:[i];return e.runWebGPUProgram(g,v,h,b,m)}const Mz={kernelName:Hp,backendName:"webgpu",kernelFunc:Fz};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Pz{constructor(t,e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.uniforms="blockSize : i32,",this.outputShape=t,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`depthToSpace_${e}`,this.dataFormat=e}getUserCode(){return`
      ${ot("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let h = ${this.getHeightCoordString()};
          let w = ${this.getWidthCoordString()};
          let d = ${this.getDepthCoordString()};

          let in_h = h / uniforms.blockSize;
          let offset_h = h % uniforms.blockSize;
          let in_w = w / uniforms.blockSize;
          let offset_w = w % uniforms.blockSize;
          let offset_d = (offset_h * uniforms.blockSize + offset_w) *
            ${this.getOutputDepthSize()};
          let in_d = d + offset_d;

          let rlt = ${this.getInputSamplingString()};
          setOutputAtIndex(index, rlt);
        }
      }`}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?"uniforms.outShape[3]":"uniforms.outShape[1]"}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ez(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{blockSize:o,dataFormat:r}=s,a=i.shape[0],u=r==="NHWC"?i.shape[1]:i.shape[2],l=r==="NHWC"?i.shape[2]:i.shape[3],c=r==="NHWC"?i.shape[3]:i.shape[1],h=u*o,p=l*o,f=c/(o*o),m=r==="NHWC"?[a,h,p,f]:[a,f,h,p],g=[{type:"int32",data:[o]}],b=new Pz(m,r);return e.runWebGPUProgram(b,[i],i.dtype,g)}const Lz={kernelName:jp,backendName:"webgpu",kernelFunc:Ez};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Oz{constructor(t,e,s,i=!1,o=null,r=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>,",this.workgroupSize=[16,16,1],this.outputShape=t,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),i&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.addBias=i,this.activation=o,this.hasPreluActivation=r,this.filterHeight=e,this.filterWidth=s,this.shaderKey=`depthwiseNCHW_${this.activation}_${this.filterHeight}_${this.filterWidth}`}getUserCode(){const t=this.filterWidth*this.filterHeight,e=this.workgroupSize[0]*this.workgroupSize[1]*this.workgroupSize[2],s=this.workgroupSize[1]+this.filterHeight-1,i=this.workgroupSize[0]+this.filterWidth-1;return`
      ${is(this.activation,this.hasPreluActivation,!1,4)}

      var<workgroup> mm_Asub : array<array<f32, ${i}>, ${s}>;
      var<workgroup> mm_Bsub : array<array<f32, ${this.filterWidth}>, ${this.filterHeight}>;
      fn readX(batch : i32, channel : i32, row : i32, col : i32) -> f32 {
        var value = 0.0;
        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])
        {
          value = getX(batch, channel, row, col);
        }
        return value;
      }

      ${ot()} {
        let coords = getOutputCoords();
        let batch = coords[0];
        let xRCCorner = vec2<i32>(coords.zw) - uniforms.pads;
        let channelMul = uniforms.wShape[3];
        let d1 = coords[1] / channelMul;
        let q = coords[1] % channelMul;

        let inputRowStart = xRCCorner.x;
        let inputColStart = xRCCorner.y;

        let localRow = i32(localId.y);
        let localCol = i32(localId.x);

        // Load one tile of X into local memory.
        for (var inputRow = localRow; inputRow < ${s}; inputRow = inputRow + ${this.workgroupSize[1]}) {
          for (var inputCol = localCol; inputCol < ${i}; inputCol = inputCol + ${this.workgroupSize[0]}) {
            let rowOffset = inputRow - localRow;
            let colOffset = inputCol - localCol;
            mm_Asub[inputRow][inputCol] = readX(batch, d1, inputRowStart + rowOffset, inputColStart + colOffset);
          }
        }

        // Load one tile of W into local memory.
        var wIndex = i32(localIndex);
        ${t<e?`if (wIndex < ${t})`:`for(; wIndex < ${t}; wIndex = wIndex + ${e})`}

        {
          let wRow = wIndex / ${this.filterWidth};
          let wCol = wIndex % ${this.filterWidth};
          mm_Bsub[wRow][wCol] = getW(wRow, wCol, d1, q);
        }

        workgroupBarrier();

        var value = 0.0;
        for (var wR = 0; wR < ${this.filterHeight}; wR = wR + 1) {
          for (var wC = 0; wC < ${this.filterWidth}; wC = wC + 1) {
            let xVal = mm_Asub[localRow + wR][localCol + wC];
            let wVal = mm_Bsub[wR][wC];
            value = fma(xVal, wVal, value);
          }
        }
        ${Ks(this.addBias,this.activation)}
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Xy{constructor(t,e=!1,s=null,i=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>, virtualWidth : i32,",this.workgroupSize=[64,1,1],this.workPerThread=4,this.outputComponent=4,this.outputShape=t.outShape,this.virtualWidth=Math.ceil(this.outputShape[2]/this.workPerThread)*this.workPerThread;const o=[this.outputShape[0],this.outputShape[1],this.virtualWidth,this.outputShape[3]];this.dispatchLayout=ht(o),this.dispatch=rt(this.dispatchLayout,o,this.workgroupSize,[this.outputComponent*this.workPerThread,1,1]),tt(t.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),e&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),this.convInfo=t,this.addBias=e,this.activation=s,this.hasPreluActivation=i,this.shaderKey=`depthwiseVec4_${s}_${this.convInfo.filterHeight}_${this.convInfo.filterWidth}_${this.convInfo.strideHeight}_${this.convInfo.strideWidth}_${this.workPerThread}`}getUserCode(){const t=(this.workPerThread-1)*this.convInfo.strideWidth+this.convInfo.filterWidth,e=this.convInfo.strideHeight,s=this.convInfo.strideWidth;return`
      ${is(this.activation,this.hasPreluActivation,!0,4)}
      fn readX(batch : i32, row : i32, col : i32, channel : i32) -> vec4<f32> {
        var value = vec4<f32>(0.0);
        if (col >=0 && col < uniforms.inDims[1]) {
          value = getX(batch, row, col, channel);
        }
        return value;
      }

      ${ot("index")} {
        let width0 = uniforms.outShape[3] / ${this.outputComponent};
        let d1 = (index % width0) * ${this.outputComponent};
        var index1 = index / width0;
        let width1 = uniforms.virtualWidth / ${this.workPerThread};
        let c = (index1 % width1) * ${this.workPerThread};
        index1 = index1 / width1;
        let r = index1 % uniforms.outShape[1];
        let batch = index1 / uniforms.outShape[1];

        let xRCCorner = vec2<i32>(r, c) * vec2<i32>(${e}, ${s}) - uniforms.pads;

        let xRCorner = xRCCorner.x;
        let xCCorner = xRCCorner.y;
        var xVals : array<vec4<f32>, ${t}>;
        var dotProd : array<vec4<f32>, ${this.workPerThread}>;
        for (var i = 0; i < ${this.workPerThread}; i++) {
          dotProd[i] = vec4<f32>(0.0);
        }

        // Use constant instead of uniform can give better performance.
        for (var wR = 0; wR < ${this.convInfo.filterHeight}; wR = wR + 1) {
          let xR = xRCorner + wR;
          if (xR >=0 && xR < uniforms.inDims[0]) {
            for (var i = 0; i < ${t}; i++) {
              xVals[i] = readX(batch, xR, xCCorner + i, d1);
            }
            for (var wC = 0; wC < ${this.convInfo.filterWidth}; wC = wC + 1) {
              let wValue = getW(wR, wC, d1, 0);
              for (var i = 0; i < ${this.workPerThread}; i++) {
                dotProd[i] = fma(xVals[i * ${s} + wC], wValue, dotProd[i]);
              }
            }
          }
        }

        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let coords = vec4<i32>(batch, r, c + i, d1);
          if (coordsInBounds4D(coords, uniforms.outShape)) {
            var value = dotProd[i];
            ${Ks(this.addBias,this.activation)}
            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qy{constructor(t,e=!1,s=null,i=!1){this.variableNames=["x","W"],this.uniforms=`pads : vec2<i32>, inDims : vec2<i32>, filterHeight : i32,
      filterWidth : i32, strides : vec2<i32>, dilations : vec2<i32>,`,this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=t.outShape,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=t.dataFormat==="channelsLast",e&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),this.convInfo=t,this.addBias=e,this.activation=s,this.hasPreluActivation=i,this.shaderKey=`depthwise_${this.activation}_${this.isChannelsLast}`}getUserCode(){const t=this.isChannelsLast?"getX(batch, xR, xC, d1);":"getX(batch, d1, xR, xC);";return`
      ${is(this.activation,this.hasPreluActivation,!1,4)}

      ${ot("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let batch = coords[0];
          let xRCCorner = vec2<i32>(coords.${this.isChannelsLast?"yz":"zw"}) * uniforms.strides - uniforms.pads;
          let d2 = coords[${this.isChannelsLast?3:1}];
          let channelMul = uniforms.wShape[3];
          let d1 = d2 / channelMul;
          let q = d2 % channelMul;

          let inputRowStart = xRCCorner.x;
          let inputColStart = xRCCorner.y;
          let inputRowEnd = inputRowStart + uniforms.filterHeight *
              uniforms.dilations[0];
          let inputColEnd = inputColStart + uniforms.filterWidth *
              uniforms.dilations[1];

          // Convolve x(?, ?, d1)|x(d1, ?, ?) with w(:, :, d1, q) to get
          // y(yR, yC, d2)|y(d2, yR, yC). ? = to be determined. : = across all
          // values in that axis. x(?, ?, d1) and y(yR, yC, d2) is for NHWC.
          // x(d1, ?, ?) and y(d2, yR, yC) is for NCHW.
          var value = 0.0;

          // Extract if checking out of for loop for performance.
          if (inputRowStart >= 0 && inputColStart >= 0 &&
            inputRowEnd < uniforms.inDims[0] &&
                inputColEnd < uniforms.inDims[1]) {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  let xVal = ${t};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            } else {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                if (xR < 0 || xR >= uniforms.inDims[0]) {
                  continue;
                }

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  if (xC < 0 || xC >= uniforms.inDims[1]) {
                    continue;
                  }

                  let xVal = ${t};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            }
            ${Ks(this.addBias,this.activation)}
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _z(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,filter:o}=t,{strides:r,pad:a,dataFormat:u,dilations:l,dimRoundingMode:c}=s,h=ws(u);let p=l;p==null&&(p=[1,1]);const f=Xe(i.shape,o.shape,r,p,a,c,!0,h),m=[{type:"int32",data:[f.padInfo.top,f.padInfo.left]},{type:"int32",data:[f.inHeight,f.inWidth]}],g=f.dataFormat==="channelsLast";let b;return!g&&f.inHeight>16&&f.inWidth>16&&f.strideHeight===1&&f.strideWidth===1&&f.dilationWidth===1&&f.dilationHeight===1&&f.inChannels===f.outChannels?b=new Oz(f.outShape,f.filterHeight,f.filterWidth):g&&f.outHeight>4&&f.outWidth>4&&f.strideWidth<=2&&f.inChannels===f.outChannels&&f.dilationHeight===1&&f.dilationWidth===1&&f.inChannels%4===0?(b=new Xy(f),m.push({type:"int32",data:[b.virtualWidth]})):(b=new qy(f),m.push({type:"int32",data:[f.filterHeight]},{type:"int32",data:[f.filterWidth]},{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.dilationHeight,f.dilationWidth]})),e.runWebGPUProgram(b,[i,o],i.dtype,m)}const Bz={kernelName:Pu,backendName:"webgpu",kernelFunc:_z};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Wz{constructor(t){this.variableNames=["x","dy"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>, outHeight : i32,
      outWidth : i32, inHeight : i32, inWidth : i32, batchSize : i32, channelMul : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.filterShape,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_filter"}getUserCode(){return`
      ${ot("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let dm = coords[3];
        let d2 = d1 * uniforms.channelMul + dm;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yR = 0; yR < uniforms.outHeight; yR++) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];

            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC++) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              let dyValue = getDy(b, yR, yC, d2);
              let xValue = getX(b, xR, xC, d1);
              dotProd += xValue * dyValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}class Vz{constructor(t){this.variableNames=["dy","W"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, channelMul : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.inShape,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_input"}getUserCode(){return`
      ${ot("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[3];
        let dyCorner = coords.yz - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }

          let idyR = i32(dyR);
          let wRPerm = uniforms.filterDims[0] - 1 - wR;

          for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }

            let idyC = i32(dyC);
            let wCPerm = uniforms.filterDims[1] - 1 - wC;

            for (var dm = 0; dm < uniforms.channelMul; dm++) {
              let d2 = d1 * uniforms.channelMul + dm;
              let xValue = getDy(batch, idyR, idyC, d2);
              let wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uz(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,dy:o}=t,{strides:r,dilations:a,pad:u,dimRoundingMode:l,filterShape:c}=s,h=Xe(i.shape,c,r,a,u,l,!0),p=new Wz(h),f=[{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.filterHeight,h.filterWidth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]},{type:"int32",data:[h.inHeight]},{type:"int32",data:[h.inWidth]},{type:"int32",data:[h.batchSize]},{type:"int32",data:[h.outChannels/h.inChannels]}];return e.runWebGPUProgram(p,[i,o],"float32",f)}const Gz={kernelName:Kp,backendName:"webgpu",kernelFunc:Uz};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hz(n){const{inputs:t,backend:e,attrs:s}=n,{dy:i,filter:o}=t,{strides:r,dilations:a,pad:u,dimRoundingMode:l,inputShape:c}=s,h=Xe(c,o.shape,r,a,u,l,!0),p=new Vz(h),f=[{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.filterHeight-1-h.padInfo.top,h.filterWidth-1-h.padInfo.left]},{type:"int32",data:[h.filterHeight,h.filterWidth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]},{type:"int32",data:[h.outChannels/h.inChannels]}];return e.runWebGPUProgram(p,[i,o],i.dtype,f)}const jz={kernelName:Xp,backendName:"webgpu",kernelFunc:Hz};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Kz{constructor(t){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[t,t],this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="diag"}getUserCode(){return`
      ${ot("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let value = select(0.0, getX(coords[0]), coords[0] == coords[1]);
          setOutputAtIndex(index, value);
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xz(n){const{inputs:t,backend:e}=n,{x:s}=t,i=[...s.shape,...s.shape],o=et(s.shape),r=ft({inputs:{x:s},backend:e,attrs:{shape:[o]}}),a=new Kz(o),u=e.runWebGPUProgram(a,[r],r.dtype),l=ft({inputs:{x:u},backend:e,attrs:{shape:i}});return e.disposeData(r.dataId),e.disposeData(u.dataId),l}const qz={kernelName:qp,backendName:"webgpu",kernelFunc:Xz};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Yz{constructor(t){this.variableNames=["x","w"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.outShape,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="dilation2d"}getUserCode(){return`
       ${ot("index")} {
         if (index < uniforms.size) {
           let neg_infinity = -3.4e38;
           let coords = getOutputCoords();
           let batch = coords.x;
           let d1 = coords.w;
           let outTopLeftCorner = coords.yz * uniforms.strides - uniforms.pads;
           let hBeg = outTopLeftCorner.x;
           let wBeg = outTopLeftCorner.y;

           var curVal = neg_infinity;
           for (var h = 0; h < uniforms.filterDims[0]; h = h + 1) {
             let hIn = hBeg + h * uniforms.dilations[0];

             if (hIn >= 0 && hIn < uniforms.xShape[1]) {
               for (var w = 0; w < uniforms.filterDims[1]; w = w + 1) {
                 let wIn = wBeg + w * uniforms.dilations[1];

                 if (wIn >= 0 && wIn < uniforms.xShape[2]) {
                   let val = getX(batch, hIn, wIn, d1) + getW(h, w, d1);
                   if (val > curVal) {
                     curVal = val;
                   }
                 }
               }
             }
           }

           setOutputAtIndex(index, curVal);
         }
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zz(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,filter:o}=t,{strides:r,pad:a,dilations:u}=s,l=$i(i.shape,o.shape,r,a,"NHWC",u),c=[l.padInfo.top,l.padInfo.left],h=[{type:"int32",data:[l.filterHeight,l.filterWidth]},{type:"int32",data:[...c]},{type:"int32",data:[l.strideHeight,l.strideWidth]},{type:"int32",data:[l.dilationHeight,l.dilationWidth]}],p=new Yz(l);return e.runWebGPUProgram(p,[i,o],i.dtype,h)}const Qz={kernelName:Eu,backendName:"webgpu",kernelFunc:Zz};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Jz{constructor(t,e){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=t.inShape,this.dispatchLayout=ht(t.outShape),this.dispatch=rt(this.dispatchLayout,t.outShape,this.workgroupSize),e!=="float32"&&e!=="int32")throw new Error(`Dilation2DBackpropInput only supports float32 and int32
          types, does not support ${e} type.`);this.type=e,this.shaderKey="dilation2DBackpropInput"}getUserCode(){return`
       ${ot("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var xRMax = 0;
           var xCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     xRMax = xR;
                     xCMax = xC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.xShape[3] *
               (xCMax + uniforms.xShape[2] * (xRMax + uniforms.xShape[1] * b));
           let value = getDy(b, r, c, d);
           ${Cs("&result[flatIndexIn]","value",this.type)}
         }
       }
     `}}class tF{constructor(t,e,s){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=t.filterShape,this.dispatchLayout=ht(t.outShape),this.dispatch=rt(this.dispatchLayout,t.outShape,this.workgroupSize),s!=="float32"&&s!=="int32")throw new Error(`Dilation2DBackpropFilter only supports float32 and int32
          types, does not support ${s} type.`);this.type=s,this.shaderKey="dilation2DBackpropFilter"}getUserCode(){return`
       ${ot("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var wRMax = 0;
           var wCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     wRMax = wR;
                     wCMax = wC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.wShape[2] * (wCMax + wRMax * uniforms.wShape[1]);
           let value = getDy(b, r, c, d);
           ${Cs("&result[flatIndexIn]","value",this.type)}
         }
       }
     `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eF(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,filter:o,dy:r}=t,{strides:a,pad:u,dilations:l}=s,c=$i(i.shape,o.shape,a,u,"NHWC",l),h=o.dtype,p=new tF(c,o.shape,h),f=[{type:"int32",data:[c.filterHeight,c.filterWidth]},{type:"int32",data:[c.padInfo.top,c.padInfo.left]},{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.dilationHeight,c.dilationWidth]},{type:"int32",data:[et(c.outShape)]}],m=_e({backend:e,attrs:{shape:o.shape,value:0,dtype:h}});return e.runWebGPUProgram(p,[i,o,r],h,f,m)}const nF={kernelName:Go,backendName:"webgpu",kernelFunc:eF};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sF(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,filter:o,dy:r}=t,{strides:a,pad:u,dilations:l}=s,c=$i(i.shape,o.shape,a,u,"NHWC",l),h=i.dtype,p=new Jz(c,h),f=[{type:"int32",data:[c.filterHeight,c.filterWidth]},{type:"int32",data:[c.padInfo.top,c.padInfo.left]},{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.dilationHeight,c.dilationWidth]},{type:"int32",data:[et(c.outShape)]}],m=_e({backend:e,attrs:{shape:c.inShape,value:0,dtype:h}});return e.runWebGPUProgram(p,[i,o,r],h,f,m)}const iF={kernelName:Uo,backendName:"webgpu",kernelFunc:sF};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oF{constructor(t,e,s){this.variableNames=["Image"],this.uniforms="alpha: f32,",this.workgroupSize=[64,1,1],this.pixelsOpType=bi.DRAW,this.size=!0,this.outputShape=t,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.type=e,this.textureFormat=s,this.shaderKey=`draw_${e}_${s}`}getUserCode(){let t;const e=this.type==="float32"?"value":"value / 255.0";return t=`
      if (uniforms.numChannels == 1) {
        rgba[0] = ${e};
        rgba[1] = ${e};
        rgba[2] = ${e};
      } else {
        rgba[d] = ${e};
      }`,`
       @group(0) @binding(0) var outImage : texture_storage_2d<${this.textureFormat}, write>;
       ${ot("index")} {
         if (index < uniforms.size) {
           var rgba = vec4<f32>(0.0, 0.0, 0.0, uniforms.alpha);
           for (var d = 0; d < uniforms.numChannels; d = d + 1) {
             let value = f32(inBuf[index * uniforms.numChannels + d]);
             ${t}
           }
           rgba.x = rgba.x * rgba.w;
           rgba.y = rgba.y * rgba.w;
           rgba.z = rgba.z * rgba.w;
           let coords = getCoordsFromIndex(index);
           textureStore(outImage, vec2<i32>(coords.yx), rgba);
         }
       }
      `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use backend file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rF(n){const{inputs:t,backend:e,attrs:s}=n,{image:i}=t,{canvas:o,options:r}=s,[a,u]=i.shape.slice(0,2),{imageOptions:l}=r||{},c=(l==null?void 0:l.alpha)||1,h=e.device.features.has("bgra8unorm-storage")?"bgra8unorm":"rgba8unorm",p=[a,u],f=new oF(p,i.dtype,h);o.width=u,o.height=a;const m="webgpu";let g=o.getContext(m),b;g||(b=new OffscreenCanvas(u,a),g=b.getContext(m));const v=i.shape.length===3?i.shape[2]:1;g.configure({device:e.device,format:h,usage:GPUTextureUsage.STORAGE_BINDING,alphaMode:"premultiplied"});const w="int32",k=e.makeTensorInfo(p,w),C=e.tensorMap.get(k.dataId);C.resource=g.getCurrentTexture(),C.external=!0;const I=[{type:"uint32",data:[v]},{type:"float32",data:[c]}];if(e.runWebGPUProgram(f,[i],w,I,k),b){const N=o.getContext("2d");if(!N)throw new Error("Please make sure this canvas has only been used for 2d or webgpu context!");N.drawImage(b,0,0)}return e.disposeData(k.dataId),i}const aF={kernelName:Zp,backendName:"webgpu",kernelFunc:rF};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yy=Se({opType:vt.MUL,cpuKernelImpl:dA,supportsComplex:!0}),uF={kernelName:jd,backendName:"webgpu",kernelFunc:Yy};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zy(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:o,keepDims:r}=s;return qs(i,o,r,"sum",e)}const lF={kernelName:bl,backendName:"webgpu",kernelFunc:Zy};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cF(n){const{inputs:t,backend:e,attrs:s}=n,{equation:i}=s,o=t,{allDims:r,summedDims:a,idDims:u}=Jp(i,o.length);tf(r.length,u,o);const{path:l,steps:c}=ef(a,u),h=c.length;let p=null,f=r.length;const m=[];for(let g=0;g<h;++g){for(const b of c[g]){const{permutationIndices:v,expandDims:w}=nf(f,u[b]);let k;sf(v)?k=o[b]:(k=_n({inputs:{x:o[b]},backend:e,attrs:{perm:v}}),m.push(k));const C=k.shape.slice();for(let I=0;I<w.length;++I)C.splice(w[I],0,1);ke(k.shape,C)||(k=ft({inputs:{x:k},backend:e,attrs:{shape:C}}),m.push(k)),p===null?p=k:(p=Yy({inputs:{a:k,b:p},backend:e}),m.push(p))}g<h-1&&(l[g]>=0&&(p=Zy({inputs:{x:p},backend:e,attrs:{axis:l[g]-(r.length-f),keepDims:!1}}),m.push(p)),f--)}for(const g of m)g!==p&&e.disposeData(g.dataId);return p}const hF={kernelName:Qp,backendName:"webgpu",kernelFunc:cF};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dF=Bt({opType:st.ELU}),pF={kernelName:Sr,backendName:"webgpu",kernelFunc:dF};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fF=n=>{const{inputs:t,backend:e}=n,{dy:s,y:i}=t,o=new ar(vt.ELU_DER,s.shape,i.shape);return e.runWebGPUProgram(o,[s,i],s.dtype)},mF={kernelName:Lu,backendName:"webgpu",kernelFunc:fF};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gF=Se({opType:vt.EQUAL,dtype:"bool",cpuKernelImpl:ZR}),yF={kernelName:w1,backendName:"webgpu",kernelFunc:gF};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bF=Bt({opType:st.ERF}),xF={kernelName:Ir,backendName:"webgpu",kernelFunc:bF};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wF=Bt({opType:st.EXP,cpuKernelImpl:QR,dtype:"float32"}),vF={kernelName:Md,backendName:"webgpu",kernelFunc:wF};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pu(n){const{inputs:t,attrs:e,backend:s}=n,{dim:i}=e,{input:o}=t,r=o.shape.length,a=o.shape.slice();let u=i;return i<0&&(tt(-(r+1)<=i,()=>`Axis must be in the interval [${-(r+1)}, ${r}]`),u=r+i+1),a.splice(u,0,1),ft({inputs:{x:o},backend:s,attrs:{shape:a}})}const CF={kernelName:Ou,backendName:"webgpu",kernelFunc:pu};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kF=Bt({opType:st.EXPM1,cpuKernelImpl:JR}),SF={kernelName:Pd,backendName:"webgpu",kernelFunc:kF};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Kh{constructor(t,e){this.variableNames=["real","imag"],this.outputShape=[],this.uniforms="exponentMultiplier : f32, denominator: f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.component=t,this.shaderKey=`fft_${t}`}getUserCode(){return`
    fn unaryOpComplex(real: f32, expR: f32, imag: f32, expI: f32) -> f32 {
      ${this.component==="real"?"return real * expR - imag * expI;":"return real * expI + imag * expR;"}
    }

    fn mulMatDFT(batch: i32, index: i32) -> f32 {
      let indexRatio = f32(index) / f32(uniforms.realShape[1]);
      let exponentMultiplierTimesIndexRatio =
          uniforms.exponentMultiplier * indexRatio;

      var result = 0.0;

      for (var i = 0; i < uniforms.realShape[1]; i = i + 1) {
        // x = (-2|2 * PI / N) * index * i;
        let x = exponentMultiplierTimesIndexRatio * f32(i);
        let expR = cos(x);
        let expI = sin(x);
        let real = getReal(batch, i);
        let imag = getImag(batch, i);

        result = result +
            unaryOpComplex(real, expR, imag, expI) / uniforms.denominator;
      }

      return result;
    }

    ${ot("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        setOutputAtIndex(index, mulMatDFT(coords[0], coords[1]));
      }
    }
  `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qy(n,t,e){const s=e.tensorMap.get(n.dataId),i=et(n.shape),o=n.shape[n.shape.length-1],r=i/o,a=[],u=ft({inputs:{x:n},backend:e,attrs:{shape:[r,o]}});a.push(u);const l=u.shape,c=new Kh("real",l),h=new Kh("imag",l),p=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:l},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:l}],f=t?2*Math.PI:-2*Math.PI,m=t?l[1]:1,g=[{type:"float32",data:[f]},{type:"float32",data:[m]}],b=e.runWebGPUProgram(c,p,"float32",g);a.push(b);const v=e.runWebGPUProgram(h,p,"float32",g);a.push(v);const w=Xs({inputs:{real:b,imag:v},backend:e});a.push(w);const k=ft({inputs:{x:w},backend:e,attrs:{shape:n.shape}});return a.forEach(C=>e.disposeData(C.dataId)),k}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IF(n){const{inputs:t,backend:e}=n,{input:s}=t;return Qy(s,!1,e)}const NF={kernelName:ff,backendName:"webgpu",kernelFunc:IF};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $F{constructor(t){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="flipLeftRight"}getUserCode(){return`
      ${ot("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let coordX = uniforms.xShape[2] - coords[2] - 1;
          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);
          setOutputAtIndex(index, outputValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DF={kernelName:yf,backendName:"webgpu",kernelFunc:({inputs:n,backend:t})=>{const{image:e}=n,s=t,i=new $F(e.shape);return s.runWebGPUProgram(i,[e],e.dtype)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RF=Bt({opType:st.FLOOR,cpuKernelImpl:tA}),AF={kernelName:Ed,backendName:"webgpu",kernelFunc:RF};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TF=Se({opType:vt.FLOOR_DIV,cpuKernelImpl:eA,dtype:"int32"}),zF={kernelName:Ld,backendName:"webgpu",kernelFunc:TF};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FF{constructor(t,e,s=!1){this.pixelsOpType=bi.FROM_PIXELS,this.outputShape=[0],this.variableNames=[],this.workgroupSize=[256,1,1],this.outputShape=t,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize,[e,1,1]),this.importVideo=s,this.shaderKey=`fromPixels_${this.importVideo}`}getUserCode(){const t=this.importVideo?"textureLoad(src, vec2<i32>(coords.yx));":"textureLoad(src, vec2<i32>(coords.yx), 0)";return`
      @binding(1) @group(0) var src: ${this.importVideo?"texture_external":"texture_2d<f32>"};
      ${ot("index")} {
        let flatIndex = index * uniforms.numChannels;
        if (flatIndex < uniforms.size) {
          let coords = getCoordsFromIndex(flatIndex);
          let values = ${t};
          for (var i = 0; i < uniforms.numChannels; i = i + 1) {
            result[flatIndex + i] = i32(floor(255.0 * values[i]));
          }
        }
      }
  `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use backend file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MF={kernelName:v1,backendName:"webgpu",kernelFunc:PF};let ei,Wa=he().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function PF(n){const{inputs:t,backend:e,attrs:s}=n;let{pixels:i}=t;const{numChannels:o}=s;if(i==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");const r=typeof HTMLVideoElement<"u"&&i instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&i instanceof HTMLImageElement,u=typeof HTMLCanvasElement<"u"&&i instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&i instanceof OffscreenCanvas,l=typeof ImageBitmap<"u"&&i instanceof ImageBitmap,[c,h]=r?[i.videoWidth,i.videoHeight]:[i.width,i.height],p=[h,c,o],f=he().getBool("WEBGPU_IMPORT_EXTERNAL_TEXTURE")&&r,m=r||a;if(l||u||m){let w;if(f)w=e.device.importExternalTexture({source:i});else{if(m){const L=he().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(ei==null||L!==Wa)&&(Wa=L,ei=document.createElement("canvas").getContext("2d",{willReadFrequently:Wa})),ei.canvas.width=c,ei.canvas.height=h,ei.drawImage(i,0,0,c,h),i=ei.canvas}const F=GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,U=e.textureManager.acquireTexture(p[1],p[0],"rgba8unorm",F);e.queue.copyExternalImageToTexture({source:i},{texture:U},[p[1],p[0]]),w=U}const k=et(p),C=Tt(p),I=new FF(p,o,f),N=[{type:"uint32",data:[k]},{type:"uint32",data:[o]},{type:"uint32",data:[...C]}],$=e.makeTensorInfo([h,c],"int32"),A=e.tensorMap.get($.dataId);A.resource=w;const z=e.runWebGPUProgram(I,[$],"int32",N);return e.disposeData($.dataId),z}const g=i.data;let b=g;if(o!=null&&o!==4){b=new Uint8Array(i.width*i.height*o);const w=g.length;let k=0;for(let C=0;C<w;C++)C%4<o&&(b[k++]=g[C])}const v=e.makeTensorInfo(p,"int32",new Int32Array(b));return e.uploadToGPU(v.dataId),v}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class EF{constructor(t,e,s,i,o){this.uniforms="varianceEpsilon : f32,",this.workgroupSize=[128,1,1],this.size=!0,this.variableNames=["x","mean","variance"],Ne(t,e),Ne(t,s),this.outputShape=t,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),i!=null&&(Ne(t,i),this.variableNames.push("offset")),o!=null&&(Ne(t,o),this.variableNames.push("scale")),this.offsetShape=i,this.scaleShape=o,this.shaderKey="batchNorm"}getUserCode(){let t="0.0";this.offsetShape!=null&&(t="getOffsetByOutputIndex(index)");let e="1.0";return this.scaleShape!=null&&(e="getScaleByOutputIndex(index)"),`
      ${ot("index")} {
        if (index < uniforms.size)
        {
          let xValue = getXByOutputIndex(index);
          let meanValue = getMeanByOutputIndex(index);
          let varianValue = getVarianceByOutputIndex(index);
          let offsetValue = ${t};
          let scaleValue = ${e};
          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));
          setOutputAtIndex(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));
        }
      }
  `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LF={kernelName:_u,backendName:"webgpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:s,scale:i,offset:o,mean:r,variance:a}=n,{varianceEpsilon:u}=t,l=e,c=[s,r,a];let h=null;o!=null&&(h=o.shape,c.push(o));let p=null;i!=null&&(p=i.shape,c.push(i));const f=new EF(s.shape,r.shape,a.shape,h,p),m=[{type:"float32",data:[u]}];return l.runWebGPUProgram(f,c,s.dtype,m)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OF(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,filter:o,bias:r,preluActivationWeights:a}=t,{strides:u,pad:l,dataFormat:c,dilations:h,dimRoundingMode:p,activation:f,leakyreluAlpha:m}=s,g=ws(c),b=Xe(i.shape,o.shape,u,h,l,p,!1,g);return jy({x:i,filter:o,convInfo:b,backend:e,bias:r,preluActivationWeights:a,leakyreluAlpha:m,activation:f})}const _F={kernelName:bf,backendName:"webgpu",kernelFunc:OF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BF(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,filter:o,bias:r,preluActivationWeights:a}=t,{strides:u,pad:l,dilations:c,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=s;let m=c;m==null&&(m=[1,1]),tt(ki(u,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${m}'`);const g=Xe(i.shape,o.shape,u,m,l,h,!0),b=[i,o],v=r!=null,w=a!=null;v&&b.push(r),w&&b.push(a);const k=[{type:"int32",data:[g.padInfo.top,g.padInfo.left]},{type:"int32",data:[g.inHeight,g.inWidth]}];let C;return g.outHeight>4&&g.outWidth>4&&g.strideWidth<=2&&g.inChannels===g.outChannels&&g.dilationHeight===1&&g.dilationWidth===1&&g.inChannels%4===0?(C=new Xy(g,v,p,w),k.push({type:"int32",data:[C.virtualWidth]})):(C=new qy(g,v,p,w),k.push({type:"int32",data:[g.filterHeight]},{type:"int32",data:[g.filterWidth]},{type:"int32",data:[g.strideHeight,g.strideWidth]},{type:"int32",data:[g.dilationHeight,g.dilationWidth]})),p==="leakyrelu"&&(k.push({type:"float32",data:[f]}),C.uniforms+=" alpha : f32,"),e.runWebGPUProgram(C,b,"float32",k)}const WF={kernelName:xf,backendName:"webgpu",kernelFunc:BF};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class VF{constructor(t,e){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`gathernd_${t}`,this.sliceDim=t,this.uniforms=`sliceDim : i32, strides : ${de(t)},`}getUserCode(){let t;return this.sliceDim>1?t="uniforms.strides[j]":t="uniforms.strides",`
      ${ot("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          var flattenIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexTemp = i32(round(getIndices(coords[0], j)));
            let strideNum = ${t};
            flattenIndex = flattenIndex + indexTemp * strideNum;
          }

          setOutputAtIndex(index, getA(flattenIndex, coords[1]));
        }
      }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UF(n){const{inputs:t,backend:e}=n,{params:s,indices:i}=t,o=i.shape,r=o[o.length-1],a=et(s.shape),[u,l,c,h]=vf(s,i),p=ft({inputs:{x:i},backend:e,attrs:{shape:[l,r]}}),f=ft({inputs:{x:s},backend:e,attrs:{shape:[et(s.shape)/c,c]}});if(e.shouldExecuteOnCPU([s,i])||s.dtype==="string"){const w=e.readSync(i.dataId),k=e.bufferSync(s),C=nA(w,k,s.dtype,l,r,c,h,s.shape,a);return e.makeTensorInfo(u,s.dtype,C.values)}const m=new VF(r,[l,c]),g=[{type:"int32",data:[r]},{type:"int32",data:h}],b=e.runWebGPUProgram(m,[f,p],f.dtype,g),v=ft({inputs:{x:b},backend:e,attrs:{shape:u}});return e.disposeData(p.dataId),e.disposeData(f.dataId),e.disposeData(b.dataId),v}const GF={kernelName:wf,backendName:"webgpu",kernelFunc:UF};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class HF{constructor(t,e){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.slice(),this.aShape=t,this.outputShape=e,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="gather"}getUserCode(){const t=jF(this.aShape);return`
      ${ot("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let indexZ = i32(getIndices(resRC.x, resRC.z));
          let inBounds = select(0.0, 1.0, indexZ >= 0 && indexZ < uniforms.aShape[2]);
          setOutputAtIndex(index, inBounds * getA(${t}));
        }
      }
    `}}function jF(n){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],e=[];for(let s=0;s<n.length;s++)s===2?e.push("indexZ"):e.push(`${t[s]}`);return e.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jy(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,indices:o}=t,{axis:r,batchDims:a}=s,u=ee(r,i.shape)[0],l=Cf(i,o,u,a),c=et(o.shape),h=[],p=ft({inputs:{x:i},backend:e,attrs:{shape:[l.batchSize,l.outerSize,l.dimSize,l.sliceSize]}}),f=ft({inputs:{x:o},backend:e,attrs:{shape:[l.batchSize,c/l.batchSize]}});h.push(p),h.push(f);const m=[l.batchSize,l.outerSize,c/l.batchSize,l.sliceSize];if(e.shouldExecuteOnCPU([i,o])){const k=e.tensorMap.get(f.dataId).values,C=ue(f.shape,f.dtype,k),N=e.tensorMap.get(p.dataId).values,$=ue(p.shape,p.dtype,N),A=sA($,C,m);return h.forEach(z=>e.disposeData(z.dataId)),e.makeTensorInfo(l.outputShape,A.dtype,A.values)}const g=new HF(p.shape,m),b=e.runWebGPUProgram(g,[p,f],p.dtype);h.push(b);const v=ft({inputs:{x:b},backend:e,attrs:{shape:l.outputShape}});return h.forEach(w=>e.disposeData(w.dataId)),v}const KF={kernelName:Bu,backendName:"webgpu",kernelFunc:Jy};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XF=Se({opType:vt.GREATER,cpuKernelImpl:oA,dtype:"bool"}),qF={kernelName:C1,backendName:"webgpu",kernelFunc:XF};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YF=Se({opType:vt.GREATER_EQUAL,dtype:"bool",cpuKernelImpl:iA}),ZF={kernelName:Bd,backendName:"webgpu",kernelFunc:YF};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QF(n){const{inputs:t,backend:e}=n,{input:s}=t;return Qy(s,!0,e)}const JF={kernelName:kf,backendName:"webgpu",kernelFunc:QF};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tM=Bt({opType:st.IS_FINITE,dtype:"bool"}),eM={kernelName:Nr,backendName:"webgpu",kernelFunc:tM};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nM=Bt({opType:st.IS_INF,dtype:"bool"}),sM={kernelName:$r,backendName:"webgpu",kernelFunc:nM};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iM=Bt({opType:st.IS_NAN,dtype:"bool"}),oM={kernelName:Dr,backendName:"webgpu",kernelFunc:iM};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rM(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{alpha:o}=s,r=[{type:"float32",data:[o]}],a=new Ti(i.shape,st.LEAKYRELU,"alpha : f32,");return e.runWebGPUProgram(a,[i],"float32",r)}const aM={kernelName:Wu,backendName:"webgpu",kernelFunc:rM};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uM=Se({opType:vt.LESS,dtype:"bool",cpuKernelImpl:aA}),lM={kernelName:k1,backendName:"webgpu",kernelFunc:uM};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cM=Se({opType:vt.LESS_EQUAL,dtype:"bool",cpuKernelImpl:rA}),hM={kernelName:S1,backendName:"webgpu",kernelFunc:cM};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dM{constructor(t){this.variableNames=[],this.outputShape=[],this.uniforms="start : f32, step : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[t],this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="linSpace"}getUserCode(){return`
      ${ot("index")} {
        if (index < uniforms.size) {
          setOutputAtIndex(index, uniforms.start + f32(index) * uniforms.step);
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pM(n){const{backend:t,attrs:e}=n,{start:s,stop:i,num:o}=e,r=(i-s)/(o-1),a=new dM(o),u=[{type:"float32",data:[s]},{type:"float32",data:[r]}];return t.runWebGPUProgram(a,[],"float32",u)}const fM={kernelName:Sf,backendName:"webgpu",kernelFunc:pM};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mM=Bt({opType:st.LOG,cpuKernelImpl:uA}),gM={kernelName:Vd,backendName:"webgpu",kernelFunc:mM};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yM=Bt({opType:st.LOG1P}),bM={kernelName:Rr,backendName:"webgpu",kernelFunc:yM};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xM=Se({opType:vt.LOGICAL_AND,dtype:"bool"}),wM={kernelName:zl,backendName:"webgpu",kernelFunc:xM};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vM=Bt({opType:st.LOGICAL_NOT}),CM={kernelName:Fl,backendName:"webgpu",kernelFunc:vM};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kM=Se({opType:vt.LOGICAL_OR}),SM={kernelName:Ml,backendName:"webgpu",kernelFunc:kM};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tb=`
  var powValue = 0.0;
  let basis = uniforms.bias + uniforms.alpha * sum;
  if (uniforms.beta == 0.5) {
    powValue = inverseSqrt(basis);
  } else if (uniforms.beta == 1.0) {
    powValue = 1.0 / basis;
  } else {
    powValue = exp(log(basis) * (-uniforms.beta));
  }
`;class IM{constructor(t){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn"}getUserCode(){return`
    ${ot("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];
        let d = coords[3];

        let x = getX(b, r, c, d);
        var sum = 0.0;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let idx = d + i;
          if (idx >= 0 && idx < uniforms.xShape[3]) {
            let z = getX(b, r, c, idx);
            sum = sum + z * z;
          }
        }
        ${tb}

        setOutputAtIndex(index, x * powValue);
      }
    }
  `}}class NM{constructor(t,e){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[256,1,1],this.maxAllowRadius=16,tt(e<=this.maxAllowRadius,()=>`Radius must be less than or equal to ${this.maxAllowRadius}, current radius is ${e}`),this.outputShape=t,this.elementsPerWorkgroup=this.workgroupSize[0]-2*this.maxAllowRadius,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=rt(this.dispatchLayout,this.outputShape,[this.elementsPerWorkgroup,this.workgroupSize[1],this.workgroupSize[2]]),this.shaderKey="lrn_shared"}getUserCode(){return`
    var <workgroup>lrnSub: array<f32, ${this.workgroupSize[0]}>;
    const elementsPerWorkgroup = ${this.elementsPerWorkgroup};
    const maxAllowRadius = ${this.maxAllowRadius};

    ${ot()} {
      let localDepth = i32(localId.x);
      let workgroupDepth = i32(workgroupId.x) * elementsPerWorkgroup;
      let xDepth = workgroupDepth + localDepth - maxAllowRadius;
      let b = i32(globalId.z) / uniforms.xShape[1];
      let r = i32(globalId.z) - b * uniforms.xShape[1];
      let c = i32(globalId.y);
      let d = workgroupDepth + localDepth;

      var x = 0.0;
      if (xDepth >= 0 && xDepth < uniforms.xShape[3]) {
        x = getX(b, r, c, xDepth);
      }
      lrnSub[localDepth] = x;
      workgroupBarrier();

      if (localDepth < elementsPerWorkgroup && d < uniforms.outShape[3]) {
        var sum = 0.0;
        let index = localDepth + maxAllowRadius;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let z = lrnSub[index + i];
          sum = sum + z * z;
        }
        ${tb}

        setOutputAtCoords(b, r, c, d, lrnSub[index] * powValue);
      }
    } `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $M(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{depthRadius:o,bias:r,alpha:a,beta:u}=s;let l;o>16?l=new IM(i.shape):l=new NM(i.shape,o);const c=[{type:"int32",data:[o]},{type:"float32",data:[r]},{type:"float32",data:[a]},{type:"float32",data:[u]}];return e.runWebGPUProgram(l,[i],i.dtype,c)}const DM={kernelName:Uu,backendName:"webgpu",kernelFunc:$M};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class RM{constructor(t){this.outputShape=[],this.variableNames=["inputImage","outputImage","dy"],this.uniforms="depthRadius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn_grad"}getUserCode(){return`
    ${ot("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];

        let MIN_DEPTH_BEGIN = 0;
        let MAX_DEPTH_END = uniforms.outShape[3];
        var result = 0.0;
        for (var d = MIN_DEPTH_BEGIN; d < MAX_DEPTH_END; d++) {
          let depthBegin = max(MIN_DEPTH_BEGIN, d - uniforms.depthRadius);
          let depthEnd = min(MAX_DEPTH_END, d + uniforms.depthRadius + 1);

          var norm = 0.0;
          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            } else {
              break;
            }
          }

          norm = uniforms.alpha * norm + uniforms.bias;

          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              var dyi = -2.0 * uniforms.alpha * uniforms.beta
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d) / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * uniforms.beta);
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            } else {
              break;
            }
          }
        }

        setOutputAtIndex(index, result);
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AM(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,y:o,dy:r}=t,{depthRadius:a,bias:u,alpha:l,beta:c}=s,h=new RM(i.shape),p=[{type:"int32",data:[a]},{type:"float32",data:[u]},{type:"float32",data:[l]},{type:"float32",data:[c]}];return e.runWebGPUProgram(h,[i,o,r],i.dtype,p)}const TM={kernelName:Vu,backendName:"webgpu",kernelFunc:AM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zM=Se({opType:vt.MAX,cpuKernelImpl:cA}),FM={kernelName:Ud,backendName:"webgpu",kernelFunc:zM};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MM(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{filterSize:o,strides:r,pad:a,dimRoundingMode:u}=s,c=Un(i.shape,o,r,1,a,u);return Vy(i,c,"max",e)}const PM={kernelName:Xu,backendName:"webgpu",kernelFunc:MM};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EM(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{filterSize:o,strides:r,pad:a,dataFormat:u,dimRoundingMode:l}=s,c=[1,1,1],h=xs(i.shape,o,r,c,a,l,u),p=new cc(h,"max"),f=[{type:"int32",data:[h.strideDepth,h.strideHeight,h.strideWidth]},{type:"int32",data:[h.padInfo.front,h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.inDepth,h.inHeight,h.inWidth]},{type:"int32",data:[h.effectiveFilterDepth,h.effectiveFilterHeight,h.effectiveFilterWidth]}];return e.runWebGPUProgram(p,[i],i.dtype,f)}const LM={kernelName:ju,backendName:"webgpu",kernelFunc:EM};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class OM{constructor(t){this.variableNames=["dy","maxPos"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.inShape,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool2DBackprop"}getUserCode(){return`
      ${ot("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] - 1;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR += uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC += uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);
            let maxPosValue = lastIndex - i32(getMaxPos(batch, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            let curPosValue = wR * uniforms.filterDims[1] + wC;
            let mask = select(0.0, 1.0, maxPosValue == curPosValue);
            dotProd += dyValue * mask;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}class _M{constructor(t){this.variableNames=["dy","maxPos"],this.uniforms=`strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.inShape,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool3DBackprop"}getUserCode(){return`
      ${ot("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] * uniforms.filterDims[2] - 1;

        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              let maxPosValue = lastIndex - i32(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              let curPosValue = wD * uniforms.filterDims[1] * uniforms.filterDims[2] + wR * uniforms.filterDims[2] + wC;
              let mask = select(0.0, 1.0, maxPosValue == curPosValue);
              dotProd += dyValue * mask;
            }
          }
        }

        setOutputAtIndex(index, dotProd);
      }
    }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BM(n){const{inputs:t,backend:e,attrs:s}=n,{dy:i,input:o}=t,r=o,{filterSize:a,strides:u,pad:l,dimRoundingMode:c}=s,h=[1,1,1],p=xs(r.shape,a,u,h,l,c),f=new cc(p,"max",!0);let m=[{type:"int32",data:[p.strideDepth,p.strideHeight,p.strideWidth]},{type:"int32",data:[p.padInfo.front,p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.inDepth,p.inHeight,p.inWidth]},{type:"int32",data:[p.effectiveFilterDepth,p.effectiveFilterHeight,p.effectiveFilterWidth]}];const g=e.runWebGPUProgram(f,[r],"int32",m),b=new _M(p);m=[{type:"int32",data:[p.strideDepth,p.strideHeight,p.strideWidth]},{type:"int32",data:[p.effectiveFilterDepth-1-p.padInfo.front,p.effectiveFilterHeight-1-p.padInfo.top,p.effectiveFilterWidth-1-p.padInfo.left]},{type:"int32",data:[p.effectiveFilterDepth,p.effectiveFilterHeight,p.effectiveFilterWidth]},{type:"int32",data:[p.outDepth]},{type:"int32",data:[p.outHeight]},{type:"int32",data:[p.outWidth]}];const v=e.runWebGPUProgram(b,[i,g],r.dtype,m);return e.disposeData(g.dataId),v}const WM={kernelName:Hu,backendName:"webgpu",kernelFunc:BM};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VM(n){const{inputs:t,backend:e,attrs:s}=n,{dy:i,input:o,output:r}=t,a=o;Ey([o,r],"maxPoolGrad");const{filterSize:u,strides:l,pad:c,dimRoundingMode:h}=s,p=Un(a.shape,u,l,1,c,h),f=new oo(p,"max",!0);let m=[{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.dilationHeight,p.dilationWidth]},{type:"int32",data:[p.inHeight,p.inWidth]},{type:"int32",data:[p.effectiveFilterHeight,p.effectiveFilterWidth]}];const g=e.runWebGPUProgram(f,[a],"int32",m),b=new OM(p);m=[{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.effectiveFilterHeight-1-p.padInfo.top,p.effectiveFilterWidth-1-p.padInfo.left]},{type:"int32",data:[p.dilationHeight,p.dilationWidth]},{type:"int32",data:[p.effectiveFilterHeight,p.effectiveFilterWidth]},{type:"int32",data:[p.outHeight]},{type:"int32",data:[p.outWidth]}];const v=e.runWebGPUProgram(b,[i,g],a.dtype,m);return e.disposeData(g.dataId),v}const UM={kernelName:Ku,backendName:"webgpu",kernelFunc:VM};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GM(n){const{inputs:t,backend:e,attrs:s}=n,{filterSize:i,strides:o,pad:r,includeBatchInIndex:a}=s,{x:u}=t;tt(u.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${u.shape.length}.`);const l=[1,1];tt(ki(o,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${l}'`);const c=Un(u.shape,i,o,l,r),h=[{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.padInfo.top,c.padInfo.left]},{type:"int32",data:[c.dilationHeight,c.dilationWidth]},{type:"int32",data:[c.inHeight,c.inWidth]},{type:"int32",data:[c.effectiveFilterHeight,c.effectiveFilterWidth]}];let p=new oo(c,"max",!1);const f=e.runWebGPUProgram(p,[u],u.dtype,h);p=new oo(c,"max",!0,!0,a);const m=e.runWebGPUProgram(p,[u],"int32",h);return[f,m]}const HM={kernelName:If,backendName:"webgpu",kernelFunc:GM};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jM(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:o,keepDims:r}=s;return qs(i,o,r,"min",e)}const KM={kernelName:Yu,backendName:"webgpu",kernelFunc:jM};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XM=Se({opType:vt.MIN,cpuKernelImpl:hA}),qM={kernelName:Hd,backendName:"webgpu",kernelFunc:XM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class YM{constructor(t,e,s){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.map((i,o)=>i[0]+t[o]+i[1]),this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=t,e.map((i,o)=>{this.uniforms+=` pad${o} : vec2<i32>,`}),this.offset=s==="reflect"?0:1,this.shaderKey=`mirrorPad_${s}`}getUserCode(){const t=this.xShape.length,e=this.xShape.map((l,c)=>`uniforms.pad${c}[0]`).join(","),s=this.xShape.map((l,c)=>`uniforms.pad${c}[0] + uniforms.xShape${t>1?`[${c}]`:""}`).join(","),i=t===1?"start":"start[i]",o=t===1?"end":"end[i]",r=t===1?"outC":"outC[i]",a=de(t),u=t>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,t):"coords";return`
      ${ot("index")} {
        if (index < uniforms.size) {
          let start = ${a}(${e});
          let end = ${a}(${s});
          var outC = getCoordsFromIndex(index);
          for (var i = 0; i < ${t}; i = i + 1) {
            if (${r} < ${i}) {
              ${r} = ${i} * 2 - ${r} - ${this.offset};
            } else if(${r} >= ${o}) {
              ${r} = (${o} - 1) * 2 - ${r} + ${this.offset};
            }
          }
          let coords = outC - start;
          setOutputAtIndex(index, getX(${u}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZM={kernelName:Zu,backendName:"webgpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:s}=n,{paddings:i,mode:o}=t,r=e,a=i.map(c=>({type:"int32",data:[c[0],c[1]]})),u=new YM(s.shape,i,o);return r.runWebGPUProgram(u,[s],s.dtype,a)}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QM=Se({opType:vt.MOD}),JM={kernelName:Ar,backendName:"webgpu",kernelFunc:QM};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tP{constructor(t,e){this.variableNames=["probs"],this.outputShape=[],this.uniforms="seed : f32, numOutcomes: i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[t,e],this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="multinomial"}getUserCode(){return`
    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    fn random (seed : f32, resultUV : vec2<f32>) -> f32 {
      let HASHSCALE1 = 443.8975;
      let p = resultUV * seed;
      var p3  = fract(vec3<f32>(p.xyx) * HASHSCALE1);
      p3 = p3 + dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${ot("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords[0];

        let resUV = vec2<f32>(f32(coords[1]) / f32(uniforms.outShape[1]),
            f32(coords[0]) / f32(uniforms.outShape[0]));
        let r = random(uniforms.seed, resUV);
        var cdf = 0.0;
        for (var i = 0; i < uniforms.numOutcomes - 1; i = i + 1) {
          cdf = cdf + getProbs(batch, i);

          if (r < cdf) {
            setOutputAtIndexI32(index, i);
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutputAtIndexI32(index, uniforms.numOutcomes - 1);
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eP{constructor(t){this.variableNames=["logits"],this.outputShape=t,this.dispatchLayout=ht(this.outputShape),this.dispatch=[this.outputShape[0],1,1],this.outputShape[1]>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.shaderKey="softmax"}getUserCode(){return`
    var<workgroup> buf : array<f32, ${this.workgroupSize[0]}>;
    var<workgroup> rowMaxShared : f32;
    var<workgroup> rowSumShared : f32;
    const blockSize = ${this.workgroupSize[0]};
    ${ot("index")} {
      let row = index / blockSize;
      let tid = i32(localId.x);
      let cols = uniforms.outShape[1];

      var threadMax = -3.402823e+38f;
      for (var col = tid; col < cols; col += blockSize) {
        let value = getLogits(row, col);
        threadMax = max(threadMax, value);
      }
      if (tid < cols) {
        buf[tid] = threadMax;
      }
      workgroupBarrier();

      var reduceSize = min(cols, blockSize);
      for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
        reduceSize = currSize + (reduceSize & 1);
        if (tid < currSize) {
          buf[tid] = max(buf[tid], buf[tid + reduceSize]);
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowMaxShared = buf[0];
      }
      workgroupBarrier();

      var threadSum = 0.0;
      for (var col = tid; col < cols; col += blockSize) {
        let subExp = exp(getLogits(row, col) - rowMaxShared);
        threadSum += subExp;
      }
      buf[tid] = threadSum;
      workgroupBarrier();

      for (var currSize = blockSize >> 1;  currSize > 0; currSize = currSize >> 1) {
        if (tid < currSize) {
          buf[tid] = buf[tid] + buf[tid + currSize];
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowSumShared = buf[0];
      }
      workgroupBarrier();

      for (var col = tid; col < cols; col += blockSize) {
        let value = exp(getLogits(row, col) - rowMaxShared) / rowSumShared;
        setOutputAtCoords(row, col, value);
      }
  }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eb(n){const{inputs:t,backend:e,attrs:s}=n,{logits:i}=t,{dim:o}=s,r=ft({inputs:{x:i},backend:e,attrs:{shape:[et(i.shape)/i.shape[o],i.shape[o]]}}),a=new eP(r.shape),u=e.runWebGPUProgram(a,[r],i.dtype),l=ft({inputs:{x:u},backend:e,attrs:{shape:i.shape}});return e.disposeData(r.dataId),e.disposeData(u.dataId),l}const nP={kernelName:fl,backendName:"webgpu",kernelFunc:eb};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sP(n){const{inputs:t,backend:e,attrs:s}=n,{logits:i}=t,{numSamples:o,seed:r,normalized:a}=s,u=a?i:eb({inputs:{logits:i},backend:e,attrs:{dim:i.shape.length-1}}),l=u.shape[0],c=u.shape[1],h=new tP(l,o),p=[{type:"float32",data:[r]},{type:"int32",data:[c]}],f=e.runWebGPUProgram(h,[u],"int32",p);return a||e.disposeData(u.dataId),f}const iP={kernelName:$f,backendName:"webgpu",kernelFunc:sP};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oP(n){const{inputs:t,backend:e}=n,{x:s}=t;if(e.shouldExecuteOnCPU([s])){const o=e.tensorMap.get(s.dataId),[r,a]=pA(o.values,s.shape,s.dtype);return e.makeTensorInfo(a,s.dtype,r)}const i=new Ti(s.shape,st.NEG);return e.runWebGPUProgram(i,[s],s.dtype)}const rP={kernelName:Kd,backendName:"webgpu",kernelFunc:oP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aP(n){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:s}=n,{boxes:i,scores:o}=t,{maxOutputSize:r,iouThreshold:a,scoreThreshold:u}=s,l=e.readSync(i.dataId),c=e.readSync(o.dataId),{selectedIndices:h}=Rf(l,c,r,a,u);return e.makeTensorInfo([h.length],"int32",new Int32Array(h))}const uP={kernelName:Df,backendName:"webgpu",kernelFunc:aP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lP(n){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:s}=n,{boxes:i,scores:o}=t,{maxOutputSize:r,iouThreshold:a,scoreThreshold:u,softNmsSigma:l}=s,c=e.readSync(i.dataId),h=e.readSync(o.dataId),p=r,f=a,m=u,g=l,{selectedIndices:b,selectedScores:v}=Tf(c,h,p,f,m,g);return[e.makeTensorInfo([b.length],"int32",new Int32Array(b)),e.makeTensorInfo([v.length],"float32",new Float32Array(v))]}const cP={kernelName:Af,backendName:"webgpu",kernelFunc:lP};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hP{constructor(t,e){this.variableNames=["x"],this.uniforms="onValue : f32, offValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[t,e],this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="onehot"}getUserCode(){return`
      ${ot("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          setOutputAtIndex(index, mix(uniforms.offValue, uniforms.onValue,
                                      f32(i32(round(getX(coords.x))) == coords.y)));
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dP(n){const{inputs:t,backend:e,attrs:s}=n,{indices:i}=t,{dtype:o,depth:r,onValue:a,offValue:u}=s,l=et(i.shape),c=new hP(l,r),h=ft({inputs:{x:i},backend:e,attrs:{shape:[l]}}),p=[{type:"float32",data:[a]},{type:"float32",data:[u]}],f=e.runWebGPUProgram(c,[h],o,p);e.disposeData(h.dataId);const m=[...i.shape,r],g=ft({inputs:{x:f},backend:e,attrs:{shape:m}});return e.disposeData(f.dataId),g}const pP={kernelName:Ju,backendName:"webgpu",kernelFunc:dP};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lr(n){const{inputs:t,backend:e}=n,{x:s}=t;if(s.dtype==="complex64"){const i=Co({inputs:{input:s},backend:e}),o=lr({inputs:{x:i},backend:e}),r=fa({inputs:{input:s},backend:e}),a=lr({inputs:{x:r},backend:e}),u=Xs({inputs:{real:o,imag:a},backend:e});return e.disposeData(i.dataId),e.disposeData(o.dataId),e.disposeData(r.dataId),e.disposeData(a.dataId),u}else return _e({attrs:{shape:s.shape,dtype:s.dtype,value:s.dtype==="string"?"":0},backend:e})}const fP={kernelName:kl,backendName:"webgpu",kernelFunc:lr};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nb(n){const{inputs:t,backend:e}=n,{x:s}=t;if(s.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(s.dtype==="complex64"){const i=Co({inputs:{input:s},backend:e}),o=nb({inputs:{x:i},backend:e}),r=fa({inputs:{input:s},backend:e}),a=lr({inputs:{x:r},backend:e}),u=Xs({inputs:{real:o,imag:a},backend:e});return e.disposeData(i.dataId),e.disposeData(o.dataId),e.disposeData(r.dataId),e.disposeData(a.dataId),u}else return _e({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:e})}const mP={kernelName:tl,backendName:"webgpu",kernelFunc:nb};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gP(n){const{inputs:t,backend:e,attrs:s}=n,{axis:i}=s;if(t.length===1)return pu({inputs:{input:t[0]},backend:e,attrs:{dim:i}});const o=t[0].shape,r=t[0].dtype;t.forEach(c=>{zf(o,c.shape,"All tensors passed to stack must have matching shapes"),tt(r===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],u=t.map(c=>{const h=pu({inputs:{input:c},backend:e,attrs:{dim:i}});return a.push(h),h}),l=Hy({inputs:u,backend:e,attrs:{axis:i}});return a.forEach(c=>e.disposeData(c.dataId)),l}const yP={kernelName:el,backendName:"webgpu",kernelFunc:gP};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sb(n,t=!1){const e=n.length,s=de(e),i=n.map((h,p)=>`uniforms.pad${p}[0]`).join(","),o=n.map((h,p)=>`uniforms.pad${p}[0] + uniforms.xShape${e>1?`[${p}]`:""}`).join(","),r=e>1?`${s}(${i})`:`${i}`,a=e>1?`${s}(${o})`:`${o}`,u=e>1?"any(paddedCoords < start)":"paddedCoords < start",l=e>1?"any(paddedCoords >= end)":"paddedCoords >= end",c=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`
        let start = ${r};
        let end = ${a};
        if (${u} || ${l}) {
          setOutputAtIndex(index, ${t?0:"uniforms.constantValue"});
        } else {
          let coords = paddedCoords - start;
          setOutputAtIndex(index, getX(${c}));
        }
  `}class bP{constructor(t,e){this.variableNames=["x"],this.uniforms="constantValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.map((s,i)=>s[0]+t[i]+s[1]),this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),e.map((s,i)=>{this.uniforms+=` pad${i} : vec2<i32>,`}),this.xShape=t,this.shaderKey="pad"}getUserCode(){return`
      ${ot("index")} {
        if (index < uniforms.size) {
          let paddedCoords = getCoordsFromIndex(index);
          ${sb(this.xShape)}
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xP=n=>{const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{paddings:o,constantValue:r}=s;if(o.every(l=>ke(l,[0,0])))return je({inputs:{x:i},backend:e});if(et(i.shape)===0){const l=o.map((c,h)=>c[0]+i.shape[h]+c[1]);return _e({backend:e,attrs:{shape:l,value:r,dtype:i.dtype}})}const a=[{type:"float32",data:[r]}];o.map(l=>a.push({type:"int32",data:[l[0],l[1]]}));const u=new bP(i.shape,o);return e.runWebGPUProgram(u,[i],i.dtype,a)},wP={kernelName:nl,backendName:"webgpu",kernelFunc:xP};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vP=Se({opType:vt.POW}),CP={kernelName:Tr,backendName:"webgpu",kernelFunc:vP};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kP(n){const{inputs:t,backend:e}=n,{x:s,alpha:i}=t,o=new ar(vt.PRELU,s.shape,i.shape);return e.runWebGPUProgram(o,[s,i],"float32")}const SP={kernelName:sl,backendName:"webgpu",kernelFunc:kP};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IP(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:o,keepDims:r}=s;return qs(i,o,r,"prod",e)}const NP={kernelName:Xd,backendName:"webgpu",kernelFunc:IP};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $P=n=>{const{backend:t,attrs:e}=n,{start:s,stop:i,step:o,dtype:r}=e,a=gA(s,i,o,r);return t.makeTensorInfo([a.length],r,a)},DP={kernelName:Ff,backendName:"webgpu",kernelFunc:$P};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RP=Se({opType:vt.DIV}),AP={kernelName:Fr,backendName:"webgpu",kernelFunc:RP};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TP=Bt({opType:st.RECIPROCAL}),zP={kernelName:Mr,backendName:"webgpu",kernelFunc:TP};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FP=Bt({opType:st.RELU}),MP={kernelName:Er,backendName:"webgpu",kernelFunc:FP};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PP=Bt({opType:st.RELU6}),EP={kernelName:Pr,backendName:"webgpu",kernelFunc:PP};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class LP{constructor(t,e,s){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, halfPixelCenters : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[t[0],e,s,t[3]],this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="resizeBilinear"}getUserCode(){return`
      ${ot("index")} {
        if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC =
            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *
            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);

          // Compute the four integer indices.
          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);
          let sourceCeilRC = vec2<i32>(
            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));

          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);
          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);
          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);
          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);

          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);

          let top = topLeft + (topRight - topLeft) * fracRC.y;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
          let newValue = top + (bottom - top) * fracRC.x;

          setOutputAtIndex(index, newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OP(n){const{inputs:t,backend:e,attrs:s}=n,{images:i}=t,{alignCorners:o,size:r,halfPixelCenters:a}=s,[u,l]=r,c=o&&u>1?1:0,h=o&&l>1?1:0,f=[{type:"float32",data:[c,h]},{type:"float32",data:[a?.5:0]}],m=new LP(i.shape,u,l);return e.runWebGPUProgram(m,[i],"float32",f)}const _P={kernelName:ol,backendName:"webgpu",kernelFunc:OP};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class BP{constructor(t,e){this.variableNames=["dy"],this.uniforms=`effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, heightScale : f32, widthScale : f32,
       invHeightScale : f32, invWidthScale : f32, winHeight : i32, winWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=e,this.shaderKey=`resizeBilinearBackprop_${e}`}getUserCode(){return`
      ${ot("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(startRLerp - f32(uniforms.winHeight / 2));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(startCLerp - f32(uniforms.winWidth / 2));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let dxR = f32(dyR) * uniforms.heightScale;
              let topDxRIndex = i32(floor(dxR));
              let bottomDxRIndex = i32(min(ceil(dxR), f32(uniforms.outShape[1] - 1)));
              let dxRLerp = dxR - f32(topDxRIndex);
              let inverseDxRLerp = 1.0 - dxRLerp;

              let dxC = f32(dyC) * uniforms.widthScale;
              let leftDxCIndex = i32(floor(dxC));
              let rightDxCIndex = i32(min(ceil(dxC), f32(uniforms.outShape[2] - 1)));
              let dxCLerp = dxC - f32(leftDxCIndex);
              let inverseDxCLerp = 1.0 - dxCLerp;

              if (r == topDxRIndex && c == leftDxCIndex) {
                // topLeft
                accumulator +=
                  getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
              }

              if (r == topDxRIndex && c == rightDxCIndex) {
                // topRight
                accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
              }

              if (r == bottomDxRIndex && c == leftDxCIndex) {
                // bottomLeft
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
              }

              if (r == bottomDxRIndex && c == rightDxCIndex) {
                // bottomRight
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WP(n){const{inputs:t,backend:e,attrs:s}=n,{images:i,dy:o}=t,{alignCorners:r}=s,[,a,u]=i.shape,[,l,c]=o.shape,h=[r&&l>1?a-1:a,r&&c>1?u-1:u],p=[r&&l>1?l-1:l,r&&c>1?c-1:c],f=h[0]/p[0],m=h[1]/p[1],g=1/f,b=1/m,v=Math.ceil(g)*2+2,w=Math.ceil(b)*2+2,k=new BP(i.shape,r),C=[{type:"int32",data:h},{type:"int32",data:p},{type:"float32",data:[f]},{type:"float32",data:[m]},{type:"float32",data:[g]},{type:"float32",data:[b]},{type:"int32",data:[v]},{type:"int32",data:[w]}];return e.runWebGPUProgram(k,[o],o.dtype,C)}const VP={kernelName:rl,backendName:"webgpu",kernelFunc:WP};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class UP{constructor(t,e,s,i){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, roundBase : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[t[0],e,s,t[3]],this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.halfPixelCenters=i,this.shaderKey=`resizeNearest_${i}`}getUserCode(){let t;return this.halfPixelCenters?t="max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))":t="vec2<f32>(rc) * effectiveInputOverOutputRatioRC",`
      ${ot("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC = ${t};

          // Compute the coordinators of nearest neighbor point.
          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));
          let sourceNearestRC = vec2<i32>(
            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));
          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);

          setOutputAtIndex(index, newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GP(n){const{inputs:t,backend:e,attrs:s}=n,{images:i}=t,{alignCorners:o,halfPixelCenters:r,size:a}=s,[u,l]=a,c=o&&u>1?1:0,h=o&&l>1?1:0,f=[{type:"float32",data:[c,h]},{type:"float32",data:[o?.5:0]}],m=new UP(i.shape,u,l,r);return e.runWebGPUProgram(m,[i],i.dtype,f)}const HP={kernelName:al,backendName:"webgpu",kernelFunc:GP};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jP{constructor(t,e){this.variableNames=["dy"],this.uniforms=`effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, invHeightScale : f32, invWidthScale : f32,
       winHeight : i32, winWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=e,this.shaderKey=`resizeNearestNeigborBackprop_${e}`}getUserCode(){return`
      ${ot("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(floor(startRLerp - f32(uniforms.winHeight / 2)));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(floor(startCLerp - f32(uniforms.winWidth / 2)));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let sourceFracRow = f32(uniforms.effectiveXSize[0]) *
                  (f32(dyR) / f32(uniforms.effectiveYSize[0]));

              let sourceFracCol = f32(uniforms.effectiveXSize[1]) *
                  (f32(dyC) / f32(uniforms.effectiveYSize[1]));

              let sourceNearestRow =
                  i32(min(f32(uniforms.outShape[1] - 1),
                  ${this.alignCorners?"floor(sourceFracRow + 0.5)":"floor(sourceFracRow)"}));

              let sourceNearestCol =
                  i32(min(f32(uniforms.outShape[2] - 1),
                  ${this.alignCorners?"floor(sourceFracCol + 0.5)":"floor(sourceFracCol)"}));

              if (r == sourceNearestRow && c == sourceNearestCol) {
                accumulator += getDy(b, dyR, dyC, d);
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KP(n){const{inputs:t,backend:e,attrs:s}=n,{images:i,dy:o}=t,{alignCorners:r}=s,[,a,u]=i.shape,[,l,c]=o.shape,h=[r&&l>1?a-1:a,r&&c>1?u-1:u],p=[r&&l>1?l-1:l,r&&c>1?c-1:c],f=h[0]/p[0],m=h[1]/p[1],g=1/f,b=1/m,v=Math.ceil(g)*2+2,w=Math.ceil(b)*2+2,k=new jP(i.shape,r),C=[{type:"int32",data:h},{type:"int32",data:p},{type:"float32",data:[g]},{type:"float32",data:[b]},{type:"int32",data:[v]},{type:"int32",data:[w]}];return e.runWebGPUProgram(k,[o],o.dtype,C)}const XP={kernelName:ul,backendName:"webgpu",kernelFunc:KP};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qP{constructor(t){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=" axis : vec4<i32>,",this.shaderKey="reverse"}getUserCode(){return`
      
      // Using uniform variables as judging conditions, so the function has
      // coherent execution within all threads.
      fn getReverseCoords(coords : vec4<i32>) -> vec4<i32> {
        var reverseCoords = coords;
        if (uniforms.axis[0] == 1) {
          reverseCoords[0] = uniforms.xShape[0] - coords[0] - 1;
        }
        if (uniforms.axis[1] == 1) {
          reverseCoords[1] = uniforms.xShape[1] - coords[1] - 1;
        }
        if (uniforms.axis[2] == 1) {
          reverseCoords[2] = uniforms.xShape[2] - coords[2] - 1;
        }
        if (uniforms.axis[3] == 1) {
          reverseCoords[3] = uniforms.xShape[3] - coords[3] - 1;
        }

        return reverseCoords;
      }
    
      ${ot("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let reverseCoords = getReverseCoords(coords);
          setOutputAtIndex(index, getX(reverseCoords[0],
              reverseCoords[1], reverseCoords[2], reverseCoords[3]));
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YP(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{dims:o}=s,r=i.shape.length;if(r===0)return je({inputs:{x:i},backend:e});const a=i.shape,u=[1,1,1,1];a.forEach((b,v)=>{const w=v+4-r;u[w]=b});const l=ee(o,i.shape),c=[0,0,0,0];l.forEach(b=>{const v=b+4-r;c[v]=1});const h=[{type:"int32",data:c}],p=ft({inputs:{x:i},backend:e,attrs:{shape:u}}),f=new qP(u),m=e.runWebGPUProgram(f,[p],p.dtype,h);e.disposeData(p.dataId);const g=ft({inputs:{x:m},backend:e,attrs:{shape:a}});return e.disposeData(m.dataId),g}const ZP={kernelName:ll,backendName:"webgpu",kernelFunc:YP};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class QP{constructor(t,e){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=`centerX : f32, centerY : f32, sinRadians : f32,
          cosRadians : f32,`,this.shaderKey="rotate",this.outputShape=t,typeof e=="number"?(this.uniforms+=" fillValue : f32,",this.fillSnippet="var outputValue = uniforms.fillValue;",this.shaderKey+="_float"):(this.uniforms+=" fillValue : vec3<f32>,",this.fillSnippet="var outputValue = uniforms.fillValue[coords[3]];",this.shaderKey+="_vec3")}getUserCode(){return`
        ${ot("index")} {
          if (index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *
                uniforms.sinRadians;
            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *
                uniforms.cosRadians;
            let coordX = i32(round(coordXFloat + uniforms.centerX));
            let coordY = i32(round(coordYFloat + uniforms.centerY));
            ${this.fillSnippet}
            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&
                coordY < uniforms.xShape[1]) {
              outputValue = getX(coords[0], coordY, coordX, coords[3]);
            }
            setOutputAtIndex(index, outputValue);
          }
        }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JP={kernelName:Mf,backendName:"webgpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:s}=n,{radians:i,fillValue:o,center:r}=t,a=e,u=new QP(s.shape,o),[l,c]=Pf(r,s.shape[1],s.shape[2]),h=[{type:"float32",data:[l]},{type:"float32",data:[c]},{type:"float32",data:[Math.sin(i)]},{type:"float32",data:[Math.cos(i)]}];return typeof o=="number"?h.push({type:"float32",data:[Number.parseFloat(o.toFixed(2))]}):h.push({type:"float32",data:o}),a.runWebGPUProgram(u,[s],s.dtype,h)}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tE=Bt({opType:st.ROUND}),eE={kernelName:Lr,backendName:"webgpu",kernelFunc:tE};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nE=Bt({opType:st.RSQRT,cpuKernelImpl:yA}),sE={kernelName:qd,backendName:"webgpu",kernelFunc:nE};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Yi{constructor(t,e,s,i,o,r,a,u=!0){this.variableNames=["updates","indices"],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=r,this.type=a,this.sumDupeIndices=u,this.dispatchLayout=ht(t),this.dispatch=rt(this.dispatchLayout,t,this.workgroupSize),this.sliceDimGreaterThanOne=e>1,this.shaderKey=`scatter_${s}_${i}_${this.sliceDimGreaterThanOne}_${a}_${u}_${o.length}`;const l=de(o.length);this.uniforms=`sliceDim : i32, strides: ${l}, updatesSize: i32,`,this.updatesRank=i,this.indicesRank=s}getUserCode(){let t="";this.indicesRank===1?t="coords[0]":this.indicesRank===2&&(t="coords[0], j");const e=`getIndices(${t})`,s=this.sliceDimGreaterThanOne?"uniforms.strides[j]":"uniforms.strides";let i="",o="";this.dispatchLayout.x.length===1?(i="flattenedIndex",o=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {
        return index;
      }
      `):this.dispatchLayout.x.length===2&&(i="vec2<i32>(flattenedIndex, coords[1])",o=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {
        // N.B. |updates| could be a scalar tensor, conceptually representing a
        // 2D tensor with all values equal to that. By design, its size must be
        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|
        // gives the other.
        let sliceSize = uniforms.outShape[1];
        let d0 = index / sliceSize;
        let d1 = index - d0 * sliceSize;
        return vec2<i32>(d0, d1);
      }
      `);const a=`getUpdates(${Array.from({length:this.updatesRank},(l,c)=>`coords[${c}]`).join(", ")})`;return`
    ${o}
      ${ot("index")} {
        if (index < uniforms.updatesSize) {
          let coords = getUpdatesCoordsFromFlatIndex(index);
          var flattenedIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexInside = i32(round(${e}));
            flattenedIndex = flattenedIndex + indexInside * ${s};
          }
          let updateValue =
              ${Rs(this.type)}(${a});
          let flatIndex = getOutputIndexFromCoords(${i});

          ${this.sumDupeIndices?Cs("&result[flatIndex]","updateValue",this.type):"atomicStore(&result[flatIndex], bitcast<i32>(updateValue));"}
        }
      }`}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iE(n){const{inputs:t,backend:e,attrs:s}=n,{indices:i,updates:o}=t,{shape:r}=s,{sliceRank:a,numUpdates:u,sliceSize:l,strides:c,outputSize:h}=Di(o,i,r),p=[h/l,l];if(h===0)return e.makeTensorInfo(r,i.dtype);const f=ft({inputs:{x:i},backend:e,attrs:{shape:[u,a]}}),m=ft({inputs:{x:o},backend:e,attrs:{shape:[u,l]}}),g=m.dtype,b=_e({backend:e,attrs:{shape:p,value:0,dtype:g}}),v=et(m.shape),w=[{type:"int32",data:[a]},{type:"int32",data:c},{type:"int32",data:[v]}],k=new Yi(m.shape,a,f.shape.length,m.shape.length,c,p,g),C=e.runWebGPUProgram(k,[m,f],g,w,b),I=ft({inputs:{x:C},backend:e,attrs:{shape:r}});return e.disposeData(f.dataId),e.disposeData(m.dataId),e.disposeData(C.dataId),I}const oE={kernelName:Ef,backendName:"webgpu",kernelFunc:iE};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rE{constructor(t,e){this.outputShape=[],this.variableNames=["sortedSequence","values"],this.uniforms="numInputs : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.side=e,this.shaderKey=`search_sorted_${e}`}getUserCode(){return`
      fn findBound(batch: i32, value: f32) -> i32 {
        var left = i32(0);
        var right = uniforms.numInputs;
        while (left < right) {
          var mid = (left + right) / 2;
          if (getSortedSequence(batch, mid) ${this.side==="left"?"<":"<="} value) {
            left = mid + 1;
          } else {
            right = mid;
          }
        }
        return right;
      }

      ${ot("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let value = getValuesByOutputIndex(index);
          setOutputAtIndexI32(index, findBound(coords[0], value));
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aE(n){const{inputs:t,backend:e,attrs:s}=n,{sortedSequence:i,values:o}=t,{side:r}=s,a=new rE([o.shape[0],o.shape[1]],r),u=[{type:"int32",data:[i.shape[1]]}];return e.runWebGPUProgram(a,[i,o],"int32",u)}const uE={kernelName:Lf,backendName:"webgpu",kernelFunc:aE};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lE{constructor(t,e,s){this.variableNames=["c","a","b"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.cRank=t,this.rank=s,this.shaderKey="select"}getUserCode(){let t,e;if(this.rank>4)throw Error(`Where for rank ${this.rank} is not yet supported`);if(this.rank===1)e="resRC",t="resRC";else{const i=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[],r=[];for(let a=0;a<this.outputShape.length;a++)r.push(`${i[a]}`),a<this.cRank&&o.push(`${i[a]}`);t=o.join(),e=r.join()}return`
      ${ot("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let cVal = getC(${t});
          if (cVal >= 1.0) {
            setOutputAtIndex(index, getA(${e}));
          } else {
            setOutputAtIndex(index, getB(${e}));
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cE(n){const{inputs:t,backend:e}=n,{condition:s,t:i,e:o}=t,r=new lE(s.shape.length,i.shape,i.shape.length);return e.runWebGPUProgram(r,[s,i,o],es(i.dtype,o.dtype))}const hE={kernelName:cl,backendName:"webgpu",kernelFunc:cE};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dE=Bt({opType:st.SELU}),pE={kernelName:Or,backendName:"webgpu",kernelFunc:dE};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fE=Bt({opType:st.SIGMOID}),mE={kernelName:Zd,backendName:"webgpu",kernelFunc:fE};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gE=Bt({opType:st.SIGN}),yE={kernelName:_r,backendName:"webgpu",kernelFunc:gE};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bE=Bt({opType:st.SIN}),xE={kernelName:Br,backendName:"webgpu",kernelFunc:bE};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wE=Bt({opType:st.SINH}),vE={kernelName:Wr,backendName:"webgpu",kernelFunc:wE};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CE=Bt({opType:st.SOFTPLUS}),kE={kernelName:Vr,backendName:"webgpu",kernelFunc:CE};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class SE{constructor(t,e,s,i,o,r){this.variableNames=["x"],this.outputShape=[],this.uniforms="",this.workgroupSize=[64,1,1],this.size=!0;const a=new Array(i.length);for(let u=0;u<a.length;u++)a[u]=i[o[u]];this.outputShape=a,this.newDim=o,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=t,this.paddedXShape=e,this.uniforms+=`reshapedPaddedXShape : ${de(i.length)}, paddedXShapeStrides : ${de(r)}, `,s.map((u,l)=>{this.uniforms+=` pad${l} : vec2<i32>,`}),this.shaderKey=`spaceToBatchND_${o}`}getUserCode(){const t=de(this.outputShape.length),e=Oy(this.newDim);return`
      ${Wo(this.paddedXShape,"PaddedX")}
      ${ot("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let switchedIndex = getIndexFromCoords${this.outputShape.length}D(${t}(${e}), uniforms.reshapedPaddedXShape);
          let paddedCoords = getPaddedXCoordsFromIndex(switchedIndex);
          ${sb(this.xShape,!0)}
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IE=n=>{const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{blockShape:o,paddings:r}=s;tt(i.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet");const a=o.reduce((w,k)=>w*k),u=[[0,0]];u.push(...r);for(let w=1+o.length;w<i.shape.length;++w)u.push([0,0]);const l=u.map((w,k)=>w[0]+i.shape[k]+w[1]),c=Yr(l,o,a,!1),h=Zr(c.length,o.length,!1),p=Qr(l,o,a,!1),f=Tt(l),m=new SE(i.shape,l,u,c,h,f.length),g=[{type:"int32",data:c},{type:"int32",data:f}];u.map(w=>g.push({type:"int32",data:[w[0],w[1]]}));const b=e.runWebGPUProgram(m,[i],i.dtype,g),v=ft({inputs:{x:b},backend:e,attrs:{shape:p}});return e.disposeData(b.dataId),v},NE={kernelName:ml,backendName:"webgpu",kernelFunc:IE};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $E{constructor(t,e,s){this.variableNames=["input","indices","segmentIds"],this.outputShape=[],this.uniforms="segmentSize : i32, sparseSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=t,this.type=s,this.dispatchLayout=ht([e]),this.dispatch=rt(this.dispatchLayout,[e],this.workgroupSize),this.shaderKey="sparseSegmentSum"}getUserCode(){return`
    ${ot("index")} {
      if (index < uniforms.sparseSize) {
        let indexInSegmentIds = index / uniforms.segmentSize;
        let indexInSegment = index % uniforms.segmentSize;
        let indexInInput = indices[indexInSegmentIds];
        let segmentId = segmentIds[indexInSegmentIds];

        let value = input[indexInInput * uniforms.segmentSize + indexInSegment];
        let outIndex = segmentId * uniforms.segmentSize + indexInSegment;
        ${Cs("&result[outIndex]","value",this.type)}
      }
    }
  `}}class DE{constructor(t,e){this.variableNames=["segmentIds"],this.outputShape=[],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=[t],this.dispatchLayout=ht(e),this.dispatch=rt(this.dispatchLayout,e,this.workgroupSize),this.shaderKey="sparseSegmentIdCountProgram"}getUserCode(){return`
    ${ot("index")} {
      if (index < uniforms.segmentIdsShape) {
        let segmentId = segmentIds[index];
        ${Cs("&result[segmentId]","1","int32")}
      }
    }
  `}}class RE{constructor(t,e){this.variableNames=["segmentSum","sameSegmentIdCount"],this.outputShape=[],this.uniforms="segmentSize : i32",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.type=e,this.dispatchLayout=ht(t),this.dispatch=rt(this.dispatchLayout,t,this.workgroupSize),this.shaderKey="sparseSegmentMean"}getUserCode(){return`
    ${ot("index")} {
      if (index < uniforms.size) {
        let segmentId = index / uniforms.segmentSize;
        let count = sameSegmentIdCount[segmentId];
        if (count != 0) {
          ${this.type==="float32"?"setOutputAtIndex(index, segmentSum[index] / f32(count));":"setOutputAtIndexI32(index, segmentSum[index] / count);"}
        }
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ib(n,t,e,s=!1,i){const r=et(n.shape)/n.shape[0],a=n.dtype,u=et(t.shape),l=i.readSync(e.dataId),h=u>0?l[u-1]+1:0;let p;const f=n.shape.slice();f[0]=h;const m=u*r,g=_e({backend:i,attrs:{shape:f,value:0,dtype:a}});p=new $E(f,m,a);let b=[{type:"int32",data:[r]},{type:"int32",data:[m]}];const v=i.runWebGPUProgram(p,[n,t,e],a,b,g);if(s)return v;const w=_e({backend:i,attrs:{shape:[h],value:0,dtype:"int32"}});p=new DE(h,e.shape);const k=i.runWebGPUProgram(p,[e],"int32",null,w),C=_e({backend:i,attrs:{shape:f,value:0,dtype:a}});p=new RE(f,a),b=[{type:"int32",data:[r]}];const I=i.runWebGPUProgram(p,[v,k],a,b,C);return i.disposeData(v.dataId),i.disposeData(k.dataId),I}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AE(n){const{inputs:t,backend:e}=n,{data:s,indices:i,segmentIds:o}=t;return ib(s,i,o,!1,e)}const TE={kernelName:Of,backendName:"webgpu",kernelFunc:AE};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zE(n){const{inputs:t,backend:e}=n,{data:s,indices:i,segmentIds:o}=t;return ib(s,i,o,!0,e)}const FE={kernelName:Bf,backendName:"webgpu",kernelFunc:zE};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ME{constructor(t,e){this.variableNames=["A"],this.workgroupSize=[64,1,1],this.size=!0;const s=new Array(t.length);for(let i=0;i<s.length;i++)s[i]=t[i]*e[i];this.outputShape=s,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.rank=this.outputShape.length,this.shaderKey="tile"}getUserCode(){const t=PE(this.rank,"uniforms.");return`
      ${ot("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          setOutputAtIndex(index, getA(${t}));
        }
      }
    `}}function PE(n,t=""){if(n>=5)throw Error(`Tile for rank ${n} is not yet supported`);if(n===1)return`(resRC % ${t}aShape)`;const e=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let i=0;i<n;i++)s.push(`(${e[i]} % ${t}aShape[${i}])`);return s.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hc(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{reps:o}=s;if(e.shouldExecuteOnCPU([i])||i.dtype==="string"||i.shape.length>=5){const u=e.readSync(i.dataId),l=i.dtype==="string"?u.map(p=>ho(p)):u,c=ue(i.shape,i.dtype,l),h=SA(c,o);return e.makeTensorInfo(h.shape,h.dtype,h.values)}const r=new ME(i.shape,o);return e.runWebGPUProgram(r,[i],i.dtype)}const EE={kernelName:xl,backendName:"webgpu",kernelFunc:hc};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LE(n){const{inputs:t,backend:e,attrs:s}=n,{sparseIndices:i,sparseValues:o,defaultValue:r}=t,{outputShape:a}=s,{sliceRank:u,numUpdates:l,sliceSize:c,strides:h,outputSize:p}=Di(o,i,a),f=!1;if(o.dtype==="string"){const A=e.bufferSync(i),z=e.bufferSync(o),F=ho(e.readSync(r.dataId)[0]),E=bA(A,z,a,p,c,l,u,h,F,f);return e.makeTensorInfo(a,E.dtype,E.values)}const m=[p/c,c],g=ft({inputs:{x:i},backend:e,attrs:{shape:[l,u]}}),b=o.shape.length?ft({inputs:{x:o},backend:e,attrs:{shape:[l,c]}}):je({inputs:{x:o},backend:e}),v=b.dtype,w=e.makeTensorInfo([],v,ss(1,v)),k=ft({inputs:{x:r},backend:e,attrs:{shape:Array(m.length).fill(1)}}),C=hc({inputs:{x:k},backend:e,attrs:{reps:m}}),I=et([l,c]),N=[{type:"int32",data:[u]},{type:"int32",data:h},{type:"int32",data:[I]}];switch(l){case 0:break;case 1:{const A=new Yi([l,c],u,g.shape.length,b.shape.length,h,m,v,f);e.runWebGPUProgram(A,[b,g],v,N,C)}break;default:{const A=new Yi([l,c],u,g.shape.length,w.shape.length,h,m,v,f);e.runWebGPUProgram(A,[w,g],v,N,C)}{const A=new Yi([l,c],u,g.shape.length,b.shape.length,h,m,v);e.runWebGPUProgram(A,[b,g],v,N,C)}}const $=ft({inputs:{x:C},backend:e,attrs:{shape:a}});return e.disposeData(g.dataId),e.disposeData(b.dataId),e.disposeData(k.dataId),e.disposeData(w.dataId),e.disposeData(C.dataId),$}const OE={kernelName:Wf,backendName:"webgpu",kernelFunc:LE};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _E(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{numOrSizeSplits:o,axis:r}=s,a=ee(r,i.shape)[0],u=Vf(i,o,a),l=i.shape.length,c=new Array(l).fill(0),h=i.shape.slice();return u.map(p=>{const f=[...h];f[a]=p;const m=zi({inputs:{x:i},backend:e,attrs:{begin:c,size:f}});return c[a]+=p,m})}const BE={kernelName:gl,backendName:"webgpu",kernelFunc:_E};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WE=Bt({opType:st.SQRT}),VE={kernelName:np,backendName:"webgpu",kernelFunc:WE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UE={kernelName:yl,backendName:"webgpu",kernelFunc:({inputs:n,backend:t})=>{const{x:e}=n,s=t,i=new Ti(e.shape,st.SQUARE);return s.runWebGPUProgram(i,[e],e.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GE=Se({opType:vt.SQUARED_DIFFERENCE}),HE={kernelName:sp,backendName:"webgpu",kernelFunc:GE};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jE({inputs:n,attrs:t,backend:e}){const{x:s}=n,i=new Ti(s.shape,st.STEP,"stepAlpha : f32,"),o=[{type:"float32",data:[t.alpha]}];return e.runWebGPUProgram(i,[s],s.dtype,o)}const KE={kernelName:Ur,backendName:"webgpu",kernelFunc:jE};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XE{constructor(t){this.variableNames=["x"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]);const e=de(this.outputShape.length);this.uniforms=`begin : ${e},  strides : ${e}, `,this.shaderKey="stridedSlice"}getUserCode(){const t=this.outputShape.length;let e="";if(t===1)e="coords * uniforms.strides + uniforms.begin";else{let i=0;e=this.outputShape.map((o,r)=>(i++,this.outputShape.length===1?`coords * uniforms.strides[${r}] + uniforms.begin[${r}]`:`coords[${i-1}] * uniforms.strides[${r}] + uniforms.begin[${r}]`)).join(",")}return`
       ${ot("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index);
           setOutputAtIndex(index, getX(${e}));
         }
       }
     `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qE(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{begin:o,end:r,strides:a,beginMask:u,endMask:l,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:p}=s,{finalShapeSparse:f,finalShape:m,isIdentity:g,sliceDim0:b,isSimpleSlice:v,begin:w,end:k,strides:C}=Gf(i.shape,o,r,a,u,l,c,h,p);let I;if(g)I=ft({inputs:{x:i},backend:e,attrs:{shape:m}});else if(b||v){tt(i.shape.length>=1,()=>`Input must have rank at least 1, got: ${i.shape.length}`);const N=Hf(w,k,C),$=zi({inputs:{x:i},backend:e,attrs:{begin:w,size:N}});I=ft({inputs:{x:$},backend:e,attrs:{shape:m}}),e.disposeData($.dataId)}else if(e.shouldExecuteOnCPU([i])){const $=e.readSync(i.dataId),A=ue(i.shape,i.dtype,$),z=vA(f,A,C,w);I=e.makeTensorInfo(m,i.dtype,z.values)}else{const $=new XE(f),A=[{type:"int32",data:w},{type:"int32",data:C}],z=e.runWebGPUProgram($,[i],i.dtype,A);I=ft({inputs:{x:z},backend:e,attrs:{shape:m}}),e.disposeData(z.dataId)}return I}const YE={kernelName:Uf,backendName:"webgpu",kernelFunc:qE};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZE(n){const{inputs:t,backend:e,attrs:s}=n,{separator:i,nGramWidths:o,leftPad:r,rightPad:a,padWidth:u,preserveShortSequences:l}=s,{data:c,dataSplits:h}=t,p=e.readSync(c.dataId),f=e.readSync(h.dataId),[m,g]=CA(p,f,i,o,r,a,u,l);return[e.makeTensorInfo([m.length],"string",m),e.makeTensorInfo(h.shape,"int32",g)]}const QE={kernelName:jf,backendName:"webgpu",kernelFunc:ZE};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JE=Se({opType:vt.SUB,cpuKernelImpl:kA,supportsComplex:!0}),tL={kernelName:ip,backendName:"webgpu",kernelFunc:JE};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eL=Bt({opType:st.TAN}),nL={kernelName:Gr,backendName:"webgpu",kernelFunc:eL};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sL=Bt({opType:st.TANH}),iL={kernelName:Hr,backendName:"webgpu",kernelFunc:sL};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oL(n){const{inputs:t,backend:e,attrs:s}=n,{tensor:i,indices:o,updates:r}=t,{sliceRank:a,numUpdates:u,sliceSize:l,strides:c,outputSize:h}=Di(r,o,i.shape),p=[h/l,l];if(h===0)return e.makeTensorInfo(i.shape,o.dtype);const f=[],m=ft({inputs:{x:o},backend:e,attrs:{shape:[u,a]}});f.push(m);const g=ft({inputs:{x:r},backend:e,attrs:{shape:[u,l]}});f.push(g);const b=ft({inputs:{x:i},backend:e,attrs:{shape:p}});f.push(b);const v=hc({inputs:{x:b},backend:e,attrs:{reps:Array(p.length).fill(1)}}),w=new Yi([u,l],a,m.shape.length,g.shape.length,c,p,i.dtype,!1),k=et([u,l]),C=[{type:"int32",data:[a]},{type:"int32",data:c},{type:"int32",data:[k]}],I=e.runWebGPUProgram(w,[g,m],b.dtype,C,v);f.push(I);const N=ft({inputs:{x:I},backend:e,attrs:{shape:i.shape}});return f.forEach($=>e.disposeData($.dataId)),N}const rL={kernelName:Kf,backendName:"webgpu",kernelFunc:oL};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aL{constructor(t){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=`inputSize : i32, firstPass : i32, negativeInf : f32,
        dir : i32, inc : i32,`,this.shaderKey="swap"}getUserCode(){return`
        ${ot("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // We compare elements pair-wise within a group of size 2 * inc.
            // The comparing rule for each group alternates between ascending
            // and descending. Within each group, we compare each pair at
            // positions i and i+inc. To decide whether an element at position i
            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
            // inc, it is in the first half of the group, we denote it as x0,
            // otherwise we denote it as x1.
            // For example, as shown in the Bitonic top K paper referenced
            // above, Figure5(a) shows that element[1] is in the second half of
            // the group when group size is 2, but it is in the first half of
            // the group when group size is 4.
            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;
            var i = 0;
            if (isFirstInPair) {
              i = elemIdx;
            } else {
              i = elemIdx - uniforms.inc;
            }

            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }

            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.inc;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.inc));
            }

            var x0 = f32(0.0);
            var x1 = f32(0.0);
            if (i0 < uniforms.inputSize) {
              x0 = getX(batch, i0);
            } else {
              x0 = uniforms.negativeInf;
            }
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = uniforms.negativeInf;
            }

            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;
            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
            if (reverse == isGreater) {
              // Elements in opposite order of direction
              let iTemp = i0;
              i0 = i1;
              i1 = iTemp;
            }
            if (isFirstInPair) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}}class uL{constructor(t){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="inputSize : i32, firstPass : i32, k : i32,",this.shaderKey="merge"}getUserCode(){return`
        ${ot("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // The output size is half of the previous size.
            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _
            // (k=4), we only need to output the indices at positions |, the
            // indices at positions _ can be thrown away, see Figure5(b) After
            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced
            // above.
            // For example, the paper shows we only need to output the orange
            // bars. The output sequence should look like this | | | | | | | |.
            // Because the sequence is halved, to map the output index back to
            // the previous sequence to find the corresponding value, we need
            // to double the index. When we double the index, we basically
            // interpolate a position, so 2i looks like
            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k
            // position of each 2k positions by - elemIdx % k. E.g. for output
            // at index 4,5,6,7, we want to get the corresponding element at
            // original index 8,9,10,11, for output at index 8,9,10,11,
            // we want to get the corresponding element at original index
            // 16,17,18,19, so on and so forth.

            var i = 0;
            if (elemIdx < uniforms.k) {
              i = elemIdx;
            } else {
              i = elemIdx * 2 - elemIdx % uniforms.k;
            }
            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }
            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.k;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.k));
            }

            let x0 = getX(batch, i0);
            var x1 = f32(0.0);
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = x0;
            }

            if (x0 >= x1) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ni(n,t){t!==null&&n.disposeData(t.dataId)}function Xh(n){let t=1;for(;t<n;)t*=2;return t}function lL(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{k:o,sorted:r}=s,a=i.shape,u=a[a.length-1];if(e.shouldExecuteOnCPU([i])){const I=e.readSync(i.dataId),[N,$]=IA(I,a,i.dtype,o,r);return[e.makeTensorInfo(N.shape,N.dtype,N.values),e.makeTensorInfo($.shape,$.dtype,$.values)]}if(o===0)return a[a.length-1]=0,[e.makeTensorInfo(a,i.dtype,[]),e.makeTensorInfo(a,"int32",[])];if(u===1)return[i,_e({attrs:{shape:a,dtype:"int32",value:0},backend:e})];const c=et(a)/u,h=ft({inputs:{x:i},attrs:{shape:[c,u]},backend:e}),p=Xh(o),f=Xh(u);let m=null;const g=()=>m===null?[h,h]:[h,m],b=(I,N,$)=>{const A=g(),z=new aL($),E=[{type:"int32",data:[u]},{type:"int32",data:[m===null?1:0]},{type:"float32",data:[Number.NEGATIVE_INFINITY]},{type:"int32",data:[I]},{type:"int32",data:[N]}],U=m;m=e.runWebGPUProgram(z,A,"int32",E),ni(e,U)};for(let I=1;I<p;I*=2){const N=I*2;for(let $=I;$>=1;$/=2)b(N,$,[c,f])}for(let I=f;I>p;I/=2){const N=g(),$=new uL([c,I/2]),z=[{type:"int32",data:[u]},{type:"int32",data:[m===null?1:0]},{type:"int32",data:[p]}],F=m;m=e.runWebGPUProgram($,N,"int32",z),ni(e,F);const E=p/2,U=E*2;for(let L=E;L>=1;L/=2)b(U,L,m.shape)}let v=m;m=zi({inputs:{x:m},backend:e,attrs:{begin:0,size:[c,o]}}),ni(e,v);let w=Jy({inputs:{x:h,indices:m},backend:e,attrs:{axis:1,batchDims:1}});ni(e,h);const k=a.slice(0,-1);k.push(o),v=m,m=ft({inputs:{x:m},attrs:{shape:k},backend:e}),ni(e,v);const C=w;return w=ft({inputs:{x:w},attrs:{shape:k},backend:e}),ni(e,C),[w,m]}const cL={kernelName:Xf,backendName:"webgpu",kernelFunc:lL};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hL{constructor(t){this.variableNames=["Image","Transforms"],this.uniforms="interpolationModeId : i32, fillModeId : i32, fillValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="transform"}getUserCode(){return`
          fn mapCoord(outCoord : f32, len : f32) -> f32{
            var inCoord = outCoord;
            if(uniforms.fillModeId == 2) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  if (inCoord < sz2) {
                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +
                    inCoord;
                  }
                  if (inCoord < -len) {
                    inCoord = inCoord + sz2;
                  } else {
                    inCoord = -inCoord - 1.0;
                  }
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));
                  if (inCoord >= len) {
                    inCoord = sz2 - inCoord - 1.0;
                  }
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 3) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 4) {
              return clamp(outCoord, 0.0, len - 1.0);
            }
            return outCoord;
          }
          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,
            channel : i32) -> f32 {
            var outputValue : f32;
            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {
                outputValue = getImage(batch, coordY, coordX, channel);
            } else {
              outputValue = uniforms.fillValue;
            }
            return outputValue;
          }

          ${ot("index")} {
            if (index < uniforms.size) {
              let coords = getCoordsFromIndex(index);
              var outputValue : f32;
              let batch = coords[0];
              let x = coords[2];
              let y = coords[1];
              let channel = coords[3];
              let xf = f32(x);
              let yf = f32(y);
              let a1 = getTransforms(batch, 0);
              let a2 = getTransforms(batch, 1);
              let a3 = getTransforms(batch, 2);
              let b1 = getTransforms(batch, 3);
              let b2 = getTransforms(batch, 4);
              let b3 = getTransforms(batch, 5);
              let c1 = getTransforms(batch, 6);
              let c2 = getTransforms(batch, 7);
              let projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = uniforms.fillValue;
              } else {
                let inX = (a1 * xf + a2 * yf + a3) / projection;
                let inY = (b1 * xf + b2 * yf + b3) / projection;
                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));
                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));

                if (uniforms.interpolationModeId == 1) {
                  let coordY = i32(round(mapY));
                  let coordX = i32(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  let yFloor = floor(mapY);
                  let xFloor = floor(mapX);
                  let yCeil = yFloor + 1.0;
                  let xCeil = xFloor + 1.0;
                  let valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);
                  let valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutputAtIndex(index, outputValue);
            }
          }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dL(n){const{inputs:t,backend:e,attrs:s}=n,{image:i,transforms:o}=t,{interpolation:r,fillMode:a,fillValue:u,outputShape:l}=s,[c,h,p,f]=i.shape,[m,g]=l??[h,p],b=[c,m,g,f],v=new hL(b),w=r==="nearest"?1:2;let k;switch(a){case"constant":k=1;break;case"reflect":k=2;break;case"wrap":k=3;break;case"nearest":k=4;break;default:k=1;break}const C=[{type:"int32",data:[w]},{type:"int32",data:[k]},{type:"float32",data:[u]}];return e.runWebGPUProgram(v,[i,o],"float32",C)}const pL={kernelName:qf,backendName:"webgpu",kernelFunc:dL};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fL(n){const{inputs:t,backend:e,attrs:s}=n,{value:i}=t;let{axis:o}=s;o<0&&(o+=i.shape.length);const r=i,a=r.shape.length,u=i.shape[o],l=new Array(a-1);let c=0;for(let g=0;g<a;g++)g!==o&&(l[c++]=r.shape[g]);const h=[],p=new Array(a).fill(0),f=r.shape.slice();f[o]=1;const m=new Array(u);for(let g=0;g<m.length;g++){p[o]=g;const b=zi({inputs:{x:r},backend:e,attrs:{begin:p,size:f}}),v=ft({inputs:{x:b},backend:e,attrs:{shape:l}});m[g]=v,h.push(b)}return h.forEach(g=>e.disposeData(g.dataId)),m}const mL={kernelName:wl,backendName:"webgpu",kernelFunc:fL};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gL{constructor(t,e,s){if(this.outputShape=[],this.variableNames=["x","segmentIds"],this.uniforms="numSegments : i32, xSize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e,this.dispatchLayout=ht(t),this.dispatch=rt(this.dispatchLayout,t,this.workgroupSize),s!=="float32"&&s!=="int32")throw new Error(`UnsortedSegmentSum only supports float32 and int32
              types, does not support ${s} type.`);this.type=s,this.shaderKey="unsortedSegmentSum"}getUserCode(){return`
    ${ot("index")} {
      if (index < uniforms.xSize) {
        let coords = getXCoordsFromIndex(index);
        let b = coords[0];
        let inCol = coords[1];

        let segmentId = i32(getSegmentIds(inCol));
        if (segmentId >= 0) {
          let flatIndex = b * uniforms.numSegments + segmentId % uniforms.numSegments;
          let value = getX(b, inCol);

          ${Cs("&result[flatIndex]","value",this.type)}
        }
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yL(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,segmentIds:o}=t,{numSegments:r}=s,a=i.shape.length,u=[];let l=0;const c=Me([l],a);let h=i;c!=null&&(h=_n({inputs:{x:i},backend:e,attrs:{perm:c}}),u.push(h),l=Ke(1,a)[0]);const p=I1(h.shape,l,r),f=et([h.shape[l]]),m=ft({inputs:{x:h},backend:e,attrs:{shape:[-1,f]}});u.push(m);const g=i.dtype,b=[m.shape[0],r],v=_e({backend:e,attrs:{shape:b,value:0,dtype:g}}),w=new gL(m.shape,b,g),k=[{type:"int32",data:[r]},{type:"int32",data:[et(m.shape)]}],C=e.runWebGPUProgram(w,[m,o],g,k,v),I=ft({inputs:{x:C},backend:e,attrs:{shape:p}});u.push(C);let N=I;if(c!=null){u.push(I);const $=_s(c);N=_n({inputs:{x:N},backend:e,attrs:{perm:$}})}return u.forEach($=>e.disposeData($.dataId)),N}const bL={kernelName:vl,backendName:"webgpu",kernelFunc:yL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xL=[GR,DA,AA,zA,MA,LA,GA,jA,XA,YA,QA,tT,nT,iT,rT,hT,pT,yT,xT,vT,NT,AT,FT,LT,_T,UT,jR,jT,YT,iz,cz,fz,yz,xz,vz,kz,Iz,Dz,Az,zz,Mz,Lz,Gz,jz,Bz,qz,Qz,nF,iF,aF,hF,pF,mF,yF,xF,vF,CF,SF,NF,WR,DF,MF,AF,zF,LF,_F,WF,GF,KF,qF,ZF,HR,JF,XT,eM,sM,oM,aM,lM,hM,fM,bM,gM,wM,CM,SM,DM,TM,uT,FM,PM,UM,LM,WM,HM,lT,KM,qM,ZM,JM,iP,uF,rP,uP,cP,MT,pP,mP,yP,wP,CP,SP,NP,DP,PT,AP,zP,MP,EP,VR,_P,VP,HP,XP,ZP,JP,eE,sE,oE,uE,hE,pE,mE,yE,xE,vE,ST,KE,YE,QE,nP,kE,NE,TE,FE,OE,BE,VE,UE,HE,tL,lF,nL,iL,rL,EE,cL,pL,BA,mL,bL,fP];for(const n of xL)Yf(n);/**
    * @license
    * Copyright 2023 Google LLC. All Rights Reserved.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    */var ob=function(n,t){return(ob=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,s){e.__proto__=s}||function(e,s){for(var i in s)Object.prototype.hasOwnProperty.call(s,i)&&(e[i]=s[i])})(n,t)};function rb(n,t){if(typeof t!="function"&&t!==null)throw new TypeError("Class extends value "+String(t)+" is not a constructor or null");function e(){this.constructor=n}ob(n,t),n.prototype=t===null?Object.create(t):(e.prototype=t.prototype,new e)}var Zt=function(){return(Zt=Object.assign||function(n){for(var t,e=1,s=arguments.length;e<s;e++)for(var i in t=arguments[e])Object.prototype.hasOwnProperty.call(t,i)&&(n[i]=t[i]);return n}).apply(this,arguments)};function Ot(n,t,e,s){return new(e||(e=Promise))(function(i,o){function r(l){try{u(s.next(l))}catch(c){o(c)}}function a(l){try{u(s.throw(l))}catch(c){o(c)}}function u(l){var c;l.done?i(l.value):(c=l.value,c instanceof e?c:new e(function(h){h(c)})).then(r,a)}u((s=s.apply(n,[])).next())})}function _t(n,t){var e,s,i,o,r={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return o={next:a(0),throw:a(1),return:a(2)},typeof Symbol=="function"&&(o[Symbol.iterator]=function(){return this}),o;function a(u){return function(l){return function(c){if(e)throw new TypeError("Generator is already executing.");for(;r;)try{if(e=1,s&&(i=2&c[0]?s.return:c[0]?s.throw||((i=s.return)&&i.call(s),0):s.next)&&!(i=i.call(s,c[1])).done)return i;switch(s=0,i&&(c=[2&c[0],i.value]),c[0]){case 0:case 1:i=c;break;case 4:return r.label++,{value:c[1],done:!1};case 5:r.label++,s=c[1],c=[0];continue;case 7:c=r.ops.pop(),r.trys.pop();continue;default:if(i=r.trys,!((i=i.length>0&&i[i.length-1])||c[0]!==6&&c[0]!==2)){r=0;continue}if(c[0]===3&&(!i||c[1]>i[0]&&c[1]<i[3])){r.label=c[1];break}if(c[0]===6&&r.label<i[1]){r.label=i[1],i=c;break}if(i&&r.label<i[2]){r.label=i[2],r.ops.push(c);break}i[2]&&r.ops.pop(),r.trys.pop();continue}c=t.call(n,r)}catch(h){c=[6,h],s=0}finally{e=i=0}if(5&c[0])throw c[1];return{value:c[0]?c[1]:void 0,done:!0}}([u,l])}}}function Ts(n,t,e){if(e||arguments.length===2)for(var s,i=0,o=t.length;i<o;i++)!s&&i in t||(s||(s=Array.prototype.slice.call(t,0,i)),s[i]=t[i]);return n.concat(s||Array.prototype.slice.call(t))}var Bn=["nose","left_eye","right_eye","left_ear","right_ear","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle"],ao=["nose","left_eye_inner","left_eye","left_eye_outer","right_eye_inner","right_eye","right_eye_outer","left_ear","right_ear","mouth_left","mouth_right","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_pinky","right_pinky","left_index","right_index","left_thumb","right_thumb","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle","left_heel","right_heel","left_foot_index","right_foot_index"],wL={left:[1,2,3,7,9,11,13,15,17,19,21,23,25,27,29,31],right:[4,5,6,8,10,12,14,16,18,20,22,24,26,28,30,32],middle:[0]},vL={left:[1,3,5,7,9,11,13,15],right:[2,4,6,8,10,12,14,16],middle:[0]},CL=[[0,1],[0,2],[1,3],[2,4],[5,6],[5,7],[5,11],[6,8],[6,12],[7,9],[8,10],[11,12],[11,13],[12,14],[13,15],[14,16]],kL=[[0,1],[0,4],[1,2],[2,3],[3,7],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[11,23],[12,14],[14,16],[12,24],[13,15],[15,17],[16,18],[16,20],[15,17],[15,19],[15,21],[16,22],[17,19],[18,20],[23,25],[23,24],[24,26],[25,27],[26,28],[27,29],[28,30],[27,31],[28,32],[29,31],[30,32]];function cr(n){return n instanceof SVGAnimatedLength?n.baseVal.value:n}function ab(n){return Ot(this,void 0,void 0,function(){var t,e;return _t(this,function(s){switch(s.label){case 0:return t=document.createElement("canvas"),n instanceof Ge?[4,El(n,t)]:[3,2];case 1:return s.sent(),[3,3];case 2:t.width=cr(n.width),t.height=cr(n.height),e=t.getContext("2d"),n instanceof ImageData?e.putImageData(n,0,0):e.drawImage(n,0,0),s.label=3;case 3:return[2,t]}})})}function ub(n){return Ot(this,void 0,void 0,function(){var t,e,s,i,o,r;return _t(this,function(a){switch(a.label){case 0:return n instanceof Ge?(t=n.shape.slice(0,2),e=t[0],s=t[1],i=ImageData.bind,[4,El(n)]):[3,2];case 1:return[2,new(i.apply(ImageData,[void 0,a.sent(),s,e]))];case 2:return o=document.createElement("canvas"),r=o.getContext("2d"),o.width=cr(n.width),o.height=cr(n.height),r.drawImage(n,0,0),[2,r.getImageData(0,0,o.width,o.height)]}})})}function SL(n){return Ot(this,void 0,void 0,function(){var t,e;return _t(this,function(s){switch(s.label){case 0:return n instanceof SVGImageElement||n instanceof OffscreenCanvas?[4,ab(n)]:[3,2];case 1:return e=s.sent(),[3,3];case 2:e=n,s.label=3;case 3:return t=e,[2,Qf(t,4)]}})})}function lb(n){if(n<0||n>=256)throw new Error("Mask value must be in range [0, 255] but got ".concat(n));if(!Number.isInteger(n))throw new Error("Mask value must be an integer but got ".concat(n))}var Gi={runtime:"mediapipe",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,modelType:"full"},IL=function(){function n(t){this.mask=t}return n.prototype.toCanvasImageSource=function(){return Ot(this,void 0,void 0,function(){return _t(this,function(t){return[2,this.mask]})})},n.prototype.toImageData=function(){return Ot(this,void 0,void 0,function(){return _t(this,function(t){return[2,ub(this.mask)]})})},n.prototype.toTensor=function(){return Ot(this,void 0,void 0,function(){return _t(this,function(t){return[2,SL(this.mask)]})})},n.prototype.getUnderlyingType=function(){return"canvasimagesource"},n}();function NL(n){return lb(n),"person"}var $L=function(){function n(t){var e,s=this;switch(this.width=0,this.height=0,this.selfieMode=!1,this.poseSolution=new V$.Pose({locateFile:function(i,o){if(t.solutionPath){var r=t.solutionPath.replace(/\/+$/,"");return"".concat(r,"/").concat(i)}return"".concat(o,"/").concat(i)}}),t.modelType){case"lite":e=0;break;case"heavy":e=2;break;case"full":default:e=1}this.poseSolution.setOptions({modelComplexity:e,smoothLandmarks:t.enableSmoothing,enableSegmentation:t.enableSegmentation,smoothSegmentation:t.smoothSegmentation,selfieMode:this.selfieMode}),this.poseSolution.onResults(function(i){if(s.height=i.image.height,s.width=i.image.width,i.poseLandmarks==null)s.poses=[];else{var o=s.translateOutput(i.poseLandmarks,i.poseWorldLandmarks);i.segmentationMask&&(o.segmentation={maskValueToLabel:NL,mask:new IL(i.segmentationMask)}),s.poses=[o]}})}return n.prototype.translateOutput=function(t,e){var s=this,i={keypoints:t.map(function(o,r){return{x:o.x*s.width,y:o.y*s.height,z:o.z,score:o.visibility,name:ao[r]}})};return e!=null&&(i.keypoints3D=e.map(function(o,r){return{x:o.x,y:o.y,z:o.z,score:o.visibility,name:ao[r]}})),i},n.prototype.estimatePoses=function(t,e,s){return Ot(this,void 0,void 0,function(){var i,o;return _t(this,function(r){switch(r.label){case 0:return e&&e.flipHorizontal&&e.flipHorizontal!==this.selfieMode&&(this.selfieMode=e.flipHorizontal,this.poseSolution.setOptions({selfieMode:this.selfieMode})),t instanceof Ge?(o=ImageData.bind,[4,El(t)]):[3,2];case 1:return i=new(o.apply(ImageData,[void 0,r.sent(),t.shape[1],t.shape[0]])),[3,3];case 2:i=t,r.label=3;case 3:return t=i,[4,this.poseSolution.send({image:t},s)];case 4:return r.sent(),[2,this.poses]}})})},n.prototype.dispose=function(){this.poseSolution.close()},n.prototype.reset=function(){this.poseSolution.reset()},n.prototype.initialize=function(){return this.poseSolution.initialize()},n}();function DL(n){return Ot(this,void 0,void 0,function(){var t,e;return _t(this,function(s){switch(s.label){case 0:return t=function(i){if(i==null)return Zt({},Gi);var o=Zt({},i);return o.runtime="mediapipe",o.enableSegmentation==null&&(o.enableSegmentation=Gi.enableSegmentation),o.enableSmoothing==null&&(o.enableSmoothing=Gi.enableSmoothing),o.smoothSegmentation==null&&(o.smoothSegmentation=Gi.smoothSegmentation),o.modelType==null&&(o.modelType=Gi.modelType),o}(n),[4,(e=new $L(t)).initialize()];case 1:return s.sent(),[2,e]}})})}function xi(n){return n instanceof Ge?{height:n.shape[0],width:n.shape[1]}:{height:n.height,width:n.width}}function cb(n){return n-2*Math.PI*Math.floor((n+Math.PI)/(2*Math.PI))}function dc(n){return n instanceof Ge?n:Qf(n)}function hb(n,t,e){return fu(e,"inputResolution"),[1/e.width*n[0][0]*t.width,1/e.height*n[0][1]*t.width,n[0][3]*t.width,1/e.width*n[1][0]*t.height,1/e.height*n[1][1]*t.height,n[1][3]*t.height,0,0]}function fu(n,t){tt(n.width!==0,function(){return"".concat(t," width cannot be 0.")}),tt(n.height!==0,function(){return"".concat(t," height cannot be 0.")})}function Va(n,t,e){var s=e.rotationVectorStartKeypointIndex,i=e.rotationVectorEndKeypointIndex,o=n.locationData,r=o.relativeKeypoints[s].x*t.width,a=o.relativeKeypoints[s].y*t.height,u=o.relativeKeypoints[i].x*t.width,l=o.relativeKeypoints[i].y*t.height,c=2*Math.sqrt((u-r)*(u-r)+(l-a)*(l-a)),h=function(p,f,m){var g,b=p.locationData,v=m.rotationVectorStartKeypointIndex,w=m.rotationVectorEndKeypointIndex;g=m.rotationVectorTargetAngle?m.rotationVectorTargetAngle:Math.PI*m.rotationVectorTargetAngleDegree/180;var k=b.relativeKeypoints[v].x*f.width,C=b.relativeKeypoints[v].y*f.height,I=b.relativeKeypoints[w].x*f.width,N=b.relativeKeypoints[w].y*f.height;return cb(g-Math.atan2(-(N-C),I-k))}(n,t,e);return{xCenter:r/t.width,yCenter:a/t.height,width:c/t.width,height:c/t.height,rotation:h}}function db(n){if(n.length!==16)throw new Error("Array length must be 16 but got ".concat(n.length));return[[n[0],n[1],n[2],n[3]],[n[4],n[5],n[6],n[7]],[n[8],n[9],n[10],n[11]],[n[12],n[13],n[14],n[15]]]}function Ua(n,t,e,s,i,o,r){return n[t][i]*(n[e][o]*n[s][r]-n[e][r]*n[s][o])}function ze(n,t,e){var s=(t+1)%4,i=(t+2)%4,o=(t+3)%4,r=(e+1)%4,a=(e+2)%4,u=(e+3)%4;return Ua(n,s,i,o,r,a,u)+Ua(n,i,o,s,r,a,u)+Ua(n,o,s,i,r,a,u)}function qh(n,t,e){e===void 0&&(e={ignoreRotation:!1});for(var s=[],i=0,o=n;i<o.length;i++){var r=o[i],a=r.x-.5,u=r.y-.5,l=e.ignoreRotation?0:t.rotation,c=Math.cos(l)*a-Math.sin(l)*u,h=Math.sin(l)*a+Math.cos(l)*u;c=c*t.width+t.xCenter,h=h*t.height+t.yCenter;var p=r.z*t.width,f=Zt({},r);f.x=c,f.y=h,f.z=p,s.push(f)}return s}function pb(n,t){var e=function(s,i,o,r){var a=i-s,u=r-o,l=u/a;return{scale:l,offset:o-s*l}}(0,255,t[0],t[1]);return B(function(){return ct(O(n,e.scale),e.offset)})}function mu(n,t,e){var s,i,o,r,a,u,l,c,h,p,f,m,g,b,v=t.outputTensorSize,w=t.keepAspectRatio,k=t.borderMode,C=t.outputTensorFloatRange,I=xi(n),N=function(z,F){return F?{xCenter:F.xCenter*z.width,yCenter:F.yCenter*z.height,width:F.width*z.width,height:F.height*z.height,rotation:F.rotation}:{xCenter:.5*z.width,yCenter:.5*z.height,width:z.width,height:z.height,rotation:0}}(I,e),$=function(z,F,E){if(E===void 0&&(E=!1),!E)return{top:0,left:0,right:0,bottom:0};var U=F.height,L=F.width;fu(F,"targetSize"),fu(z,"roi");var W,_,V=U/L,X=z.height/z.width,j=0,K=0;return V>X?(W=z.width,_=z.width*V,K=(1-X/V)/2):(W=z.height/V,_=z.height,j=(1-V/X)/2),z.width=W,z.height=_,{top:K,left:j,right:j,bottom:K}}(N,v,w),A=(s=N,i=I.width,o=I.height,r=!1,a=s.width,u=s.height,l=r?-1:1,c=Math.cos(s.rotation),h=Math.sin(s.rotation),p=s.xCenter,f=s.yCenter,m=1/i,g=1/o,(b=new Array(16))[0]=a*c*l*m,b[1]=-u*h*m,b[2]=0,b[3]=(-.5*a*c*l+.5*u*h+p)*m,b[4]=a*h*l*g,b[5]=u*c*g,b[6]=0,b[7]=(-.5*u*c-.5*a*h*l+f)*g,b[8]=0,b[9]=0,b[10]=a*m,b[11]=0,b[12]=0,b[13]=0,b[14]=0,b[15]=1,db(b));return{imageTensor:B(function(){var z=dc(n),F=zs(hb(A,I,v),[1,8]),E=k==="zero"?"constant":"nearest",U=Oe.transform(Ye(mt(z,"float32")),F,"bilinear",E,0,[v.height,v.width]);return C!=null?pb(U,C):U}),padding:$,transformationMatrix:A}}function Yh(n,t,e,s){return s===1?.5*(n+t):n+(t-n)*e/(s-1)}function RL(n){return B(function(){var t=function(i){return B(function(){return[le(i,[0,0,0],[1,-1,1]),le(i,[0,0,1],[1,-1,-1])]})}(n),e=t[0],s=t[1];return{boxes:Xt(s),logits:Xt(e)}})}function fb(n){return n!=null&&n.currentTime!=null}function Zh(n){for(var t={locationData:{relativeKeypoints:[]}},e=Number.MAX_SAFE_INTEGER,s=Number.MIN_SAFE_INTEGER,i=Number.MAX_SAFE_INTEGER,o=Number.MIN_SAFE_INTEGER,r=0;r<n.length;++r){var a=n[r];e=Math.min(e,a.x),s=Math.max(s,a.x),i=Math.min(i,a.y),o=Math.max(o,a.y),t.locationData.relativeKeypoints.push({x:a.x,y:a.y})}return t.locationData.relativeBoundingBox={xMin:e,yMin:i,xMax:s,yMax:o,width:s-e,height:o-i},t}function AL(n,t,e,s){return Ot(this,void 0,void 0,function(){var i,o,r,a,u;return _t(this,function(l){switch(l.label){case 0:return n.sort(function(c,h){return Math.max.apply(Math,h.score)-Math.max.apply(Math,c.score)}),i=zs(n.map(function(c){return[c.locationData.relativeBoundingBox.yMin,c.locationData.relativeBoundingBox.xMin,c.locationData.relativeBoundingBox.yMax,c.locationData.relativeBoundingBox.xMax]})),o=jn(n.map(function(c){return c.score[0]})),[4,Oe.nonMaxSuppressionAsync(i,o,t,e)];case 1:return[4,(r=l.sent()).array()];case 2:return a=l.sent(),u=n.filter(function(c,h){return a.indexOf(h)>-1}),zt([i,o,r]),[2,u]}})})}function mb(n,t){return n.map(function(e){var s=Zt(Zt({},e),{x:e.x*t.width,y:e.y*t.height});return e.z!=null&&(s.z=e.z*t.width),s})}function TL(n,t,e){return Ot(this,void 0,void 0,function(){var s,i,o,r,a,u,l,c,h,p,f,m,g,b,v,w,k,C,I,N,$,A,z,F;return _t(this,function(E){switch(E.label){case 0:if(s=Xt(t,[0]),i=s.shape,o=i[0],r=i[1],a=i[2],n.length!==a)throw new Error("Expected heatmap to have same number of channels as the number of landmarks. But got landmarks length: "+"".concat(n.length,", heatmap length: ").concat(a));return u=[],[4,s.buffer()];case 1:for(l=E.sent(),c=0;c<n.length;c++)if(h=n[c],p=Zt({},h),u.push(p),f=Math.trunc(p.x*r),m=Math.trunc(p.y*o),!(f<0||f>=r||m<0||f>=o)){for(g=Math.trunc((e.kernelSize-1)/2),b=Math.max(0,f-g),v=Math.min(r,f+g+1),w=Math.max(0,m-g),k=Math.min(o,m+g+1),C=0,I=0,N=0,$=0,A=w;A<k;++A)for(z=b;z<v;++z)F=l.get(A,z,c),C+=F,$=Math.max($,F),I+=z*F,N+=A*F;$>=e.minConfidenceToRefine&&C>0&&(p.x=I/r/C,p.y=N/o/C)}return s.dispose(),[2,u]}})})}function Qh(n,t){var e=t.left,s=t.top,i=t.left+t.right,o=t.top+t.bottom;return n.map(function(r){return Zt(Zt({},r),{x:(r.x-e)/(1-i),y:(r.y-s)/(1-o),z:r.z/(1-i)})})}function zL(n,t,e){return Xo()==="webgl"?function(s,i,o){var r=o.combineWithPreviousRatio.toFixed(2),a={variableNames:["prevMask","newMask"],outputShape:s.shape,userCode:`
  void main() {
      ivec2 coords = getOutputCoords();
      int height = coords[0];
      int width = coords[1];

      float prevMaskValue = getPrevMask(height, width);
      float newMaskValue = getNewMask(height, width);

      /*
      * Assume p := newMaskValue
      * H(p) := 1 + (p * log(p) + (1-p) * log(1-p)) / log(2)
      * uncertainty alpha(p) =
      *   Clamp(1 - (1 - H(p)) * (1 - H(p)), 0, 1) [squaring the
      * uncertainty]
      *
      * The following polynomial approximates uncertainty alpha as a
      * function of (p + 0.5):
      */
      const float c1 = 5.68842;
      const float c2 = -0.748699;
      const float c3 = -57.8051;
      const float c4 = 291.309;
      const float c5 = -624.717;
      float t = newMaskValue - 0.5;
      float x = t * t;

      float uncertainty =
        1.0 - min(1.0, x * (c1 + x * (c2 + x * (c3 + x * (c4 + x * c5)))));

      float outputValue = newMaskValue + (prevMaskValue - newMaskValue) *
                             (uncertainty * `.concat(r,`);

      setOutput(outputValue);
    }
`)},u=hi();return B(function(){var l=u.compileAndRun(a,[s,i]);return ls().makeTensorFromDataId(l.dataId,l.shape,l.dtype)})}(n,t,e):B(function(){var s=Lt(t,.5),i=Ie(s),o=Lt(1,jr(1,O(i,ct(5.68842,O(i,ct(-.748699,O(i,ct(-57.8051,O(i,ct(291.309,O(i,-624.717)))))))))));return ct(t,O(Lt(n,t),O(o,e.combineWithPreviousRatio)))})}function FL(n,t,e){return Ot(this,void 0,void 0,function(){var s,i,o,r,a;return _t(this,function(u){switch(u.label){case 0:return s=n[0],i=n[1],o=function(l,c,h){return B(function(){var p,f,m,g;h.reverseOutputOrder?(f=Xt(le(l,[0,h.boxCoordOffset+0],[-1,1])),p=Xt(le(l,[0,h.boxCoordOffset+1],[-1,1])),g=Xt(le(l,[0,h.boxCoordOffset+2],[-1,1])),m=Xt(le(l,[0,h.boxCoordOffset+3],[-1,1]))):(p=Xt(le(l,[0,h.boxCoordOffset+0],[-1,1])),f=Xt(le(l,[0,h.boxCoordOffset+1],[-1,1])),m=Xt(le(l,[0,h.boxCoordOffset+2],[-1,1])),g=Xt(le(l,[0,h.boxCoordOffset+3],[-1,1]))),f=ct(O(Ct(f,h.xScale),c.w),c.x),p=ct(O(Ct(p,h.yScale),c.h),c.y),h.applyExponentialOnBoxSize?(m=O(Qn(Ct(m,h.hScale)),c.h),g=O(Qn(Ct(g,h.wScale)),c.w)):(m=O(Ct(m,h.hScale),c.h),g=O(Ct(g,h.wScale),c.h));var b=Lt(p,Ct(m,2)),v=Lt(f,Ct(g,2)),w=ct(p,Ct(m,2)),k=ct(f,Ct(g,2)),C=fs([Q(b,[h.numBoxes,1]),Q(v,[h.numBoxes,1]),Q(w,[h.numBoxes,1]),Q(k,[h.numBoxes,1])],1);if(h.numKeypoints)for(var I=0;I<h.numKeypoints;++I){var N=h.keypointCoordOffset+I*h.numValuesPerKeypoint,$=void 0,A=void 0;h.reverseOutputOrder?($=Xt(le(l,[0,N],[-1,1])),A=Xt(le(l,[0,N+1],[-1,1]))):(A=Xt(le(l,[0,N],[-1,1])),$=Xt(le(l,[0,N+1],[-1,1])));var z=ct(O(Ct($,h.xScale),c.w),c.x),F=ct(O(Ct(A,h.yScale),c.h),c.y);C=fs([C,Q(z,[h.numBoxes,1]),Q(F,[h.numBoxes,1])],1)}return C})}(i,t,e),r=B(function(){var l=s;return e.sigmoidScore?(e.scoreClippingThresh!=null&&(l=Ue(s,-e.scoreClippingThresh,e.scoreClippingThresh)),l=Ws(l)):l}),[4,ML(o,r,e)];case 1:return a=u.sent(),zt([o,r]),[2,a]}})})}function ML(n,t,e){return Ot(this,void 0,void 0,function(){var s,i,o,r,a,u,l,c,h,p,f,m;return _t(this,function(g){switch(g.label){case 0:return s=[],[4,n.data()];case 1:return i=g.sent(),[4,t.data()];case 2:for(o=g.sent(),r=0;r<e.numBoxes;++r)if(!(e.minScoreThresh!=null&&o[r]<e.minScoreThresh||(a=r*e.numCoords,u=PL(i[a+0],i[a+1],i[a+2],i[a+3],o[r],e.flipVertically,r),(l=u.locationData.relativeBoundingBox).width<0||l.height<0))){if(e.numKeypoints>0)for((c=u.locationData).relativeKeypoints=[],h=e.numKeypoints*e.numValuesPerKeypoint,p=0;p<h;p+=e.numValuesPerKeypoint)f=a+e.keypointCoordOffset+p,m={x:i[f+0],y:e.flipVertically?1-i[f+1]:i[f+1]},c.relativeKeypoints.push(m);s.push(u)}return[2,s]}})})}function PL(n,t,e,s,i,o,r){return{score:[i],ind:r,locationData:{relativeBoundingBox:{xMin:t,yMin:o?1-e:n,xMax:s,yMax:o?1-n:e,width:s-t,height:e-n}}}}function EL(n,t){return n==="none"?t:function(e){return 1/(1+Math.exp(-e))}(t)}function Jh(n,t,e,s){return Ot(this,void 0,void 0,function(){var i,o,r,a,u,l,c,h;return _t(this,function(p){switch(p.label){case 0:return e=e||t.flipHorizontally||!1,s=s||t.flipVertically||!1,i=n.size,o=i/t.numLandmarks,[4,n.data()];case 1:for(r=p.sent(),a=[],u=0;u<t.numLandmarks;++u)l=u*o,(h={x:0,y:0}).x=e?t.inputImageWidth-r[l]:r[l],o>1&&(h.y=s?t.inputImageHeight-r[l+1]:r[l+1]),o>2&&(h.z=r[l+2]),o>3&&(h.score=EL(t.visibilityActivation,r[l+3])),a.push(h);for(c=0;c<a.length;++c)(h=a[c]).x=h.x/t.inputImageWidth,h.y=h.y/t.inputImageHeight,h.z=h.z/t.inputImageWidth/(t.normalizeZ||1);return[2,a]}})})}function td(n,t,e){var s=n.width,i=n.height,o=n.rotation;if(e.rotation==null&&e.rotationDegree==null||(o=function(l,c){return c.rotation!=null?l+=c.rotation:c.rotationDegree!=null&&(l+=Math.PI*c.rotationDegree/180),cb(l)}(o,e)),o===0)n.xCenter=n.xCenter+s*e.shiftX,n.yCenter=n.yCenter+i*e.shiftY;else{var r=(t.width*s*e.shiftX*Math.cos(o)-t.height*i*e.shiftY*Math.sin(o))/t.width,a=(t.width*s*e.shiftX*Math.sin(o)+t.height*i*e.shiftY*Math.cos(o))/t.height;n.xCenter=n.xCenter+r,n.yCenter=n.yCenter+a}{var u=Math.max(s*t.width,i*t.height);s=u/t.width,i=u/t.height}return n.width=s*e.scaleX,n.height=i*e.scaleY,n}function LL(n,t){return n.map(function(e){var s=Zt(Zt({},e),{x:e.x/t.width,y:e.y/t.height});return e.z!=null&&(e.z=e.z/t.width),s})}var us=function(){function n(t){this.alpha=t,this.initialized=!1}return n.prototype.apply=function(t,e){var s;return this.initialized?s=e==null?this.storedValue+this.alpha*(t-this.storedValue):this.storedValue+this.alpha*e*Math.asinh((t-this.storedValue)/e):(s=t,this.initialized=!0),this.rawValue=t,this.storedValue=s,s},n.prototype.applyWithAlpha=function(t,e,s){return this.alpha=e,this.apply(t,s)},n.prototype.hasLastRawValue=function(){return this.initialized},n.prototype.lastRawValue=function(){return this.rawValue},n.prototype.reset=function(){this.initialized=!1},n}(),Ga=function(){function n(t){this.frequency=t.frequency,this.minCutOff=t.minCutOff,this.beta=t.beta,this.thresholdCutOff=t.thresholdCutOff,this.thresholdBeta=t.thresholdBeta,this.derivateCutOff=t.derivateCutOff,this.x=new us(this.getAlpha(this.minCutOff)),this.dx=new us(this.getAlpha(this.derivateCutOff)),this.lastTimestamp=0}return n.prototype.apply=function(t,e,s){if(t==null)return t;var i=Math.trunc(e);if(this.lastTimestamp>=i)return t;this.lastTimestamp!==0&&i!==0&&(this.frequency=1/(1e-6*(i-this.lastTimestamp))),this.lastTimestamp=i;var o=this.x.hasLastRawValue()?(t-this.x.lastRawValue())*s*this.frequency:0,r=this.dx.applyWithAlpha(o,this.getAlpha(this.derivateCutOff)),a=this.minCutOff+this.beta*Math.abs(r),u=this.thresholdCutOff!=null?this.thresholdCutOff+this.thresholdBeta*Math.abs(r):null;return this.x.applyWithAlpha(t,this.getAlpha(a),u)},n.prototype.getAlpha=function(t){return 1/(1+this.frequency/(2*Math.PI*t))},n}(),gu=function(){function n(t){this.config=t}return n.prototype.apply=function(t,e,s){var i=this;if(t==null)return this.reset(),null;this.initializeFiltersIfEmpty(t);var o=1;if(!this.config.disableValueScaling){if(s<this.config.minAllowedObjectScale)return Ts([],t,!0);o=1/s}return t.map(function(r,a){var u=Zt(Zt({},r),{x:i.xFilters[a].apply(r.x,e,o),y:i.yFilters[a].apply(r.y,e,o)});return r.z!=null&&(u.z=i.zFilters[a].apply(r.z,e,o)),u})},n.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},n.prototype.initializeFiltersIfEmpty=function(t){var e=this;this.xFilters!=null&&this.xFilters.length===t.length||(this.xFilters=t.map(function(s){return new Ga(e.config)}),this.yFilters=t.map(function(s){return new Ga(e.config)}),this.zFilters=t.map(function(s){return new Ga(e.config)}))},n}(),Ha=function(){function n(t){this.config=t,this.window=[],this.lowPassFilter=new us(1),this.lastValue=0,this.lastValueScale=1,this.lastTimestamp=-1}return n.prototype.apply=function(t,e,s){if(t==null)return t;var i,o=Math.trunc(e);if(this.lastTimestamp>=o)return t;if(this.lastTimestamp===-1)i=1;else{for(var r=t*s-this.lastValue*this.lastValueScale,a=o-this.lastTimestamp,u=r,l=a,c=(1+this.window.length)*(1e6/30),h=0,p=this.window;h<p.length;h++){var f=p[h];if(l+f.duration>c)break;u+=f.distance,l+=f.duration}var m=u/(1e-6*l);i=1-1/(1+this.config.velocityScale*Math.abs(m)),this.window.unshift({distance:r,duration:a}),this.window.length>this.config.windowSize&&this.window.pop()}return this.lastValue=t,this.lastValueScale=s,this.lastTimestamp=o,this.lowPassFilter.applyWithAlpha(t,i)},n}(),OL=function(){function n(t){this.config=t}return n.prototype.apply=function(t,e,s){var i=this;if(t==null)return this.reset(),null;var o=1;if(!this.config.disableValueScaling){if(s<this.config.minAllowedObjectScale)return Ts([],t,!0);o=1/s}return this.initializeFiltersIfEmpty(t),t.map(function(r,a){var u=Zt(Zt({},r),{x:i.xFilters[a].apply(r.x,e,o),y:i.yFilters[a].apply(r.y,e,o)});return r.z!=null&&(u.z=i.zFilters[a].apply(r.z,e,o)),u})},n.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},n.prototype.initializeFiltersIfEmpty=function(t){var e=this;this.xFilters!=null&&this.xFilters.length===t.length||(this.xFilters=t.map(function(s){return new Ha(e.config)}),this.yFilters=t.map(function(s){return new Ha(e.config)}),this.zFilters=t.map(function(s){return new Ha(e.config)}))},n}(),ja=function(){function n(t){if(t.velocityFilter!=null)this.keypointsFilter=new OL(t.velocityFilter);else{if(t.oneEuroFilter==null)throw new Error("Either configure velocityFilter or oneEuroFilter, but got "+"".concat(t,"."));this.keypointsFilter=new gu(t.oneEuroFilter)}}return n.prototype.apply=function(t,e,s,i,o){if(i===void 0&&(i=!1),t==null)return this.keypointsFilter.reset(),null;var r=o!=null?function(l,c){return(l.width*c.width+l.height*c.height)/2}(o,s):1,a=i?mb(t,s):t,u=this.keypointsFilter.apply(a,e,r);return i?LL(u,s):u},n}(),ed=function(){function n(t){this.alpha=t.alpha}return n.prototype.apply=function(t){var e=this;if(t==null)return this.visibilityFilters=null,null;this.visibilityFilters!=null&&this.visibilityFilters.length===t.length||(this.visibilityFilters=t.map(function(a){return new us(e.alpha)}));for(var s=[],i=0;i<t.length;++i){var o=t[i],r=Zt({},o);r.score=this.visibilityFilters[i].apply(o.score),s.push(r)}return s},n}(),_L={reduceBoxesInLowestlayer:!1,interpolatedScaleAspectRatio:1,featureMapHeight:[],featureMapWidth:[],numLayers:5,minScale:.1484375,maxScale:.75,inputSizeHeight:224,inputSizeWidth:224,anchorOffsetX:.5,anchorOffsetY:.5,strides:[8,16,32,32,32],aspectRatios:[1],fixedAnchorSize:!0},si={runtime:"tfjs",modelType:"full",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,detectorModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/detector/1",landmarkModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"},BL={maxPoses:1,flipHorizontal:!1},WL={applyExponentialOnBoxSize:!1,flipVertically:!1,ignoreClasses:[],numClasses:1,numBoxes:2254,numCoords:12,boxCoordOffset:0,keypointCoordOffset:4,numKeypoints:4,numValuesPerKeypoint:2,sigmoidScore:!0,scoreClippingThresh:100,reverseOutputOrder:!0,xScale:224,yScale:224,hScale:224,wScale:224,minScoreThresh:.5},VL=.3,nd={shiftX:0,shiftY:0,scaleX:1.25,scaleY:1.25,squareLong:!0},UL={outputTensorSize:{width:224,height:224},keepAspectRatio:!0,outputTensorFloatRange:[-1,1],borderMode:"zero"},GL={outputTensorSize:{width:256,height:256},keepAspectRatio:!0,outputTensorFloatRange:[0,1],borderMode:"zero"},HL={numLandmarks:39,inputImageWidth:256,inputImageHeight:256,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},jL={numLandmarks:39,inputImageWidth:1,inputImageHeight:1,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},KL={kernelSize:7,minConfidenceToRefine:.5},sd={alpha:.1},XL={oneEuroFilter:{frequency:30,minCutOff:.05,beta:80,derivateCutOff:1,minAllowedObjectScale:1e-6}},qL={oneEuroFilter:{frequency:30,minCutOff:.01,beta:10,derivateCutOff:1,minAllowedObjectScale:1e-6}},YL={oneEuroFilter:{frequency:30,minCutOff:.1,beta:40,derivateCutOff:1,minAllowedObjectScale:1e-6,disableValueScaling:!0}},ZL={activation:"none"},QL={combineWithPreviousRatio:.7},JL=function(){function n(t){this.mask=t}return n.prototype.toCanvasImageSource=function(){return Ot(this,void 0,void 0,function(){return _t(this,function(t){return[2,ab(this.mask)]})})},n.prototype.toImageData=function(){return Ot(this,void 0,void 0,function(){return _t(this,function(t){return[2,ub(this.mask)]})})},n.prototype.toTensor=function(){return Ot(this,void 0,void 0,function(){return _t(this,function(t){return[2,this.mask]})})},n.prototype.getUnderlyingType=function(){return"tensor"},n}();function tO(n){return lb(n),"person"}var eO=function(){function n(t,e,s,i,o,r){this.detectorModel=t,this.landmarkModel=e,this.enableSmoothing=s,this.enableSegmentation=i,this.smoothSegmentation=o,this.modelType=r,this.regionOfInterest=null,this.prevFilteredSegmentationMask=null,this.anchors=function(h){h.reduceBoxesInLowestLayer==null&&(h.reduceBoxesInLowestLayer=!1),h.interpolatedScaleAspectRatio==null&&(h.interpolatedScaleAspectRatio=1),h.fixedAnchorSize==null&&(h.fixedAnchorSize=!1);for(var p=[],f=0;f<h.numLayers;){for(var m=[],g=[],b=[],v=[],w=f;w<h.strides.length&&h.strides[w]===h.strides[f];){var k=Yh(h.minScale,h.maxScale,w,h.strides.length);if(w===0&&h.reduceBoxesInLowestLayer)b.push(1),b.push(2),b.push(.5),v.push(.1),v.push(k),v.push(k);else{for(var C=0;C<h.aspectRatios.length;++C)b.push(h.aspectRatios[C]),v.push(k);if(h.interpolatedScaleAspectRatio>0){var I=w===h.strides.length-1?1:Yh(h.minScale,h.maxScale,w+1,h.strides.length);v.push(Math.sqrt(k*I)),b.push(h.interpolatedScaleAspectRatio)}}w++}for(var N=0;N<b.length;++N){var $=Math.sqrt(b[N]);m.push(v[N]/$),g.push(v[N]*$)}var A=0,z=0;if(h.featureMapHeight.length>0)A=h.featureMapHeight[f],z=h.featureMapWidth[f];else{var F=h.strides[f];A=Math.ceil(h.inputSizeHeight/F),z=Math.ceil(h.inputSizeWidth/F)}for(var E=0;E<A;++E)for(var U=0;U<z;++U)for(var L=0;L<m.length;++L){var W={xCenter:(U+h.anchorOffsetX)/z,yCenter:(E+h.anchorOffsetY)/A,width:0,height:0};h.fixedAnchorSize?(W.width=1,W.height=1):(W.width=g[L],W.height=m[L]),p.push(W)}f=w}return p}(_L);var a=jn(this.anchors.map(function(h){return h.width})),u=jn(this.anchors.map(function(h){return h.height})),l=jn(this.anchors.map(function(h){return h.xCenter})),c=jn(this.anchors.map(function(h){return h.yCenter}));this.anchorTensor={x:l,y:c,w:a,h:u},this.prevFilteredSegmentationMask=this.enableSegmentation?zs([],[0,0]):null}return n.prototype.estimatePoses=function(t,e,s){return Ot(this,void 0,void 0,function(){var i,o,r,a,u,l,c,h,p,f,m,g,b,v,w,k,C,I,N,$,A,z,F;return _t(this,function(E){switch(E.label){case 0:return i=function(U){var L;if((L=U==null?BL:Zt({},U)).maxPoses==null&&(L.maxPoses=1),L.maxPoses<=0)throw new Error("Invalid maxPoses ".concat(L.maxPoses,". Should be > 0."));if(L.maxPoses>1)throw new Error("Multi-pose detection is not implemented yet. Please set maxPoses to 1.");return L}(e),t==null?(this.reset(),[2,[]]):(this.maxPoses=i.maxPoses,this.timestamp=s!=null?1e3*s:fb(t)?1e6*t.currentTime:null,o=xi(t),r=B(function(){return mt(dc(t),"float32")}),(a=this.regionOfInterest)!=null?[3,2]:[4,this.detectPose(r)]);case 1:if((u=E.sent()).length===0)return this.reset(),r.dispose(),[2,[]];l=u[0],a=this.poseDetectionToRoi(l,o),E.label=2;case 2:return[4,this.poseLandmarksByRoi(a,r)];case 3:return c=E.sent(),r.dispose(),c==null?(this.reset(),[2,[]]):(h=c.landmarks,p=c.auxiliaryLandmarks,f=c.poseScore,m=c.worldLandmarks,g=c.segmentationMask,b=this.poseLandmarkFiltering(h,p,m,o),v=b.actualLandmarksFiltered,w=b.auxiliaryLandmarksFiltered,k=b.actualWorldLandmarksFiltered,C=this.poseLandmarksToRoi(w,o),this.regionOfInterest=C,I=this.smoothSegmentation&&g!=null?this.poseSegmentationFiltering(g):g,(N=v!=null?mb(v,o):null)!=null&&N.forEach(function(U,L){U.name=ao[L]}),($=k)!=null&&$.forEach(function(U,L){U.name=ao[L]}),A={score:f,keypoints:N,keypoints3D:$},I!==null&&(z=B(function(){var U=Ye(I,2),L=ui(U,[[0,0],[0,0],[0,1]]);return bp(L,[[0,0],[0,0],[0,2]],"symmetric")}),this.smoothSegmentation||zt(I),F={maskValueToLabel:tO,mask:new JL(z)},A.segmentation=F),[2,[A]])}})})},n.prototype.poseSegmentationFiltering=function(t){var e=this.prevFilteredSegmentationMask;return e.size===0?this.prevFilteredSegmentationMask=t:(this.prevFilteredSegmentationMask=zL(e,t,QL),zt(t)),zt(e),this.prevFilteredSegmentationMask},n.prototype.dispose=function(){this.detectorModel.dispose(),this.landmarkModel.dispose(),zt([this.anchorTensor.x,this.anchorTensor.y,this.anchorTensor.w,this.anchorTensor.h,this.prevFilteredSegmentationMask])},n.prototype.reset=function(){this.regionOfInterest=null,this.enableSegmentation&&(zt(this.prevFilteredSegmentationMask),this.prevFilteredSegmentationMask=zs([],[0,0])),this.visibilitySmoothingFilterActual=null,this.visibilitySmoothingFilterAuxiliary=null,this.landmarksSmoothingFilterActual=null,this.landmarksSmoothingFilterAuxiliary=null},n.prototype.detectPose=function(t){return Ot(this,void 0,void 0,function(){var e,s,i,o,r,a,u,l,c,h;return _t(this,function(p){switch(p.label){case 0:return e=mu(t,UL),s=e.imageTensor,i=e.padding,o=this.detectorModel.predict(s),r=RL(o),a=r.boxes,[4,FL([u=r.logits,a],this.anchorTensor,WL)];case 1:return(l=p.sent()).length===0?(zt([s,o,u,a]),[2,l]):[4,AL(l,this.maxPoses,VL)];case 2:return c=p.sent(),h=function(f,m){f===void 0&&(f=[]);for(var g=m.left,b=m.top,v=m.left+m.right,w=m.top+m.bottom,k=0;k<f.length;k++){var C=f[k],I=C.locationData.relativeBoundingBox,N=(I.xMin-g)/(1-v),$=(I.yMin-b)/(1-w),A=I.width/(1-v),z=I.height/(1-w);I.xMin=N,I.yMin=$,I.width=A,I.height=z,I.xMax=N+A,I.yMax=$+z;var F=C.locationData.relativeKeypoints;F&&F.forEach(function(E){var U=(E.x-g)/(1-v),L=(E.y-b)/(1-w);E.x=U,E.y=L})}return f}(c,i),zt([s,o,u,a]),[2,h]}})})},n.prototype.poseDetectionToRoi=function(t,e){return td(Va(t,e,{rotationVectorEndKeypointIndex:1,rotationVectorStartKeypointIndex:0,rotationVectorTargetAngleDegree:90}),e,nd)},n.prototype.poseLandmarksByRoi=function(t,e){return Ot(this,void 0,void 0,function(){var s,i,o,r,a,u,l,c,h,p,f,m,g,b;return _t(this,function(v){switch(v.label){case 0:if(s=xi(e),i=mu(e,GL,t),o=i.imageTensor,r=i.padding,a=i.transformationMatrix,this.modelType!=="lite"&&this.modelType!=="full"&&this.modelType!=="heavy")throw new Error("Model type must be one of lite, full or heavy,"+"but got ".concat(this.modelType));return u=["ld_3d","output_poseflag","activation_heatmap","world_3d"],this.enableSegmentation&&u.push("activation_segmentation"),l=this.landmarkModel.execute(o,u),[4,this.tensorsToPoseLandmarksAndSegmentation(l)];case 1:return(c=v.sent())==null?(zt(l),zt(o),[2,null]):(h=c.landmarks,p=c.auxiliaryLandmarks,f=c.poseScore,m=c.worldLandmarks,g=c.segmentationMask,[4,this.poseLandmarksAndSegmentationInverseProjection(s,t,r,a,h,p,m,g)]);case 2:return b=v.sent(),zt(l),zt(o),[2,Zt({poseScore:f},b)]}})})},n.prototype.poseLandmarksAndSegmentationInverseProjection=function(t,e,s,i,o,r,a,u){return Ot(this,void 0,void 0,function(){var l,c,h,p,f,m;return _t(this,function(g){return l=Qh(o,s),c=Qh(r,s),h=qh(l,e),p=qh(c,e),f=function(b,v){for(var w=[],k=0,C=b;k<C.length;k++){var I=C[k],N=I.x,$=I.y,A=v.rotation,z=Math.cos(A)*N-Math.sin(A)*$,F=Math.sin(A)*N+Math.cos(A)*$,E=Zt({},I);E.x=z,E.y=F,w.push(E)}return w}(a,e),m=null,this.enableSegmentation&&(m=B(function(){var b=u.shape,v=b[0],w=b[1],k=function(N){var $=db(new Array(16).fill(0));$[0][0]=ze(N,0,0),$[1][0]=-ze(N,0,1),$[2][0]=ze(N,0,2),$[3][0]=-ze(N,0,3),$[0][2]=ze(N,2,0),$[1][2]=-ze(N,2,1),$[2][2]=ze(N,2,2),$[3][2]=-ze(N,2,3),$[0][1]=-ze(N,1,0),$[1][1]=ze(N,1,1),$[2][1]=-ze(N,1,2),$[3][1]=ze(N,1,3),$[0][3]=-ze(N,3,0),$[1][3]=ze(N,3,1),$[2][3]=-ze(N,3,2),$[3][3]=ze(N,3,3);for(var A=N[0][0]*$[0][0]+N[1][0]*$[0][1]+N[2][0]*$[0][2]+N[3][0]*$[0][3],z=0;z<$.length;z++)for(var F=0;F<$.length;F++)$[z][F]/=A;return $}(i),C=zs(hb(k,{width:w,height:v},t),[1,8]),I=[1,v,w,1];return Xt(Oe.transform(Q(u,I),C,"bilinear","constant",0,[t.height,t.width]),[0,3])}),zt(u)),[2,{landmarks:h,auxiliaryLandmarks:p,worldLandmarks:f,segmentationMask:m}]})})},n.prototype.tensorsToPoseLandmarksAndSegmentation=function(t){return Ot(this,void 0,void 0,function(){var e,s,i,o,r,a,u,l,c,h,p,f,m;return _t(this,function(g){switch(g.label){case 0:return e=t[0],s=t[1],i=t[2],o=t[3],r=this.enableSegmentation?t[4]:null,[4,s.data()];case 1:return(a=g.sent()[0])<.5?[2,null]:[4,Jh(e,HL)];case 2:return[4,TL(g.sent(),i,KL)];case 3:return u=g.sent(),l=u.slice(0,33),c=u.slice(33,35),[4,Jh(o,jL)];case 4:return h=g.sent(),p=h.slice(0,33),f=function(b,v,w){for(var k=[],C=0;C<b.length;C++){var I=Zt({},v[C]);I.score=b[C].score,k.push(I)}return k}(l,p),m=this.enableSegmentation?function(b,v,w){return B(function(){var k=Xt(b,[0]),C=k.shape[2];if(C===1){var I=k;switch(v.activation){case"none":break;case"sigmoid":I=Ws(I);break;case"softmax":throw new Error("Softmax activation requires two channels.");default:throw new Error("Activation not supported (".concat(v.activation,")"))}var N=I;return Xt(N,[2])}throw new Error("Unsupported number of tensor channels ".concat(C))})}(r,ZL):null,[2,{landmarks:l,auxiliaryLandmarks:c,poseScore:a,worldLandmarks:f,segmentationMask:m}]}})})},n.prototype.poseLandmarksToRoi=function(t,e){return td(Va(Zh(t),e,{rotationVectorStartKeypointIndex:0,rotationVectorEndKeypointIndex:1,rotationVectorTargetAngleDegree:90}),e,nd)},n.prototype.poseLandmarkFiltering=function(t,e,s,i){var o,r,a;if(this.timestamp!=null&&this.enableSmoothing){var u=Va(Zh(e),i,{rotationVectorEndKeypointIndex:0,rotationVectorStartKeypointIndex:1,rotationVectorTargetAngleDegree:90});this.visibilitySmoothingFilterActual==null&&(this.visibilitySmoothingFilterActual=new ed(sd)),o=this.visibilitySmoothingFilterActual.apply(t),this.visibilitySmoothingFilterAuxiliary==null&&(this.visibilitySmoothingFilterAuxiliary=new ed(sd)),r=this.visibilitySmoothingFilterAuxiliary.apply(e),a=this.visibilitySmoothingFilterActual.apply(s),this.landmarksSmoothingFilterActual==null&&(this.landmarksSmoothingFilterActual=new ja(XL)),o=this.landmarksSmoothingFilterActual.apply(o,this.timestamp,i,!0,u),this.landmarksSmoothingFilterAuxiliary==null&&(this.landmarksSmoothingFilterAuxiliary=new ja(qL)),r=this.landmarksSmoothingFilterAuxiliary.apply(r,this.timestamp,i,!0,u),this.worldLandmarksSmoothingFilterActual==null&&(this.worldLandmarksSmoothingFilterActual=new ja(YL)),a=this.worldLandmarksSmoothingFilterActual.apply(s,this.timestamp)}else o=t,r=e,a=s;return{actualLandmarksFiltered:o,auxiliaryLandmarksFiltered:r,actualWorldLandmarksFiltered:a}},n}();function nO(n){return Ot(this,void 0,void 0,function(){var t,e,s,i,o,r;return _t(this,function(a){switch(a.label){case 0:return t=function(u){var l=Zt({},u??si);if(l.enableSmoothing==null&&(l.enableSmoothing=si.enableSmoothing),l.enableSegmentation==null&&(l.enableSegmentation=si.enableSegmentation),l.smoothSegmentation==null&&(l.smoothSegmentation=si.smoothSegmentation),l.modelType==null&&(l.modelType=si.modelType),l.detectorModelUrl==null&&(l.detectorModelUrl=si.detectorModelUrl),l.landmarkModelUrl==null)switch(l.modelType){case"lite":l.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/lite/2";break;case"heavy":l.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/heavy/2";break;case"full":default:l.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"}return l}(n),e=typeof t.detectorModelUrl=="string"&&t.detectorModelUrl.indexOf("https://tfhub.dev")>-1,s=typeof t.landmarkModelUrl=="string"&&t.landmarkModelUrl.indexOf("https://tfhub.dev")>-1,[4,Promise.all([fi(t.detectorModelUrl,{fromTFHub:e}),fi(t.landmarkModelUrl,{fromTFHub:s})])];case 1:return i=a.sent(),o=i[0],r=i[1],[2,new eO(o,r,t.enableSmoothing,t.enableSegmentation,t.smoothSegmentation,t.modelType)]}})})}var Es,Ee,gb=function(){function n(t){(function(e){if(e.maxTracks<1)throw new Error("Must specify 'maxTracks' to be at least 1, but "+"encountered ".concat(e.maxTracks));if(e.maxAge<=0)throw new Error("Must specify 'maxAge' to be positive, but "+"encountered ".concat(e.maxAge));if(e.keypointTrackerParams!==void 0){if(e.keypointTrackerParams.keypointConfidenceThreshold<0||e.keypointTrackerParams.keypointConfidenceThreshold>1)throw new Error("Must specify 'keypointConfidenceThreshold' to be in the range [0, 1], but encountered "+"".concat(e.keypointTrackerParams.keypointConfidenceThreshold));if(e.keypointTrackerParams.minNumberOfKeypoints<1)throw new Error("Must specify 'minNumberOfKeypoints' to be at least 1, but "+"encountered ".concat(e.keypointTrackerParams.minNumberOfKeypoints));for(var s=0,i=e.keypointTrackerParams.keypointFalloff;s<i.length;s++){var o=i[s];if(o<=0)throw new Error("Must specify each keypoint falloff parameterto be positive "+"but encountered ".concat(o))}}})(t),this.tracks=[],this.maxTracks=t.maxTracks,this.maxAge=1e3*t.maxAge,this.minSimilarity=t.minSimilarity,this.nextID=1}return n.prototype.apply=function(t,e){this.filterOldTracks(e);var s=this.computeSimilarity(t);return this.assignTracks(t,s,e),this.updateTracks(e),t},n.prototype.getTracks=function(){return this.tracks.slice()},n.prototype.getTrackIDs=function(){return new Set(this.tracks.map(function(t){return t.id}))},n.prototype.filterOldTracks=function(t){var e=this;this.tracks=this.tracks.filter(function(s){return t-s.lastTimestamp<=e.maxAge})},n.prototype.assignTracks=function(t,e,s){for(var i=Array.from(Array(e[0].length).keys()),o=[],r=0,a=Array.from(Array(t.length).keys());r<a.length;r++){var u=a[r];if(i.length!==0){for(var l=-1,c=-1,h=0,p=i;h<p.length;h++){var f=p[h],m=e[u][f];m>=this.minSimilarity&&m>c&&(l=f,c=m)}if(l>=0){var g=this.tracks[l];g=Object.assign(g,this.createTrack(t[u],s,g.id)),t[u].id=g.id;var b=i.indexOf(l);i.splice(b,1)}else o.push(u)}else o.push(u)}for(var v=0,w=o;v<w.length;v++){u=w[v];var k=this.createTrack(t[u],s);this.tracks.push(k),t[u].id=k.id}},n.prototype.updateTracks=function(t){this.tracks.sort(function(e,s){return s.lastTimestamp-e.lastTimestamp}),this.tracks=this.tracks.slice(0,this.maxTracks)},n.prototype.createTrack=function(t,e,s){var i={id:s||this.nextTrackID(),lastTimestamp:e,keypoints:Ts([],t.keypoints,!0).map(function(o){return Zt({},o)})};return t.box!==void 0&&(i.box=Zt({},t.box)),i},n.prototype.nextTrackID=function(){var t=this.nextID;return this.nextID+=1,t},n.prototype.remove=function(){for(var t=[],e=0;e<arguments.length;e++)t[e]=arguments[e];this.tracks=this.tracks.filter(function(s){return!t.includes(s.id)})},n.prototype.reset=function(){this.tracks=[]},n}(),sO=function(n){function t(e){return n.call(this,e)||this}return rb(t,n),t.prototype.computeSimilarity=function(e){var s=this;return e.length===0||this.tracks.length===0?[[]]:e.map(function(i){return s.tracks.map(function(o){return s.iou(i,o)})})},t.prototype.iou=function(e,s){var i=Math.max(e.box.xMin,s.box.xMin),o=Math.max(e.box.yMin,s.box.yMin),r=Math.min(e.box.xMax,s.box.xMax),a=Math.min(e.box.yMax,s.box.yMax);if(i>=r||o>=a)return 0;var u=(r-i)*(a-o);return u/(e.box.width*e.box.height+s.box.width*s.box.height-u)},t}(gb),iO=function(n){function t(e){var s=n.call(this,e)||this;return s.keypointThreshold=e.keypointTrackerParams.keypointConfidenceThreshold,s.keypointFalloff=e.keypointTrackerParams.keypointFalloff,s.minNumKeyoints=e.keypointTrackerParams.minNumberOfKeypoints,s}return rb(t,n),t.prototype.computeSimilarity=function(e){if(e.length===0||this.tracks.length===0)return[[]];for(var s=[],i=0,o=e;i<o.length;i++){for(var r=o[i],a=[],u=0,l=this.tracks;u<l.length;u++){var c=l[u];a.push(this.oks(r,c))}s.push(a)}return s},t.prototype.oks=function(e,s){for(var i=this.area(s.keypoints)+1e-6,o=0,r=0,a=0;a<e.keypoints.length;++a){var u=e.keypoints[a],l=s.keypoints[a];if(!(u.score<this.keypointThreshold||l.score<this.keypointThreshold)){r+=1;var c=Math.pow(u.x-l.x,2)+Math.pow(u.y-l.y,2),h=2*this.keypointFalloff[a];o+=Math.exp(-1*c/(2*i*Math.pow(h,2)))}}return r<this.minNumKeyoints?0:o/r},t.prototype.area=function(e){var s=this,i=e.filter(function(u){return u.score>s.keypointThreshold}),o=Math.min.apply(Math,Ts([1],i.map(function(u){return u.x}),!1)),r=Math.max.apply(Math,Ts([0],i.map(function(u){return u.x}),!1)),a=Math.min.apply(Math,Ts([1],i.map(function(u){return u.y}),!1));return(r-o)*(Math.max.apply(Math,Ts([0],i.map(function(u){return u.y}),!1))-a)},t}(gb);function yb(n){switch(n){case Ee.BlazePose:return ao.reduce(function(t,e,s){return t[e]=s,t},{});case Ee.PoseNet:case Ee.MoveNet:return Bn.reduce(function(t,e,s){return t[e]=s,t},{});default:throw new Error("Model ".concat(n," is not supported."))}}(function(n){n.Keypoint="keypoint",n.BoundingBox="boundingBox"})(Es||(Es={})),function(n){n.MoveNet="MoveNet",n.BlazePose="BlazePose",n.PoseNet="PoseNet"}(Ee||(Ee={}));var MO=Object.freeze({__proto__:null,getKeypointIndexBySide:function(n){switch(n){case Ee.BlazePose:return wL;case Ee.PoseNet:case Ee.MoveNet:return vL;default:throw new Error("Model ".concat(n," is not supported."))}},getAdjacentPairs:function(n){switch(n){case Ee.BlazePose:return kL;case Ee.PoseNet:case Ee.MoveNet:return CL;default:throw new Error("Model ".concat(n," is not supported."))}},getKeypointIndexByName:yb}),id=["SinglePose.Lightning","SinglePose.Thunder","MultiPose.Lightning"],bb={modelType:"SinglePose.Lightning",enableSmoothing:!0},od={},rd={frequency:30,minCutOff:2.5,beta:300,derivateCutOff:2.5,thresholdCutOff:.5,thresholdBeta:5,disableValueScaling:!0},Ka={maxTracks:18,maxAge:1e3,minSimilarity:.2,keypointTrackerParams:{keypointConfidenceThreshold:.3,keypointFalloff:[.026,.025,.025,.035,.035,.079,.079,.072,.072,.062,.062,.107,.107,.087,.087,.089,.089],minNumberOfKeypoints:4}},ad={maxTracks:18,maxAge:1e3,minSimilarity:.15,trackerParams:{}};function oO(n,t,e,s){for(var i={},o=0,r=Bn;o<r.length;o++){var a=r[o];i[a]=[t[e[a]].y*s.height,t[e[a]].x*s.width]}if(function(w,k){return(w[k.left_hip].score>.2||w[k.right_hip].score>.2)&&(w[k.left_shoulder].score>.2||w[k.right_shoulder].score>.2)}(t,e)){var u=(i.left_hip[0]+i.right_hip[0])/2,l=(i.left_hip[1]+i.right_hip[1])/2,c=function(w,k,C,I,N){for(var $=["left_shoulder","right_shoulder","left_hip","right_hip"],A=0,z=0,F=0;F<$.length;F++)(_=Math.abs(I-C[$[F]][0]))>A&&(A=_),(V=Math.abs(N-C[$[F]][1]))>z&&(z=V);for(var E=0,U=0,L=0,W=Object.keys(C);L<W.length;L++){var _,V,X=W[L];w[k[X]].score<.2||((_=Math.abs(I-C[X][0]))>E&&(E=_),(V=Math.abs(N-C[X][1]))>U&&(U=V))}return[A,z,E,U]}(t,e,i,u,l),h=c[0],p=c[1],f=c[2],m=c[3],g=Math.max(1.9*p,1.9*h,1.2*f,1.2*m),b=[u-(g=Math.min(g,Math.max(l,s.width-l,u,s.height-u))),l-g];if(g>Math.max(s.width,s.height)/2)return yu(n==null,s);var v=2*g;return{yMin:b[0]/s.height,xMin:b[1]/s.width,yMax:(b[0]+v)/s.height,xMax:(b[1]+v)/s.width,height:(b[0]+v)/s.height-b[0]/s.height,width:(b[1]+v)/s.width-b[1]/s.width}}return yu(n==null,s)}function yu(n,t){var e,s,i,o;return n?t.width>t.height?(e=1,s=t.height/t.width,i=0,o=(t.width/2-t.height/2)/t.width):(e=t.width/t.height,s=1,i=(t.height/2-t.width/2)/t.height,o=0):t.width>t.height?(e=t.width/t.height,s=1,i=(t.height/2-t.width/2)/t.height,o=0):(e=1,s=t.height/t.width,i=0,o=(t.width/2-t.height/2)/t.width),{yMin:i,xMin:o,yMax:i+e,xMax:o+s,height:e,width:s}}function rO(n){var t,e=n==null?bb:Zt({},n);if(e.modelType==null)e.modelType="SinglePose.Lightning";else if(id.indexOf(e.modelType)<0)throw new Error("Invalid architecture ".concat(e.modelType,". ")+"Should be one of ".concat(id));if(e.enableSmoothing==null&&(e.enableSmoothing=!0),e.minPoseScore!=null&&(e.minPoseScore<0||e.minPoseScore>1))throw new Error("minPoseScore should be between 0.0 and 1.0");if(e.multiPoseMaxDimension!=null&&(e.multiPoseMaxDimension%32!=0||e.multiPoseMaxDimension<32))throw new Error("multiPoseMaxDimension must be a multiple of 32 and higher than 0");if(e.modelType==="MultiPose.Lightning"&&e.enableTracking==null&&(e.enableTracking=!0),e.modelType==="MultiPose.Lightning"&&e.enableTracking===!0)if(e.trackerType==null&&(e.trackerType=Es.BoundingBox),e.trackerType===Es.Keypoint)e.trackerConfig!=null?e.trackerConfig=function(s){var i=ud(Ka,s);return i.keypointTrackerParams=Zt({},Ka.keypointTrackerParams),s.keypointTrackerParams!=null&&(s.keypointTrackerParams.keypointConfidenceThreshold!=null&&(i.keypointTrackerParams.keypointConfidenceThreshold=s.keypointTrackerParams.keypointConfidenceThreshold),s.keypointTrackerParams.keypointFalloff!=null&&(i.keypointTrackerParams.keypointFalloff=s.keypointTrackerParams.keypointFalloff),s.keypointTrackerParams.minNumberOfKeypoints!=null&&(i.keypointTrackerParams.minNumberOfKeypoints=s.keypointTrackerParams.minNumberOfKeypoints)),i}(e.trackerConfig):e.trackerConfig=Ka;else{if(e.trackerType!==Es.BoundingBox)throw new Error("Tracker type not supported by MoveNet");e.trackerConfig!=null?e.trackerConfig=(t=e.trackerConfig,ud(ad,t)):e.trackerConfig=ad}return e}function ud(n,t){var e={maxTracks:n.maxTracks,maxAge:n.maxAge,minSimilarity:n.minSimilarity};return t.maxTracks!=null&&(e.maxTracks=t.maxTracks),t.maxAge!=null&&(e.maxAge=t.maxAge),t.minSimilarity!=null&&(e.minSimilarity=t.minSimilarity),e}var aO=function(){function n(t,e){this.moveNetModel=t,this.modelInputResolution={height:0,width:0},this.keypointIndexByName=yb(Ee.MoveNet),e.modelType==="SinglePose.Lightning"?(this.modelInputResolution.width=192,this.modelInputResolution.height=192):e.modelType==="SinglePose.Thunder"&&(this.modelInputResolution.width=256,this.modelInputResolution.height=256),this.multiPoseModel=e.modelType==="MultiPose.Lightning",this.multiPoseModel||(this.keypointFilter=new gu(rd),this.cropRegionFilterYMin=new us(.9),this.cropRegionFilterXMin=new us(.9),this.cropRegionFilterYMax=new us(.9),this.cropRegionFilterXMax=new us(.9)),this.enableSmoothing=e.enableSmoothing,e.minPoseScore?this.minPoseScore=e.minPoseScore:this.minPoseScore=.25,e.multiPoseMaxDimension?this.multiPoseMaxDimension=e.multiPoseMaxDimension:this.multiPoseMaxDimension=256,this.enableTracking=e.enableTracking,this.multiPoseModel&&this.enableTracking&&(e.trackerType===Es.Keypoint?this.tracker=new iO(e.trackerConfig):e.trackerType===Es.BoundingBox&&(this.tracker=new sO(e.trackerConfig)),this.enableSmoothing&&(this.keypointFilterMap=new Map))}return n.prototype.runSinglePersonPoseModel=function(t){return Ot(this,void 0,void 0,function(){var e,s,i,o,r;return _t(this,function(a){switch(a.label){case 0:if((e=this.moveNetModel.execute(t)).shape.length!==4||e.shape[0]!==1||e.shape[1]!==1||e.shape[2]!==17||e.shape[3]!==3)throw e.dispose(),new Error("Unexpected output shape from model: [".concat(e.shape,"]"));return Xo()==="webgpu"?[3,1]:(s=e.dataSync(),[3,3]);case 1:return[4,e.data()];case 2:s=a.sent(),a.label=3;case 3:for(e.dispose(),i={keypoints:[],score:0},o=0,r=0;r<17;++r)i.keypoints[r]={y:s[3*r],x:s[3*r+1],score:s[3*r+2]},i.keypoints[r].score>.2&&(++o,i.score+=i.keypoints[r].score);return o>0&&(i.score/=o),[2,i]}})})},n.prototype.runMultiPersonPoseModel=function(t){return Ot(this,void 0,void 0,function(){var e,s,i,o,r,a,u,l;return _t(this,function(c){switch(c.label){case 0:if((e=this.moveNetModel.execute(t)).shape.length!==3||e.shape[0]!==1||e.shape[2]!==56)throw e.dispose(),new Error("Unexpected output shape from model: [".concat(e.shape,"]"));return Xo()==="webgpu"?[3,1]:(s=e.dataSync(),[3,3]);case 1:return[4,e.data()];case 2:s=c.sent(),c.label=3;case 3:for(e.dispose(),i=[],o=s.length/56,r=0;r<o;++r)for(i[r]={keypoints:[]},a=56*r+51,i[r].box={yMin:s[a],xMin:s[a+1],yMax:s[a+2],xMax:s[a+3],width:s[a+3]-s[a+1],height:s[a+2]-s[a]},u=56*r+55,i[r].score=s[u],i[r].keypoints=[],l=0;l<17;++l)i[r].keypoints[l]={y:s[56*r+3*l],x:s[56*r+3*l+1],score:s[56*r+3*l+2]};return[2,i]}})})},n.prototype.estimatePoses=function(t,e,s){return e===void 0&&(e=od),Ot(this,void 0,void 0,function(){var i,o,r,a,u,l;return _t(this,function(c){switch(c.label){case 0:return e=function(h){return h==null?od:Zt({},h)}(e),t==null?(this.reset(),[2,[]]):(s==null?fb(t)&&(s=1e6*t.currentTime):s*=1e3,i=dc(t),o=xi(i),r=Ye(i,0),t instanceof Ge||i.dispose(),a=[],this.multiPoseModel?[3,2]:[4,this.estimateSinglePose(r,o,s)]);case 1:return a=c.sent(),[3,4];case 2:return[4,this.estimateMultiplePoses(r,o,s)];case 3:a=c.sent(),c.label=4;case 4:for(u=0;u<a.length;++u)for(l=0;l<a[u].keypoints.length;++l)a[u].keypoints[l].name=Bn[l],a[u].keypoints[l].y*=o.height,a[u].keypoints[l].x*=o.width;return[2,a]}})})},n.prototype.estimateSinglePose=function(t,e,s){return Ot(this,void 0,void 0,function(){var i,o,r,a,u=this;return _t(this,function(l){switch(l.label){case 0:return this.cropRegion||(this.cropRegion=yu(this.cropRegion==null,e)),i=B(function(){var c=zs([[u.cropRegion.yMin,u.cropRegion.xMin,u.cropRegion.yMax,u.cropRegion.xMax]]),h=Le([1],"int32"),p=[u.modelInputResolution.height,u.modelInputResolution.width];return mt(Oe.cropAndResize(t,c,h,p,"bilinear",0),"int32")}),t.dispose(),[4,this.runSinglePersonPoseModel(i)];case 1:if(o=l.sent(),i.dispose(),o.score<this.minPoseScore)return this.reset(),[2,[]];for(r=0;r<o.keypoints.length;++r)o.keypoints[r].y=this.cropRegion.yMin+o.keypoints[r].y*this.cropRegion.height,o.keypoints[r].x=this.cropRegion.xMin+o.keypoints[r].x*this.cropRegion.width;return s!=null&&this.enableSmoothing&&(o.keypoints=this.keypointFilter.apply(o.keypoints,s,1)),a=oO(this.cropRegion,o.keypoints,this.keypointIndexByName,e),this.cropRegion=this.filterCropRegion(a),[2,[o]]}})})},n.prototype.estimateMultiplePoses=function(t,e,s){return Ot(this,void 0,void 0,function(){var i,o,r,a,u,l,c,h,p,f,m,g=this;return _t(this,function(b){switch(b.label){case 0:return e.width>e.height?(o=this.multiPoseMaxDimension,r=Math.round(this.multiPoseMaxDimension*e.height/e.width),i=Oe.resizeBilinear(t,[r,o]),u=o,l=32*Math.ceil(r/32),a=ui(i,[[0,0],[0,l-r],[0,0],[0,0]])):(o=Math.round(this.multiPoseMaxDimension*e.width/e.height),r=this.multiPoseMaxDimension,i=Oe.resizeBilinear(t,[r,o]),u=32*Math.ceil(o/32),l=r,a=ui(i,[[0,0],[0,0],[0,u-o],[0,0]])),i.dispose(),t.dispose(),c=mt(a,"int32"),a.dispose(),[4,this.runMultiPersonPoseModel(c)];case 1:for(h=b.sent(),c.dispose(),h=h.filter(function(v){return v.score>=g.minPoseScore}),f=0;f<h.length;++f)for(p=0;p<h[f].keypoints.length;++p)h[f].keypoints[p].y*=l/r,h[f].keypoints[p].x*=u/o;if(this.enableTracking&&(this.tracker.apply(h,s),this.enableSmoothing)){for(f=0;f<h.length;++f)this.keypointFilterMap.has(h[f].id)||this.keypointFilterMap.set(h[f].id,new gu(rd)),h[f].keypoints=this.keypointFilterMap.get(h[f].id).apply(h[f].keypoints,s,1);m=this.tracker.getTrackIDs(),this.keypointFilterMap.forEach(function(v,w){m.has(w)||g.keypointFilterMap.delete(w)})}return[2,h]}})})},n.prototype.filterCropRegion=function(t){if(t){var e=this.cropRegionFilterYMin.apply(t.yMin),s=this.cropRegionFilterXMin.apply(t.xMin),i=this.cropRegionFilterYMax.apply(t.yMax),o=this.cropRegionFilterXMax.apply(t.xMax);return{yMin:e,xMin:s,yMax:i,xMax:o,height:i-e,width:o-s}}return this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset(),null},n.prototype.dispose=function(){this.moveNetModel.dispose()},n.prototype.reset=function(){this.cropRegion=null,this.resetFilters()},n.prototype.resetFilters=function(){this.keypointFilter.reset(),this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset()},n}();function uO(n){return n===void 0&&(n=bb),Ot(this,void 0,void 0,function(){var t,e,s,i;return _t(this,function(o){switch(o.label){case 0:return t=rO(n),s=!0,t.modelUrl?(s=typeof t.modelUrl=="string"&&t.modelUrl.indexOf("https://tfhub.dev")>-1,[4,fi(t.modelUrl,{fromTFHub:s})]):[3,2];case 1:return e=o.sent(),[3,4];case 2:return i=void 0,t.modelType==="SinglePose.Lightning"?i="https://tfhub.dev/google/tfjs-model/movenet/singlepose/lightning/4":t.modelType==="SinglePose.Thunder"?i="https://tfhub.dev/google/tfjs-model/movenet/singlepose/thunder/4":t.modelType==="MultiPose.Lightning"&&(i="https://tfhub.dev/google/tfjs-model/movenet/multipose/lightning/1"),[4,fi(i,{fromTFHub:s})];case 3:e=o.sent(),o.label=4;case 4:return Xo()==="webgl"&&he().set("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",0),[2,new aO(e,t)]}})})}var ld={architecture:"MobileNetV1",outputStride:16,multiplier:.75,inputResolution:{height:257,width:257}},cd=["MobileNetV1","ResNet50"],hd={MobileNetV1:[8,16],ResNet50:[16]},lO=[8,16,32],dd={MobileNetV1:[.5,.75,1],ResNet50:[1]},pd=[1,2,4],fd={maxPoses:1,flipHorizontal:!1},cO={maxPoses:5,flipHorizontal:!1,scoreThreshold:.5,nmsRadius:20},hO=[-123.15,-115.9,-103.06];function Xa(n){return Math.floor(n/2)}var dO=function(){function n(t,e){this.priorityQueue=new Array(t),this.numberOfElements=-1,this.getElementValue=e}return n.prototype.enqueue=function(t){this.priorityQueue[++this.numberOfElements]=t,this.swim(this.numberOfElements)},n.prototype.dequeue=function(){var t=this.priorityQueue[0];return this.exchange(0,this.numberOfElements--),this.sink(0),this.priorityQueue[this.numberOfElements+1]=null,t},n.prototype.empty=function(){return this.numberOfElements===-1},n.prototype.size=function(){return this.numberOfElements+1},n.prototype.all=function(){return this.priorityQueue.slice(0,this.numberOfElements+1)},n.prototype.max=function(){return this.priorityQueue[0]},n.prototype.swim=function(t){for(;t>0&&this.less(Xa(t),t);)this.exchange(t,Xa(t)),t=Xa(t)},n.prototype.sink=function(t){for(;2*t<=this.numberOfElements;){var e=2*t;if(e<this.numberOfElements&&this.less(e,e+1)&&e++,!this.less(t,e))break;this.exchange(t,e),t=e}},n.prototype.getValueAt=function(t){return this.getElementValue(this.priorityQueue[t])},n.prototype.less=function(t,e){return this.getValueAt(t)<this.getValueAt(e)},n.prototype.exchange=function(t,e){var s=this.priorityQueue[t];this.priorityQueue[t]=this.priorityQueue[e],this.priorityQueue[e]=s},n}();function pO(n,t,e,s,i,o){for(var r=o.shape,a=r[0],u=r[1],l=!0,c=Math.max(e-i,0),h=Math.min(e+i+1,a),p=c;p<h;++p){for(var f=Math.max(s-i,0),m=Math.min(s+i+1,u),g=f;g<m;++g)if(o.get(p,g,n)>t){l=!1;break}if(!l)break}return l}function fO(n){return Ot(this,void 0,void 0,function(){return _t(this,function(t){return[2,Promise.all(n.map(function(e){return e.buffer()}))]})})}function xb(n,t,e,s){return{y:s.get(n,t,e),x:s.get(n,t,e+17)}}function wb(n,t,e){var s=xb(n.heatmapY,n.heatmapX,n.id,e),i=s.y,o=s.x;return{x:n.heatmapX*t+o,y:n.heatmapY*t+i}}function vb(n,t,e,s){var i=e.x,o=e.y;return n.some(function(r){var a,u,l,c,h,p,f=r.keypoints;return a=o,u=i,l=f[s].y,c=f[s].x,(h=l-a)*h+(p=c-u)*p<=t})}var md=Bn.reduce(function(n,t,e){return n[t]=e,n},{}),Cb=[["nose","left_eye"],["left_eye","left_ear"],["nose","right_eye"],["right_eye","right_ear"],["nose","left_shoulder"],["left_shoulder","left_elbow"],["left_elbow","left_wrist"],["left_shoulder","left_hip"],["left_hip","left_knee"],["left_knee","left_ankle"],["nose","right_shoulder"],["right_shoulder","right_elbow"],["right_elbow","right_wrist"],["right_shoulder","right_hip"],["right_hip","right_knee"],["right_knee","right_ankle"]].map(function(n){var t=n[0],e=n[1];return[md[t],md[e]]}),qa=Cb.map(function(n){return n[1]}),gd=Cb.map(function(n){return n[0]});function yd(n,t,e){return n<t?t:n>e?e:n}function Ya(n,t,e,s){return{y:yd(Math.round(n.y/t),0,e-1),x:yd(Math.round(n.x/t),0,s-1)}}function bd(n,t){return{x:n.x+t.x,y:n.y+t.y}}function xd(n,t,e,s,i,o,r,a){a===void 0&&(a=2);for(var u=s.shape,l=u[0],c=u[1],h={y:t.y,x:t.x},p=bd(h,function(w,k,C){var I=C.shape[2]/2;return{y:C.get(k.y,k.x,w),x:C.get(k.y,k.x,I+w)}}(n,Ya(h,o,l,c),r)),f=0;f<a;f++){var m=Ya(p,o,l,c),g=xb(m.y,m.x,e,i);p=bd({x:m.x*o,y:m.y*o},{x:g.x,y:g.y})}var b=Ya(p,o,l,c),v=s.get(b.y,b.x,e);return{y:p.y,x:p.x,name:Bn[e],score:v}}function mO(n,t,e,s,i,o){var r=t.shape[2],a=qa.length,u=new Array(r),l=n.part,c=n.score,h=wb(l,s,e);u[l.id]={score:c,name:Bn[l.id],y:h.y,x:h.x};for(var p=a-1;p>=0;--p){var f=qa[p],m=gd[p];u[f]&&!u[m]&&(u[m]=xd(p,u[f],m,t,e,s,o))}for(p=0;p<a;++p)f=gd[p],m=qa[p],u[f]&&!u[m]&&(u[m]=xd(p,u[f],m,t,e,s,i));return u}function gO(n,t,e){return e.reduce(function(s,i,o){var r=i.y,a=i.x,u=i.score;return vb(n,t,{y:r,x:a},o)||(s+=u),s},0)/e.length}function yO(n,t,e,s,i,o,r,a){return r===void 0&&(r=.5),a===void 0&&(a=20),Ot(this,void 0,void 0,function(){var u,l,c,h,p,f,m,g,b,v,w,k;return _t(this,function(C){switch(C.label){case 0:return[4,fO([n,t,e,s])];case 1:for(u=C.sent(),l=u[0],c=u[1],h=u[2],p=u[3],f=[],m=function(I,N,$){for(var A=$.shape,z=A[0],F=A[1],E=A[2],U=new dO(z*F*E,function(X){return X.score}),L=0;L<z;++L)for(var W=0;W<F;++W)for(var _=0;_<E;++_){var V=$.get(L,W,_);V<I||pO(_,V,L,W,N,$)&&U.enqueue({score:V,part:{heatmapY:L,heatmapX:W,id:_}})}return U}(r,1,l),g=a*a;f.length<o&&!m.empty();)b=m.dequeue(),v=wb(b.part,i,c),vb(f,g,v,b.part.id)||(w=mO(b,l,c,i,h,p),k=gO(f,g,w),f.push({keypoints:w,score:k}));return[2,f]}})})}function kb(){for(var n,t=[],e=0;e<arguments.length;e++)t[e]=arguments[e];switch(t.length){case 0:n="fn main() ";break;case 1:n="fn main(".concat(t[0]," : i32)");break;default:throw Error("Unreachable")}return n}var bO=function(){function n(t){this.variableNames=["A","B"],this.size=!0,this.workgroupSize=[32,1,1],this.outputShape=[t[0],1],this.dispatchLayout=ht(this.outputShape),this.dispatch=rt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="getpointsConfidenceOp"}return n.prototype.getUserCode=function(){return`
        `.concat(kb("index"),` {
          if (index < uniforms.size) {
            let y = B[index * 2];
            let x = B[index * 2 + 1];
            let outIndex = y * uniforms.aShape.x * uniforms.aShape.z + x * uniforms.aShape.z + index;
            result[index] = A[outIndex];
          }
        }
        `)},n}();function xO(n,t){if(hi()instanceof Ai)return function(e,s){var i=hi(),o=new bO(s.shape),r=i.runWebGPUProgram(o,[e,s],"float32");return ls().makeTensorFromTensorInfo(r)}(n,t);throw new Error("getPointsConfidenceWebGPU is not supported in this backend!")}var wO=function(){function n(t){if(this.variableNames=["A","B"],this.size=!0,this.supportedLastDimension=2,t.length!==2||t[1]!==this.supportedLastDimension)throw new Error("GetOffsetVectorsProgram only supports shape of [x, ".concat(this.supportedLastDimension,"], but current shape is ").concat(t));this.workgroupSize=[32,1,1],this.outputShape=t;var e=[t[0],1];this.dispatchLayout=ht(e),this.dispatch=rt(this.dispatchLayout,e,this.workgroupSize),this.shaderKey="GetOffsetVectors"}return n.prototype.getUserCode=function(){return`
    fn getOffsetPoint(y: i32, x: i32, index: i32) -> vec2<i32> {
      let outIndexY = y * uniforms.bShape.x * uniforms.bShape.y + x * uniforms.bShape.y + index;
      let outIndexX = outIndexY + uniforms.bShape.z;
      let outY = i32(B[outIndexY]);
      let outX = i32(B[outIndexX]);
      return vec2<i32>(outY, outX);
    }

    `.concat(kb("index"),` {
      if (index < uniforms.size) {
        let indexY = index * `).concat(this.supportedLastDimension,`;
        let indexX = indexY + 1;
        let heatmapY = A[indexY];
        let heatmapX = A[indexX];
        let out = getOffsetPoint(i32(heatmapY), i32(heatmapX), index);
        result[indexY] = f32(out[0]);
        result[indexX] = f32(out[1]);
      }
    }
    `)},n}();function vO(n,t){if(hi()instanceof Ai)return function(e,s){var i=hi(),o=new wO(e.shape),r=i.runWebGPUProgram(o,[e,s],"float32");return ls().makeTensorFromTensorInfo(r)}(n,t);throw new Error("getOffsetVectorsGPU is not supported in this backend!")}function Sb(n){var t=n.shape,e=t[0],s=t[1],i=t[2];return B(function(){var o,r,a=Q(n,[e*s,i]),u=li(a,0),l=Ye(Ct(u,se(s,"int32")),1),c=Ye((o=u,r=s,B(function(){var h=Ct(o,se(r,"int32"));return Lt(o,O(h,se(r,"int32")))})),1);return fs([l,c],1)})}function CO(n,t,e){return B(function(){var s=function(i,o){for(var r=[],a=0;a<Bn.length;a++){var u=i.get(a,0).valueOf(),l=i.get(a,1).valueOf(),c=kO(u,l,a,o),h=c.x,p=c.y;r.push(p),r.push(h)}return zs(r,[Bn.length,2])}(n,e);return ct(mt(O(n.toTensor(),se(t,"int32")),"float32"),s)})}function kO(n,t,e,s){return{y:s.get(n,t,e),x:s.get(n,t,e+Bn.length)}}function SO(n,t,e){return Ot(this,void 0,void 0,function(){var s,i,o,r,a,u,l,c,h,p;return _t(this,function(f){switch(f.label){case 0:return s=0,i=Sb(n),[4,Promise.all([n.buffer(),t.buffer(),i.buffer()])];case 1:return o=f.sent(),r=o[0],a=o[1],u=o[2],[4,(l=CO(u,e,a)).buffer()];case 2:return c=f.sent(),h=Array.from(function(m,g){for(var b=g.shape[0],v=new Float32Array(b),w=0;w<b;w++){var k=g.get(w,0),C=g.get(w,1);v[w]=m.get(k,C,w)}return v}(r,u)),p=h.map(function(m,g){return s+=m,{y:c.get(g,0),x:c.get(g,1),score:m,name:Bn[g]}}),i.dispose(),l.dispose(),[2,{keypoints:p,score:s/p.length}]}})})}function IO(n,t,e){return Ot(this,void 0,void 0,function(){var s,i,o;return _t(this,function(r){return s=Sb(n),i=function(a,u,l){return B(function(){var c=vO(a,l);return ct(mt(O(a,se(u,"int32")),"float32"),c)})}(s,e,t),o=xO(n,s),[2,[i,o]]})})}function wd(n,t){return(n-1)%t==0}var vd="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/mobilenet/",Cd="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/resnet50/";function kd(n,t){return function(e,s){return(e-1)%s==0}(n,t)?n:Math.floor(n/t)*t+1}var Sd=function(){function n(t,e){this.posenetModel=t;var s=this.posenetModel.inputs[0].shape;tt(s[1]===-1&&s[2]===-1,function(){return"Input shape [".concat(s[1],", ").concat(s[2],"] ")+"must both be equal to or -1"});var i,o,r=(i=e.inputResolution,o=e.outputStride,{height:kd(i.height,o),width:kd(i.width,o)});(function(a){tt(lO.indexOf(a)>=0,function(){return"outputStride of ".concat(a," is invalid. ")+"It must be either 8 or 16."})})(e.outputStride),function(a,u){tt(wd(a.height,u),function(){return"height of ".concat(a.height," is invalid for output stride ")+"".concat(u,".")}),tt(wd(a.width,u),function(){return"width of ".concat(a.width," is invalid for output stride ")+"".concat(u,".")})}(r,e.outputStride),this.inputResolution=r,this.outputStride=e.outputStride,this.architecture=e.architecture}return n.prototype.estimatePoses=function(t,e){return e===void 0&&(e=fd),Ot(this,void 0,void 0,function(){return _t(this,function(s){return[2,this.estimatePosesGPU(t,e,!1)]})})},n.prototype.estimatePosesGPU=function(t,e,s){return e===void 0&&(e=fd),s===void 0&&(s=!1),Ot(this,void 0,void 0,function(){var i,o,r,a,u,l,c,h,p,f,m,g,b,v,w,k,C,I;return _t(this,function(N){switch(N.label){case 0:return i=function($){var A=$;if(A.maxPoses==null&&(A.maxPoses=1),A.maxPoses<=0)throw new Error("Invalid maxPoses ".concat(A.maxPoses,". Should be > 0."));if(A.maxPoses>1){if((A=Zt(Zt({},cO),A)).scoreThreshold<0||A.scoreThreshold>1)throw new Error("Invalid scoreThreshold ".concat(A.scoreThreshold,". ")+"Should be in range [0.0, 1.0]");if(A.nmsRadius<=0)throw new Error("Invalid nmsRadius ".concat(A.nmsRadius,"."))}return A}(e),t==null?[2,s?[[],[]]:[]]:(this.maxPoses=i.maxPoses,o=mu(t,{outputTensorSize:this.inputResolution,keepAspectRatio:!0,borderMode:"replicate"}),r=o.imageTensor,a=o.padding,u=this.architecture==="ResNet50"?ct(r,hO):pb(r,[-1,1]),l=this.posenetModel.predict(u),this.architecture==="ResNet50"?(c=Xt(l[2],[0]),h=Xt(l[3],[0]),p=Xt(l[0],[0]),f=Xt(l[1],[0])):(c=Xt(l[0],[0]),h=Xt(l[1],[0]),p=Xt(l[2],[0]),f=Xt(l[3],[0])),m=Ws(h),this.maxPoses!==1?[3,5]:s?[4,IO(m,c,this.outputStride)]:[3,2]);case 1:return b=N.sent(),w=b[0],v=b[1],g=[w,v],[3,4];case 2:return[4,SO(m,c,this.outputStride)];case 3:w=N.sent(),g=[w],N.label=4;case 4:return[3,7];case 5:if(s)throw new Error("GPU renderer only supports single pose!");return[4,yO(m,c,p,f,this.outputStride,this.maxPoses,i.scoreThreshold,i.nmsRadius)];case 6:g=N.sent(),N.label=7;case 7:if(s){if(i.flipHorizontal===!0)throw new Error("flipHorizontal is not supported!");k=this.getCanvasInfo(xi(t),this.inputResolution,a)}else I=xi(t),C=function($,A,z,F){var E=A.height,U=A.width,L=E/(z.height*(1-F.top-F.bottom)),W=U/(z.width*(1-F.left-F.right)),_=-F.top*z.height,V=-F.left*z.width;if(W===1&&L===1&&_===0&&V===0)return $;for(var X=0,j=$;X<j.length;X++)for(var K=0,Z=j[X].keypoints;K<Z.length;K++){var Y=Z[K];Y.x=(Y.x+V)*W,Y.y=(Y.y+_)*L}return $}(g,I,this.inputResolution,a),i.flipHorizontal&&(C=function($,A){for(var z=0,F=$;z<F.length;z++)for(var E=0,U=F[z].keypoints;E<U.length;E++){var L=U[E];L.x=A.width-1-L.x}return $}(C,I));return r.dispose(),u.dispose(),zt(l),c.dispose(),h.dispose(),p.dispose(),f.dispose(),m.dispose(),[2,s?[g,k]:C]}})})},n.prototype.getCanvasInfo=function(t,e,s){var i=t.height,o=t.width,r=i/(e.height*(1-s.top-s.bottom)),a=o/(e.width*(1-s.left-s.right)),u=-s.top*e.height;return[-s.left*e.width,u,a,r,t.width,t.height]},n.prototype.dispose=function(){this.posenetModel.dispose()},n.prototype.reset=function(){},n}();function NO(n){return n===void 0&&(n=ld),Ot(this,void 0,void 0,function(){var t,e,s,i,o;return _t(this,function(r){switch(r.label){case 0:return(t=function(c){var h=c||ld;if(h.architecture==null&&(h.architecture="MobileNetV1"),cd.indexOf(h.architecture)<0)throw new Error("Invalid architecture ".concat(h.architecture,". ")+"Should be one of ".concat(cd));if(h.inputResolution==null&&(h.inputResolution={height:257,width:257}),h.outputStride==null&&(h.outputStride=16),hd[h.architecture].indexOf(h.outputStride)<0)throw new Error("Invalid outputStride ".concat(h.outputStride,". ")+"Should be one of ".concat(hd[h.architecture]," ")+"for architecture ".concat(h.architecture,"."));if(h.multiplier==null&&(h.multiplier=1),dd[h.architecture].indexOf(h.multiplier)<0)throw new Error("Invalid multiplier ".concat(h.multiplier,". ")+"Should be one of ".concat(dd[h.architecture]," ")+"for architecture ".concat(h.architecture,"."));if(h.quantBytes==null&&(h.quantBytes=4),pd.indexOf(h.quantBytes)<0)throw new Error("Invalid quantBytes ".concat(h.quantBytes,". ")+"Should be one of ".concat(pd," ")+"for architecture ".concat(h.architecture,"."));if(h.architecture==="MobileNetV1"&&h.outputStride===32&&h.multiplier!==1)throw new Error("When using an output stride of 32, you must select 1 as the multiplier.");return h}(n)).architecture!=="ResNet50"?[3,2]:(a=t.outputStride,u=t.quantBytes,l="model-stride".concat(a,".json"),e=u===4?Cd+"float/"+l:Cd+"quant".concat(u,"/")+l,[4,fi(t.modelUrl||e)]);case 1:return s=r.sent(),[2,new Sd(s,t)];case 2:return i=function(c,h,p){var f={1:"100",.75:"075",.5:"050"},m="model-stride".concat(c,".json");return p===4?vd+"float/".concat(f[h],"/")+m:vd+"quant".concat(p,"/").concat(f[h],"/")+m}(t.outputStride,t.multiplier,t.quantBytes),[4,fi(t.modelUrl||i)];case 3:return o=r.sent(),[2,new Sd(o,t)]}var a,u,l})})}function PO(n,t){return Ot(this,void 0,void 0,function(){var e,s;return _t(this,function(i){switch(n){case Ee.PoseNet:return[2,NO(t)];case Ee.BlazePose:if(s=void 0,(e=t)!=null){if(e.runtime==="tfjs")return[2,nO(t)];if(e.runtime==="mediapipe")return[2,DL(t)];s=e.runtime}throw new Error("Expect modelConfig.runtime to be either 'tfjs' "+"or 'mediapipe', but got ".concat(s));case Ee.MoveNet:return[2,uO(t)];default:throw new Error("".concat(n," is not a supported model name."))}})})}export{PO as m,MO as p,Ee as s};
